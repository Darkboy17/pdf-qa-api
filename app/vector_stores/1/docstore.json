{"docstore/metadata": {"416c68dd-511e-4fd9-9b42-3c428fbc005d": {"doc_hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd"}, "9e7640ce-ab93-4262-a732-a73f9dd97e82": {"doc_hash": "dded107fb74136ddb835e442c4145ff3025e61d5c6cea36834b401a4343e9313", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "99931567-eeec-475e-b958-c8081027bcaa": {"doc_hash": "320e939621f7b5e25bde779ae558d9f4b76f150132c53cf8197fc402292ee460", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f3042a90-da33-4fce-86a4-cba13454b325": {"doc_hash": "6dd2778e5e15275dd2d3fe0aa038589aa8a4be141c5ec5ab78e411518cfa2c57", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a70440e4-965b-4d18-a789-b4ed02a5b664": {"doc_hash": "a9aa268afa571a0bb071e309a63d042bcc6628c3c64dba39073c966c7c46ae5e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5c57b46b-5b48-4e89-a0e4-2326b2648c6e": {"doc_hash": "89a25403b8f9c0bec8532d70e3d8469ee1306fee67f512158073883ad753d0b5", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "31dae6ff-2c08-4116-8078-f1f44fe27016": {"doc_hash": "caaf4bb6b3292228db6f71979e92f54c37dad65498b9ceebe397c049f823797d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "283b477f-83e5-4a9c-b71b-8e437232de9f": {"doc_hash": "fda9edb5196540b893240e08e79128a0a2a7feaaef9cfbeba64c595c0ea7b2f5", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4b7f32e0-1dd6-4863-b1b4-4e78f8df7a5d": {"doc_hash": "6f3de078d9bc20c43facbe672fb8d0f41742d927f93dd3fff32603d7571e7d40", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "035e79ca-eb2a-439f-b4fb-e0077ea563ca": {"doc_hash": "493a34f20941c79052377de9f28b9517f0dae0838b4fb74f33af5afbaa0e5fd9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c25de355-1f0b-4f5f-a995-59725a59b112": {"doc_hash": "0fa5cb5fbd1d1ca5e83c1a06d5dc8963c6c0eb1deb2f6a7d6cdbd42e9ccdefcc", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d42da43f-6120-4c1a-b232-536251c3675c": {"doc_hash": "cde5774e484af998206ce148e26c9d8a3e044a76caeb47e4ea875c6aafa33a4a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "81e2871e-a153-4bca-b9c0-88f601e6af51": {"doc_hash": "39b04630899d58e960c196496b49b4051008aa24c064523d9968e119671d6e9d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a892ac17-5046-48c4-b190-0121079e9a6c": {"doc_hash": "aa57b8136c175cd3b05b3663bcbea55617cf822d49dd502b79dab16db30439e2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "cabb17a6-c955-47a8-91bf-62e29404f9fb": {"doc_hash": "ffc55cb24a28fc5b3a1dad216427f8f1a3f8c8db49c237d301612f934488968f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9c903b83-4464-4314-81fc-01550ca75547": {"doc_hash": "1a9f44b0536fdc0bfdd0eb62de2c88e92b7cd02c4a3cb9360ab93680ca18341e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "6ea117f5-0801-452e-aa74-920af4c88e85": {"doc_hash": "82264a5db44e45e9866eb4273cc99e60b34b51b376f76dd5e3fceda6ac3750dd", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3ee4a736-0bbd-4db0-8f82-8cede134cb6d": {"doc_hash": "04e7eae798b00830bb7eae56592418fc3be0c0b5612e06be152a39f0200c00c4", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f5d39c19-e7e2-49d5-b54e-f38071da7c81": {"doc_hash": "b21de110c2d65f1deb6947a0c755668569d97d2faf6243daad1e428e8848aa14", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e539adf6-499c-4618-8ea4-04f1de63bf39": {"doc_hash": "b5591c7a44f93dbf97486bbf96760bcd8e7c4375ef478c17859ffad041aa65c0", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "245729d6-825a-47a2-a58e-20c7de435c72": {"doc_hash": "f2c675e763c04064fe101e208ff8a15060f3d8c272773733ce6d452f7c1a385d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "74134c91-4832-4f2e-bd57-749151651b9f": {"doc_hash": "2c8e8cfcf4bd83fa2b62a2e67a39621c495816add4f683feb3499d5cdf37ff6c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5e679599-9d3e-49bb-88e8-e9e04ac0b266": {"doc_hash": "3cde853436e7cf67f52ab95c611447e36318031422df324fa4f9d7cb5e1ffcef", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b7aa21ea-d15e-4ec6-a5a9-6e31519129f1": {"doc_hash": "18fde1ce444db22b96dcefbb3a7854d5d2240a824465a4da5c38eeaebe2256a4", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a76c70bc-0efa-4158-9b4b-2025daf63bf7": {"doc_hash": "1ee04fe7619ac5ad9d258055bc1324cd3c3863953f29865a052024b70c294fdc", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "dfb680fd-020c-4781-8fd3-92837d2f471d": {"doc_hash": "044744f21b91d98247cf2e3120aa5c642e522ef8185ae32e2610ae61a5e91d22", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "8658b90c-0ecb-402f-adc7-16201f8f11ba": {"doc_hash": "453a569b39df87f8955897e1aabe38b5e4e8294662e1b76f6540651ca840584b", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "915b0bc5-aec5-4084-b602-c96698cb7d0b": {"doc_hash": "240756f02efd0e6fb8bc676295415d073747c51c7475449e8405085b646c9516", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "0d15a50d-f5d6-4306-96c8-d3c6c92016a0": {"doc_hash": "14b666c6d738c80c13902870a33a3d8280578c565680b93a750bfd75dc5f1669", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "994ecc5e-da2d-4242-9c94-6c5336c198f9": {"doc_hash": "dbc268ae2cbd3ddd8a61d5dc7a55b1b768a7758ef977ef9ce31bfec6a30ec259", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3a11a3ed-ea2d-4d2b-bed1-4c2ce792ecb9": {"doc_hash": "2038bfdb3f97d4ebf25f1c4d9016a2ca83f49cf7db1cc51480a92a86a67190f7", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5bd5f64b-f497-4484-a8b8-e67275bba34b": {"doc_hash": "1b688f8ef0a67f1625804c5ae11c3ccbc0a90a578f1a78d00cc94fb0835ff7d7", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "23ea8d9e-0d14-46e5-9278-42d342ee811f": {"doc_hash": "6102d06d9c46fda7191ea3f5520a34bc3c70b7bfd2c7c960b6b4870e51682dd3", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d7581205-66b6-4b56-a1ef-264ea7fa50d9": {"doc_hash": "f7ddb125c79cd82c57285a05d96ec5536ae4c654c3556b5a72a9d2a56480af00", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "cb3cf225-a62c-455e-b776-73000c34bd29": {"doc_hash": "422c660c5ddeff5cc81118a0eca4d8b4277fe6fffbfaf338a7724acd87c6bfef", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "272dcb3b-a3f1-4bcb-b1fe-1fd5f850e885": {"doc_hash": "adc2c5f0619039de03a604c8bde039f18ebfd7a7d5a035ec8f70b18c30a6f7bb", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2644c642-bfaa-4c2e-81ec-4dcca17be037": {"doc_hash": "d51e9e721b1715dc3d3c844205771ba0d91b166d83dbee607634aafb78232f97", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "ec9d5d5d-8344-4ec1-84a6-b6b4ea800749": {"doc_hash": "c2e2dc4ea6954a2a2a85a976883ebf2826b54615d8a1039096011a26f438e6ae", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "7128023b-576e-4ec1-8821-d9181e48fc0c": {"doc_hash": "d87c11608f0cc885fdf6f1a21e64afa88a3198854ce4c756448e5145bb9b4c82", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f7829b03-f6e8-4e87-aa6b-3a7d12b7d21e": {"doc_hash": "c221042f0a966bb3e5e96a4eaa185073ea6c4b7f3863dc5731cfd62bba98a90f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5af3a4f7-6e9b-4156-bdf7-33156cdbf1b5": {"doc_hash": "8990648f4e75080dbc406b479cb0d7485d9d05f7936b038fe436cef96c550aae", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2b246c2f-6e2d-49d3-89d8-8e5eb8475dbb": {"doc_hash": "a1737c0df86eafda2536bdb858dc06306e58ca7470a883c2347fb6a36a3e4aec", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "ae652625-8732-4cdc-b7c9-7572925d2de7": {"doc_hash": "61dcbd3304bad3827bb6bc444a4a6b9e49f34c4e01fe6d3d01c5fbe5ddd89798", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "73e17c4f-b629-46b8-aee0-f8c79ba84b14": {"doc_hash": "72176dec51591642c1a5e6aeb477f6bb8e3d067e330236eaedeadbb13c2b992b", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "afa08a1f-7d79-44e1-9a98-42ed8daaec7c": {"doc_hash": "3bf3fb2b7ed14c927f9453cc3be163618949f0b0ae5fe3258c6cde0f3f30f143", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "bed8ed10-c3f3-43d7-a759-c6d8530e4501": {"doc_hash": "022eb0488d5e66e2c721d04076d6fd2300a1a2c0b09acd88539fdca71610f426", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9d06f407-cadd-463b-bb56-f36f7f1afa22": {"doc_hash": "a4f055b77d529634842bd99efc43dd99b87c66a265475adf8e48fea708d1a69d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "eef3ba66-0dc6-4d5e-b329-2c2b136989b5": {"doc_hash": "06e67f1fd9a8f62fe51fea54b833b09a93850129ada48fcc787380433bd83f5c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "881d7beb-790c-4444-97d9-d8b22f1ec288": {"doc_hash": "4d5b3d45c5e9860208144b141eedcbaca33f0d2016c067ff45b31fc4bd18d787", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b8647d1c-cdee-4664-b486-bfecb4c4fd20": {"doc_hash": "165c595e6978b3cf928e6422a809edbad8b008613f4ad5be5d9fe044e8ad2f15", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4ad7982f-7bd8-400d-b81d-b46e26fcee55": {"doc_hash": "83a93134c603bb7837852580bae0c75008242cd59d29f5b06192259cf6ac3816", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "115bf630-860d-4919-b530-39d5df9da62e": {"doc_hash": "63ee3b8f4710ee3f22173c9a2aefac90d4393cdbade9fe60a498f59f800289e6", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "dab07ff0-9214-41ee-aec4-9f4cbe1dc276": {"doc_hash": "01a2f5f4982367e1753f6e81c02166e9a96c281255cd9c5f73fa326539af51d1", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4229cd55-0250-4c4a-a793-95c7c0f060ae": {"doc_hash": "c6f0da931c8552cf088dd58403be81351b7e6499bb8295b74c0609ff0604ac80", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b917c4e6-8479-4744-877f-75eeebaf8262": {"doc_hash": "0cd35d38ad7da48e2b5e4a6909f80fbd6722a44e12aa98788b36f6b190ba6ff7", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f023453c-c045-4644-aea6-aeb80c792cc2": {"doc_hash": "374eb5d351fd1f0862a1f19dd497c5b4a7f2659778523c272ba0ed3b64cc9b76", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "25acbd6a-0f97-436e-944b-ae5cd6317ec1": {"doc_hash": "5add0e12381b4be67fc5a857ca26a5df42b43b22109a9ed0b01fc9549cbd61a3", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a66a21f5-1094-478d-8536-4eb310b19dc8": {"doc_hash": "680ab50ac025e03ce56f18a6f6bc061a3f81b281d3a12e0529d7a7ee4d49b1ae", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "30b0c3c3-891f-428d-a037-6ebca59d31e8": {"doc_hash": "b47626c4eb209f83c7e32fe4b0a355dc71be050b7c4b28a6b9f33af890be3972", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f0332119-eb61-4172-9e14-dd98d0c7e966": {"doc_hash": "b889367109b439c07ca9ede9fad80ca8843d0b407c618da991688d831ea56bbd", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "72f21f4e-2596-4943-bf96-8bd3780ce7d6": {"doc_hash": "993db7e78a5082d7ac9713328d68f787e4193cdbec52539e4325932d71c439cc", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "096c2e4b-4d6a-4c89-9fba-aaa0adc1d2e6": {"doc_hash": "ad15c8087da16b064338189ae8d080f86805ab51e47084d752f80e63bad57ff3", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "8615ed30-6595-4da8-bf62-9e4edff63f7a": {"doc_hash": "87f0888726a5de2512b7ddc2ca26c8d1b619fcd93cc76294f8db2060450e761f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9c0daa2d-6cab-41af-ba67-2eaef05b7afb": {"doc_hash": "a6f21ec317f715e913d2a884dd37053f2afeccaab069de9344c4c098e298b5f8", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "36697aaf-12f2-4dd0-a2cb-0bee99087d57": {"doc_hash": "103dae1822c9d0ebc2e08ccd9199ce0a980e63552c2a91f3690d769a8d0fd672", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "66db4153-a9a4-4486-a152-60d2363d841c": {"doc_hash": "a1e8d78f141a72708be631bfc04d202040c9c3b75d74093d24267a078e1e587d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "49f087de-9be7-4150-9afb-39916233a484": {"doc_hash": "d621328f49358da01fac444f25492ce5cb02e28c9d56fda493e4bb5a191352f1", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a921c7e4-1eec-4fc2-aabe-1074dcc07d31": {"doc_hash": "791cccfa012f314e7e10299146d58a6afca15aa2fc3d74495eeb204a9644dc8f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5870f848-a410-46df-9219-2fb7430a1c17": {"doc_hash": "0d0ce317f3ee2ddb953be132b9a4d15308a54fa3f1204cad5b3667dd87bdcd2c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "0a8914b0-ce95-4dbd-9dc8-6b802701792e": {"doc_hash": "816edfca248cd36efde24b1f61e92c20736d8fc290f64436a2639b5c9f12b346", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "7eb778d0-b5ac-41fe-a7e8-7ede998fa443": {"doc_hash": "1bc32baf3f9828a92bc7431856b9fc051e6e26e2f348b987f4c693a431c2a46a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "40d136a9-d91c-4b5e-bfa5-5d144e3d4948": {"doc_hash": "8c186ef73c501293852eef1b6249e2d327b8d466192bbddbbd018e894b731988", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a2b41182-5217-4261-bf9d-d115c43d6299": {"doc_hash": "c3d4cc075582309623fca243cbf93709068ccece618ca36a34a86830f8d536b9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4a22fb06-f827-4bd3-a09b-4a0f882e6e36": {"doc_hash": "c64523953d8d976efa1071b662a7aa85afc6df726c61060331fd46f01870a492", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b2d38d6b-69fe-4bd0-bf05-389b1ba783cb": {"doc_hash": "d6baf7966efdf05e6ab73159bcf6c288df7b4c657a854d54f45c5f41f6783a5d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c40dd641-061f-4420-b550-23ce55093235": {"doc_hash": "8d80d1a534458bf836e2648691b1184d50dcfdfdd8a534ac91af78c5dba5f805", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "62d527f0-310e-4f9a-89ce-a3fdd9d3296f": {"doc_hash": "3ebc08bb8a14ed0f88f25a21dd870c246a021561583087aca772a8ca331062be", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "dbf4cbd1-7037-460a-948c-79cea6f16272": {"doc_hash": "2c564e3aa50a6c84d814ceb1675ffa5dd1b1735b529195e0d1c2fef546947b79", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4f49f486-d93d-4f73-beec-228e10ae1996": {"doc_hash": "32a93b9e1c9f841a59b63c17684088fed71b5c83347a0ca6f03b1c2003b48658", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a92cd5b3-2750-480e-8458-d8827a917cc7": {"doc_hash": "e7463d5e1f3f8747f4a8355065b974a7ff10fc339dd9b175893659eb01e4700b", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2228205c-6c56-4f82-8adc-cf2239eace53": {"doc_hash": "564cae44b26cc402f808e7000dffb24048fcc75c3a2c8eefa811f397f27a917d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5c10c372-7baa-4d65-8af0-3437081adb09": {"doc_hash": "478e925ed991ba597b19abf04d5e392a520315421dae248bdb34168f6745a725", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d564279a-159a-49ed-95de-6c89d7e5ea8f": {"doc_hash": "0e8e561a9310c8c66dd739c191e16fa72b42caba6a2d8f7ad739435fcdf9adb6", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "04c3c39d-0dea-46c0-bfd4-cff92937b41a": {"doc_hash": "afc8b891b00a5001d7bec8ac8c5411d2532360b8219b838beb6a25d7c3c24cfa", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "6e6fb7b4-caf7-41dc-914c-335ef093838b": {"doc_hash": "9e9c5cc95747aa8c2834e192072a4b80909a299dabf8b8461e2be62bff38b976", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5e3bb644-fe1a-43e5-b19a-051a233098d0": {"doc_hash": "79517477f207d866bc8c4c1cc932c7e16a7383e098f706bb9c2e2557d5a052ac", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "72062330-c47b-437f-8883-1369d75e870d": {"doc_hash": "a4563a3c2eee0e8cba3137c249ec3064e10bf4157cc50561c9da15db29bee8d0", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "53f0463a-e472-49c2-a787-599301a971b4": {"doc_hash": "fab87fe65986a65b4c8689f2bb41f65d84a9df5297e6637ce0cc346088eeceeb", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e939f213-d4c0-4734-9263-499221f5c85f": {"doc_hash": "91ed4bbc44465ea5e0f73b14d80e38afd3aa336db14bfbdbffcd0cbb03b89fca", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "daa38e64-5d54-42be-8375-5958dea13124": {"doc_hash": "ff8b0cc97522ca0e8bebfdb322783e3e9182c6e37b59db7cd927bf61336d5635", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c7bf8e0f-6c52-4568-aaa6-b9197b41b246": {"doc_hash": "76409a32705607ea4e423560d3aa509ba619476127aba53ca2a2792c4e8ba040", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a22dc1c5-b431-4fa2-9f0b-a3ac38ad0e43": {"doc_hash": "83c255f3d7cae1ec16c3c29dca2c5848c4eebf3f2b56632ad9849bbbc214f102", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "83f5682c-3881-4658-9c71-18f247e7939e": {"doc_hash": "dd5e0bc9a842a2b8f71532d877511d8fa8bcdbf81cf09946c9f626946bd92bda", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5c71451f-7e77-4ba3-92d0-63b3fe268459": {"doc_hash": "2e436289d3b69d6775935c056f19fb9f748e1bbbda555569c944bbf616bd7f48", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e4dc2d94-b8ee-4dc0-a3bb-d00b48d4a41f": {"doc_hash": "466d5a9833ae31d74b3b4afd7cec13833152f4673536702abff5b6933e2f6ede", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2584ed75-4493-4a8d-a06c-0c99dc1846d6": {"doc_hash": "d15171714deb76674a4b9e7ea44f96c9fb604c83dfe1544029d1c45ec6d51755", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "757736e5-bdba-42a9-938b-d6cfc7a30f4b": {"doc_hash": "ec91f58fad13868576d2ec2a412c497efe929afc1c3d2477c6ded3581d327ff2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a96fccec-1e0d-4682-b3e4-692f102c8440": {"doc_hash": "b723e76c711608a67637962b088da902e8b4737ab4165895fb96d8d8b2365cfb", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b3197541-d5da-46a3-998c-a159675ba1f9": {"doc_hash": "6aad7f04730d005b3c5215f21322b0b4143d7e5862c771d8dba5ba3c662618f8", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "1d1381ce-7f54-4530-8a45-1930ddaad0a6": {"doc_hash": "d263d1a0737b02e3cd9e703aac064701d0a79c20c4fa4e527c3cbc1ff15861e4", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "90d3e703-2125-4d39-9aa8-efa943425a53": {"doc_hash": "144e3511e29070ebc7b9938e38193c964bd0a6972c89e2e523f8ed0cf6ea7162", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a737f9c4-c064-4793-b8a8-63171cab5780": {"doc_hash": "2c0f896264b9c0d39330b1ed464e2b60c050c44fa527f99f7419c5938f38428f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "75c043fd-02e6-43a2-b834-fea90df8f100": {"doc_hash": "ba20c19aa5970e0fb518d2341d3f1a7b14ea65837527049fec1f28e23065b771", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b5d5aac7-a068-43e0-bc4b-f800c6ef3f4a": {"doc_hash": "f81258f48a6a13ee41585fc04e3bb17afb7ccb630f761dde00fc6e8b264f8c36", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2d74e6ae-bfb6-4566-9daa-9f5d5b2125fb": {"doc_hash": "93bcf81e5fa21fc4b847b6e354225f87b2fd4b9c058a7747b9bb580dc5a5f683", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "42ecfd74-6f9d-4e60-93ab-67b0c41c35fd": {"doc_hash": "6dc7b22851ce27734404e147c2404d3698a97b63f42bac8b56d1ee61b9ca1cd4", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "24249ab0-2b7c-42c4-993d-f67e77dd96b0": {"doc_hash": "3f281f6176051c339093c1f3f6110535d13e13db60f12255f4818d9bc9c2c58a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a905f101-515e-43d2-99e2-e0ac3a759970": {"doc_hash": "f8aa770adad0be0218d5a6365ba44a077361a5c25bf9111998620b4852554db3", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "24148f9a-3e02-4379-a425-f35959db7777": {"doc_hash": "36e2074583cc89e70a7c7196a6e6d6a0766dff154b856a82ce4d09bb39ead637", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9a7a1d2b-b1b9-45dd-9d34-e51736138a24": {"doc_hash": "989f5791da9d1f52c657c3811e2bdaf70262395d531d7b6bc891ff27e70d3df5", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "1be4cee3-acc9-40a3-be4e-a0f0422f8422": {"doc_hash": "ce68fe1bbacd49dcd5d8b1bedf97270c47833f24ac4290d57f7f5f6b5c6f9c9c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3638f542-4b64-4566-993c-e941e9d28f3b": {"doc_hash": "fa5f954285bf48c2c7793e6ddd254514f360e66b8ed45c9e0733e27fe6822694", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "090b0a35-827e-4f04-a7ab-2f331a1f9e54": {"doc_hash": "9f9d077e5be10689b7b0126fd1b58fcf91013f2f97fd586a597c96d704af7c8e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3de92378-8f37-4a4e-a806-80ce63529c50": {"doc_hash": "257087b1f5cc0a1e162b8eee5cb0dc03f5afe11d4988d56b23f2f32d3b99f400", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "34f28792-d2e6-48b7-90f2-f3c2edba834c": {"doc_hash": "66370c5a47377ebabeb2f16c9c7ade36b99e13c78bdd901363e7d6152fe856d4", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "58249bd0-3409-45a6-b57a-b91e60fae83d": {"doc_hash": "7b80ca345c74e3b91afa7d35037890fa187e6b581d97e6969323d397557618f6", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3faad072-71fe-4728-95ba-2c86e29ba076": {"doc_hash": "d1e1d8b9ed473a3fd4533094ffdec55235715f55cd43cc632b997194d1c61e06", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "89058d4e-e6c9-4560-9756-e798ac837423": {"doc_hash": "b84f511248d749219c90b8418ccbfed389297b62788e322722225e7fd1406872", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "cc19f965-ea78-4393-9207-38dfa2c76166": {"doc_hash": "483f26d33ed361c50e1eed351b8844190dfd161c1aaa22a5756c6a595fb4cd7f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "7dc77a20-4081-4ae4-90fa-60f300b4c566": {"doc_hash": "fd06699757cab9507c498c1b405683f8d59201e44e04759d9a47f553d0deb1f2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "cc6bb88c-c41a-4a95-b204-59176e916630": {"doc_hash": "1923a064dd8254ea0ad5b5a354d7c995a029e8eb295201699c163f33529eeef2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "cfd46ede-8865-49cb-b6fb-447cff08180f": {"doc_hash": "9e0befc10d9cccfa0c9d31cf20cf455ee991d1178141780049f721a97407dd30", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f9fb01c4-28b8-4e22-80fe-61a5504ef95a": {"doc_hash": "accaa7915f56c57bf5304901a28752ab027cf648788b02dbeef65c5d1dd0a6b3", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "13a69172-f1fb-4bbe-b486-6705ca0dd3e0": {"doc_hash": "d6621dfa813734d4de5e7cc765d22511a49bcc8ad8303b2266e050434f6b72d2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "976a0b82-c220-4608-8717-f5fda40b589d": {"doc_hash": "3ef4485131e795973c5bbac20bc0c595544de6eba4f18c16b9b529e5332d5f80", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "97b42b37-b833-47db-b78a-6fcf958d82b8": {"doc_hash": "283949efecf311afcee7e86b6767505744d512c4dadae794b06cb872b34d6a7f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2eab4670-82a5-49ce-885f-89d05076d69c": {"doc_hash": "71dd63c9c0bc30e41ec1a36798a44cdce0f57aca1990d8031af808ac3c251ebd", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2ee4f07a-65ae-427d-aa18-bad8268671e6": {"doc_hash": "cdf5f846ebe236c440ca4b5a8c79a773484e9423dbadc084fd50bf77fa113051", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "6a6a26e0-0d81-48a9-8da1-f5ee8fff4301": {"doc_hash": "9f3b9200573fded94bb04d11736f71da0bc892b3effaf12c7c582923375f6a07", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "8636d26e-b777-4881-8bd2-36070d66bde9": {"doc_hash": "aed66c03c75abcb17a1fca5b62705fef19bf8eea0b7bb83c881cdc3421447182", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "aeabf378-88c2-4ab0-a6e1-3bae6af8fcbe": {"doc_hash": "0281edb1be8a413822c39aa4ca4fb88d0bd9e122d78407453bfb7fa22974a05d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c675890d-a913-41fa-a267-900d2db8baf5": {"doc_hash": "aacedd5ad1a1e5e8d5a91d750f841c84d3b5f27bd213cf4634da7b6fd383b50b", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "ca35db60-20eb-4da3-9813-e64de6027423": {"doc_hash": "8690857986633e930c78041389605df7567aab7ae542e19225f1cd7a8ef76540", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "318eb557-470c-4488-a451-ad0d441fa2aa": {"doc_hash": "74df4a18b1c224c87a3159d395cc02d6030cd32dfd84ab97bb7b87818830547e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "51ed877b-aecd-49d0-a93f-1c927ef760ba": {"doc_hash": "c0639d76f11049f0f792923fccdfa9e1b5e0689dcdbf1015d41afa7277db5d40", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b735c775-4891-4d95-bb6d-747bf379c53c": {"doc_hash": "332bfc93963b8694c4c79f1cb135d56adc2d2b6e3be80a48cd2d4c18903cc41f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "6c2c430a-4ebe-4be8-876a-d61898dffd12": {"doc_hash": "30d6c8666bc14b4592289788cf093ce20967dcd07b3ef10f3b181cd6fd048f73", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b2fcd079-151e-4762-afb3-75e73662d773": {"doc_hash": "883870e6dbec975fc3b30a5aa3302ba11f403c8a23584ec782610925732572f7", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d8c40691-573b-4a8d-8fcd-055c94dd275c": {"doc_hash": "58529c04a1f39606579f6af581a34726c67269ae70216b935ccd8006c555db2e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "68d3de96-3bda-4161-a2c6-831b02493bec": {"doc_hash": "506ae08d6fc3631e7829cb9ec19e12fd0b8fa19deb1031789359e05dc3bcd6e9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e8777ce0-4e3d-4037-ade1-90c2954d1850": {"doc_hash": "5fee9ad340b8be9625d326e96744604cbf85f3a81ee267d8f52c3f13fd3ebbc9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d2cd5c0d-e1fd-464a-b5fd-658275486540": {"doc_hash": "c8cba6efc1851b70588330b03545487fa69bba149f64d04545ad8e1a3171d154", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2fe778c2-016e-4e95-b2f8-b910574f4ff1": {"doc_hash": "fe0ce370382357637ce02353f32ba8e17771e5eb9dbdaf6d5b19bcc465c1ca15", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "7984f61f-4dad-4704-988f-83feeed85ad9": {"doc_hash": "a3774aee52b0f5b34460af52e862ab7dfc5f7b0b2002bf88077763405efc5680", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5cd45d32-1e0f-4f69-8824-260fff5f6ee8": {"doc_hash": "80753be47bcf89169edc31290033164cc73c08b27c4f9d99d14d275252c90c19", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "bd315507-f7d0-49e4-b4d5-45328d276e85": {"doc_hash": "2b0981a5aae5d11c3db4f53927eb5684f91db8f6757e3c701e4837be814e0502", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "bc9679ce-bece-4931-bc92-1d48aa2e3ff3": {"doc_hash": "838df1ba65b5472f1889fd374a193ab9692f2ef834331ade23e0486c4f4111be", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "02bbd247-cc7a-4e94-934d-8de0d27d31d1": {"doc_hash": "11a7f1d68623471d8a56e24b72b0083517d44824f12bee0c5611dd1ccb50000b", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "88e619bc-7cc8-4174-af95-6704c3570f8b": {"doc_hash": "cd7495381f494b10564a998bdc76402d7364611cda904b91bbcd3c7e626b5548", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "6e23ec52-328a-4fa1-a402-ebed7090d1e9": {"doc_hash": "5fce6a9f723c9f875c2c0f7258738ee790c4990868fbcffacd414b5d95074003", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "503ae3a8-7cf8-48e7-87e7-26f381793dc0": {"doc_hash": "1db79d0220e789d83920a7c95adcbffb5cc4edfaafb6b36af9e8e51599338beb", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c318a363-0581-48cb-a76f-fc84d1d606f8": {"doc_hash": "88ed0fa03a3625ac499601e60674076e8ae91224b88597a107a6b166df8ad323", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "da0abace-9b8c-4942-a950-38241689c0db": {"doc_hash": "892700b9dc7aac531269a0a8aaca9e6c570a549dd04105067c82ec4258f20d70", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9f229035-8f40-4b06-9eca-a730b0f59151": {"doc_hash": "2e4225f61bf753ef6a7a8d92d47f8424b55d01a066b1a36b532418bae8c6d85a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "da83e738-5c56-4ad6-af6f-3f789fb909b0": {"doc_hash": "b50be45b9ce9e78969225b3ad5a75b60725d89a318f72c4d746cdd5612392d8c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "54bed8ff-4170-458d-945a-ae93ba18f467": {"doc_hash": "07d01f72d1fb8e65e1294052381e1b7d69d44a33d3a78d33a423e61db8125fb2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "507838c2-28ce-4e8e-9be5-c1d7668559af": {"doc_hash": "f89745caa60723a60248dbf1fd51a2157d8247b62bb4ba3ded7050177d0188c2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "54d91d97-f3da-4ef6-93ff-0c481f4155dc": {"doc_hash": "8d9869dc9b0965cb7ca129d9a1145ef8b992687c937ee5a837a865bf6286fd82", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "daa2b039-82c1-44bd-8498-e3a34c17ab91": {"doc_hash": "baaadad2050a313bb86ef093cda46c60eeeb4a8e651848ecf4d44328a940e5b9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a441f272-97bb-44b0-9b41-cdcfbe1271de": {"doc_hash": "fb8cbc6b74bc75f59171bc1a838224af5e4514819d11ae7b147fd5c99ae333ef", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f706fc4f-014f-4c4a-a424-37d4f575b6e1": {"doc_hash": "e8585f3348f09230760e2253d844c9b5bb2aa48e76cd602e9761c0683560d9e6", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c510323f-9234-4cc9-9177-972882dc4c92": {"doc_hash": "73da85008784036ed545e46fa325fb0142a3e1527918a03e3e4b914adc64cc39", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c4464ade-f4b5-45fb-954a-bf08970554a4": {"doc_hash": "0362e2fa0d7def90f76568223baa7e9265ba2ab8ebc59a29a63ade4ed21a3b85", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "41c7ce11-0858-4f4c-a529-c975f25fcce1": {"doc_hash": "7769bf64eb6e35e9b95846a34011053c6381d30d19592e5b79778af3db54d940", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5a7ece0e-17c3-4104-a056-a89ea1159c7d": {"doc_hash": "7444c3b0087ebce3a2a8037b68fa82a2a19e008a42a5bc39109c7480aa310c9c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3d07c2c0-5fa3-45b9-896a-b00b8b9376db": {"doc_hash": "51813bf4c7c2a4bcdca5c275c253f654379cb4b966dc1170cab540c96fcc5fb7", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3fa16795-8749-49ca-b368-e0aee1c9bb8b": {"doc_hash": "abedf719b8dd3c943d97ca8a80f52a4865da445a6de52814589b5103cf9ce81b", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "305b3fad-ab0d-4347-a4a8-f692396fe162": {"doc_hash": "a37832e252206f1dfd37d3045baa2aa36d79078b86e47a0fde2879b36869f061", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e3d50b49-642b-49ce-b5a1-6a6957ea1bff": {"doc_hash": "81baed481823f3669dfccb6af5f95fcd9d02fac17bffdaf819ee9e68ed71f679", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b63d9d27-8c18-4865-9312-d9295047e3a2": {"doc_hash": "c4d0c05bd54f08e3fe99f18bbd1f72b59ab045d85abcb96db76a076d93663d17", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a2dd392f-caf8-4f63-b39a-89af7d5e45b9": {"doc_hash": "3fa1dfe4cde3d3ef6f7e1cd6cebf832db3232004ee6bc9f3f2c00fb656be6ed6", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4590ec06-6d10-4146-b6ad-f95e18cc7981": {"doc_hash": "e595f5c9fadeef08628b3c2960cef475f4c904c6d01e9d46333bc464155b8b96", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9f6f7fca-ffc5-43e3-934c-ffd8477c0b68": {"doc_hash": "a5670dfefc400e6ab7c82d03404b5115cc74de6b87c564f5175d6ef845251a97", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5e800259-51fc-4253-8153-6610aab6703c": {"doc_hash": "420ac33f25a4f59c719c0154bf4fe5211251c6f2da8283476a5e26c6e3b95fd4", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f46dcf2d-6e3b-47d4-9ad0-f9e6b19eed13": {"doc_hash": "e460b48d3ada6f4e62c5e6aea574295c4f9759a131b76cb935492b9d29f4d388", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3c75a03b-7b40-4cac-aafd-9404b1e6f6a4": {"doc_hash": "8769a7ea7d195aa64d1ab10cd5e909b183233828d7a3a6c780439f5415caf295", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "50e0a2be-b209-4d61-9e8e-c0265ccf1eb8": {"doc_hash": "e47f4363b9faf32362c59a081b39c2e79ecbf75613ae31358a9f805eb7b2a74b", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "df1cae18-e5c4-4c8c-a057-f3acfed248d5": {"doc_hash": "4984dc1ab63fe52e4d5b5c48a605350d8ac5be9b0f42ad6115123a0f4507d578", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "1592a926-e773-47a5-b542-8e4892271326": {"doc_hash": "ed5acb25cd4d1777ce23a69e47a4ddfd0362e6f31f29d297d457204cc222731f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e3805032-ebeb-4017-841f-772afe7d80da": {"doc_hash": "cc91cd9cdb8201bceb220c1b64117d757b28b32f03402e2e846a03f408ec7d8e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5320215f-7cb1-479e-8f0a-98d19b52685e": {"doc_hash": "78a0e2c24f8b15e02a40cd49eaef5488d615ad652aa6a48db591ed77a3af533a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a5957a05-1510-4b01-a59b-1e7b2ff465f8": {"doc_hash": "b07325a1864d7d132fcbf473c7520f9d1b5761774c704243ffd012976d22da61", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "6536fe42-1b76-4d6f-9030-34c29459e4ae": {"doc_hash": "a89fddd5d349ad087e66249e3a5161c6610cc31b24cedfb676f09efddd2cb2a8", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f4c68d10-8304-4201-9740-ed93244612aa": {"doc_hash": "c04dc0d127a602dfbfa45c45cd5c8232b412643a4fdd6b7030bef217c12bcef6", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "97ee77f4-e793-406e-a5f7-86aa16ca3c50": {"doc_hash": "896fae241a74a95d7e36ad6a6b12757e91175a90f9d93de4108e92c2c308d02c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "24ca5357-fc2e-437f-9809-532a330299ba": {"doc_hash": "2839136bdd77ac69dcb1fcb044d1a232b697b3d68ed26c563fb54458dd0621ab", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3119c97f-6fd0-458b-a756-00c02f2f8bde": {"doc_hash": "da6d24ab0546650093014728903107d0c643f7d1eb718b7ac5d3f50c7128f8bd", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "08e6b320-9bbf-4928-b482-7a9a4cc3ec48": {"doc_hash": "720c3a9919e455a60a15fe76f4658873b53e125b85a6dac9019e9169a82dfce9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b30f64a4-fd94-4eb3-aa15-f5d024b11799": {"doc_hash": "93b48f6b1e2ad4cd99bd4c91ae44c2d00c37e698614a093788adca720217df19", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "50f949a3-5060-4181-971a-6f6ecb238efa": {"doc_hash": "9a268229739322060589794b414e22257b4e71e2c29c10704d85bdc3523cb6c1", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "430e339a-2652-48a2-96dd-99bf1ca848c2": {"doc_hash": "cea0e343d24d1cbcd122357e9d25685cddec95cb435be279bb0f6f39d9b3cbf1", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "02512f5c-1172-4850-9c8e-40a38cf8919a": {"doc_hash": "45c1c2701ed7a3b269f8f8ea15d6ea2cfe8368569057d0af612c9df5b52af3d8", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "69d36dc7-323b-443e-816b-ea8566566973": {"doc_hash": "e4014a91e0da4d477ae28e9dde435edf89ee0b8bac3bd11447574099aea7baee", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "54eef8ca-ca40-4ab8-b607-e39c8fe7e12e": {"doc_hash": "25869262390ebf1b2114b06672fd0e7cabdc47f42acf97c551113fec7a1304be", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "737a7657-def7-4a13-a2dd-ea5889e96d95": {"doc_hash": "30895774dbacd4ca1665f168d3f1e4ec25e85ccab26ba1952b78422863a182ea", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "0cf25ae8-d2c0-4ec3-ac51-0140398bfcc3": {"doc_hash": "b1fa6442969c1fcc375e0bd8203383d26162542735ef60736f3f2eb41bb9798e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4c7d79c2-68a3-42cf-879e-384021a7d199": {"doc_hash": "a318edb83885e424b54c8e03c33d2e85349c6a36ab1a34f188e5831ae9852ea7", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "091820a0-24c0-4db1-b3f4-dd04c696811f": {"doc_hash": "09e0f0da2ffd56ba09fb57319e6c871d6bacc5d982aeac125a7d7f7af2e34d16", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a00682a1-bdd1-4df0-a918-7d20e17c388e": {"doc_hash": "951f05722b8168f259aebdd27080e3d31a36dc578eb6a5b6922ad9cef0e9372a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a54c614a-4953-4373-ac65-18bd0fdfd974": {"doc_hash": "882e1e6acd8e861e06640afbcff1eb2e9d0f5f645056c590d3dae3f71f1c8f68", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9d4ae3e9-054a-42ff-8ef3-376c2791e575": {"doc_hash": "9d1c7d7728a2bee5eccfe31a96d481de734e973ac8235d96c0cdb1807124a282", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5b504746-7a4f-45e1-a7fb-16e1d447bd50": {"doc_hash": "8c61fbfa142824a1aded20254338356824e02d913c8dafdd78fe6584d8f375b0", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f3645bf1-aca8-4b4d-b1a0-f96bfefee913": {"doc_hash": "9f10114bca42276de5adb61ae917e145ede32d857527448604467f7599400069", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "35e563a8-9cf4-48af-8f65-b5a626108753": {"doc_hash": "528b7973ba642be7c29f92cfb7f792b497f4b293e29eb9bd2261fb42fa9fe3cb", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2adb80b9-5b48-40cf-9a74-9f7cb3dce652": {"doc_hash": "23ea39998f48448d94100d12205bc0e0eee0a9322b224685494f4d8f75fa1680", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "26f81cb3-be38-4548-8613-8d465df3cf20": {"doc_hash": "638864adf0b212ad31836b31fc907be60e2347822da5236a879b61ce03675b5c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "87123bb9-c1be-45c2-b433-7eee74da94c1": {"doc_hash": "e69a3a51ad465a0613a1efde04ec86f29e6086f2398df4154e27cc611d5ca407", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "1531d0a3-9773-49a9-baf4-4c08b11c96ac": {"doc_hash": "b4063a80fcf84f4cbf9fc12b1826711a15fb8bc28bd5e5f10066e6cfc7fa06f3", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e8071a64-431c-424e-9c9d-84857be6e6b0": {"doc_hash": "314cdd2a9d0aab384d78f0e4c9508687ee0b8f98467fe2348366d055f4d2566e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "20e1f495-27f3-4ccc-9296-d26dbcdccf84": {"doc_hash": "27de3565b91135cf036b9d94f4d625bda864283fecb2b4cd1b0f9a1d59dfec57", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "f3a149d5-39bb-4d66-9110-e2b871e141f8": {"doc_hash": "496493d583ad584a910f462a82872c3919aee269df517498675007d0d910974c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e4707514-89d9-4daf-bc92-44468f41403d": {"doc_hash": "fe533532d29e023a82e9671bfbe00eac23579c2acc9f68ccc082f09699710343", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "075d378b-1cd4-4457-a226-4c53ce9489a9": {"doc_hash": "315e6c5f9ff0b4d446a1ec0ac065fa8c5035d91b93079a53e00197f46c71addf", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "54b24a89-1196-4580-8a2b-a9063e64aadf": {"doc_hash": "6b1e2c72b4dc8729e877ed248411f8201f339ea1cdcebac3223b4e27f0b688ee", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5fb3adb6-49f4-4767-b5a8-fb0bd7221819": {"doc_hash": "4df40f78b45160e9df5142cafb9692faf606e50192507318ec57edb0f8d7aad1", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "aa1ac5a5-622f-44f5-8bd2-502973bac1e2": {"doc_hash": "919ab94b9935011b57c9e1acd3ed52e4b259033d526a7efd5a47937639b5cf41", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "159c0ce9-0550-433e-ad21-7308cb963196": {"doc_hash": "a032b2397023a0e97c443e7a289ca00106255db9650ee6852d11a5b33b0e8329", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e677c92a-3dfd-452d-a54f-aad2deddd8d1": {"doc_hash": "0e4541257c89138030a46d7a397ed24ec4a9addad17adf638cd104e601231c24", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d4b4d6b0-7837-4ba8-b7ee-97743637a9e7": {"doc_hash": "6b923b4b01f2c5f1cc25e720caf1b2e8fbdd2842b5a11235fe70f5bebd020cdc", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "04dd4beb-8f76-40d8-b789-ab091ed11cba": {"doc_hash": "e398f68fc7e5d475e2737e127514d65b22e7ce41cc0f4b6555af44204ecf2a22", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9bed1b83-2d62-47cc-b9e7-9c76a5ef2803": {"doc_hash": "4b3580f63a38d306bb92381194d5e17d1225944efe990b2db838e1cff1746d61", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "316c77f3-760e-40bc-b7cc-bec6cc17a976": {"doc_hash": "b7101772adc063c055882f5537e4243ca4de65ca9e5686e3415ee7a1d393e797", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4ca516a4-f1dc-4ec7-b35f-90a45bcd5210": {"doc_hash": "087243be1349feaed6621b17f76a76f43d6c738827c6285d58e7333fc3606d40", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "bc703d50-b163-4f8d-9ebb-4c0513f3df80": {"doc_hash": "94423fb5c2eb50c18a8ee5e304f98054a6eacbbabbe553004aed783a674a8daa", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "47debdbf-a2a9-4d09-9159-aea64f35bd83": {"doc_hash": "0b963d07eac006ab86303aacc6babcc8133cd89b35f8635604e031861252ea0e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "464020d2-e8b6-46b9-9bc0-f57eb9f27c35": {"doc_hash": "1634ebf3a38e66c3b51e34564fc84fb8188cead6a01e11d6a43a46d00d86a5ec", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "49195315-41bc-4a7a-b48d-3134fc835c35": {"doc_hash": "4343553200061d9c5d39f5eff14a90423ad3cb86f6bc6bdf6db5d5b4c6e44f7d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c5ca4760-838f-42a3-903d-47ba895f0514": {"doc_hash": "38507e592cac30e44c867659ba76bc05c183ab034930084e41ff76c43a5d7975", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "82d4b21c-b6f3-42be-80b3-dfb4045929c3": {"doc_hash": "55e59ab39ec937536e565daa9614f4d35992e4b685f491320461eda5bb2fd153", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9350a3b4-adf8-4c48-b84d-d4f3495efe3b": {"doc_hash": "180b9553a2b7c8c9e4bb60fe0bd06ed9db8f1267e5b9999eb3d4f1a13d05ef39", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "6403085f-ae51-46ed-8355-3aa29b08b8c1": {"doc_hash": "29051f9a1bb87ae258de1ff81b782fae471405cbdb608cf9e86754ed1a1d5554", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "62c72ac7-89c5-44a0-885c-844999408084": {"doc_hash": "b94ac20cf28e9274fa1c0bb5eafb3cb2921255fc03680e38a8f458084542102f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d85f620b-8926-462e-a0e0-d08bcd62afbe": {"doc_hash": "820209d6aa42aaeced9d99b2ddff4eea7a048ea841445431d565f754dbd0a09e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "12c30ae7-9b7b-4425-8027-dd3868a8d8e1": {"doc_hash": "812637385b74cdeff0ac2913188e59bbb9ae5d5ed8b6bd57373ca7bd0a4712f6", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "47ec6063-7b80-4c92-b55f-7d81a1f08061": {"doc_hash": "6fbdf2321609a0546460edd2f7de2841750b3e9e198c7a6c38c38a12af46ad69", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a0d2e95c-d2c5-4cb7-9ae3-1a01263383d0": {"doc_hash": "f6998a4ca4a4b20ccee8e335e17a2241657fea3ecd25b26aa00eaaeeae946970", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "7ef2cdd7-418f-4923-ab27-8f78e129dbaa": {"doc_hash": "c3372300df4f5be5518459d2e147308090cd427c115d18a7ff293ba7c421a791", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "966e6019-4b2c-459a-9336-3878b710fd9b": {"doc_hash": "1cae01185efcf1ce905813a62a531efca64c81fd0159c70aab53275fc9bb3a98", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "ca96cf2f-ec15-48c9-868b-e75d14d47fd3": {"doc_hash": "365d1dc4be7cff4b008ab739d7d9f138532c129ebbd07210fcfc847952c0d9c2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a4046b38-68a8-4f7d-97be-10949973f986": {"doc_hash": "0a0f4aaa67a064dda7421de7c31a2a11597ac3edf8c8400c78ef91a52b3ac2f9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a1d0c310-32d6-4c3c-aaab-0cf3066e1f25": {"doc_hash": "9d3889b1330e07fc752ae5d7bd765baa7e41ac45c4dace0a8e2f2c9412a7dd55", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "fc74c24d-2187-40b2-b17e-1fa5dc5e1f70": {"doc_hash": "eb72eedb3b6ce6651a760263604586e28d8b7606692c6a096f67abee65dc322c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "64e41ea4-f089-414e-bd82-d8db9412fbdd": {"doc_hash": "ed9bfd5fa1b949ea6b08a292082e26c43e9f78c9ffdd16b2d9b21d9cdb6a35fa", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3e6e80e9-2e24-4f20-a2ec-10cbfe4c0717": {"doc_hash": "20029c91614d1e7f5b0fc3e0bab01c8e213a0e024332cde22a622cf1608f1cb7", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "0e373c6e-7abf-4cd7-89d6-c0039b2c2832": {"doc_hash": "1196ba217b385b449efc30a967852ef746915402a09f46062669b387dc9ba2af", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "64861338-bd52-4209-9ba0-dd38ea526402": {"doc_hash": "c4b8a3d5a8215de852da46319187d04464e54f198faa19015275e34baa3f589c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "cbcb136e-dcb6-4092-a715-687f97c07afc": {"doc_hash": "05f53ced1e3bc9f3d908f49796cc28d2f039d5f799b27d22f14c6564cdda1d8e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3d58f128-51bc-4f87-b7aa-ae0384b91819": {"doc_hash": "c0caecc1a60065d3ab62b50e64aaeccf896c421cc22a7821047bbf047b2c5ff3", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b8b21f69-38f1-4343-b0b7-1b75c059e6af": {"doc_hash": "a42420c680758b7d796bf52c9f551386ed199adf5965ecc36b552c63c9f2ecc2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "0af3b05b-de1c-4c1d-b2ae-2ee2f8a61ad0": {"doc_hash": "af28fba7212abe1c94fa791ea281a30644b358e4facd141fc3fe2ec10d24e7c8", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "55bb1aa3-9096-4fe8-a422-e0485256687e": {"doc_hash": "b45e0774b6c851d5220feb5b162d958309a88a874fd5a1796cb1cb3be874e0aa", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "df366276-0ad7-4421-b5a1-bfd1a663f6a5": {"doc_hash": "0dfdc02b7510c3fc3d65cc0918ae8363a9b09ed8fb2f5bb26d77d337ba741705", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2be2bfb0-b7eb-4196-bf01-e71f9154f193": {"doc_hash": "1f6677bf433e44bb9a818b9d6d03b79f33633c8c581751f1430cd3d732d65722", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "2ccc1970-bb12-46ad-a341-d9d54f45fa00": {"doc_hash": "ee78bae5c73543b95381704c4d1b75c0ec117b61fdb9258aea33780db3d5c2c1", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b37734f1-1a9b-4530-aa5c-74f0364f41f5": {"doc_hash": "a9bec5bf0bbad5d94f32906e4c0cc51054d377c0b10109dc7029f32b33561171", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "7601a4c3-90b8-4fa4-ac73-5ba24aba0b49": {"doc_hash": "b012f46567bf771825bb7a7a5473d3ab1b721bed65e44fbaa82734b7f91c1188", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "6cf9c5c8-a429-4b8e-b762-9c079b356f8a": {"doc_hash": "503a04794966593baf583a4292c0354f53b78b96ed17115f1bdbcc84357275e9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "67d6d349-d8fc-4870-bda8-36b410558650": {"doc_hash": "7e2f56215a09c12ef065f4375d937f1aeee23f3df89a224aaccfc13a484b3335", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "bea0a649-6bb3-4d32-b387-6702794f15ae": {"doc_hash": "3873ef5bc0ad1b626db1eea16098abab690d8c7606bb69efeba124b93d76c4fe", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c2aa1c65-2c93-4d7a-9c3a-aa645b1ea611": {"doc_hash": "67d225cade84508b3f0cd25467bfe1854faa630a54396b5fc2aadb67167751d0", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a93e5b70-9208-4de1-9529-c0fd4780f777": {"doc_hash": "de28142637cc8fa15baa2b6d9044095fb87664a1a7db70f655b435fdb21a43b2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "bdd83ef0-09f0-4f91-a6b2-f797268f2753": {"doc_hash": "1cb4e1d8f9d2733a93ce1f6d5dc551da08d9e441f6ea7b1fa3c7349be7b3fe59", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "aa5f738b-bb9f-401a-8d87-c88c357515b3": {"doc_hash": "deaa82f521707a61b9e2c4a534c42b5a75dd856da102122efd30e425d7c2eeb9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5269fb2e-a072-416b-80a1-a59a72e544fc": {"doc_hash": "bffed1158c15dcd6bfcdbd09f3684ae89da55323cbccb3af51d50a30fdcab55f", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5c270fad-5bac-4906-b396-bcfb31c83c60": {"doc_hash": "1bcd0c564546c7c441e6853943c6af4b8977fcfb234f9f4a1d08b378443b491a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5c150795-2bcf-42c5-8232-9b46b2a508fc": {"doc_hash": "62068a9c2e15f5ad281652e3beb965c58273bc22224e136418388b7f72bf003e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a5640c6c-8e94-4a89-ba81-281107c3db97": {"doc_hash": "1280903405ebd6ea635c8f9deb2d86f883afb005ed16c4e7a4133769b2f45ce6", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "c1d8e65d-ef3e-4219-8d61-f1933587d878": {"doc_hash": "a3a6d1fe7871b245baf0309e49c77ca76413c882f495b5c8a300144c43a5a522", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b67d5714-2def-4b59-8ac9-2407d0e6d472": {"doc_hash": "40f37196c2005a4e9fb63fe970403b113142a8b22c95a6f49538b1560f1f2c2d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "ce24ebcc-b0a1-4404-b4a9-6bf9fe7ef6b6": {"doc_hash": "da103e144cd0d7311464133a764d0b353fe8b3532422d47e37337d2c468beb2c", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "97cf9a1d-126a-48d6-9dd5-06a2214b55e8": {"doc_hash": "adaae760006f9b4a345ea5525504ed7b58719273cd538fb616bd87d589f0c867", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e2c380c3-5882-4361-9f19-d0a3cc15bdda": {"doc_hash": "3e053d2152e118ce4ea489985746a283e87488f41e0329467e5a0c9a7f2102b0", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "6b15849a-dd3b-48cd-b709-b08966e31948": {"doc_hash": "7f461140c9367923072d680e4ee88c63aeeb9540fdc37936b960580d791cf203", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "38d9aae8-0938-44d7-8693-2f240adf0426": {"doc_hash": "a63f9c0bd70aa537070eb9c792076bc9fb110277bb3c2215b4ddfce0cfa242bf", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "0cb9da55-d5a0-45f4-a60c-fd5c1d55b372": {"doc_hash": "e7994142a8580f379fd9f5df93ee6423ce987682b0b1c0c9f334ae0e778a71a2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3a40befc-46b3-4e28-aef5-60a4645a01db": {"doc_hash": "1da57e275707b054542791c82be5c2cf323ef3314fd01e5db220c19285bcf980", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "bb5abc18-9f27-4940-8b34-c0275c88d8e9": {"doc_hash": "984a5d1f28532a6e0d16df0f9332a8e2bcb8ea1a9e26377c4857703b4ba7fa0d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "8854baf9-a58c-418c-b629-c1cea783ce2d": {"doc_hash": "cd53621a556a7f37b4c76f271f1ffe3e9209295e2987a912da45b323057211df", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "af874795-0079-4842-b74d-118633a92be2": {"doc_hash": "65959820fed52bbecf9139a82c2f8edfd25d49e8d4bba8c8247a21e29e329204", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "71f2eebf-98d1-4574-abdc-cbeedaf19805": {"doc_hash": "33a2c229447360bd9f2ef28dcf68e5bc450f1c0a3b448b109f2164bbe0b058cf", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "736c8c54-49d0-410f-8a8f-67a370f7d149": {"doc_hash": "4161ca5dfeb97ca8064504362449b1d35350d4cea5759ecbde9a1e04a8463b3a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4703a5d2-7cb4-4934-b40d-4c2bbb3e93a4": {"doc_hash": "58f3bad29ea9103339731e345b4b3f7dc9d9758719d56b0801d9347b9c50fc5e", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "fb560e0f-58e0-4f46-9f47-21e54feed8f5": {"doc_hash": "1a8e7b27bed8b6b91516d7281a08ed7b4c16430c6ea0c04ef5ab513cf685ed22", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d752bb49-9b51-447d-a7c2-8d4328f79264": {"doc_hash": "5a1e6c8768799793030032cdc40a0607ee522275d0c7fbfa96abddf415e37521", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "ff1fc269-e1bb-41ee-836c-57189998bad4": {"doc_hash": "fa7135748abe70f716fb93b497092900484396a9f7dc8bf79559ddf8704d646a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "e7d331d4-2271-418c-b43e-4c2f4bf38933": {"doc_hash": "26a71dd6c05f5220fe573eebcf7e7010cf329ca26d5457f7cd1a65e2278d4d3a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "68e2d899-0329-41d6-8d37-050f5181fdeb": {"doc_hash": "0ba364b8bbf613fe44181f32189f250421d29ed14f69c56124900c5386f54acc", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "8b922dca-ff19-4502-aedd-b8ebd109f1b3": {"doc_hash": "70fa85fbb7bd93688b74062054544d129787779f36ab14931c38db8f0a81f926", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "ad9c7596-ebd4-4aa3-8775-0378e5a95a1c": {"doc_hash": "431dcdd32c328776be46901bf4cbaa9e71999fd519ce2904e724df53c8cd37bf", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a8ec929b-d879-4c29-9aea-7533d4d2ac92": {"doc_hash": "6458c330db2c8bff7e31c075bbfca63afd7776dbefeaca3d961fc85c717ea633", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "65660e7d-7f7b-4b8d-9629-6aba797d7cbf": {"doc_hash": "eb6d5ba585cc2ddc15b36483f1f9c1a83ffe2e8e53c8fa9504d193d8b13857aa", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "96a11867-a9be-461d-bd1c-1b027a50d46d": {"doc_hash": "be882df28ec75af3ccd0b9c073fdd71dfb6942edde1f079b84efa7e0f43933b0", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b6ccc757-3d15-439f-8782-8b69218b4962": {"doc_hash": "87b4031cd2d1341b4b36e558ed1f63c6a5493230d01280f5ff77d11b381ff231", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "a3c1c4c3-98a3-476e-ad09-112e0b80ce61": {"doc_hash": "ffabc5b8856924d5f79286598d2df912e370084318b3f1ce624b1d24f33fab76", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "73f11948-5a0c-4daa-a097-9e1b6c0ef218": {"doc_hash": "d2013c257beff170f455f8e3230b23f76a8306b7586145df8bdf8beba2507ca8", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "44d62242-44c1-4ab9-b9dd-8cd34c152969": {"doc_hash": "48fe7f543386c217a0cd15ec1c7c0f688260a6b37cc271ddd23265076b8ed7ff", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "bb23df04-83cd-4341-a097-4103a5d3abb7": {"doc_hash": "82a29967010c15b2ee28e22722169405b63fe9ea23b4a93be0f39ac4482c07e9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "752fe29a-722b-4620-baae-5dda32fe01da": {"doc_hash": "cc1fbc165535cc505e4976cc4c150378cb6656cebb172565c0f525f24c1d9b53", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "39ced19f-b8be-482c-bae7-654e71a682b3": {"doc_hash": "d19b8fbd8fe3057abeaa05add308396437cf9bd0fa468419913cf38be13b104d", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b1348c77-3357-4750-90a7-1b7fbdc05799": {"doc_hash": "d8a831af7356bba22fedfd698baca73cd8e02dcd9ed0e2e891c89a5509380a63", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d8d2fcff-05f7-4c65-895b-d61ef7c3bb83": {"doc_hash": "7decf81294e2760ad7f029820263ad97a33064a61bb56bd18730cfed33160cfa", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "5c314b63-09df-4dce-a50f-be993514b32a": {"doc_hash": "8726b316bd83b2abe106608878c71a789335cbb85d0c140eefeb1790773dbb10", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4a4d332b-a670-4bcb-b934-b252c1c3c550": {"doc_hash": "4587a0a06cb9399d0d9b47b6ab9eb1ab582f02ddbcdd3c94682f62ef6c5efece", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "92d88b27-bc15-4c28-9fed-d2f23b0453dd": {"doc_hash": "5b660ae9846045c90d3323e93862a75a143a990eba56af8c037f9f0398f44086", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "b95ab453-715d-4a61-be3b-ba011d6f15ac": {"doc_hash": "a593940b12b67ac827b8cf876618dd33eea233a46b881dd7b33f52b384355545", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "516c14f3-66f7-4253-ace5-1fa005e1848e": {"doc_hash": "6801ff957e4e232a07d14b5ff0b4b433606010c30700acc6fa6b755b0445cad3", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "1046d801-81ce-4023-b131-d396de2ee0f7": {"doc_hash": "db738ab92829197cf31c79daea60e2ea7c5a704ca5f0c5f8b026fed9fc25a0cd", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9952d9f7-2036-444c-a07e-e17d7bad1436": {"doc_hash": "7ffff9252d1ef2d5fde2cc8494ca97573520ec5045d9bd8a83c63ddf0e9f91a9", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "1a411229-227a-4178-a507-6f219c8e6373": {"doc_hash": "af71d66fe59e230402c818d501cd4f8175fee61a269b6eed0068ed891c87f5b6", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "513056ca-4109-48ae-99dd-ad90ffd40f55": {"doc_hash": "b2c95b862d5740d80d17362591070d3134400523fda73488ee53a29ef7e8d230", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "1319e319-f429-48ed-a40e-d46426f2057d": {"doc_hash": "5149fca0d4063dd438fec0e5524a8c5a637a13c5565520965cf25df411de582a", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "3081a98c-a13b-48c7-a9b1-acc30f34b13d": {"doc_hash": "fc93f9c8f82799ff2fc0b1556e2385f0aabef49884dfa691a2da2b95e9a54da2", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "4b6dfc30-1afb-47e7-b07c-7144417a344d": {"doc_hash": "04361974c067a81a4932f1bc092a6002819b2c6da55b199d92feefc9dc99a7c0", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "9cb1834a-25b9-41d0-968b-59f486c8a99e": {"doc_hash": "4c3c290b8e0c261acaf7c6b2488ed0a5b267d21e804fa648a3028ce5f9449872", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "91bc5dd8-d2b2-490a-84de-c57e0165a662": {"doc_hash": "0f93d0bdc2b6d1206113fb79aba0bc861e987eb21fefe81b0c54548a861ab476", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}, "d3f48770-22aa-448d-8f44-0d1086753eec": {"doc_hash": "725cf1555dafde89dd1d8631041f0e6b4ebaa0d66565c8564c6dc57d88800355", "ref_doc_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d"}}, "docstore/data": {"9e7640ce-ab93-4262-a732-a73f9dd97e82": {"__data__": {"id_": "9e7640ce-ab93-4262-a732-a73f9dd97e82", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "99931567-eeec-475e-b958-c8081027bcaa", "node_type": "1", "metadata": {}, "hash": "320e939621f7b5e25bde779ae558d9f4b76f150132c53cf8197fc402292ee460", "class_name": "RelatedNodeInfo"}}, "text": "This is the 100% identical eBook (PDF) version of CP4 Book 1 \nthat was released on 19 July 2020\nPlease read https://cpbook.net/errata\nfor the latest known updates to this PDF\n\nc\u20ddSteven, Felix, Suhendry\nii\n\nContents\nForewords for CP4\nvii\nTestimonials of CP1/2/3\nxiii\nPreface for CP4\nxv\nAuthors\u2019 Pro\ufb01les\nxxvii\nAbbreviations\nxxix\n1\nIntroduction\n1\n1.1\nCompetitive Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1\n1.2\nThe Competitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3\n1.2.1\nInternational Olympiad in Informatics (IOI) . . . . . . . . . . . . . .\n3\n1.2.2\nInternational Collegiate Programming Contests (ICPC) . . . . . . . .\n4\n1.2.3\nOther Programming Contests . . . . . . . . . . . . . . . . . . . . . .\n6\n1.3\nTips to be Competitive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6\n1.3.1\nTip 1: Type Code Faster!\n. . . . . . . . . . . . . . . . . . . . . . . .\n6\n1.3.2\nTip 2: Quickly Identify Problem Types . . . . . . . . . . . . . . . . .\n8\n1.3.3\nTip 3: Do Algorithm Analysis . . . . . . . . . . . . . . . . . . . . . .\n10\n1.3.4\nTip 4: Master Programming Languages . . . . . . . . . . . . . . . . .\n15\n1.3.5\nTip 5: Master the Art of Testing Code . . . . . . . . . . . . . . . . .\n18\n1.3.6\nTip 6: Practice and More Practice\n. . . . . . . . . . . . . . . . . . .\n21\n1.3.7\nTip 7: Team Work (for ICPC) . . . . . . . . . . . . . . . . . . . . . .\n22\n1.4\nGetting Started: The Easy Problems . . . . . . . . . . . . . . . . . . . . . .\n23\n1.4.1\nAnatomy of a Programming Contest Problem\n. . . . . . . . . . . . .\n23\n1.4.2\nTypical Input/Output Routines . . . . . . . . . . . . . . . . . . . . .\n23\n1.4.3\nTime to Start the Journey . . . . . . .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1697, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "99931567-eeec-475e-b958-c8081027bcaa": {"__data__": {"id_": "99931567-eeec-475e-b958-c8081027bcaa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9e7640ce-ab93-4262-a732-a73f9dd97e82", "node_type": "1", "metadata": {}, "hash": "dded107fb74136ddb835e442c4145ff3025e61d5c6cea36834b401a4343e9313", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f3042a90-da33-4fce-86a4-cba13454b325", "node_type": "1", "metadata": {}, "hash": "6dd2778e5e15275dd2d3fe0aa038589aa8a4be141c5ec5ab78e411518cfa2c57", "class_name": "RelatedNodeInfo"}}, "text": ". . . . . . . . . . .\n22\n1.4\nGetting Started: The Easy Problems . . . . . . . . . . . . . . . . . . . . . .\n23\n1.4.1\nAnatomy of a Programming Contest Problem\n. . . . . . . . . . . . .\n23\n1.4.2\nTypical Input/Output Routines . . . . . . . . . . . . . . . . . . . . .\n23\n1.4.3\nTime to Start the Journey . . . . . . . . . . . . . . . . . . . . . . . .\n26\n1.4.4\nGetting Our First Accepted (AC) Verdict\n. . . . . . . . . . . . . . .\n27\n1.5\nBasic String Processing Skills\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n31\n1.6\nThe Ad Hoc Problems\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n33\n1.7\nSolutions to Non-Starred Exercises\n. . . . . . . . . . . . . . . . . . . . . . .\n41\n1.8\nChapter Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n51\n2\nData Structures and Libraries\n53\n2.1\nOverview and Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n53\n2.2\nLinear DS with Built-in Libraries . . . . . . . . . . . . . . . . . . . . . . . .\n55\n2.2.1\nArray\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n55\n2.2.2\nSpecial Sorting Problems . . . . . . . . . . . . . . . . . . . . . . . . .\n59\n2.2.3\nBitmask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n62\n2.2.4\nBig Integer (Python & Java) . . . . . . . . . . . . . . . . . . . . . . .\n66\niii\n\nCONTENTS\nc\u20ddSteven, Felix, Suhendry\n2.2.5\nLinked Data Structures . . . . . . . . . . . . . . . . . .", "mimetype": "text/plain", "start_char_idx": 1384, "end_char_idx": 2824, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f3042a90-da33-4fce-86a4-cba13454b325": {"__data__": {"id_": "f3042a90-da33-4fce-86a4-cba13454b325", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "99931567-eeec-475e-b958-c8081027bcaa", "node_type": "1", "metadata": {}, "hash": "320e939621f7b5e25bde779ae558d9f4b76f150132c53cf8197fc402292ee460", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a70440e4-965b-4d18-a789-b4ed02a5b664", "node_type": "1", "metadata": {}, "hash": "a9aa268afa571a0bb071e309a63d042bcc6628c3c64dba39073c966c7c46ae5e", "class_name": "RelatedNodeInfo"}}, "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n62\n2.2.4\nBig Integer (Python & Java) . . . . . . . . . . . . . . . . . . . . . . .\n66\niii\n\nCONTENTS\nc\u20ddSteven, Felix, Suhendry\n2.2.5\nLinked Data Structures . . . . . . . . . . . . . . . . . . . . . . . . . .\n69\n2.2.6\nSpecial Stack-based Problems . . . . . . . . . . . . . . . . . . . . . .\n71\n2.3\nNon-Linear DS with Built-in Libraries\n. . . . . . . . . . . . . . . . . . . . .\n78\n2.3.1\nBinary Heap (Priority Queue) . . . . . . . . . . . . . . . . . . . . . .\n78\n2.3.2\nHash Table\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n81\n2.3.3\nBalanced Binary Search Tree (bBST) . . . . . . . . . . . . . . . . . .\n84\n2.3.4\nOrder Statistics Tree . . . . . . . . . . . . . . . . . . . . . . . . . . .\n87\n2.4\nDS with Our Own Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . .\n94\n2.4.1\nGraph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n94\n2.4.2\nUnion-Find Disjoint Sets . . . . . . . . . . . . . . . . . . . . . . . . .\n99\n2.4.3\nFenwick (Binary Indexed) Tree\n. . . . . . . . . . . . . . . . . . . . .\n104\n2.4.4\nSegment Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n114\n2.5\nSolution to Non-Starred Exercises . . . . . . . . . . . . . . . . . . . . . . . .\n124\n2.6\nChapter Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .", "mimetype": "text/plain", "start_char_idx": 2568, "end_char_idx": 3934, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a70440e4-965b-4d18-a789-b4ed02a5b664": {"__data__": {"id_": "a70440e4-965b-4d18-a789-b4ed02a5b664", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f3042a90-da33-4fce-86a4-cba13454b325", "node_type": "1", "metadata": {}, "hash": "6dd2778e5e15275dd2d3fe0aa038589aa8a4be141c5ec5ab78e411518cfa2c57", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5c57b46b-5b48-4e89-a0e4-2326b2648c6e", "node_type": "1", "metadata": {}, "hash": "89a25403b8f9c0bec8532d70e3d8469ee1306fee67f512158073883ad753d0b5", "class_name": "RelatedNodeInfo"}}, "text": ".\n104\n2.4.4\nSegment Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n114\n2.5\nSolution to Non-Starred Exercises . . . . . . . . . . . . . . . . . . . . . . . .\n124\n2.6\nChapter Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n127\n3\nProblem Solving Paradigms\n129\n3.1\nOverview and Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n129\n3.2\nComplete Search\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n130\n3.2.1\nIterative Complete Search . . . . . . . . . . . . . . . . . . . . . . . .\n131\n3.2.2\nRecursive Complete Search . . . . . . . . . . . . . . . . . . . . . . . .\n135\n3.2.3\nComplete Search Tips\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n139\n3.2.4\nComplete Search in Programming Contests . . . . . . . . . . . . . . .\n143\n3.3\nDivide and Conquer\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n148\n3.3.1\nInteresting Usages of Binary Search . . . . . . . . . . . . . . . . . . .\n148\n3.3.2\nTernary Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n152\n3.3.3\nDivide and Conquer in Programming Contests . . . . . . . . . . . . .\n153\n3.4\nGreedy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n155\n3.4.1\nExamples\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n155\n3.4.2\nGreedy Algorithm in Programming Contests . . . . . . . . . . . . . .", "mimetype": "text/plain", "start_char_idx": 3676, "end_char_idx": 5081, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c57b46b-5b48-4e89-a0e4-2326b2648c6e": {"__data__": {"id_": "5c57b46b-5b48-4e89-a0e4-2326b2648c6e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a70440e4-965b-4d18-a789-b4ed02a5b664", "node_type": "1", "metadata": {}, "hash": "a9aa268afa571a0bb071e309a63d042bcc6628c3c64dba39073c966c7c46ae5e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "31dae6ff-2c08-4116-8078-f1f44fe27016", "node_type": "1", "metadata": {}, "hash": "caaf4bb6b3292228db6f71979e92f54c37dad65498b9ceebe397c049f823797d", "class_name": "RelatedNodeInfo"}}, "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n155\n3.4.1\nExamples\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n155\n3.4.2\nGreedy Algorithm in Programming Contests . . . . . . . . . . . . . .\n161\n3.5\nDynamic Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n164\n3.5.1\nDP Illustration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n164\n3.5.2\nClassical Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n173\n3.5.3\nNon-Classical Examples\n. . . . . . . . . . . . . . . . . . . . . . . . .\n184\n3.5.4\nDynamic Programming in Programming Contests . . . . . . . . . . .\n187\n3.6\nSolution to Non-Starred Exercises . . . . . . . . . . . . . . . . . . . . . . . .\n190\n3.7\nChapter Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n191\n4\nGraph\n193\n4.1\nOverview and Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n193\n4.2\nGraph Traversal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n195\n4.2.1\nOverview and Motivation\n. . . . . . . . . . . . . . . . . . . . . . . .\n195\n4.2.2\nDepth First Search (DFS) . . . . . . . . . . . . . . . . . . . . . . . .\n195\n4.2.3\nBreadth First Search (BFS) . . . . . . . . . . . . . . . . . . . . . . .\n197\n4.2.4\nFinding Connected Components (Undirected Graph)\n. . . . . . . . .\n198\n4.2.5\nFlood Fill (Implicit 2D Grid Graph)\n. . . . . .", "mimetype": "text/plain", "start_char_idx": 4842, "end_char_idx": 6257, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "31dae6ff-2c08-4116-8078-f1f44fe27016": {"__data__": {"id_": "31dae6ff-2c08-4116-8078-f1f44fe27016", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5c57b46b-5b48-4e89-a0e4-2326b2648c6e", "node_type": "1", "metadata": {}, "hash": "89a25403b8f9c0bec8532d70e3d8469ee1306fee67f512158073883ad753d0b5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "283b477f-83e5-4a9c-b71b-8e437232de9f", "node_type": "1", "metadata": {}, "hash": "fda9edb5196540b893240e08e79128a0a2a7feaaef9cfbeba64c595c0ea7b2f5", "class_name": "RelatedNodeInfo"}}, "text": ". . . . . . .\n195\n4.2.2\nDepth First Search (DFS) . . . . . . . . . . . . . . . . . . . . . . . .\n195\n4.2.3\nBreadth First Search (BFS) . . . . . . . . . . . . . . . . . . . . . . .\n197\n4.2.4\nFinding Connected Components (Undirected Graph)\n. . . . . . . . .\n198\n4.2.5\nFlood Fill (Implicit 2D Grid Graph)\n. . . . . . . . . . . . . . . . . .\n199\n4.2.6\nTopological Sort (Directed Acyclic Graph) . . . . . . . . . . . . . . .\n200\n4.2.7\nBipartite Graph Check (Undirected Graph)\n. . . . . . . . . . . . . .\n202\n4.2.8\nCycle Check (Directed Graph) . . . . . . . . . . . . . . . . . . . . . .\n203\n4.2.9\nFinding Articulation Points and Bridges (Undirected Graph) . . . . .\n205\n4.2.10 Finding Strongly Connected Components (Directed Graph) . . . . . .\n208\niv\n\nCONTENTS\nc\u20ddSteven, Felix, Suhendry\n4.2.11 Graph Traversal in Programming Contests . . . . . . . . . . . . . . .\n211\n4.3\nMinimum Spanning Tree (MST) . . . . . . . . . . . . . . . . . . . . . . . . .\n215\n4.3.1\nOverview and Motivation\n. . . . . . . . . . . . . . . . . . . . . . . .\n215\n4.3.2\nKruskal\u2019s Algorithm\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n215\n4.3.3\nPrim\u2019s Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n217\n4.3.4\nOther Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n218\n4.3.5\nMST in Programming Contests . . . . . . . . . . . . . . . . . . . . .\n221\n4.4\nSingle-Source Shortest Paths (SSSP)\n. . . . . . . . . . . . . . . . . . . . . .\n223\n4.4.1\nOverview and Motivation\n. . . . . . . . . . . . . . . . . . . . . . . .\n223\n4.4.2\nOn Unweighted Graph: BFS . . . . . . . . . . . .", "mimetype": "text/plain", "start_char_idx": 5944, "end_char_idx": 7533, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "283b477f-83e5-4a9c-b71b-8e437232de9f": {"__data__": {"id_": "283b477f-83e5-4a9c-b71b-8e437232de9f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "31dae6ff-2c08-4116-8078-f1f44fe27016", "node_type": "1", "metadata": {}, "hash": "caaf4bb6b3292228db6f71979e92f54c37dad65498b9ceebe397c049f823797d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4b7f32e0-1dd6-4863-b1b4-4e78f8df7a5d", "node_type": "1", "metadata": {}, "hash": "6f3de078d9bc20c43facbe672fb8d0f41742d927f93dd3fff32603d7571e7d40", "class_name": "RelatedNodeInfo"}}, "text": ". . . . . . . . . . . . . . . . . . . .\n221\n4.4\nSingle-Source Shortest Paths (SSSP)\n. . . . . . . . . . . . . . . . . . . . . .\n223\n4.4.1\nOverview and Motivation\n. . . . . . . . . . . . . . . . . . . . . . . .\n223\n4.4.2\nOn Unweighted Graph: BFS . . . . . . . . . . . . . . . . . . . . . . .\n223\n4.4.3\nOn Weighted Graph: Dijkstra\u2019s . . . . . . . . . . . . . . . . . . . . .\n227\n4.4.4\nOn Small Graph (with Negative Cycle): Bellman-Ford\n. . . . . . . .\n234\n4.4.5\nSSSP in Programming Contests . . . . . . . . . . . . . . . . . . . . .\n237\n4.5\nAll-Pairs Shortest Paths (APSP)\n. . . . . . . . . . . . . . . . . . . . . . . .\n241\n4.5.1\nOverview and Motivation\n. . . . . . . . . . . . . . . . . . . . . . . .\n241\n4.5.2\nFloyd-Warshall Algorithm . . . . . . . . . . . . . . . . . . . . . . . .\n242\n4.5.3\nOther Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n244\n4.5.4\nAPSP in Programming Contests . . . . . . . . . . . . . . . . . . . . .\n246\n4.6\nSpecial Graphs\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n249\n4.6.1\nDirected Acyclic Graph . . . . . . . . . . . . . . . . . . . . . . . . . .\n249\n4.6.2\nTree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n255\n4.6.3\nBipartite Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n257\n4.6.4\nEulerian Graph . . . . . . . . . . . . . . . . . . . . . . . . .", "mimetype": "text/plain", "start_char_idx": 7265, "end_char_idx": 8638, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4b7f32e0-1dd6-4863-b1b4-4e78f8df7a5d": {"__data__": {"id_": "4b7f32e0-1dd6-4863-b1b4-4e78f8df7a5d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "283b477f-83e5-4a9c-b71b-8e437232de9f", "node_type": "1", "metadata": {}, "hash": "fda9edb5196540b893240e08e79128a0a2a7feaaef9cfbeba64c595c0ea7b2f5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "035e79ca-eb2a-439f-b4fb-e0077ea563ca", "node_type": "1", "metadata": {}, "hash": "493a34f20941c79052377de9f28b9517f0dae0838b4fb74f33af5afbaa0e5fd9", "class_name": "RelatedNodeInfo"}}, "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n255\n4.6.3\nBipartite Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n257\n4.6.4\nEulerian Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n260\n4.6.5\nSpecial Graphs in Programming Contests . . . . . . . . . . . . . . . .\n263\n4.7\nSolution to Non-Starred Exercises . . . . . . . . . . . . . . . . . . . . . . . .\n267\n4.8\nChapter Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n270\nBibliography\n276\nv\n\nCONTENTS\nc\u20ddSteven, Felix, Suhendry\nvi\n\nForewords for CP4\nBill Poucher\nIntroduction\nIn 1970, the Texas A&M UPE Honor Society hosted the \ufb01rst university competitive pro-\ngramming competition in the history of the ICPC. The \ufb01rst Finals was held in 1977 in\nAtlanta in conjunction with the Winter Meeting of the ACM Computer Science Conference.\nThe ICPC International Collegiate Programming Contest hosted regional competitions at\n643 sites in 104 countries for 59 000 team members and their 5043 coaches from over 3400\nuniversities that span the globe. The top 135 teams of three will advance to the ICPC World\nFinals in Moscow hosted by MIPT scheduled for June 2021.\nICPC alumni number over 400,000 worldwide, many playing key roles in building the\nglobal digital community for many decades. The ICPC is the root of competitive program-\nming that reaches out through the global digital community to persons from all cultures and\nin increasingly-younger generations.\nThe UVa Online Judge opened the doors for online competition and access to ICPC prob-\nlems under the direction of Professor Miguel \u00b4Angel Revilla. Three of the star-studded team\nare Steven Halim, Felix Halim, and Suhendry E\u21b5endy, authors of Competitive Programming\n4, Book 1 and Book 2. Their work will be honored at the ICPC World Finals in Moscow\nhosted by MIPT with a special award from the ICPC Foundation.\nCompetitive Programming\nWhat is competitive programming and why should you get involved? First and foremost, it\u2019s\na mind sport. It more fully develops your algorithmic reasoning skills and bridges the gap\nbetween theory and application in bite-sized chunks. Full participation develops problem-\nsolving intuition and competence. Get ready for the Digital Renaissance that will shape\nyour world in the coming decades. To understand the landscape, it is important to shape\nyour mind beyond a swarm of buzzwords. Do it as a team sport.\nHow do we get started?\nStart with Competitive Programming 4, Book 1 and Book 2. Start with Book 1 \ufb01rst :). The\nauthors are seasoned competitive programming experts who have dedicated decades of work\nto help at all levels of the sport.\nIn parallel, engage in a culture that develops habits excellence. You are the \ufb01rst genera-\ntion that has never been disconnected. Being connected is best when we bind our strengths\ntogether in common cause. Do that and prepare to meet the challenges that will de\ufb01ne your\ngeneration.\nLife needs you. We are born to compete. We compete best when we compete together, in\ngood faith, in goodwill, and with good deeds.", "mimetype": "text/plain", "start_char_idx": 8412, "end_char_idx": 11491, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "035e79ca-eb2a-439f-b4fb-e0077ea563ca": {"__data__": {"id_": "035e79ca-eb2a-439f-b4fb-e0077ea563ca", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4b7f32e0-1dd6-4863-b1b4-4e78f8df7a5d", "node_type": "1", "metadata": {}, "hash": "6f3de078d9bc20c43facbe672fb8d0f41742d927f93dd3fff32603d7571e7d40", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c25de355-1f0b-4f5f-a995-59725a59b112", "node_type": "1", "metadata": {}, "hash": "0fa5cb5fbd1d1ca5e83c1a06d5dc8963c6c0eb1deb2f6a7d6cdbd42e9ccdefcc", "class_name": "RelatedNodeInfo"}}, "text": "To understand the landscape, it is important to shape\nyour mind beyond a swarm of buzzwords. Do it as a team sport.\nHow do we get started?\nStart with Competitive Programming 4, Book 1 and Book 2. Start with Book 1 \ufb01rst :). The\nauthors are seasoned competitive programming experts who have dedicated decades of work\nto help at all levels of the sport.\nIn parallel, engage in a culture that develops habits excellence. You are the \ufb01rst genera-\ntion that has never been disconnected. Being connected is best when we bind our strengths\ntogether in common cause. Do that and prepare to meet the challenges that will de\ufb01ne your\ngeneration.\nLife needs you. We are born to compete. We compete best when we compete together, in\ngood faith, in goodwill, and with good deeds. When you come to college, consider the ICPC\nvii\n\nFOREWORDS\nBill Poucher\nand the new program ICPC University Commons that will provide a spectrum of activities\nthat happen outside of the classroom. You can visit https://icpc.global for details.\nWhy get started?\nIs developing your problem-solving skills important? Yes. Is preparing for a future engaged\nin the global digital community important? Yes. Is following T.S. Elliot\u2019s advice that to\nfully develop you must go too far? Yes. Do that in competitive programming. Be careful of\npursuits that are not reversible.\nIs competitive programming practical?\nAristotle asserted that there is nothing more\npractical than engaging in mental activities and re\ufb02ections which have their goal in them-\nselves and take pace for their own sake. Let me recommend that you engage your spirit in\nbuilding a more beautiful world. In the immense scope of life, abundant small kindnesses\nmake a di\u21b5erence. Find friends with common interest and embrace this cycle:\nRepeat for a lifetime: Study; Practice; Rehearse; Dress Rehearse; Perform.\nIt works for athletes.\nIt works for musicians.\nIt works for all performance arts.\nIt will work for you.\nBest, Bill\nDr. William B. \u201cBill\u201d Poucher, Ph.D., ACM Fellow\nProfessor of Computer Science, Baylor University\nExecutive Director, ICPC International Collegiate Programming Contest\nPresident, ICPC Foundation\nJuly 13th, 2020.\nviii\n\nFOREWORDS\nMiguel Revilla Rodr\u00b4\u0131guez\nMiguel Revilla Rodr\u00b4\u0131guez\nAlmost 20 years ago (on November 11th, 2003, to be precise), my father (Miguel \u00b4Angel\nRevilla) received an e-mail with the following message:\n\u201cI should say in a simple word that with the UVa Site, you have given birth to\na new CIVILIZATION and with the books you write (he meant \u201cProgramming\nChallenges: The Programming Contest Training Manual\u201d [53], coauthored with\nSteven Skiena), you inspire the soldiers to carry on marching. May you live long\nto serve the humanity by producing super-human programmers.\u201d\nWhat, in my father\u2019s words, was \u201cclearly an exaggeration\u201d, caused some thinking. And it\u2019s\nnot a secret that thoughts can easily lead to dreams. His dream was to create a community\naround the project he had started, as part of is teaching job at the University of Valladolid,\nSpain, that gathered people from all around the world working together towards the same\nideal, the same quest. With a little searching, on the primitive Internet of the \ufb01rst years of\nour century, a whole online community of excellent users and tools, built around the UVa\nsite, came to light.\nThe website Methods to Solve1, created by a very young student from Indonesia, was one\nof the most impressive among them. There was the result of the hard work of a real genius\nof algorithms and computer science. The seed was planted to believe that the dream could\ncome true. Moreover, it was not only that the leaves of that growing tree were a perfect\nmatch, but the root of both projects were exactly the same: to serve the humanity. That\nyoung student, the author of the e-mail and the website that put my father to dream, was\nSteven Halim. Later he would discover that Steven was not alone in his quest, as his younger\nbrother, Felix, shared his view, his interests, and his extraordinary capabilities.\nAfter 15 years of fruitful collaboration and, more important, friendship with Steven and\nFelix, my father sadly passed away in 2018. His work, and his dreams, now belong to us,\nthe next generation. This book is the living proof that the dream has become true.", "mimetype": "text/plain", "start_char_idx": 10727, "end_char_idx": 15003, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c25de355-1f0b-4f5f-a995-59725a59b112": {"__data__": {"id_": "c25de355-1f0b-4f5f-a995-59725a59b112", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "035e79ca-eb2a-439f-b4fb-e0077ea563ca", "node_type": "1", "metadata": {}, "hash": "493a34f20941c79052377de9f28b9517f0dae0838b4fb74f33af5afbaa0e5fd9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d42da43f-6120-4c1a-b232-536251c3675c", "node_type": "1", "metadata": {}, "hash": "cde5774e484af998206ce148e26c9d8a3e044a76caeb47e4ea875c6aafa33a4a", "class_name": "RelatedNodeInfo"}}, "text": "There was the result of the hard work of a real genius\nof algorithms and computer science. The seed was planted to believe that the dream could\ncome true. Moreover, it was not only that the leaves of that growing tree were a perfect\nmatch, but the root of both projects were exactly the same: to serve the humanity. That\nyoung student, the author of the e-mail and the website that put my father to dream, was\nSteven Halim. Later he would discover that Steven was not alone in his quest, as his younger\nbrother, Felix, shared his view, his interests, and his extraordinary capabilities.\nAfter 15 years of fruitful collaboration and, more important, friendship with Steven and\nFelix, my father sadly passed away in 2018. His work, and his dreams, now belong to us,\nthe next generation. This book is the living proof that the dream has become true.\n\u201cI can\u2019t imagine a better complement for the UVa Online Judge\u201d, are my father\u2019s words.\nNow, with this fourth version of Competitive Programming in my hands, I can add that I\ncan\u2019t imagine the very existence of the Online Judge without this book. Both projects have\ngrown in parallel and are, no doubt, perfect complements and companions to each other.\nBy practicing and mastering most programming exercises in this book, the reader can learn\nhow to solve hundreds of tasks and \ufb01nd a place in the top 500 best Online Judge coders.\nYou have in your hands over 2000 (yes, two thousand!) selected, classi\ufb01ed, and carefully\ncommented problems from the Online Judge.\nThe authors, in the past two decades, have grown from contestants, to coaches and,\n\ufb01nally, masters in the art of competitive programming. They perfectly know every curve\nand crossroad in that long path, and they can put themselves in the skins of the young\nIOI contestant, the ICPC newcomer or the seasoned coach, speaking to each in their own\nlanguage. This book is, for that very reason, the perfect reading for all of them. No matter\nif you are starting as a competitive programmer in your local IOI, or are coaching in the\nnext ICPC World Finals, no doubt this IS the book for you.\n1Please visit https://cpbook.net/methodstosolve\nix\n\nFOREWORDS\nMiguel Revilla Rodr\u00b4\u0131guez\nI love movies, I adore classic movies, and I know that what I\u2019m watching is a masterpiece,\nwhen, after the \ufb01lm ends, I can\u2019t wait to start all over again. In Steven and Felix own words\n\u201cthe book is not meant to be read once, but several times\u201d. And you will \ufb01nd that same\nfeeling, not only because the authors recommend it, but because you will be anxious to read\nand re-read it as, like in the greatest movies, you will \ufb01nd something new and amazing each\ntime. This book is, by that logic, a masterpiece.\nI also have the great honor of being the Spanish language translator of this book. Trans-\nlating requires a very meticulous process of converting the words while keeping the spirit.\nYou have to think as the author would think, and have to perfectly understand not only\nwhat the author is saying, but also what the author is meaning. It is a handcrafting exer-\ncise. Having gone forth and back through this text hundreds of times, I have enjoyed every\nconcept, every new idea, and every tip, not only by what is written in it, but also by what\nit wants to achieve. The quest of making better programmers and, behind that, the quest\nof serving humanity. This book is, indeed, a truly masterpiece.\nOnce you\u2019ve read this book several times, you will realize how much a better programmer\nyou are but, believe it or not, you will realize that you are also a happier person.\nMiguel Revilla Rodr\u00b4\u0131guez (Miguel Jr)\nOnline Judge Manager\nhttps://onlinejudge.org\nJuly 1st, 2020, Valladolid.\nx\n\nFOREWORDS\nFredrik Niemel\u00a8a\nFredrik Niemel\u00a8a\nI got my \ufb01rst physical copy of this book from Steven at IOI 2012 in Italy. Like so many other\ncomputer scientists, he has a great sense of humor, and named it \u201cCompetitive Programming:\nIncreasing the Lower Bound of Programming Contests.\u201d It was the second edition of the\nbook and already twice the size of the \ufb01rst edition. Packed with practical advice, it was well-\nsuited to get beginners started and had useful material for the more seasoned algorithmist.", "mimetype": "text/plain", "start_char_idx": 14157, "end_char_idx": 18329, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d42da43f-6120-4c1a-b232-536251c3675c": {"__data__": {"id_": "d42da43f-6120-4c1a-b232-536251c3675c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c25de355-1f0b-4f5f-a995-59725a59b112", "node_type": "1", "metadata": {}, "hash": "0fa5cb5fbd1d1ca5e83c1a06d5dc8963c6c0eb1deb2f6a7d6cdbd42e9ccdefcc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "81e2871e-a153-4bca-b9c0-88f601e6af51", "node_type": "1", "metadata": {}, "hash": "39b04630899d58e960c196496b49b4051008aa24c064523d9968e119671d6e9d", "class_name": "RelatedNodeInfo"}}, "text": "Miguel Revilla Rodr\u00b4\u0131guez (Miguel Jr)\nOnline Judge Manager\nhttps://onlinejudge.org\nJuly 1st, 2020, Valladolid.\nx\n\nFOREWORDS\nFredrik Niemel\u00a8a\nFredrik Niemel\u00a8a\nI got my \ufb01rst physical copy of this book from Steven at IOI 2012 in Italy. Like so many other\ncomputer scientists, he has a great sense of humor, and named it \u201cCompetitive Programming:\nIncreasing the Lower Bound of Programming Contests.\u201d It was the second edition of the\nbook and already twice the size of the \ufb01rst edition. Packed with practical advice, it was well-\nsuited to get beginners started and had useful material for the more seasoned algorithmist.\nSteven and Felix\u2019s vision for their book was to teach everybody how to program (As\nGusteau from Ratatouille would put it: \u201cTout le monde peut programmer\u201d). I had a similar\nvision, but instead of writing a book, we created Kattis. \u201cCompetitive Programming\u201d and\nKattis share this motivating principle: to make learning computer science and programming\naccessible for everyone. In that sense, they are like two of many pieces in the same puzzle.\nKattis is an online tool for teaching computer science and programming, which relies on\na curated library of programming tasks. I managed to convince Steven that he should try\nusing Kattis for some of his teaching activities. Over the years he has moved from using\nKattis, to pushing us to improve Kattis, to adding high-quality content to Kattis.\nFrom years of teaching algorithms and using similar systems that preceded Kattis, we\nlearned that the quality of the problems, and their absolute correctness, are paramount for\nlearning outcomes. So, this is where we put extra e\u21b5ort into Kattis. (If you ever felt that\nit\u2019s too much work to add problems to Kattis, this is why). What we did back then is now\nstandard practice\u2014both the ICPC and IOI use the same kinds of methods for their \ufb01nals.\nIn this fourth edition (more than twice as large as the second edition!), Steven and Felix,\nnow joined by co-author Suhendry, are using problems from Kattis. We are honored to be\nincluded. Finally, our puzzle pieces are directly connected, and I am very excited about\nthat.\nI hope you will \ufb01nd this book informative and helpful and that you will spend the time\nit asks of you. You will not be disappointed.\nFredrik Niemel\u00a8a\nFounder of Kattis\nICPC Contest System Director\nIOI Technical Committee Founding Member\nhttps://www.kattis.com\nJuly 11th, 2020.\nxi\n\nFOREWORDS\nBrian Christopher Dean\nBrian Christopher Dean\nI\u2019ve had the privilege to be part of the competitive programming world for more than three\ndecades, during which time I\u2019ve seen the \ufb01eld grow substantially in terms of its impact\non modern computing.\nAs director of the USA Computing Olympiad and coach of my\nUniversity\u2019s ICPC teams, I have seen \ufb01rsthand how competitive programming has become a\nkey part of the global computing talent pipeline - both academia and industry are now \ufb01lled\nwith present-day superstars who were formerly superstars in competitive programming.\nJust as the world of competitive programming has shown tremendous growth in scope,\ndepth, and relevance, so too has this text, now in its fourth edition. Earlier editions of\nthis book provided what I consider to be the gold standard for both an introduction and a\nthorough reference to the algorithmic concepts most prevalent in competitive programming.\nThe same remains true for this edition.\nCompetitive programming can be a daunting undertaking for the novice student - learn-\ning to code is plenty challenging by itself, and on top of this we add a layer of \u201dstandard\u201d\nalgorithms and data structures and then another layer of problem-solving insight and tricks.\nThis text helps the introductory student navigate these challenges in several ways, by its\nthoughtful organization, extensive practice exercises, and by articulating ideas both in clear\nprose and code. Competitive programming can also be a daunting prospect for the advanced\nstudent due to its rapid pace of evolution - techniques can go from cutting-edge to common-\nplace in a matter of just a few years, and one must demonstrate not only pro\ufb01ciency but\ntrue mastery of a formidable and ever-expanding body of algorithmic knowledge. With its\ncomprehensive algorithmic coverage and its extensive listing of \u21e13458 categorized problems,\nthis text provides the advanced student with years of structured practice that will lead to a\nhigh baseline skill level.", "mimetype": "text/plain", "start_char_idx": 17713, "end_char_idx": 22120, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "81e2871e-a153-4bca-b9c0-88f601e6af51": {"__data__": {"id_": "81e2871e-a153-4bca-b9c0-88f601e6af51", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d42da43f-6120-4c1a-b232-536251c3675c", "node_type": "1", "metadata": {}, "hash": "cde5774e484af998206ce148e26c9d8a3e044a76caeb47e4ea875c6aafa33a4a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a892ac17-5046-48c4-b190-0121079e9a6c", "node_type": "1", "metadata": {}, "hash": "aa57b8136c175cd3b05b3663bcbea55617cf822d49dd502b79dab16db30439e2", "class_name": "RelatedNodeInfo"}}, "text": "This text helps the introductory student navigate these challenges in several ways, by its\nthoughtful organization, extensive practice exercises, and by articulating ideas both in clear\nprose and code. Competitive programming can also be a daunting prospect for the advanced\nstudent due to its rapid pace of evolution - techniques can go from cutting-edge to common-\nplace in a matter of just a few years, and one must demonstrate not only pro\ufb01ciency but\ntrue mastery of a formidable and ever-expanding body of algorithmic knowledge. With its\ncomprehensive algorithmic coverage and its extensive listing of \u21e13458 categorized problems,\nthis text provides the advanced student with years of structured practice that will lead to a\nhigh baseline skill level.\nI think this is a book that belongs in the library of anyone serious about computing, not\njust those training for their \ufb01rst or their hundredth programming competition. Ideas from\ncompetitive programming can help one develop valuable skills and insight - both in theory\nand implementation - that can be brought to bear on a wide range of modern computing\nproblems of great importance in practice. Algorithmic problem solving is, after all, truly\nthe heart and soul of computer science!\nThese types of problems are often used in job\ninterviews for a good reason, since they indicate the type of prospective employee who has\na skill set that is broadly applicable and that can adapt gracefully to changes in underlying\ntechnologies and standards. Studying the concepts in this text is an excellent way to sharpen\nyour skills at problem solving and coding, irrespective of whether you intend to use them in\ncompetition or in your other computational pursuits.\nI\u2019ve thoroughly enjoyed reading successive drafts\nof this updated work shared with me by the au-\nthors at recent IOIs, and I commend the authors on\nthe impressive degree to which they have been able\nextend the scope, clarity, and depth of an already-\nremarkable text.\nBrian Christopher Dean\nProfessor and Chair\nDivision of Computer Science, School of Computing\nClemson University, Clemson, SC, USA\nDirector, USA Computing Olympiad\nJuly 5th, 2020\nhttp://www.usaco.org/\nxii\n\nTestimonials of CP1/2/3\n\u201cCompetitive Programming 3 has contributed immensely to my understanding of data\nstructures & algorithms. Steven & Felix have created an incredible book that thoroughly\ncovers every aspect of competitive programming, and have included plenty of practice\nproblems to make sure each topic sinks in. Practicing with CP3 has helped me nail job\ninterviews at Google, and I can\u2019t thank Steven & Felix enough!\u201d\n\u2014 Troy Purvis, Software Engineer @ Google.\n\u201cSteven and Felix are passionate about competitive programming. Just as importantly,\nthey are passionate about helping students become better programmers. CP3 is the result:\na dauntless dive into the data structures, algorithms, tips, and secrets used by competitive\nprogrammers around the world. Yet, when the dust settles on the book, the strongest\nsillage is likely to be one of con\ufb01dence\u2014that, yes, this stu\u21b5is challenging, but that you can\ndo it.\u201d \u2014 Dr. Daniel Zingaro, Associate Professor Teaching Stream,\nUniversity of Toronto Mississauga.\n\u201cCP-Book helped us to train many generations of ICPC and IOI participants for Bolivia.\nIt\u2019s the best source to start and reach a good level to be a competitive programmer.\u201d \u2014\nJhonatan Castro, ICPC coach and Bolivia IOI Team coach,\nUniversidad Mayor de San Andr\u00b4es, La Paz, Bolivia.\n\u201cReading CP3 has been a major contributor to my growth, not just as a competitive\nprogrammer, but also as a computer scientist. My entire approach to problem solving has\nbeen improved by doing the exercises in the book; my passion for the art of problem\nsolving, especially in contest environments, has been intensi\ufb01ed. I now mentor several\nstudents using this book as a guide. It is an invaluable resource to anyone who wants to be\na better problem solver.\u201d \u2014 Ryan Austin Fernandez, Assistant Professor,\nDe La Salle University, Manila, Philippines.\n\u201cI rediscovered CP3 book on 2017-2019 when I come back to Peru after my master in\nBrazil, I enjoyed, learned and solved many problems, more than during my undergraduate,\ncoaching and learning together in small group of new students that are interesting in\ncompetitive programming. It kept me in a constantly competition with them, at the end\nthey have solved more problems than me.\u201d \u2014 Luciano Arnaldo Romero Calla,\nPhD Student, University of Zurich.\n\u201cCP1 helped my preparation during national team training and selection for participating\nthe IOI. When I took the competitive programming course in NUS, CP2 book is\nextensively used for practice and homework.", "mimetype": "text/plain", "start_char_idx": 21365, "end_char_idx": 26059, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a892ac17-5046-48c4-b190-0121079e9a6c": {"__data__": {"id_": "a892ac17-5046-48c4-b190-0121079e9a6c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "81e2871e-a153-4bca-b9c0-88f601e6af51", "node_type": "1", "metadata": {}, "hash": "39b04630899d58e960c196496b49b4051008aa24c064523d9968e119671d6e9d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cabb17a6-c955-47a8-91bf-62e29404f9fb", "node_type": "1", "metadata": {}, "hash": "ffc55cb24a28fc5b3a1dad216427f8f1a3f8c8db49c237d301612f934488968f", "class_name": "RelatedNodeInfo"}}, "text": "I now mentor several\nstudents using this book as a guide. It is an invaluable resource to anyone who wants to be\na better problem solver.\u201d \u2014 Ryan Austin Fernandez, Assistant Professor,\nDe La Salle University, Manila, Philippines.\n\u201cI rediscovered CP3 book on 2017-2019 when I come back to Peru after my master in\nBrazil, I enjoyed, learned and solved many problems, more than during my undergraduate,\ncoaching and learning together in small group of new students that are interesting in\ncompetitive programming. It kept me in a constantly competition with them, at the end\nthey have solved more problems than me.\u201d \u2014 Luciano Arnaldo Romero Calla,\nPhD Student, University of Zurich.\n\u201cCP1 helped my preparation during national team training and selection for participating\nthe IOI. When I took the competitive programming course in NUS, CP2 book is\nextensively used for practice and homework. The good balance between the programming\nand theoretic exercises for deeper understanding in the book makes CP book a great book\nto be used for course references, as well as for individual learning. Even at the top\ncompetitive programming level, experts can still learn topics they have not learnt before\nthanks to the rare miscellaneous topics at the end of the book.\u201d\n\u2014 Jonathan Irvin Gunawan, Software Engineer, Google.\nxiii\n\nTESTIMONIALS\nVarious Book Readers\n\u201cDr. Steven Halim is one of the best professors I have had in NUS. His intuitive\nvisualizations and clear explanations of highly complex algorithms make it signi\ufb01cantly\neasier for us to grasp di\ufb03cult concepts. Even though I was never fully into Competitive\nProgramming, his book and his teaching were vital in helping me in job interviews and\nmaking me a better coder. Highly recommend CP4 to anyone looking to impress in\nsoftware engineering job interviews.\u201d \u2014 Patrick Cho, Machine Learning Scientist, Tesla.\n\u201cFlunked really hard at IOI 2017, missing medal cuto\u21b5by 1 place. Then at the beginning\nof 2018 Steven Halim gave me a draft copy of CP3.1 / CP4 and I ended up getting a gold\nmedal!\u201d \u2014 Joey Yu, Student, University of Waterloo, SWE Intern at Rippling,\nIOI 2018 Gold Medalist.\n\u201cAs a novice self-learner, CP-book helped me to learn the topics in both fun and\nchallenging ways. As an avid and experienced CP-er, CP-book helped me to \ufb01nd a\nplentiful and diverse problems. As a trainer, CP-book helped me to plan ahead the\nmaterials and tactical strategies or tricks in competition for the students. As the person\never in those three di\u21b5erent levels, I must e\u21b5ortlessly say CP-book is a must-have to being\na CP master!\u201d \u2014 Ammar Fathin Sabili, PhD Student, National University of Singapore.\n\u201cI\u2019ve been in CP for three years. A rookie number for all the competitive programmers out\nthere. I have a friend (still chatting with him today) who introduced me to this book. He\u2019s\nmy roommate on our National Training Camp for IOI 2018\u2019s selection. I \ufb01nally get a grab\nof this book in early 2019. To be honest I\u2019m not the \u2018Adhoc\u2019 and good at \u2018Math\u2019 type of\nCP-er. I love data structures, graph (especially trees) And this CP3 book. Is a leap of\nknowledge. No joke. I met Dr Felix when I was training in BINUS, I also met Dr Steven\nwhen I competed in Singapore\u2019s NOI and one of my unforgettable moment is, this legend\nbook got signed by its two authors. Even tho the book is full of marks and stains, truly\none of my favorite. Kudos for taking me to this point of my life.\u201d\n\u2014 Hocky Yudhiono, Student, University of Indonesia.\n\u201cI bought CP3 on 7th April 2014 on my birthday as a gift for myself and it has been the\nmost worth-it 30USD spent by me on any educational material. In the later years, I was\nable to compete in IOI and ICPC WF. I think CP3 played a very big factor in igniting the\ninterest and providing a strong technical foundation about all the essential topics required\nin CP.\u201d \u2014 Sidhant Bansal, Student, National University of Singapore.\n\u201cI have always wanted to get involved in competitive programming, but I didn\u2019t know how\nand where to get started.", "mimetype": "text/plain", "start_char_idx": 25171, "end_char_idx": 29181, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cabb17a6-c955-47a8-91bf-62e29404f9fb": {"__data__": {"id_": "cabb17a6-c955-47a8-91bf-62e29404f9fb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a892ac17-5046-48c4-b190-0121079e9a6c", "node_type": "1", "metadata": {}, "hash": "aa57b8136c175cd3b05b3663bcbea55617cf822d49dd502b79dab16db30439e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9c903b83-4464-4314-81fc-01550ca75547", "node_type": "1", "metadata": {}, "hash": "1a9f44b0536fdc0bfdd0eb62de2c88e92b7cd02c4a3cb9360ab93680ca18341e", "class_name": "RelatedNodeInfo"}}, "text": "Even tho the book is full of marks and stains, truly\none of my favorite. Kudos for taking me to this point of my life.\u201d\n\u2014 Hocky Yudhiono, Student, University of Indonesia.\n\u201cI bought CP3 on 7th April 2014 on my birthday as a gift for myself and it has been the\nmost worth-it 30USD spent by me on any educational material. In the later years, I was\nable to compete in IOI and ICPC WF. I think CP3 played a very big factor in igniting the\ninterest and providing a strong technical foundation about all the essential topics required\nin CP.\u201d \u2014 Sidhant Bansal, Student, National University of Singapore.\n\u201cI have always wanted to get involved in competitive programming, but I didn\u2019t know how\nand where to get started. I was introduced to this book while taking Steven\u2019s companion\ncourse (CS3233) in NUS as an exchange student, and I found the book to be really helpful\nin helping me to learn competitive programming. It comes with a set of Kattis exercises as\nwell. This book provides a structured content for competitive programming, and can be\nreally useful to anyone ranging from beginners to experts. Just like CLRS for algorithms,\nCP is THE book for competitive programming.\u201d \u2014 Jay Ching Lim,\nStudent, University of Waterloo.\n\u201cMy memories about CP3 is me reading it in many places, the bus, my room, the library,\nthe contest \ufb02oor...not much time had passed since I start in competitive programming\nreading CP3 until I got quali\ufb01ed to an ICPC World Final.\u201d\n\u2014 Javier Eduardo Ojeda Jorge, ICPC World Finalist, Universidad Mayor de San Sim\u00b4on,\nSoftware Engineer at dParadig, Chile\nxiv\n\nPreface for CP4\nThis Competitive Programming book, 4th edition (CP4) is a must have for every compet-\nitive programmer. Mastering the contents of this book is a necessary (but admittedly not\nsu\ufb03cient) condition if one wishes to take a leap forward from being just another ordinary\ncoder to being among one of the world\u2019s \ufb01nest competitive programmers.\nTypical readers of Book 1 (only) of CP4 would include:\n1. Secondary or High School Students who are competing in the annual International\nOlympiad in Informatics (IOI) [31] (including the National or Provincial Olympiads)\nas Book 1 covers most of the current IOI Syllabus [16],\n2. Casual University students who are using this book as supplementary material for\ntypical Data Structures and Algorithms courses,\n3. Anyone who wants to prepare for typical fundamental data structure/algorithm part\nof a job interview at top IT companies.\nTypical readers of both Book 1 + Book 2 of CP4 would include:\n1. University students who are competing in the annual International Collegiate Program-\nming Contest (ICPC) [57] Regional Contests (including the World Finals) as Book 2\ncovers much more Computer Science topics that have appeared in the ICPCs,\n2. Teachers or Coaches who are looking for comprehensive training materials [21],\n3. Anyone who loves solving problems through computer programs. There are numerous\nprogramming contests for those who are no longer eligible for ICPC, including Google\nCodeJam, Facebook Hacker Cup, TopCoder Open, CodeForces contest, Internet Prob-\nlem Solving Contest (IPSC), etc.\nPrerequisites\nThis book is not written for novice programmers so that we can write much more about\nCompetitive Programming instead of repeating the basic programming methodology con-\ncepts that are widely available in other Computer Science textbooks. This book is aimed\nat readers who have at least basic knowledge in programming methodology, are familiar\nwith at least one of these programming languages (C/C++, Java, Python, or OCaml) but\npreferably more than one programming language, have passed (or currently taking) a basic\ndata structures and algorithms course and a discrete mathematics course (both are typically\ntaught in year one of Computer Science university curricula or in the NOI/IOI training\ncamps), and understand simple algorithmic analysis (at least the big-O notation). In the\nnext subsections, we will address the di\u21b5erent potential readers of this book.\nxv\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\nTo (Aspiring) IOI Contestants\nIOI is not a speed contest and for now, currently excludes the topics listed in the following\nTable 1 (many are in Book 2). You can skip these topics until your University years (when\nyou join that university\u2019s ICPC teams).", "mimetype": "text/plain", "start_char_idx": 28470, "end_char_idx": 32777, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9c903b83-4464-4314-81fc-01550ca75547": {"__data__": {"id_": "9c903b83-4464-4314-81fc-01550ca75547", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cabb17a6-c955-47a8-91bf-62e29404f9fb", "node_type": "1", "metadata": {}, "hash": "ffc55cb24a28fc5b3a1dad216427f8f1a3f8c8db49c237d301612f934488968f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6ea117f5-0801-452e-aa74-920af4c88e85", "node_type": "1", "metadata": {}, "hash": "82264a5db44e45e9866eb4273cc99e60b34b51b376f76dd5e3fceda6ac3750dd", "class_name": "RelatedNodeInfo"}}, "text": "In the\nnext subsections, we will address the di\u21b5erent potential readers of this book.\nxv\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\nTo (Aspiring) IOI Contestants\nIOI is not a speed contest and for now, currently excludes the topics listed in the following\nTable 1 (many are in Book 2). You can skip these topics until your University years (when\nyou join that university\u2019s ICPC teams).\nHowever, learning these techniques in advance\nis de\ufb01nitely bene\ufb01cial as some tasks in IOI can become easier with additional knowledge.\nTherefore, we recommend that you grab a copy of this book early in your competitive\nprogramming journey (i.e., during your high school days).\nWe are aware that one cannot win a medal in IOI just by mastering the contents of the\ncurrent version (CP4) of this book. While we believe that many parts of the latest IOI\nsyllabus [16] has been included in this book (especially Book 1)\u2014hopefully enabling you to\nachieve a respectable score in future IOIs\u2014we are well aware that modern IOI tasks require\nkeen problem solving skills and tremendous creativity [20]\u2014virtues that we cannot possibly\nimpart through a static textbook. This book can provide knowledge, but the hard work must\nultimately be done by you. With practice comes experience, and with experience comes skill.\nSo, keep on practicing!\nTopics in Book 2\nMath: Big Integer, Modular Inverse, Probability Theory, Game Theory\nString Processing: Su\ufb03x Trees/Arrays, KMP, String Hashing/Rabin-Karp\n(Computational) Geometry: Various Geometry-speci\ufb01c library routines\nGraph: Network Flow, Harder Matching problems, Rare NP-hard/complete Problems\nMore than half of the Rare Topics\nTable 1: Not in IOI Syllabus [16] Yet\nTo Students of Data Structures and Algorithms Courses\nThe contents of this book have been expanded in CP4 so that the \ufb01rst four chapters of this\nbook are more accessible to \ufb01rst year Computer Science students. Topics and exercises that\nwe have found to be relatively di\ufb03cult and thus unnecessarily discouraging for \ufb01rst timers\nhave been moved to Book 2. This way, students who are new to Computer Science will\nperhaps not feel overly intimidated when they peruse Book 1.\nChapter 1 has a collection of very easy programming contest problems that can be solved\nby typical Computer Science students who have just passed (or currently taking) a basic\nprogramming methodology course.\nChapter 2 has received another major update. Now the writeups in the Sections about\nLinear and Non-linear Data Structures have been expanded with lots of written exercises so\nthat this book can also be used to support a Data Structures course, especially in the terms\nof implementation details.\nThe four problem solving paradigms discussed in Chapter 3 appear frequently in typical\nAlgorithms courses. The text in this chapter has been expanded and edited to help new\nComputer Science students.\nParts of Chapter 4 can also be used as a supplementary reading or implementation\nguide to enhance a Discrete Mathematics [50, 11] or a basic/intermediate (Graph) Algo-\nrithms course. We have also provide some (relatively) new insights on viewing Dynamic\nProgramming techniques as algorithms on DAGs. Such discussion is currently still regret-\ntably uncommon in many Computer Science textbooks.\nxvi\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\nTo Job Seekers Preparing for IT Job Interview\nIt is well known that many job interviews in top IT companies involve fundamental data\nstructure/algorithm/implementation questions. Many such questions have been discussed\nespecially in Book 1 of CP4. We wish you the best in passing those interview(s).\nOn the other side of the job interview process, some interviewers read this book too in\norder to get inspiration for their interview questions.\nTo ICPC Contestants\nYou are the primary readers of this CP4. Both Book 1 and Book 2 are for you.\nWe know that one cannot probably win an ICPC Regional Contest just by mastering\nthe contents of the current version of this book (CP4). While we have included a lot of\nmaterials in this book\u2014much more than in the \ufb01rst three editions (CP1 \u2713CP2, then CP2\n\u2713CP3, and \ufb01nally CP3 \u2713CP4)\u2014we are aware that much more than what this book can\no\u21b5er is required to achieve that feat. Some additional pointers to useful references are listed\nin the chapter notes for readers who are hungry for more.", "mimetype": "text/plain", "start_char_idx": 32400, "end_char_idx": 36712, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6ea117f5-0801-452e-aa74-920af4c88e85": {"__data__": {"id_": "6ea117f5-0801-452e-aa74-920af4c88e85", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9c903b83-4464-4314-81fc-01550ca75547", "node_type": "1", "metadata": {}, "hash": "1a9f44b0536fdc0bfdd0eb62de2c88e92b7cd02c4a3cb9360ab93680ca18341e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3ee4a736-0bbd-4db0-8f82-8cede134cb6d", "node_type": "1", "metadata": {}, "hash": "04e7eae798b00830bb7eae56592418fc3be0c0b5612e06be152a39f0200c00c4", "class_name": "RelatedNodeInfo"}}, "text": "We wish you the best in passing those interview(s).\nOn the other side of the job interview process, some interviewers read this book too in\norder to get inspiration for their interview questions.\nTo ICPC Contestants\nYou are the primary readers of this CP4. Both Book 1 and Book 2 are for you.\nWe know that one cannot probably win an ICPC Regional Contest just by mastering\nthe contents of the current version of this book (CP4). While we have included a lot of\nmaterials in this book\u2014much more than in the \ufb01rst three editions (CP1 \u2713CP2, then CP2\n\u2713CP3, and \ufb01nally CP3 \u2713CP4)\u2014we are aware that much more than what this book can\no\u21b5er is required to achieve that feat. Some additional pointers to useful references are listed\nin the chapter notes for readers who are hungry for more. We believe, however, that your\nteam will fare much better in future ICPCs after mastering the contents of this book. We\nhope that this book will serve as both inspiration and motivation for your 3-4 year journey\ncompeting in ICPCs during your University days.\nTo Teachers and Coaches\nWk\nTopic\nIn CP4\n01\nIntroduction\nChapter 1\n02\nData Structures & Libraries\nChapter 2+9\n03\nComplete Search\nChapter 3+8+9\n04\nDynamic Programming\nChapter 3+8+9\n05\nBu\u21b5er slot\nChapter 3/4/9/others\n06\nMid-Semester Team Contest\nEntire Book 1\n-\nMid-Semester Break\n-\n07\nGraph 1 (Network Flow)\nChapter 8+9\n08\nGraph 2 (Matching)\nChapter 8+9\n09\nNP-hard/complete Problems\nChapter 8\n10\nMathematics\nChapter 5+9\n11\nString Processing (esp Su\ufb03x Array)\nChapter 6\n12\n(Computational) Geometry (Libraries)\nChapter 7+9\n13\nFinal Team Contest\nEntire Book 1+2 and beyond\n-\nNo Final Examination\n-\nTable 2: Lesson Plan of Steven\u2019s CS3233 (ICPC Regionals Level)\nThis book is mainly used in Steven\u2019s CS3233 - \u201cCompetitive Programming\u201d course in the\nSchool of Computing at the National University of Singapore. CS3233 is conducted in 13\nteaching weeks using the lesson plan mentioned in Table 2 (we abbreviate \u201cWeek\u201d as \u201cWk\u201d\nin Table 2). Fellow teachers/coaches should feel free to modify the lesson plan to suit your\nstudents\u2019 needs. Hints or brief solutions of the non-starred written exercises in this book\nare given at the back of each chapter.\nSome of the starred written exercises are quite\nchallenging and have neither hints nor solutions.\nThese can probably be used as exam\nquestions or for your local contest problems (of course, you have to solve them \ufb01rst!).\nxvii\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\nTo All Readers\nDue to its diversity of coverage and depth of discussion, this book is not meant to be\nread once, but several times. There are many written (\u21e1258) and programming exercises\n(\u21e13458) listed and spread across almost every section. You can skip these exercises at\n\ufb01rst if the solution is too di\ufb03cult or requires further knowledge and technique, and revisit\nthem after studying other chapters of this book. Solving these exercises will strengthen\nyour understanding of the concepts taught in this book as they usually involve interesting\napplications, twists or variants of the topic being discussed.\nMake an e\u21b5ort to attempt\nthem\u2014time spent solving these problems will de\ufb01nitely not be wasted.\nWe believe that this book is and will be relevant to many high school students, University\nstudents, and even for those who have graduated from University but still love problem solv-\ning using computers. Programming competitions such as the IOI and ICPC are here to stay,\nat least for many years ahead. New students should aim to understand and internalize the\nbasic knowledge presented in this book before hunting for further challenges. However, the\nterm \u2018basic\u2019 might be slightly misleading\u2014please check the table of contents to understand\nwhat we mean by \u2018basic\u2019.\nAs the title of this book may imply, the purpose of this book is clear: we aim to improve\nthe reader\u2019s programming and problem solving abilities and thus increase the lower bound\nof programming competitions like the IOI and ICPC in the future.", "mimetype": "text/plain", "start_char_idx": 35934, "end_char_idx": 39891, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3ee4a736-0bbd-4db0-8f82-8cede134cb6d": {"__data__": {"id_": "3ee4a736-0bbd-4db0-8f82-8cede134cb6d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6ea117f5-0801-452e-aa74-920af4c88e85", "node_type": "1", "metadata": {}, "hash": "82264a5db44e45e9866eb4273cc99e60b34b51b376f76dd5e3fceda6ac3750dd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f5d39c19-e7e2-49d5-b54e-f38071da7c81", "node_type": "1", "metadata": {}, "hash": "b21de110c2d65f1deb6947a0c755668569d97d2faf6243daad1e428e8848aa14", "class_name": "RelatedNodeInfo"}}, "text": "Make an e\u21b5ort to attempt\nthem\u2014time spent solving these problems will de\ufb01nitely not be wasted.\nWe believe that this book is and will be relevant to many high school students, University\nstudents, and even for those who have graduated from University but still love problem solv-\ning using computers. Programming competitions such as the IOI and ICPC are here to stay,\nat least for many years ahead. New students should aim to understand and internalize the\nbasic knowledge presented in this book before hunting for further challenges. However, the\nterm \u2018basic\u2019 might be slightly misleading\u2014please check the table of contents to understand\nwhat we mean by \u2018basic\u2019.\nAs the title of this book may imply, the purpose of this book is clear: we aim to improve\nthe reader\u2019s programming and problem solving abilities and thus increase the lower bound\nof programming competitions like the IOI and ICPC in the future. With more contestants\nmastering the contents of this book, we believe that the year 2010 (CP1 publication year) was\na watershed marking an accelerated improvement in the standards of programming contests.\nWe hope to help more contestants to achieve greater scores (\u226570 \u2013 at least \u21e16 \u21e510 points\nfor solving all subtask 1 of the 6 tasks of the IOI) in future IOIs and help more teams\nsolve more problems (\u22652 \u2013 at least 1 more than the typical 1 giveaway problem per ICPC\nproblemset) in future ICPCs. We also hope to see many IOI/ICPC coaches around the world\nadopt this book for the aid it provides in mastering topics that students cannot do without\nin competitive programming contests. If such a proliferation of the required \u2018lower-bound\u2019\nknowledge for competitive programming is continued in this 2020s decade, then this book\u2019s\nprimary objective of advancing the level of human knowledge will have been ful\ufb01lled, and\nwe, as the authors of this book, will be very happy indeed.\nConvention\nThere are lots of C/C++, Java, Python, and occasionally OCaml code included in this book.\nIf they appear, they will be typeset in this monospace font. All code have 2 spaces per\nindentation level except Python code (4 spaces per indentation level).\nFor the C/C++ code in this book, we have adopted the frequent use of typedefs and\nmacros\u2014features that are commonly used by competitive programmers for convenience,\nbrevity, and coding speed. However, we may not always be able to use those techniques in\nJava, Python, and/or OCaml as they may not contain similar or analogous features. Here\nare some examples of our C/C++ code shortcuts:\ntypedef long long ll;\n// common data types\ntypedef pair<int, int> ii;\n// comments that are mixed\ntypedef vector<int> vi;\n// in with code are placed\ntypedef vector<ii> vii;\n// on the right side\nmemset(memo, -1, sizeof memo);\n// to init DP memo table\nvi memo(n, -1);\n// alternative way\nmemset(arr, 0, sizeof arr);\n// to clear array of ints\nxviii\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\nThe following shortcuts are frequently used in both our C/C++ and Java code (not all of\nthem are applicable in Python or OCaml):\n// Shortcuts for \"common\" constants\nconst int INF = 1e9;\n// 10^9 = 1B is < 2^31-1\nconst int LLINF = 4e18;\n// 4*10^18 is < 2^63-1\nconst double EPS = 1e-9;\n// a very small number\n++i;\n// to simplify: i = i+1;\nans = a ? b : c;\n// ternary operator\nans += val;\n// from ans = ans+val;\nindex = (index+1) % n;\n// to right or back to 0\nindex = (index+n-1) % n;\n// to left or back to n-1\nint ans = (int)((double)d + 0.5);\n// for rounding\nans = min(ans, new_computation);\n// min/max shortcut\n// some code use short circuit && (AND) and || (OR)\n// some code use structured bindings of C++17 for dealing with pairs/tuples\n// we don\u2019t use braces for 1 liner selection/repetition body\n// we use pass by reference (&) as far as possible\nProblem Categorization\nAs of 19 July 2020, Steven, Felix, Suhendry\u2014combined\u2014have solved 2278 UVa problems\n(\u21e145.88% of the entire UVa problemset as of publication date).", "mimetype": "text/plain", "start_char_idx": 38985, "end_char_idx": 42916, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f5d39c19-e7e2-49d5-b54e-f38071da7c81": {"__data__": {"id_": "f5d39c19-e7e2-49d5-b54e-f38071da7c81", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3ee4a736-0bbd-4db0-8f82-8cede134cb6d", "node_type": "1", "metadata": {}, "hash": "04e7eae798b00830bb7eae56592418fc3be0c0b5612e06be152a39f0200c00c4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e539adf6-499c-4618-8ea4-04f1de63bf39", "node_type": "1", "metadata": {}, "hash": "b5591c7a44f93dbf97486bbf96760bcd8e7c4375ef478c17859ffad041aa65c0", "class_name": "RelatedNodeInfo"}}, "text": "Steven has also solved\n5742.7 Kattis points (\u21e11.4K other problems and \u21e155.46% of the entire Kattis problemset\nas of publication date). There are \u21e13458 problems have been categorized in this book.\nThese problems are categorized according to a \u201cload balancing\u201d scheme: if a problem can\nbe classi\ufb01ed into two or more categories, it will be placed in the category with a lower number\nof problems. This way, you may \ufb01nd that some problems have been \u2018wrongly\u2019 categorized,\nwhere the category that it appears in might not match the technique that you have used to\nsolve it. We can only guarantee that if you see problem X in category Y, then you know\nthat we have managed to solve problem X with the technique mentioned in the section that\ndiscusses category Y.\nWe have also limit each category to at most 35 (THIRTY-FIVE) problems, splitting\nthem into separate categories when needed. In reality, each category has \u21e117 problems on\naverage. Thus, we have \u21e13458/17 \u21e1200+ categories scattered throughout the book.\nUtilize this categorization feature for your training! Solving at least a few problems from\neach category is a great way to diversify your problem solving skillset. For conciseness, we\nhave limited ourselves to a maximum of 4 UVa + 3 Kattis (or 3 UVa + 4 Kattis) = 7 starred\n* (must try) problems per category and put the rest as extras (the hints for those extras\ncan be read online at \u2018Methods to Solve\u2019 page of https://cpbook.net). You can say that\nyou have \u2018somewhat mastered\u2019 CP4 if you have solved at least three (3) problems per\ncategory (this will take some time).\nIf you need hints for any of the problems (that we have solved), \ufb02ip to the handy index\nat the back of this book instead of \ufb02ipping through each chapter\u2014it might save you some\ntime. The index contains a list of UVa/Kattis problems, ordered by problem number/id (do\na binary search!) and augmented by the pages that contain discussion of said problems (and\nthe data structures and/or algorithms required to solve that problem). In CP4, we allow\nthe hints to span more than one line (but not more than two lines) so that they can be a bit\nmore meaningful. Of course you can always challenge yourself by not reading the hints \ufb01rst.\nxix\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\nChanges for CP4\nCompetitive Programming textbook has been around since 2010 (\ufb01rst edition, dubbed as\nCP1), 2011 (second edition/CP2), and especially 2013 (third edition/CP3). There has been\n7 years gap2 between the release of CP3 to the release of this CP4 (just before the landmark\nIOI 2020 (Online) + IOI 2021 in Singapore). We highlight the important changes of these 7\nyears worth of additional Competitive Programming knowledge:\n\u2022 Obviously, we have \ufb01xed all known typos, grammatical errors, and bugs that were\nfound and reported by CP3 readers since 2013. It does not mean that this edition is\n100% free from any bug though. We strive to have only very few errors in CP4.\n\u2022 We have updated many sample code into C++17, Java 11, Python 3, and even some\nOCaml. Many of the sample code become simpler with a few more years of program-\nming language update (e.g., C++17 structured binding declaration), the upgraded cod-\ning skills/styles of the authors, and various interesting contributions from our readers\nover these past few years.\n\u2022 We use a public GitHub repo: https://github.com/stevenhalim/cpbook-code that\ncontains the same sample code content as this book during the release date of this\nedition (19 July 2020). Obviously, the content of the GitHub repo will always be more\nup-to-date/complete than the printed version as time goes on. Please star, watch, fork,\nor even contribute to this public GitHub repo. You are free to use these source code\nfor your next programming contest or any other purposes.\n\u2022 We have added Kattis online judge https://open.kattis.com on top of UVa online\njudge and have raised the number of discussed problems to \u21e13458. This is more\nthan two times the number in CP3 (1675).", "mimetype": "text/plain", "start_char_idx": 42917, "end_char_idx": 46879, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e539adf6-499c-4618-8ea4-04f1de63bf39": {"__data__": {"id_": "e539adf6-499c-4618-8ea4-04f1de63bf39", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f5d39c19-e7e2-49d5-b54e-f38071da7c81", "node_type": "1", "metadata": {}, "hash": "b21de110c2d65f1deb6947a0c755668569d97d2faf6243daad1e428e8848aa14", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "245729d6-825a-47a2-a58e-20c7de435c72", "node_type": "1", "metadata": {}, "hash": "f2c675e763c04064fe101e208ff8a15060f3d8c272773733ce6d452f7c1a385d", "class_name": "RelatedNodeInfo"}}, "text": "\u2022 We use a public GitHub repo: https://github.com/stevenhalim/cpbook-code that\ncontains the same sample code content as this book during the release date of this\nedition (19 July 2020). Obviously, the content of the GitHub repo will always be more\nup-to-date/complete than the printed version as time goes on. Please star, watch, fork,\nor even contribute to this public GitHub repo. You are free to use these source code\nfor your next programming contest or any other purposes.\n\u2022 We have added Kattis online judge https://open.kattis.com on top of UVa online\njudge and have raised the number of discussed problems to \u21e13458. This is more\nthan two times the number in CP3 (1675). Note that there are \u21e1150+ overlapping\nproblems in both UVa and Kattis online judges. We only list them once (under Kattis\nproblem id). Steven is top 9 (out of \u21e1141 132 users) in Kattis online judge and top 39\n(out of \u21e1365 857) in UVa online judge as of 19 July 2020, i.e., at the 99.9th percentile\nfor both online judges.\n\u2022 We have digitized all hints of the \u21e13458 problems that we have solved at https:\n//cpbook.net/methodstosolve, including the extras that are not fully shown in the\nprinted version of this book to save space. The online version has search/\ufb01lter feature\nand will always be more up-to-date than the printed version as time goes on. The\n750+ problems in Kattis online judge with the lowest points [1.1..3.5] as of 19 July\n2020 have been solved by us and are discussed in this book.\n\u2022 A few outdated problem categories have been adjusted/removed (e.g., Combining Max\n1D/2D Range Sum, etc). A few/emerging problem categories have been opened (e.g.,\nPre-calculate-able, Try All Possible Answer(s), Fractions, NP-hard/complete, etc).\n\u2022 To help our readers avoid the \u201cneedle in a haystack\u201d issue, we usually select only top\n4 UVa+3 Kattis (or top 3 UVa+4 Kattis), totalling 7 starred problems, per category.\nThis reduce clutter and will help new competitive programmer to prioritize their train-\ning time on the better quality practice problems. This also saves a few precious pages\nthat can be used to improve the actual content of the book.\n2Including 10 ICPC Asia Regional Wins in between the release of CP3 (2013) and CP4 (2020).\nxx\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\n\u2022 We have re-written almost every existing topic in the book to enhance their presen-\ntation.\nWe have integrated our freely accessible https://visualgo.net algorithm\nvisualization tool3 as far as possible into this book. Obviously, the content shown in\nVisuAlgo will always be more up-to-date than the printed version as time goes on. All\nthese new additions may be subtle but may be very important to avoid TLE/WA in\nthe ever increasing di\ufb03culties of programming contest problems [17]. Many starred\nexercises in CP3 that are now deemed to be \u2018standard\u2019 by year 2020 have been inte-\ngrated into the body text of this CP4 so do not be surprised to see a reduction of the\nnumber of written exercises in some chapters.\n\u2022 Re-organization of topics compared to CP3, especially to facilitate the cleaner Book 1\nversus Book 2 split:\n\u2013 Book 1 (Chapter 1-4)\n1. We select and organize some of the easiest problems found in UVa and Kattis\nonline judges that were previously scattered in several chapters (especially\nfrom Chapter 5/6/7) into a compilation of exercises for those who have only\nstarted learning basic programming methodology in Chapter 1. It is now\nmuch easier to get the \ufb01rst few ACs in UVa and/or Kattis online judge(s) to\nkick start your Competitive Programming journey.\n2. We move basic string processing problems and some easier Ad Hoc string\nprocessing problems from Chapter 6 to Chapter 1 and highlight the usage of\nshort Python code to deal with these problems.\n3. We move Roman numerals from Chapter 9 into Chapter 1, it is a rare but\nsimple Ad Hoc problem.\n4. We move Inversion Index and Sorting in Linear Time from Chapter 9 into a\n\u2018Special Sorting Problems\u2019 sub-category in Chapter 2.\n5.", "mimetype": "text/plain", "start_char_idx": 46202, "end_char_idx": 50167, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "245729d6-825a-47a2-a58e-20c7de435c72": {"__data__": {"id_": "245729d6-825a-47a2-a58e-20c7de435c72", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e539adf6-499c-4618-8ea4-04f1de63bf39", "node_type": "1", "metadata": {}, "hash": "b5591c7a44f93dbf97486bbf96760bcd8e7c4375ef478c17859ffad041aa65c0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "74134c91-4832-4f2e-bd57-749151651b9f", "node_type": "1", "metadata": {}, "hash": "2c8e8cfcf4bd83fa2b62a2e67a39621c495816add4f683feb3499d5cdf37ff6c", "class_name": "RelatedNodeInfo"}}, "text": "It is now\nmuch easier to get the \ufb01rst few ACs in UVa and/or Kattis online judge(s) to\nkick start your Competitive Programming journey.\n2. We move basic string processing problems and some easier Ad Hoc string\nprocessing problems from Chapter 6 to Chapter 1 and highlight the usage of\nshort Python code to deal with these problems.\n3. We move Roman numerals from Chapter 9 into Chapter 1, it is a rare but\nsimple Ad Hoc problem.\n4. We move Inversion Index and Sorting in Linear Time from Chapter 9 into a\n\u2018Special Sorting Problems\u2019 sub-category in Chapter 2.\n5. We move Bracket Matching and Post\ufb01x Conversion/Calculator from Chapter\n9 into a \u2018Special Stack-based Problems\u2019 sub-category in Chapter 2.\n6. We move basic Big Integer from Chapter 5 to Chapter 2 as it is essentially a\nbuilt-in data structure for Python (3) and Java users (still classi\ufb01ed as our-\nown library for C++ users). This way, readers can be presented with some\neasier Big Integer-related problems from the earlier chapters in Book 1.\n7. We move Order Statistics Tree from Chapter 9 as another non-linear data\nstructure with its C++ speci\ufb01c pbds library in Chapter 2.\n8. We swap the order of two sections: Fenwick Tree (its basic form is much more\neasier to understand for beginners) and Segment Tree (more versatile).\n9. We move (Ad Hoc) Mathematics-related Complete Search problems from\nChapter 5 to Chapter 3.\n10. We move Ad Hoc Josephus problem that mostly can be solved with Complete\nSearch from Chapter 9 to Chapter 3.\n\u2013 With these content reorganizations, we are happy enough to declare that the\ncontent of Book 1 satisfy most4 of the IOI syllabus [16] as of year 2020.\n3VisuAlgo is built with modern web programming technologies, e.g., HTML5 SVG, canvas, CSS3,\nJavaScript (jQuery, D3.js library), PHP (Laravel framework), MySQL, etc. It has e-Lecture mode for basic\nexplanations of various data structures and algorithms and Online Quiz mode to test basic understanding.\n4Note that the IOI syllabus is an evolving document that is updated yearly.\nxxi\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\n\u2013 Book 2 (Chapter 5-9)\n1. We spread Java BigInteger speci\ufb01c features to related sections, e.g., Base\nnumber conversion and simplifying fractions with GCD at Ad Hoc mathe-\nmatics section, probabilistic prime testing at Number Theory section, and\nmodular exponentiation at Matrix Power section.\n2. We swap the order of two sections in Chapter 5: Number Theory (with\nthe expanded modular arithmetic section) and Combinatorics (some harder\nCombinatorics problem now involve modular arithmetic).\n3. We swap the order of two sections in Chapter 6: String Processing with DP\nbefore String Matching. This is so that the discussion of String Matching\nspread across three related subsections: standard String Matching (KMP),\nSu\ufb03x Array, and String Matching with Hashing (Rabin-Karp).\n4. We reorganize the categorization of many DP problems that we have solved\nin Chapter 8.\n5. We defer the discussion of Network Flow from Chapter 4 (in CP3) to Chapter\n8 (in CP4) as it is still excluded from the IOI Syllabus [16] as of year 2020.\n6. We move Graph Matching from Chapter 9 to Chapter 8, after the related Net-\nwork Flow section and before the new section on NP-hard/complete problems.\n7. We add a new section on NP-complete decision and/or NP-hard optimization\nproblems in Competitive Programming, compiling ideas that were previously\nscattered in CP3. We highlight that for such problem types, we are either\ngiven small instances (where Complete Search or Dynamic Programming is\nstill su\ufb03cient) or the special case of the problem (where specialized polyno-\nmial/fast algorithm is still possible\u2014including Greedy algorithm, Network\nFlow, or Graph Matching solutions).\n\u2022 Chapter 1 changes:\n1. We add short writeups about the IOI and ICPC, the two important international\nprogramming competitions that use material in this book (and beyond).\n2. We include Python (3) as one of the supported programming languages in this\nbook, especially for easier, non runtime-critical problems, Big Integer, and/or\nstring processing problems.", "mimetype": "text/plain", "start_char_idx": 49607, "end_char_idx": 53685, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "74134c91-4832-4f2e-bd57-749151651b9f": {"__data__": {"id_": "74134c91-4832-4f2e-bd57-749151651b9f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "245729d6-825a-47a2-a58e-20c7de435c72", "node_type": "1", "metadata": {}, "hash": "f2c675e763c04064fe101e208ff8a15060f3d8c272773733ce6d452f7c1a385d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5e679599-9d3e-49bb-88e8-e9e04ac0b266", "node_type": "1", "metadata": {}, "hash": "3cde853436e7cf67f52ab95c611447e36318031422df324fa4f9d7cb5e1ffcef", "class_name": "RelatedNodeInfo"}}, "text": "7. We add a new section on NP-complete decision and/or NP-hard optimization\nproblems in Competitive Programming, compiling ideas that were previously\nscattered in CP3. We highlight that for such problem types, we are either\ngiven small instances (where Complete Search or Dynamic Programming is\nstill su\ufb03cient) or the special case of the problem (where specialized polyno-\nmial/fast algorithm is still possible\u2014including Greedy algorithm, Network\nFlow, or Graph Matching solutions).\n\u2022 Chapter 1 changes:\n1. We add short writeups about the IOI and ICPC, the two important international\nprogramming competitions that use material in this book (and beyond).\n2. We include Python (3) as one of the supported programming languages in this\nbook, especially for easier, non runtime-critical problems, Big Integer, and/or\nstring processing problems. If you can save 5 minutes of coding time on your \ufb01rst\nAccepted solution and your team eventually solves 8 problems in the problem set,\nthis is a saving of 8 \u21e55 = 40 total penalty minutes.\n3. We add some OCaml implementations (it is not yet used in the IOI or ICPC).\n4. We use up-to-date Competitive Programming techniques as of year 2020.\n\u2022 Chapter 2 changes:\n1. Throughout this data structure chapter, we add much closer integration with our\nown freely accessible visualization tool: VisuAlgo.\n2. We add Python (3) and OCaml libraries on top of C++ STL and Java API.\n3. We signi\ufb01cantly expand the discussion of Binary Heap, Hash Table, and (bal-\nanced) Binary Search Tree in Non-linear Data Structures section that are typically\ndiscussed in a \u201cData Structures and Algorithms\u201d course.\nxxii\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\n4. We emphasize the usage of the faster Hash Tables (e.g., C++ unordered map)\ninstead of balanced BST (e.g., C++ map) if we do not need the ordering of keys\nand the keys are basic data types like integers or strings. We also recommend the\nsimpler Direct Addressing Table (DAT) whenever it is applicable.\n5. We highlight the usage of balanced BSTs as a powerful (but slightly slower)\nPriority Queue and as another sorting tool (Tree Sort).\n6. We discuss ways to deal with graphs that are not labeled with [0..V -1] and on\nhow to store some special graphs more e\ufb03ciently.\n7. We enhance the presentation of the UFDS data structure.\n8. We add more features of Fenwick Tree data structure: Fenwick Tree as (a variant\nof) order statistics data structure, Range Update Point Query variant, and Range\nUpdate Range Query variant.\n9. We add more feature of Segment Tree data structure: Range Update with Lazy\nPropagation to maintain its O(log n) performance.\n\u2022 Chapter 3 changes:\n1. We add two additional complete search techniques: Pre-calculate all (or some)\nanswers and Try all possible answers (that cannot be binary-searched; or when the\npossible answers range is small). We also update iterative bitmask implementation\nto always use LSOne technique whenever possible. We also add more complete\nsearch tips, e.g., data compression to make the problem amenable to complete\nsearch techniques. We also tried Python for Complete Search problems. Although\nPython will mostly get TLE for harder Complete Search problems, there are ways\nto make Python usable for a few easier Complete Search problems.\n2. We now favor implementation of Binary Search the Answer (BSTA) using for loop\ninstead of while loop. We also integrate Ternary Search in this chapter.\n3. We now consider greedy (bipartite) matching as another classic greedy problem.\nWe add that some greedy algorithms use Priority Queue data structure to dy-\nnamically order the next candidates greedily.\n4. We now use the O(n log k) LIS solution (\u2018patience sort\u2019, not DP) as the de-\nfault solution for modern LIS problem. We now use LSOne technique inside the\nO(2n\u22121 \u21e5n2) DP-TSP solution to allow it to solve n \uf8ff[18..19] faster.\n\u2022 Chapter 4 changes:\n1. We redo almost all screenshots in this Chapter 4 using VisuAlgo tool.\n2. We now set Kosaraju\u2019s algorithm as the default algorithm for \ufb01nding Strongly\nConnected Components (SCCs) as it is simpler than Tarjan\u2019s algorithm.\n3. We signi\ufb01cantly expand the Shortest Paths section with many of its known vari-\nations.", "mimetype": "text/plain", "start_char_idx": 52844, "end_char_idx": 57018, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e679599-9d3e-49bb-88e8-e9e04ac0b266": {"__data__": {"id_": "5e679599-9d3e-49bb-88e8-e9e04ac0b266", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "74134c91-4832-4f2e-bd57-749151651b9f", "node_type": "1", "metadata": {}, "hash": "2c8e8cfcf4bd83fa2b62a2e67a39621c495816add4f683feb3499d5cdf37ff6c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b7aa21ea-d15e-4ec6-a5a9-6e31519129f1", "node_type": "1", "metadata": {}, "hash": "18fde1ce444db22b96dcefbb3a7854d5d2240a824465a4da5c38eeaebe2256a4", "class_name": "RelatedNodeInfo"}}, "text": "We add that some greedy algorithms use Priority Queue data structure to dy-\nnamically order the next candidates greedily.\n4. We now use the O(n log k) LIS solution (\u2018patience sort\u2019, not DP) as the de-\nfault solution for modern LIS problem. We now use LSOne technique inside the\nO(2n\u22121 \u21e5n2) DP-TSP solution to allow it to solve n \uf8ff[18..19] faster.\n\u2022 Chapter 4 changes:\n1. We redo almost all screenshots in this Chapter 4 using VisuAlgo tool.\n2. We now set Kosaraju\u2019s algorithm as the default algorithm for \ufb01nding Strongly\nConnected Components (SCCs) as it is simpler than Tarjan\u2019s algorithm.\n3. We signi\ufb01cantly expand the Shortest Paths section with many of its known vari-\nations. We discuss and compare both versions of Dijkstra\u2019s algorithm implemen-\ntations. We move SPFA from Chapter 9, position this algorithm as Bellman-Ford\n\u2018extension\u2019, and called it as Bellman-Ford-Moore algorithm.\n4. We signi\ufb01cantly update the section on Euler graph and replace Fleury\u2019s algorithm\nwith the better Hierholzer\u2019s algorithm.\n5. We add remarks about a few more special (rare) graphs and their properties.\nxxiii\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\n\u2022 Chapter 5 changes:\n1. We expand the discussion of this easy but big Ad Hoc Mathematics-related prob-\nlems. We identify one more recurring Ad Hoc problems in Mathematics: Fraction.\n2. We recognize the shift of trend where the number of pure Big Integer problems\nis decreasing and the number of problems that require modular arithmetic is\nincreasing. Therefore, the discussion on modular arithmetic in Number Theory\nsection have been signi\ufb01cantly expanded and presented earlier before being used\nin latter sections, e.g., Fermat\u2019s little theorem/modular multiplicative inverse\nis used in the implementation of Binomial Coe\ufb03cients and Catalan Numbers\nin Combinatorics section, modular exponentiation is now the default in Matrix\nPower section.\n3. We expand the Combinatorics section with more review of counting techniques.\n4. We expand the discussion of Probability-related problems.\n5. We enhance the explanation of Floyd\u2019s (Tortoise-Hare) cycle-\ufb01nding algorithm\nwith VisuAlgo tool.\n6. We integrate Matrix Power into this chapter, expanded the writeup about matrix\npower, and integrate modular arithmetic techniques in this section.\n\u2022 Chapter 6 changes:\n1. We discuss Digit DP as one more string processing problem with DP.\n2. We further strengthen our General Trie/Su\ufb03x Trie/Tree/Array explanation.\n3. We add String Hashing as alternative way to solve string processing related prob-\nlems including revisiting the String Matching problem with hashing.\n4. We integrate and expand section on Anagram and Palindrome, both are classic\nstring processing problems that have variants with varying di\ufb03culties.\n\u2022 Chapter 7 changes:\n1. We further enhance the existing library routines, e.g., (the shorter to code) An-\ndrew\u2019s Monotone Chain algorithm is now the default convex hull algorithm, re-\nplacing (the slightly longer to code and a bit slower) Graham\u2019s Scan.\n2. We redo the explanation and add VisuAlgo screenshots of algorithms on Polygon.\n\u2022 Chapter 8 changes:\n1. We now set the faster O(V 2 \u21e5E) Dinic\u2019s algorithm as the default algorithm,\nreplacing the slightly slower O(V \u21e5E2) Edmonds-Karp algorithm. We also add\na few more network \ufb02ow applications.\n2. We expand the discussion of Graph Matching and its bipartite/non-bipartite +\nunweighted/weighted variants. We augment the Augmenting Path algorithm with\nthe randomized greedy pre-processing step by default.\n3. We add a few more problem decomposition related techniques and listed many\nmore such problems, ordered by their frequency of appearance.\nxxiv\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\n\u2022 Chapter 9 changes:\n1. On top of enhancing previous writeups, we add more collection of new rare data\nstructures, algorithms, and/or programming problems that have not been listed\nin the \ufb01rst eight chapters and did not appear in CP3.", "mimetype": "text/plain", "start_char_idx": 56338, "end_char_idx": 60248, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b7aa21ea-d15e-4ec6-a5a9-6e31519129f1": {"__data__": {"id_": "b7aa21ea-d15e-4ec6-a5a9-6e31519129f1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5e679599-9d3e-49bb-88e8-e9e04ac0b266", "node_type": "1", "metadata": {}, "hash": "3cde853436e7cf67f52ab95c611447e36318031422df324fa4f9d7cb5e1ffcef", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a76c70bc-0efa-4158-9b4b-2025daf63bf7", "node_type": "1", "metadata": {}, "hash": "1ee04fe7619ac5ad9d258055bc1324cd3c3863953f29865a052024b70c294fdc", "class_name": "RelatedNodeInfo"}}, "text": "We also add\na few more network \ufb02ow applications.\n2. We expand the discussion of Graph Matching and its bipartite/non-bipartite +\nunweighted/weighted variants. We augment the Augmenting Path algorithm with\nthe randomized greedy pre-processing step by default.\n3. We add a few more problem decomposition related techniques and listed many\nmore such problems, ordered by their frequency of appearance.\nxxiv\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\n\u2022 Chapter 9 changes:\n1. On top of enhancing previous writeups, we add more collection of new rare data\nstructures, algorithms, and/or programming problems that have not been listed\nin the \ufb01rst eight chapters and did not appear in CP3. These new topics are:\n(a) Square Root Decomposition,\n(b) Heavy-Light Decomposition,\n(c) Tree Isomorphism,\n(d) De Bruijn Sequence,\n(e) Fast Fourier Transform,\n(f) Chinese Remainder Theorem,\n(g) Lucas\u2019 Theorem,\n(h) Combinatorial Game Theory,\n(i) Egg Dropping Puzzle,\n(j) Dynamic Programming Optimization,\n(k) Push-Relabel algorithm,\n(l) Kuhn-Munkres algorithm,\n(m) Edmonds\u2019 Matching algorithm,\n(n) Constructive Problem,\n(o) Interactive Problem,\n(p) Linear Programming,\n(q) Gradient Descent.\n\u2022 In summary, someone who only master CP3 (published back in 2013) content can be\neasily beaten in a programming contest by someone who only master CP4 content\n(published in year 2020).\nSupporting Websites\nThis book has an o\ufb03cial companion web site at https://cpbook.net. The Methods to\nSolve tool is in this web site too.\nWe have also uploaded (almost) all source code discussed in this book in the public\nGitHub repository of this book: https://github.com/stevenhalim/cpbook-code.\nSince the third edition of this book, many data structures and algorithms discussed in\nthis book already have interactive visualizations at https://visualgo.net.\nAll UVa Online Judge programming exercises in this book have been integrated in the\nhttps://uhunt.onlinejudge.org/ tool.\nAll Kattis Online Judge programming exercises in this book can be easily accessed using\nthe \u201cKattis Hint Giver\u201d Google Chrome extension (created by Steven\u2019s student Lin Si Jie)\nthat integrates the content of Methods to Solve directly to Kattis\u2019s problems pages.\nxxv\n\nPREFACE\nc\u20ddSteven, Felix, Suhendry\nCopyright\nIn order to protect the intellectual property, no part of this book may be reproduced or\ntransmitted in any form or by any means, electronically or mechanically, including photo-\ncopying, scanning, uploading to any storage and retrieval system, without o\ufb03cial permission\nof the authors.\nTo a better future of humankind,\nSteven Halim, Felix Halim, and Suhendry Effendy\nSingapore, 19 July 2020\nxxvi\n\nAuthors\u2019 Pro\ufb01les\nSteven Halim, PhD5\nstevenhalim@gmail.com\nSteven Halim is a senior lecturer in School of Comput-\ning, National University of Singapore (SoC, NUS). He\nteaches several programming courses in NUS, rang-\ning from basic programming methodology, intermedi-\nate to hard data structures and algorithms, web pro-\ngramming, and also the \u2018Competitive Programming\u2019\nmodule that uses this book. He is the coach of both\nthe NUS ICPC teams and the Singapore IOI team. He participated in several ICPC Re-\ngionals as a student (Singapore 2001, Aizu 2003, Shanghai 2004).\nSo far, he and other\ntrainers @ NUS have successfully groomed various ICPC teams that won ten di\u21b5erent ICPC\nRegionals (see below), advanced to ICPC World Finals eleven times (2009-2010; 2012-2020)\nwith current best result of Joint-14th in ICPC World Finals Phuket 2016 (see below), as\nwell as seven gold, nineteen silver, and \ufb01fteen bronze IOI medalists (2009-2019). He is also\nthe Regional Contest Director of ICPC Asia Singapore 2015+2018 and is the Deputy Di-\nrector+International Committee member for the IOI 2020+2021 in Singapore. He has been\ninvited to give international workshops about ICPC/IOI at various countries, e.g., Bolivia\nICPC/IOI camp in 2014, Saudi Arabia IOI camp in 2019, Cambodia NOI camp in 2020.", "mimetype": "text/plain", "start_char_idx": 59575, "end_char_idx": 63502, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a76c70bc-0efa-4158-9b4b-2025daf63bf7": {"__data__": {"id_": "a76c70bc-0efa-4158-9b4b-2025daf63bf7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b7aa21ea-d15e-4ec6-a5a9-6e31519129f1", "node_type": "1", "metadata": {}, "hash": "18fde1ce444db22b96dcefbb3a7854d5d2240a824465a4da5c38eeaebe2256a4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dfb680fd-020c-4781-8fd3-92837d2f471d", "node_type": "1", "metadata": {}, "hash": "044744f21b91d98247cf2e3120aa5c642e522ef8185ae32e2610ae61a5e91d22", "class_name": "RelatedNodeInfo"}}, "text": "He is also\nthe Regional Contest Director of ICPC Asia Singapore 2015+2018 and is the Deputy Di-\nrector+International Committee member for the IOI 2020+2021 in Singapore. He has been\ninvited to give international workshops about ICPC/IOI at various countries, e.g., Bolivia\nICPC/IOI camp in 2014, Saudi Arabia IOI camp in 2019, Cambodia NOI camp in 2020.\nSteven is happily married to Grace Suryani Tioso and has two daughters and one son:\nJane Angelina Halim, Joshua Ben Halim, and Jemimah Charissa Halim.\nICPC Regionals\n#\nYear(s)\nAsia Jakarta\n5\n2013 (ThanQ), 2014 (ThanQ+), 2015 (RRwatameda),\n2017 (DomiNUS), 2019 (Send Bobs to Alice)\nAsia Manila\n2\n2017 (Pandamiao), 2019 (7 Halim)\nAsia Nakhon Pathom\n1\n2018 (Pandamiao)\nAsia Yangon\n1\n2018 (3body2)\nAsia Kuala Lumpur\n1\n2019 (3body3)\nTable 3: NUS ICPC Regionals Wins in 2010s\nICPC World Finals\nTeam Name\nRank\nYear\nPhuket, Thailand\nRRwatameda\nJoint-14/128\n2016\nEkaterinburg, Russia\nThanQ+\nJoint-19/122\n2014\nRapid City, USA\nTeamTam\nJoint-20/133\n2017\nTable 4: NUS ICPC World Finals Top 3 Results in 2010s\n5PhD Thesis: \u201cAn Integrated White+Black Box Approach for Designing and Tuning Stochastic Local\nSearch Algorithms\u201d, 2009.\nxxvii\n\nAUTHORS\u2019 PROFILES\nc\u20ddSteven, Felix, Suhendry\nFelix Halim, PhD6\nfelix.halim@gmail.com\nFelix Halim is a senior software engineer at Google.\nWhile in Google, he worked on distributed system\nproblems, data analysis, indexing, internal tools, and\ndatabase related stu\u21b5. Felix has a passion for web\ndevelopment.\nHe created uHunt to help UVa on-\nline judge users \ufb01nd the next problems to solve.\nHe also developed a crowdsourcing website, https:\n//kawalpemilu.org, to let the Indonesian public to\noversee and actively keep track of the Indonesia gen-\neral election in 2014 and 2019.\nAs a contestant, Felix participated in IOI 2002 Ko-\nrea (representing Indonesia), ICPC Manila 2003-2005,\nKaohsiung 2006, and World Finals Tokyo 2007 (rep-\nresenting Bina Nusantara University). He was also\none of Google India Code Jam 2005 and 2006 \ufb01nal-\nists. As a problem setter, Felix set problems for ICPC\nJakarta 2010, 2012, 2013, ICPC Kuala Lumpur 2014,\nand several Indonesian national contests.\nFelix is happily married to Siska Gozali. The picture on the right is one of their Europe\nhoneymoon travel photos (in Switzerland) after ICPC World Finals @ Porto 2019. For more\ninformation about Felix, visit his website at https://felix-halim.net.\nSuhendry E\u21b5endy, PhD7\nsuhendry.e\u21b5endy@gmail.com\nSuhendry E\u21b5endy is a research fellow in the School\nof Computing of the National University of Singa-\npore (SoC, NUS). He obtained his bachelor degree\nin Computer Science from Bina Nusantara University\n(BINUS), Jakarta, Indonesia, and his PhD degree in\nComputer Science from National University of Singa-\npore, Singapore. Before completing his PhD, he was\na lecturer in BINUS specializing in algorithm anal-\nysis and served as the coach for BINUS competitive\nprogramming team (nicknamed as \u201cJollybee\u201d).\nSuhendry is a recurring problem setter for the\nICPC Asia Jakarta since the very \ufb01rst in 2008. From\n2010 to 2016, he served as the chief judge for the\nICPC Asia Jakarta collaborating with many other\nproblem setters. He also set problems in many other\ncontests, such as the ICPC Asia Kuala Lumpur, the\nICPC Asia Singapore, and Olimpiade Sains Nasional\nbidang Komputer (Indonesia National Science Olympiad in Informatic) to name but a few.", "mimetype": "text/plain", "start_char_idx": 63149, "end_char_idx": 66537, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dfb680fd-020c-4781-8fd3-92837d2f471d": {"__data__": {"id_": "dfb680fd-020c-4781-8fd3-92837d2f471d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a76c70bc-0efa-4158-9b4b-2025daf63bf7", "node_type": "1", "metadata": {}, "hash": "1ee04fe7619ac5ad9d258055bc1324cd3c3863953f29865a052024b70c294fdc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8658b90c-0ecb-402f-adc7-16201f8f11ba", "node_type": "1", "metadata": {}, "hash": "453a569b39df87f8955897e1aabe38b5e4e8294662e1b76f6540651ca840584b", "class_name": "RelatedNodeInfo"}}, "text": "Before completing his PhD, he was\na lecturer in BINUS specializing in algorithm anal-\nysis and served as the coach for BINUS competitive\nprogramming team (nicknamed as \u201cJollybee\u201d).\nSuhendry is a recurring problem setter for the\nICPC Asia Jakarta since the very \ufb01rst in 2008. From\n2010 to 2016, he served as the chief judge for the\nICPC Asia Jakarta collaborating with many other\nproblem setters. He also set problems in many other\ncontests, such as the ICPC Asia Kuala Lumpur, the\nICPC Asia Singapore, and Olimpiade Sains Nasional\nbidang Komputer (Indonesia National Science Olympiad in Informatic) to name but a few.\n6PhD Thesis: \u201cSolving Big Data Problems: from Sequences to Tables and Graphs\u201d, 2012.\n7PhD Thesis: \u201cGraph Properties and Algorithms in Social Networks: Privacy, Sybil Attacks, and the\nComputer Science Community\u201d, 2017.\nxxviii\n\nAbbreviations\nA* : A Star\nACM : Assoc for Computing Machinery\nAC : Accepted\nADT : Abstract Data Type\nAL : Adjacency List\nAM : Adjacency Matrix\nAPSP : All-Pairs Shortest Paths\nAVL : Adelson-Velskii Landis (BST)\nBNF : Backus Naur Form\nBFS : Breadth First Search\nBI : Big Integer\nBIT : Binary Indexed Tree\nbBST : (balanced) Binary Search Tree\nBSTA : Binary Search the Answer\nCC : Coin Change\nCCW : Counter ClockWise\nCF : Cumulative Frequency\nCH : Convex Hull\nCRT : Chinese Remainder Theorem\nCS : Computer Science\nCW : ClockWise\nDAG : Directed Acyclic Graph\nDAT : Direct Addressing Table\nD&C : Divide and Conquer\nDFS : Depth First Search\nDLS : Depth Limited Search\nDP : Dynamic Programming\nDS : Data Structure\nED : Edit Distance\nEL : Edge List\nFFT : Fast Fourier Transform\nFIFO : First In First Out\nFT : Fenwick Tree\nGCD : Greatest Common Divisor\nHLD : Heavy-Light Decomposition\nICPC : Intl. Collegiate Prog. Contest\nIDS : Iterative Deepening Search\nIDA* : Iterative Deepening A Star\nI/O : Input/Output\nIOI : Intl. Olympiad in Informatics\nIPSC : Internet Problem Solving Contest\nKISS : Keep It Short and Simple\nLA : Live Archive [30]\nLCA : Lowest Common Ancestor\nLCE : Longest Common Extension\nLCM : Least Common Multiple\nLCP : Longest Common Pre\ufb01x\nLCS1 : Longest Common Subsequence\nLCS2 : Longest Common Substring\nLIFO : Last In First Out\nLIS : Longest Increasing Subsequence\nLRS : Longest Repeated Substring\nLSB : Least Signi\ufb01cant Bit\nMCBM : Max Cardinality Bip. Matching\nMCM1 : Max Cardinality Matching\nMCM2 : Matrix Chain Multiplication\nMCMF : Min-Cost Max-Flow\nMIS : Max Independent Set\nMLE : Memory Limit Exceeded\nMPC : Min Path Cover\nMSB : Most Signi\ufb01cant Bit\nMSSP : Multi-Sources Shortest Paths\nMST : Min Spanning Tree\nMWIS : Max Weight Independent Set\nMVC : Min Vertex Cover\nMWVC : Min Weight Vertex Cover\nNP : Non-deterministic Polynomial\nOJ : Online Judge\nPE : Presentation Error\nRB : Red-Black (BST)\nRMQ : Range Min (or Max) Query\nRSQ : Range Sum Query\nRTE : Run Time Error\nRUPQ : Range Update Point Query\nRURQ : Range Update Range Query\nSSSP : Single-Source Shortest Paths\nxxix\n\nABBREVIATIONS\nc\u20ddSteven, Felix, Suhendry\nSA : Su\ufb03x Array\nSPOJ : Sphere Online Judge\nST : Su\ufb03x Tree\nSTL : Standard Template Library\nTLE : Time Limit Exceeded\nUSACO : USA Computing Olympiad\nUVa : University of Valladolid [44]\nWA : Wrong Answer\nWF : World Finals\nxxx\n\nChapter 1\nIntroduction\nI want to compete in ICPC World Finals!\n\u2014 A dedicated student\n1.1\nCompetitive Programming\nThe core directive in \u2018Competitive Programming\u2019 is this: \u201cGiven well-known Computer\nScience (CS) problems, solve them as quickly as possible!\u201d.\nLet\u2019s digest the terms one by one.", "mimetype": "text/plain", "start_char_idx": 65920, "end_char_idx": 69407, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8658b90c-0ecb-402f-adc7-16201f8f11ba": {"__data__": {"id_": "8658b90c-0ecb-402f-adc7-16201f8f11ba", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dfb680fd-020c-4781-8fd3-92837d2f471d", "node_type": "1", "metadata": {}, "hash": "044744f21b91d98247cf2e3120aa5c642e522ef8185ae32e2610ae61a5e91d22", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "915b0bc5-aec5-4084-b602-c96698cb7d0b", "node_type": "1", "metadata": {}, "hash": "240756f02efd0e6fb8bc676295415d073747c51c7475449e8405085b646c9516", "class_name": "RelatedNodeInfo"}}, "text": "\u2014 A dedicated student\n1.1\nCompetitive Programming\nThe core directive in \u2018Competitive Programming\u2019 is this: \u201cGiven well-known Computer\nScience (CS) problems, solve them as quickly as possible!\u201d.\nLet\u2019s digest the terms one by one. The term \u2018well-known CS problems\u2019 implies that in\ncompetitive programming, we are dealing with solved CS problems and not research problems\n(where the solutions are still unknown). Some people (at least the problem author) have\nde\ufb01nitely solved these problems before. To \u2018solve them\u2019 implies that we1 must push our CS\nknowledge to a certain required level so that we can produce working code that can solve\nthese problems too\u2014at least in terms of getting the same output as the problem author\nusing the problem author\u2019s secret2 test data within the stipulated time limit. The need to\nsolve the problem \u2018as quickly as possible\u2019 is where the competitive element lies\u2014speed is a\nvery natural goal in human behavior.\nAn illustration: UVa Online Judge [44] Problem Number 10911 (Forming Quiz Teams).\nAbridged Problem Description:\nLet (x, y) be the integer coordinates of a student\u2019s house on a 2D plane.\nThere\nare 2N students and we want to pair them into N groups. Let di be the distance\nbetween the houses of 2 students in group i. Form N groups such that cost = PN\ni=1 di\nis minimized. Output the minimum cost as a \ufb02oating point number with 2 digits\nprecision in one line. Constraints: 1 \uf8ffN \uf8ff8 and 0 \uf8ffx, y \uf8ff1000.\nSample input (with explanation):\nN = 2; Coordinates of the 2N = 4 houses are {1, 1}, {8, 6}, {6, 8}, and {1, 3}.\nSample output (with explanation):\ncost = 4.83.\nCan you solve this problem?\nIf so, how many minutes would you likely require to complete the working code?\nThink and try not to \ufb02ip this page immediately!\n1Some programming competitions are done in a team setting to encourage teamwork as software engineers\nusually do not work alone in real life.\n2By hiding the actual test data from the problem statement, competitive programming encourages the\nproblem solvers to exercise their mental strength to think of many (if not all) possible corner cases of the\nproblem and test their programs with those cases. This is typical in real life where software engineers have\nto test their software a lot to make sure that the software meets the requirements set by clients.\n1\n\n1.1.\nCOMPETITIVE PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nFigure 1.1: Illustration of UVa 10911 - Forming Quiz Teams\nNow ask yourself: Which of the following best describes you? Note that if you are\nunclear with the material or the terminology shown in this chapter, you can re-read it\nagain after going through this book once.\n\u2022 Uncompetitive programmer A (a.k.a. the blurry one):\nStep 1: Reads the problem and becomes confused. (This problem is new for A).\nStep 2: Tries to code something: Reading the non-trivial input and output.\nStep 3: A realizes that these two ideas below are not Accepted (AC):\nGreedy (Section 3.4): Repeatedly pairing the two remaining students with the\nshortest separating distances gives the Wrong Answer (WA).\nNa\u00a8\u0131ve Complete Search: Using recursive backtracking (Section 3.2) and trying\nall possible pairings yields Time Limit Exceeded (TLE).\n\u2022 Uncompetitive programmer B (Gives up):\nStep 1: Reads the problem and realizes that it is a graph matching problem.\nBut B has not learned how to solve this kind of problem...\nB is not aware of the Dynamic Programming (DP) solution (Section 3.5)...\nStep 2: Skips the problem and reads another problem in the problem set.\n\u2022 (Still) Uncompetitive programmer C (Slow):\nStep 1: Reads the problem and realizes that it is a di\ufb03cult problem: \u2018minimum\nweight perfect matching on a weighted complete graph\u2019. However, since\nthe input size is small, this problem is solvable using DP. The DP state is a\nbitmask that describes a matching status, and matching unmatched students i\nand j will turn on two bits i and j in the bitmask (see Book 2).\nStep 2: Codes I/O routine, writes recursive top-down DP, tests, debugs >.<...\nStep 3: After 3 hours, C\u2019s solution is AC (passed all the secret test data).", "mimetype": "text/plain", "start_char_idx": 69179, "end_char_idx": 73252, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "915b0bc5-aec5-4084-b602-c96698cb7d0b": {"__data__": {"id_": "915b0bc5-aec5-4084-b602-c96698cb7d0b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8658b90c-0ecb-402f-adc7-16201f8f11ba", "node_type": "1", "metadata": {}, "hash": "453a569b39df87f8955897e1aabe38b5e4e8294662e1b76f6540651ca840584b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0d15a50d-f5d6-4306-96c8-d3c6c92016a0", "node_type": "1", "metadata": {}, "hash": "14b666c6d738c80c13902870a33a3d8280578c565680b93a750bfd75dc5f1669", "class_name": "RelatedNodeInfo"}}, "text": "But B has not learned how to solve this kind of problem...\nB is not aware of the Dynamic Programming (DP) solution (Section 3.5)...\nStep 2: Skips the problem and reads another problem in the problem set.\n\u2022 (Still) Uncompetitive programmer C (Slow):\nStep 1: Reads the problem and realizes that it is a di\ufb03cult problem: \u2018minimum\nweight perfect matching on a weighted complete graph\u2019. However, since\nthe input size is small, this problem is solvable using DP. The DP state is a\nbitmask that describes a matching status, and matching unmatched students i\nand j will turn on two bits i and j in the bitmask (see Book 2).\nStep 2: Codes I/O routine, writes recursive top-down DP, tests, debugs >.<...\nStep 3: After 3 hours, C\u2019s solution is AC (passed all the secret test data).\n\u2022 Competitive programmer D:\nCompletes all the steps taken by uncompetitive programmer C in \uf8ff30 minutes.\n\u2022 Very competitive programmer E:\nA very competitive programmer (e.g., the red coders in Codeforces [4]) would\nsolve this \u2018well known\u2019 problem in \uf8ff10 minutes and possibly also aware of the\nvarious other possible solutions for the (harder) variant(s) of this problem...\nPlease note that being well-versed in competitive programming is not the end goal, but only\na means to an end. The true end goal is to produce all-rounder computer scientists or pro-\ngrammers who are much readier to produce better software and to face harder CS research\nproblems in the future. This is one of the objectives of the International Olympiad in Infor-\nmatics (IOI) [31] and the vision of the founders of the International Collegiate Programming\nContest (ICPC) [57]. With this book, we play our little role in preparing the current and fu-\nture generations to be more competitive in dealing with well-known CS problems frequently\nposed in the recent IOIs and ICPCs.\n2\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nExercise 1.1.1: The greedy strategy of the uncompetitive programmer A above actually\nworks for the sample test case shown in Figure 1.1 as typically good problem authors do not\nput their corner cases as sample test cases. Please give a better counter example!\nExercise 1.1.2: Analyze the time complexity of the na\u00a8\u0131ve complete search solution by\nuncompetitive programmer A above to understand why it receives the TLE verdict!\nExercise 1.1.3*: Actually, a clever recursive backtracking solution with pruning can still\nsolve this problem (with 1 \uf8ffN \uf8ff8). Solve this problem without using a DP table!\n1.2\nThe Competitions\nThere are a few international programming competitions in the world. In this section, we\noutline two of the most important programming competitions. The authors of this book are\n(heavily) involved in these programming competitions.\n1.2.1\nInternational Olympiad in Informatics (IOI)\nHistory and Format\nIOI was started in 1989 (in Bulgaria) and it has been around annually since then. Singapore\nhosts3 IOI in 2020+2021 and the authors of this book play crucial roles in those two back-\nto-back IOIs. The IOI statistics can be found at https://stats.ioinformatics.org/.\nIOI format: (optional) high school selection, (optional) provincial selection, National\nOlympiad in Informatics (NOI) or other national top 4 selection methods (as each coun-\ntry/region can only send up to 4 contestants to IOI per year), and \ufb01nally the actual IOI\n(usually held in the months of June to September).\nEligibility and Selection\nIOI eligibility rule can be found in the IOI regulations [31].\nAs IOI participants can come from various (secondary or high) schools of a country/region,\nestablished (large) teams usually do preliminary Internet based selection/aptitude test, con-\nduct intensive training camps in a centralized location, and gradually narrow down their\nteam selection via NOI or other selection methods until only top 4 students remain. These\ntop 4 represent the best 4 young students in Informatics, especially in the area of competitive\nprogramming, that can be found and available to represent their country/region that year.\nIOI team of a certain country/region is usually headed by a team leader that has experi-\nence managing their national training and olympiad. Ministry of Education representatives\nand/or onsite coach(es) from that country/region is/are also usually present.", "mimetype": "text/plain", "start_char_idx": 72482, "end_char_idx": 76751, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0d15a50d-f5d6-4306-96c8-d3c6c92016a0": {"__data__": {"id_": "0d15a50d-f5d6-4306-96c8-d3c6c92016a0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "915b0bc5-aec5-4084-b602-c96698cb7d0b", "node_type": "1", "metadata": {}, "hash": "240756f02efd0e6fb8bc676295415d073747c51c7475449e8405085b646c9516", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "994ecc5e-da2d-4242-9c94-6c5336c198f9", "node_type": "1", "metadata": {}, "hash": "dbc268ae2cbd3ddd8a61d5dc7a55b1b768a7758ef977ef9ce31bfec6a30ec259", "class_name": "RelatedNodeInfo"}}, "text": "Eligibility and Selection\nIOI eligibility rule can be found in the IOI regulations [31].\nAs IOI participants can come from various (secondary or high) schools of a country/region,\nestablished (large) teams usually do preliminary Internet based selection/aptitude test, con-\nduct intensive training camps in a centralized location, and gradually narrow down their\nteam selection via NOI or other selection methods until only top 4 students remain. These\ntop 4 represent the best 4 young students in Informatics, especially in the area of competitive\nprogramming, that can be found and available to represent their country/region that year.\nIOI team of a certain country/region is usually headed by a team leader that has experi-\nence managing their national training and olympiad. Ministry of Education representatives\nand/or onsite coach(es) from that country/region is/are also usually present.\nTypical Contest Strategies\nIOI competition consists of (usually) 2-hours practice4 session and two contest days5, 5 hours\nper session. IOI is an individual contest6. Each contest (usually) consists of 3 tasks, usually\none easi(er), one medium, and one hard(er) task, which are further divided into subtasks\nwith various points.\n3Online IOI in 2020 due to COVID-19.\n4The problems are usually already distributed online a few weeks prior to the actual IOI.\n5It is important to maintain stamina and emotional well-being for both contest days.\n6IOI 2018 used a one-o\u21b5live statistics of task scores to help contestants identify easier tasks.\n3\n\n1.2.\nTHE COMPETITIONS\nc\u20ddSteven, Felix, Suhendry\nThe International Scienti\ufb01c Committee (ISC) will strive to make the sum of subtask\npoints to be as diverse as possible to minimize ties7 (especially along medal boundaries). To\nmake IOI training in various national teams more manageable, the ISC maintains the IOI\nsyllabus [16].\nCoding speed is usually not a di\u21b5erentiating factor in IOI. One can submit a 100 points\n(full) solution at time 4h59m and still be rewarded with the same 100 points compared to\none that submits 100 points solution at 30m. Thus IOI emphasizes peak performance, i.e.,\nability to solve the (harder) subtasks instead of how fast one can solve the (easier) subtasks8.\nHistorically, to get a gold/silver/bronze medal, one should get 400+/300+/200+ points\n(out of possible 600) after two contest days, respectively.\nThe main purpose of this book is to make the number of IOI participants scoring low total\npoints (under 70 points) after two contest days to be as low as possible. Not all subtasks in\nIOI are hard as the ISC also needs to avoid demoralizing half of the contestants that will go\nhome without any medal. They are still future Computer Scientists after all.\nWhat\u2019s Next?\nMany, but not all, of IOI medalists/alumni continue to study in the \ufb01eld of Computer\nScience for their University degree9. Many of them (but not all) also join the next level\nof Programming Contests: The ICPC (see the next subsection 1.2.2). Thus, if one already\nknows this book from high school, he/she can use it throughout University too.\n1.2.2\nInternational Collegiate Programming Contests (ICPC)\nHistory and Format\nICPC10 was established in 1970, originated from the USA, spread worldwide starting from the\n1990s. Since 2000 (except 2003 and 2007), the winners are usually from Russian (especially\nfrom 2012-2019) and Asian Universities.\nICPC format: (optional) University level selection, (optional) Preliminary contest, Re-\ngional Contest (usually held in the months of October to December). The winners (and\nsometimes the runner-ups and a few other slightly lower ranked teams) from various Region-\nals will advance to World Finals in the following year (usually held in the months of April\nto July). The participation levels grow signi\ufb01cantly (< 10K in 2000, > 50K in 2020) [57].\nAs ICPC is a programming competition between Universities, the ICPC coaches are\nusually University CS sta\u21b5s who teach programming and/or algorithm classes.\nICPC competition runs for 5 hours. Each team consists of three University students.\nEach team is only provided with one computer. Only submissions that are Accepted (fully\ncorrect) will give +1 point to the team.", "mimetype": "text/plain", "start_char_idx": 75856, "end_char_idx": 80053, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "994ecc5e-da2d-4242-9c94-6c5336c198f9": {"__data__": {"id_": "994ecc5e-da2d-4242-9c94-6c5336c198f9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0d15a50d-f5d6-4306-96c8-d3c6c92016a0", "node_type": "1", "metadata": {}, "hash": "14b666c6d738c80c13902870a33a3d8280578c565680b93a750bfd75dc5f1669", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3a11a3ed-ea2d-4d2b-bed1-4c2ce792ecb9", "node_type": "1", "metadata": {}, "hash": "2038bfdb3f97d4ebf25f1c4d9016a2ca83f49cf7db1cc51480a92a86a67190f7", "class_name": "RelatedNodeInfo"}}, "text": "ICPC format: (optional) University level selection, (optional) Preliminary contest, Re-\ngional Contest (usually held in the months of October to December). The winners (and\nsometimes the runner-ups and a few other slightly lower ranked teams) from various Region-\nals will advance to World Finals in the following year (usually held in the months of April\nto July). The participation levels grow signi\ufb01cantly (< 10K in 2000, > 50K in 2020) [57].\nAs ICPC is a programming competition between Universities, the ICPC coaches are\nusually University CS sta\u21b5s who teach programming and/or algorithm classes.\nICPC competition runs for 5 hours. Each team consists of three University students.\nEach team is only provided with one computer. Only submissions that are Accepted (fully\ncorrect) will give +1 point to the team. Team gets penalty for each non-Accepted submission\n(usually +20 minutes to their total time). Teams are ranked \ufb01rst by decreasing number of\nproblems solved and if ties, by lower penalty time, and if still ties (rare), by earlier time\nof last Accepted submission. Most contests end with the second tie breaking criteria (the\nwinner and the runner up solved the same number of problems, one is faster than the other).\nWin by a +1 margin is rare. Win by a +2 or more margin is extremely rare.\n7ISC may use \ufb02oating point scoring system to help achieve this objective, e.g., in IOI 2015, 2017, 2019.\n8Implementing solution(s) for low-scoring subtask(s), no matter how fast one can code the solution,\nconsume a bit of contest time. Thus, this strategy is not optimal for top contestants who are aiming for\n(good quality) medal who should think of the best possible solution for an extended duration \ufb01rst.\n9Many are with scholarships.\n10ICPC was previously under the auspices of Association of Computing Machinery (ACM).\n4\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nEligibility and Selection\nUnlike IOI, where contestants compete individually representing their own country/region,\nin ICPC contestants can be from various nationalities, as long as they are representing the\nsame University and still eligible according to ICPC eligibility rule.\nEstablished Universities usually conduct their own internal training, team formation and\nselection, before sending the strong(er) teams to compete in the Regionals.\nTypical Contest Strategies\nICPC problem sets are usually designed in such a way that all teams solve at least one\nproblem (to avoid totally demoralizing newcomers in the competition, this is what we strive\nto help via this book), no team solves all problems (to make the contest interesting until the\nend of the \ufb01fth hour), and all problems are solvable by at least one team (thus minimize the\nnumber of \u2018impossible\u2019 problems that require much more than 5 hours to think and code out\nthe solution correctly \u2013 even for the perceived favorite team(s) before the contest).\nWe can break down a 5-hours ICPC into three big stages: The start, the mid-game, and\nthe end-game. In ICPC, time penalty11 plays a crucial role, hence the ability to \ufb01nd easy (or\neasier) problems that are buried inside the 10-13 problems in the problem set and solve them\nas quickly as possible with 0 or as few penalties as possible, is crucial. Some (but not all)\ncontests purposely designate problem A (the \ufb01rst page) to be the easiest problem. For top\nteams, the performance at the start dictates the tone for the rest of the contest, i.e., leading\nor playing catch up. Most top teams will run in individual mode at this stage, i.e., each of\nthe 3 team members try to solve the \ufb01rst 3 easiest problems individually. Teams that rely\non the public scoreboard to identify which problems are easier will always play catch up.\nThe mid-game usually starts around the second to the third hour. At this point, all three\nteam members should have read all problems (that have not been solved up to that point\nof time) and rank them based on (perceived) di\ufb03culties (and after comparing it with the\ncurrent public scoreboard). For top teams, ability to keep generating results at this stage \u2013\ni.e., the queue of next problem(s) to be solved/coded is not empty \u2013 is very important. As\nthe unsolved problems at this stage are the medium-hard problems (according to that team),\ngood team work is important. Some top teams with 3 strong contestants can probably still\nwork as 3 individuals.", "mimetype": "text/plain", "start_char_idx": 79239, "end_char_idx": 83613, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3a11a3ed-ea2d-4d2b-bed1-4c2ce792ecb9": {"__data__": {"id_": "3a11a3ed-ea2d-4d2b-bed1-4c2ce792ecb9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "994ecc5e-da2d-4242-9c94-6c5336c198f9", "node_type": "1", "metadata": {}, "hash": "dbc268ae2cbd3ddd8a61d5dc7a55b1b768a7758ef977ef9ce31bfec6a30ec259", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5bd5f64b-f497-4484-a8b8-e67275bba34b", "node_type": "1", "metadata": {}, "hash": "1b688f8ef0a67f1625804c5ae11c3ccbc0a90a578f1a78d00cc94fb0835ff7d7", "class_name": "RelatedNodeInfo"}}, "text": "Teams that rely\non the public scoreboard to identify which problems are easier will always play catch up.\nThe mid-game usually starts around the second to the third hour. At this point, all three\nteam members should have read all problems (that have not been solved up to that point\nof time) and rank them based on (perceived) di\ufb03culties (and after comparing it with the\ncurrent public scoreboard). For top teams, ability to keep generating results at this stage \u2013\ni.e., the queue of next problem(s) to be solved/coded is not empty \u2013 is very important. As\nthe unsolved problems at this stage are the medium-hard problems (according to that team),\ngood team work is important. Some top teams with 3 strong contestants can probably still\nwork as 3 individuals. Some teams will switch to a pair + 1 individual. The rest of the teams\nprobably have to pool all 3 team members\u2019 strengths in bid to solve one more problem.\nThe end-game starts when all easy and medium problems (according to that team) have\nbeen solved by the team and the team is left with problems that the team has not solved\nbefore (or have to spend lots of time to solve during practice sessions). Top teams will only\nhave a few remaining problems left at this stage and should be able to estimate what is the\ntime needed to solve +1 more so that they can submit +1 more AC code at minute 299\nrather than after minute 300. For many other teams, this stage is about salvaging the result\nwith all 3 members working on one last not-yet-solved problem, hoping that they do not\nget stuck. Most contests do not end with a clean sweep where the winning team solve all\nproblems as the judges usually set the required theoretical total time to solve all problems\n(by the perceived favorite team(s) before the contest) to be longer than 5 contest hours.\nWhat\u2019s Next?\nMost competitive programmers will likely end their competition career after their last ICPC.\nGood performance in ICPC during University days is probably a(n important) requirement\nin order to excel in technical interviews in (top) IT companies.\n11Some ex-IOI contestants may need to improve their implementation speed for ICPC.\n5\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n1.2.3\nOther Programming Contests\nBeyond University, there are other various programming competitions, mostly online (with\nperhaps last onsite \ufb01nal). For example, Google CodeJam, Facebook Hacker Cup, Topcoder\nOpen, Codeforces contest, Internet Problem Solving Contest (IPSC), etc. These other pro-\ngramming competitions are not speci\ufb01cally covered in this book.\n1.3\nTips to be Competitive\nIf you strive to be like competitive programmers D or E as illustrated in Section 1.1\u2014that\nis, if you want to be selected (via provincial/state ! national team selections) to participate\nand obtain a medal in the IOI [31], or to be one of the team members that represents your\nUniversity in the ICPC [57] (nationals ! Regionals ! and up to World Finals), or to do\nwell in other programming contests\u2014then this book is de\ufb01nitely for you12!\nIn the subsequent chapters, you will learn many things from the basic to the intermediate\nor even to the advanced13 data structures and algorithms that have frequently appeared in\nrecent programming contests, compiled from many sources [45, 7, 49, 38, 51, 40, 53, 1, 35, 6,\n52, 39, 5, 54, 42, 18, 37, 36] (see Figure 1.4). You will not only learn the concepts behind the\ndata structures and algorithms, but also how to implement them e\ufb03ciently and apply them\nto appropriate contest problems. On top of that, you will also learn many programming tips\nderived from our own experiences that can be helpful in contest situations. We start this\nbook by giving you several general tips below:\n1.3.1\nTip 1: Type Code Faster!\nNo kidding! Although this tip may not mean much as ICPC and (especially) IOI are not\ntyping contests, we have seen Rank i and Rank i + 1 ICPC teams separated only by a few\nminutes14 and frustrated IOI contestants who miss out on salvaging important marks by not\nbeing able to code a last-minute brute force solution properly. When you can solve the same\nnumber of problems as your competitor, it will then be coding skill (your ability to produce\nconcise and robust code) and ... typing speed ... that determine the winner.", "mimetype": "text/plain", "start_char_idx": 82855, "end_char_idx": 87128, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5bd5f64b-f497-4484-a8b8-e67275bba34b": {"__data__": {"id_": "5bd5f64b-f497-4484-a8b8-e67275bba34b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3a11a3ed-ea2d-4d2b-bed1-4c2ce792ecb9", "node_type": "1", "metadata": {}, "hash": "2038bfdb3f97d4ebf25f1c4d9016a2ca83f49cf7db1cc51480a92a86a67190f7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "23ea8d9e-0d14-46e5-9278-42d342ee811f", "node_type": "1", "metadata": {}, "hash": "6102d06d9c46fda7191ea3f5520a34bc3c70b7bfd2c7c960b6b4870e51682dd3", "class_name": "RelatedNodeInfo"}}, "text": "On top of that, you will also learn many programming tips\nderived from our own experiences that can be helpful in contest situations. We start this\nbook by giving you several general tips below:\n1.3.1\nTip 1: Type Code Faster!\nNo kidding! Although this tip may not mean much as ICPC and (especially) IOI are not\ntyping contests, we have seen Rank i and Rank i + 1 ICPC teams separated only by a few\nminutes14 and frustrated IOI contestants who miss out on salvaging important marks by not\nbeing able to code a last-minute brute force solution properly. When you can solve the same\nnumber of problems as your competitor, it will then be coding skill (your ability to produce\nconcise and robust code) and ... typing speed ... that determine the winner.\nTry this typing test at https://www.typingtest.com and follow the instructions there\non how to improve your typing skill. Steven\u2019s is \u21e085-95 wpm15, Felix\u2019s is \u21e055-65 wpm, and\nSuhendry\u2019s is \u21e070-80 wpm. If your typing speed is much less than these numbers, please\ntake this tip seriously!\nOn top of being able to type alphanumeric characters quickly and correctly, you will\nalso need to familiarize your \ufb01ngers with the positions of the frequently used programming\nlanguage characters: round () or curly {} or square [] or angle <> parentheses/brackets,\nthe semicolon ; and colon :, single quotes \u2018\u2019 for characters, double quotes \u201c\u201d for strings, the\nampersand &, the vertical bar or the \u2018pipe\u2019 |, the exclamation mark !, etc.\n12Notice that in a (large) competition, there can only be one (or very few) winner(s), i.e., the probability\nof not winning anything throughout your programming competition life is much higher than the opposite.\nThus, although you should still dream high and try to win at least one programming competition, you should\nultimately aim to better your programming and problem solving skills by reading books like this one.\n13Whether you perceive the material presented in this book to be of easy, intermediate, or advanced level\ndepends on your programming, algorithmic, and problem solving skills prior to reading this book.\n14Fast performance at the early stage of an ICPC is very bene\ufb01cial. As an illustration, team A and team\nB both solve a total of 8 problems. Team A gets its \ufb01rst AC only 5 minutes earlier than team B. They then\nsolve the next 7 problems at exactly the same speed. Team A wins by having 8 \u21e55 = 40 minutes lesser total\npenalty time.\n15A few of the authors\u2019 ICPC World Finalist students have typing speed faster than 120+ wpm. Note\nthat the average typing speed globally is just \u21e140 wpm.\n6\n\nCHAPTER 1.", "mimetype": "text/plain", "start_char_idx": 86379, "end_char_idx": 88973, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "23ea8d9e-0d14-46e5-9278-42d342ee811f": {"__data__": {"id_": "23ea8d9e-0d14-46e5-9278-42d342ee811f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5bd5f64b-f497-4484-a8b8-e67275bba34b", "node_type": "1", "metadata": {}, "hash": "1b688f8ef0a67f1625804c5ae11c3ccbc0a90a578f1a78d00cc94fb0835ff7d7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d7581205-66b6-4b56-a1ef-264ea7fa50d9", "node_type": "1", "metadata": {}, "hash": "f7ddb125c79cd82c57285a05d96ec5536ae4c654c3556b5a72a9d2a56480af00", "class_name": "RelatedNodeInfo"}}, "text": "13Whether you perceive the material presented in this book to be of easy, intermediate, or advanced level\ndepends on your programming, algorithmic, and problem solving skills prior to reading this book.\n14Fast performance at the early stage of an ICPC is very bene\ufb01cial. As an illustration, team A and team\nB both solve a total of 8 problems. Team A gets its \ufb01rst AC only 5 minutes earlier than team B. They then\nsolve the next 7 problems at exactly the same speed. Team A wins by having 8 \u21e55 = 40 minutes lesser total\npenalty time.\n15A few of the authors\u2019 ICPC World Finalist students have typing speed faster than 120+ wpm. Note\nthat the average typing speed globally is just \u21e140 wpm.\n6\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nAs a little practice, try typing the C++ source code below as fast as possible16:\n/*\nForming Quiz Teams, the solution for UVa 10911 above\n*/\n#include <bits/stdc++.h>\n// include all libraries\nusing namespace std;\n#define LSOne(S) ((S) & -(S))\n// important speedup\nint N;\n// max N = 8\ndouble dist[20][20], memo[1<<16];\n// 1<<16 = 2^16\ndouble dp(int mask) {\n// DP state = mask\ndouble &ans = memo[mask];\n// reference/alias\nif (ans > -0.5) return ans;\n// this has been computed\nif (mask == 0) return 0;\n// all have been matched\nans = 1e9;\n// init with a large value\nint two_pow_p1 = LSOne(mask);\n// speedup\nint p1 = __builtin_ctz(two_pow_p1);\n// p1 is first on bit\nint m = mask-two_pow_p1;\n// turn off bit p1\nwhile (m) {\nint two_pow_p2 = LSOne(m);\n// then, try to match p1\nint p2 = __builtin_ctz(two_pow_p2);\n// with another on bit p2\nans = min(ans, dist[p1][p2] + dp(mask^two_pow_p1^two_pow_p2));\nm -= two_pow_p2;\n// turn off bit p2\n}\nreturn ans;\n// memo[mask] == ans\n}\nint main() {\nint caseNo = 0, x[20], y[20];\nwhile (scanf(\"%d\", &N), N) {\n// yes, we can do this :)\nfor (int i = 0; i < 2*N; ++i)\nscanf(\"%*s %d %d\", &x[i], &y[i]);\n// \u2018%*s\u2019 skips names\nfor (int i = 0; i < 2*N-1; ++i)\n// build distance table\nfor (int j = i+1; j < 2*N; ++j)\n// use \u2018hypot\u2019 function\ndist[i][j] = dist[j][i] = hypot(x[i]-x[j], y[i]-y[j]);\nfor (int i = 0; i < (1<<16); ++i) memo[i] = -1.0;\nprintf(\"Case %d: %.2lf\\n\", ++caseNo, dp((1<<(2*N)) - 1));\n}\nreturn 0;\n} // DP to solve min weighted perfect matching on small general graph\nSource code: ch8/UVa10911.cpp|java|py|ml\nFor your reference, the explanations of this \u2018Dynamic Programming with bitmask\u2019 solution\nare gradually given in Section 2.2, 3.5, and later in Book 2. Do not be alarmed if you do not\nunderstand it yet.\n16Notice that the typical Competitive Programming coding style actually violates many good Software\nEngineering principles, e.g., over usage of global variables, usage of cryptic and incredibly short variable\nnames, inclusion of all available header \ufb01les, over usage of bit manipulation, using namespace std, etc.\n7\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n1.3.2\nTip 2: Quickly Identify Problem Types\nIn recent ICPCs, the contestants (teams) are given a set of problems (\u21e110-13 problems)\nof varying types. From our observation of recent ICPC Asia Regionals and World Finals\nproblem sets, we can categorize the problems types and their rate of appearance as in Table\n1.1.", "mimetype": "text/plain", "start_char_idx": 88273, "end_char_idx": 91446, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d7581205-66b6-4b56-a1ef-264ea7fa50d9": {"__data__": {"id_": "d7581205-66b6-4b56-a1ef-264ea7fa50d9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "23ea8d9e-0d14-46e5-9278-42d342ee811f", "node_type": "1", "metadata": {}, "hash": "6102d06d9c46fda7191ea3f5520a34bc3c70b7bfd2c7c960b6b4870e51682dd3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cb3cf225-a62c-455e-b776-73000c34bd29", "node_type": "1", "metadata": {}, "hash": "422c660c5ddeff5cc81118a0eca4d8b4277fe6fffbfaf338a7724acd87c6bfef", "class_name": "RelatedNodeInfo"}}, "text": "Do not be alarmed if you do not\nunderstand it yet.\n16Notice that the typical Competitive Programming coding style actually violates many good Software\nEngineering principles, e.g., over usage of global variables, usage of cryptic and incredibly short variable\nnames, inclusion of all available header \ufb01les, over usage of bit manipulation, using namespace std, etc.\n7\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n1.3.2\nTip 2: Quickly Identify Problem Types\nIn recent ICPCs, the contestants (teams) are given a set of problems (\u21e110-13 problems)\nof varying types. From our observation of recent ICPC Asia Regionals and World Finals\nproblem sets, we can categorize the problems types and their rate of appearance as in Table\n1.1. In IOIs, the contestants are given 6 tasks over 2 days17 that cover items 1-7 and a bit\nof item 11, with a much smaller subset of items 8-11. For more details, please refer to the\nIOI 1989-2008 problem classi\ufb01cation [58] and the latest IOI syllabus [16].\nNo\nCategory\nIn This Book\nFrequency\n1.\nAd Hoc\nSection 1.4-1.6\n1-2\n2.\n(Heavy) Data Structure\nChapter 2\n0-1\n3.\nComplete Search (Iterative/Recursive)\nSection 3.2++\n1-2\n4.\nDivide and Conquer\nSection 3.3\n0-1\n5.\nGreedy (the non-classic ones)\nSection 3.4\n1\n6.\nDynamic Programming (the non-classic ones)\nSection 3.5++\n1-2\n7.\nGraph (except Network Flow/Graph Matching)\nChapter 4\n1\n8.\nMathematics\nChapter 5\n1-2\n9.\nString Processing\nChapter 6\n1\n10.\nComputational Geometry\nChapter 7\n1\n11.\nSome Harder/Rare/Emerging Trend Problems\nChapter 8-9\n2-3\nTotal in Set is usually \uf8ff14\n10-17\nTable 1.1: Recent ICPC (Asia) Regionals Problem Types\nThe classi\ufb01cation in Table 1.1 is adapted from [43] and by no means complete. Some tech-\nniques, e.g., \u2018sorting\u2019, are not classi\ufb01ed here as they are \u2018trivial\u2019 and usually used only as\na \u2018sub-routine\u2019 in a bigger problem. We do not include \u2018recursion\u2019 as it is embedded in\ncategories like recursive backtracking or Dynamic Programming. Of course, problems some-\ntimes require mixed techniques: a problem can be classi\ufb01ed into more than one type, e.g.,\nFloyd-Warshall algorithm is both a solution for the All-Pairs Shortest Paths (APSP, Section\n4.5) graph problem and a Dynamic Programming (DP) algorithm (Section 3.5). Prim\u2019s and\nKruskal\u2019s algorithms are both solutions for the Minimum Spanning Tree (MST, Section 4.3)\ngraph problem and Greedy algorithms (Section 3.4). In Book 2, we will discuss (harder)\nproblems that require more than one algorithm and/or data structure to be solved.\nIn the (near) future, these classi\ufb01cations may change. One signi\ufb01cant example is Dynamic\nProgramming. This technique was not known before 1940s, nor frequently used in IOIs or\nICPCs before mid-1990s, but it is considered a de\ufb01nite prerequisite today. As an illustration:\nThere were \u22653 DP problems (out of 11) in ICPC World Finals 2010.\nHowever, the main goal is not just to associate problems with the techniques required to\nsolve them like in Table 1.1. Once you are familiar with most of the topics in this book, you\nshould also be able to classify problems into the four types in Table 1.2.\nNo\nCategory\nCon\ufb01dence and Expected Solving Speed\nA1.\nI have solved this type before\nI am sure that I can re-solve it again (and fast)\nA2.", "mimetype": "text/plain", "start_char_idx": 90711, "end_char_idx": 93941, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cb3cf225-a62c-455e-b776-73000c34bd29": {"__data__": {"id_": "cb3cf225-a62c-455e-b776-73000c34bd29", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d7581205-66b6-4b56-a1ef-264ea7fa50d9", "node_type": "1", "metadata": {}, "hash": "f7ddb125c79cd82c57285a05d96ec5536ae4c654c3556b5a72a9d2a56480af00", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "272dcb3b-a3f1-4bcb-b1fe-1fd5f850e885", "node_type": "1", "metadata": {}, "hash": "adc2c5f0619039de03a604c8bde039f18ebfd7a7d5a035ec8f70b18c30a6f7bb", "class_name": "RelatedNodeInfo"}}, "text": "One signi\ufb01cant example is Dynamic\nProgramming. This technique was not known before 1940s, nor frequently used in IOIs or\nICPCs before mid-1990s, but it is considered a de\ufb01nite prerequisite today. As an illustration:\nThere were \u22653 DP problems (out of 11) in ICPC World Finals 2010.\nHowever, the main goal is not just to associate problems with the techniques required to\nsolve them like in Table 1.1. Once you are familiar with most of the topics in this book, you\nshould also be able to classify problems into the four types in Table 1.2.\nNo\nCategory\nCon\ufb01dence and Expected Solving Speed\nA1.\nI have solved this type before\nI am sure that I can re-solve it again (and fast)\nA2.\nI have solved this type before\nI am sure that I can re-solve it again (but slow)\nB.\nI have seen this type before\nBut that time I know that I cannot solve it yet\nC.\nI have not seen this type before\nSee the discussion below\nTable 1.2: Problem Types (Compact Form)\n17In year 2009-2010, IOI had 8 tasks over 2 days with at least 1 (very) easy task per day. However, this\nformat is no longer continued in favor of eas(ier) subtask 1 of all tasks.\n8\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nTo be competitive, that is, do well in a programming contest, you must be able to con\ufb01dently\nand frequently classify problems as type A1 and minimize the number of problems that you\nclassify into type A2 or B. That is, you need to acquire su\ufb03cient algorithm knowledge and\ndevelop your programming skills so that you consider many classical problems to be easy \u2013\nespecially at the start of the contest.\nHowever, to win a programming contest, you will also need to develop sharp problem\nsolving skills so that you (or your team) will be able to derive the required solution to a\nhard/original type C problem in IOI or ICPC and do so within the duration of the contest,\nnot after the solution(s) is/are revealed by the problem author(s)/contest judge(s). Some of\nthe necessary problem solving skills are:\n\u2022 Reducing the given problem into another (easier) problem,\n\u2022 Reducing a known (NP-)hard problem into the given problem,\n\u2022 Identifying subtle hints or special properties in the problem,\n\u2022 Attacking the problem from a non-obvious angle/asking a di\u21b5erent question,\n\u2022 Compressing the input data,\n\u2022 Reworking mathematical formulas,\n\u2022 Listing observations/patterns,\n\u2022 Performing case analysis of possible subcases of the problem, etc.\nUVa/Kattis\nTitle\nProblem Type\nHint\nwordcloud\nWord Cloud\nSection 1.6\nturbo\nTurbo\nSection 2.4\n10360\nRat Attack\nComplete Search or DP\nSection 3.2\nhindex\nH-Index\nSection 3.3\n11292\nDragon of Loowater\nSection 3.4\n11450\nWedding Shopping\nSection 3.5\n11512\nGATTACA\nBook 2\n10065\nUseless Tile Packers\nBook 2\n11506\nAngry Programmer\nBook 2\nbilateral\nBilateral Projects\nBook 2\ncarpool\nCarpool\nBook 2\nTable 1.3: Exercise: Read and Classify These UVa/Kattis Problems\nExercise 1.3.2.1: Read the UVa [44] and Kattis [34] problems in Table 1.3 and determine\ntheir problem types. One of them has been identi\ufb01ed for you. Filling this table should be\neasy after mastering this book as all the techniques required to solve these problems are\ndiscussed in this book.\nExercise 1.3.2.2*: Using the same list of problems shown in Table 1.3 above, please provide\nthe abridged versions of those problems in at most three sentences, omitting the irrelevant\ndetails/storyline, but preserving the key points of the problems in such a way that another\ncompetitive programmer who does not read the original problem descriptions can still write\ncorrect solutions for those problems. See the \ufb01rst page of this book for an example!\n9\n\n1.3.", "mimetype": "text/plain", "start_char_idx": 93265, "end_char_idx": 96871, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "272dcb3b-a3f1-4bcb-b1fe-1fd5f850e885": {"__data__": {"id_": "272dcb3b-a3f1-4bcb-b1fe-1fd5f850e885", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cb3cf225-a62c-455e-b776-73000c34bd29", "node_type": "1", "metadata": {}, "hash": "422c660c5ddeff5cc81118a0eca4d8b4277fe6fffbfaf338a7724acd87c6bfef", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2644c642-bfaa-4c2e-81ec-4dcca17be037", "node_type": "1", "metadata": {}, "hash": "d51e9e721b1715dc3d3c844205771ba0d91b166d83dbee607634aafb78232f97", "class_name": "RelatedNodeInfo"}}, "text": "One of them has been identi\ufb01ed for you. Filling this table should be\neasy after mastering this book as all the techniques required to solve these problems are\ndiscussed in this book.\nExercise 1.3.2.2*: Using the same list of problems shown in Table 1.3 above, please provide\nthe abridged versions of those problems in at most three sentences, omitting the irrelevant\ndetails/storyline, but preserving the key points of the problems in such a way that another\ncompetitive programmer who does not read the original problem descriptions can still write\ncorrect solutions for those problems. See the \ufb01rst page of this book for an example!\n9\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n1.3.3\nTip 3: Do Algorithm Analysis\nOnce you have designed an algorithm to solve a particular problem in a programming contest,\nyou must then ask this question: Given the maximum input bound (usually given in a good\nproblem description), can the currently developed algorithm, with its time/space complexity,\npass the time/memory limit given for that particular problem?\nSometimes, there is more than one way to attack a problem. Some approaches may be\nincorrect, others not fast enough, and yet others \u2018overkill\u2019. A good strategy is to brainstorm\nfor many possible algorithms and then pick the simplest solution that works (i.e., is fast\nenough to pass the time and memory limit and yet still produce the correct answer)18!\nModern computers are quite fast and can process19 up to \u21e1100M (or 108; 1M =\n1 000 000) operations in one second.\nYou can use this information to determine if your\nalgorithm will run in time. For example, if the maximum input size n is 100K (or 105;\n1K = 1000), and your current algorithm has a time complexity of O(n2), common sense (or\nyour calculator) will inform you that (100K)2 or 1010 is a very large number that indicates\nthat your algorithm will require (on the order of) hundreds of seconds to run. You will thus\nneed to devise a faster (and also correct) algorithm to solve the problem. Suppose you then\n\ufb01nd one that runs with a time complexity of O(n log2 n). Now, your calculator will inform\nyou that 105 log2 105 is just 1.7 \u21e5106 and common sense dictates that the algorithm (which\nshould now run in under a second) will likely be able to pass the time limit.\nThe problem bounds are as important20 as your algorithm\u2019s time complexity in determin-\ning if your solution is appropriate. Suppose that you can only devise a relatively-simple-to-\ncode algorithm that runs with a horrendous time complexity of O(n4). This may appear to\nbe an infeasible solution, but if n \uf8ff50, then you have actually solved the problem. You can\nimplement your O(n4) algorithm with impunity since 504 is just 6.25M and your algorithm\nshould still run in around a second.\nNote, however, that the order of complexity does not necessarily indicate the actual num-\nber of operations that your algorithm will require. If each iteration involves a large number of\noperations (many \ufb02oating point calculations, or a signi\ufb01cant number of constant sub-loops),\nor if your implementation has a high \u2018constant\u2019 in its execution (unnecessary repeated loops,\nmultiple passes of the data set, or even Input/Output (I/O) execution overhead), your code\nmay take longer to execute than expected. However, this is usually not a big issue as the\nproblem authors should have designed the time limits so that a few (more than one) rea-\nsonable implementations of the algorithm with the intended target time complexity will all\nachieve the Accepted (AC) verdict.\nBy analyzing the complexity of your algorithm with the given input bound and the stated\ntime/memory limit, you can better decide whether you should attempt to implement your\nalgorithm (which will take up precious time in the IOIs and ICPCs), attempt to improve\nyour algorithm \ufb01rst, or switch to other problems in the problem set.\nAs mentioned in the preface of this book, we will not discuss the concept of algorithmic\nanalysis in details. We assume that you already have this basic skill. There are a multitude\nof other reference books (for example, the \u201cIntroduction to Algorithms\u201d [5], \u201cAlgorithm De-\nsign\u201d [35], \u201cAlgorithms\u201d [6], etc) that will help you to understand the following prerequisite\nconcepts/techniques in algorithmic analysis:\n18Discussion: It is true that in programming contests, picking the simplest algorithm that works is crucial.", "mimetype": "text/plain", "start_char_idx": 96229, "end_char_idx": 100624, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2644c642-bfaa-4c2e-81ec-4dcca17be037": {"__data__": {"id_": "2644c642-bfaa-4c2e-81ec-4dcca17be037", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "272dcb3b-a3f1-4bcb-b1fe-1fd5f850e885", "node_type": "1", "metadata": {}, "hash": "adc2c5f0619039de03a604c8bde039f18ebfd7a7d5a035ec8f70b18c30a6f7bb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ec9d5d5d-8344-4ec1-84a6-b6b4ea800749", "node_type": "1", "metadata": {}, "hash": "c2e2dc4ea6954a2a2a85a976883ebf2826b54615d8a1039096011a26f438e6ae", "class_name": "RelatedNodeInfo"}}, "text": "By analyzing the complexity of your algorithm with the given input bound and the stated\ntime/memory limit, you can better decide whether you should attempt to implement your\nalgorithm (which will take up precious time in the IOIs and ICPCs), attempt to improve\nyour algorithm \ufb01rst, or switch to other problems in the problem set.\nAs mentioned in the preface of this book, we will not discuss the concept of algorithmic\nanalysis in details. We assume that you already have this basic skill. There are a multitude\nof other reference books (for example, the \u201cIntroduction to Algorithms\u201d [5], \u201cAlgorithm De-\nsign\u201d [35], \u201cAlgorithms\u201d [6], etc) that will help you to understand the following prerequisite\nconcepts/techniques in algorithmic analysis:\n18Discussion: It is true that in programming contests, picking the simplest algorithm that works is crucial.\nHowever, during training sessions without time constraint, it can be bene\ufb01cial to spend more time trying\nto solve a certain problem using the best possible algorithm. If we encounter a harder version of the problem\nin the future, we will have a greater chance of obtaining and implementing the correct solution!\n19Treat this as a rule of thumb. These numbers may vary from machine to machine and likely increases\n(a bit) over time. A competitive programmer will test these numbers during practice session.\n20If you are a problem author who read this book, please pay attention to bounds!\n10\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n\u2022 Basic time and space complexity analysis for iterative and recursive algorithms:\n\u2013 An algorithm with k-nested loops of about n iterations each has O(nk) complexity.\n\u2013 If your algorithm is recursive with b recursive calls per level and has L levels, the\nalgorithm has roughly O(bL) complexity, but this is a only a rough upper bound.\nThe actual complexity depends on what actions are done per level and whether\npruning is possible.\n\u2013 A Dynamic Programming algorithm or other iterative routine which processes a\n2D n \u21e5n matrix in O(k) per cell runs in O(k \u21e5n2) time. This is explained in\nfurther detail in Section 3.5.\n\u2013 Binary searching over a range of [1..n] has O(log n) complexity.\n\u2022 More advanced algorithm analysis techniques:\n\u2013 Prove the correctness of an algorithm (especially for Greedy algorithms in Section\n3.4), to minimize your chance of getting the \u2018Wrong Answer\u2019 verdict.\n\u2013 Perform the amortized analysis (e.g., see Chapter 17 of [5])\u2014although rarely\nused in contests\u2014to minimize your chance of getting the \u2018Time Limit Exceeded\u2019\nverdict, or worse, considering your algorithm to be too slow and skipping the\nproblem when it is in fact fast enough in amortized sense.\n\u2013 Do output-sensitive analysis to analyze algorithm which (also) depends on output\nsize and minimize your chance of getting the \u2018Time Limit Exceeded\u2019 verdict. For\nexample, the time complexity of partial sort algorithm is O(n log k). The time\ntaken for this algorithm to run depends not only on the input size n but also the\noutput size\u2014the required k smallest (or largest) numbers to be sorted (see more\ndetails in Section 2.3.1).\n\u2022 Familiarity with these bounds:\n\u2013 210 = 1024 \u21e1103, 220 = 1 048 576 \u21e1106.\n\u2013 10! = 3 628 800 \u21e13 \u21e4106, 11! = 39 916 800 \u21e14 \u21e4107.\n\u2013 32-bit signed integers (int) and 64-bit signed integers (long long) have upper\nlimits of 231\u22121 \u21e12\u21e5109 (safe for up to \u21e19 decimal digits) and 263\u22121 \u21e19\u21e51018\n(safe for up to \u21e118 decimal digits), respectively.\n\u2013 Unsigned integers can be used if only non-negative numbers are required. 32-bit\nunsigned integers (unsigned int) and 64-bit unsigned integers (unsigned long\nlong) have upper limits of 232 \u22121 \u21e14 \u21e5109 and 264 \u22121 \u21e11 \u21e51019, respectively.\n\u2013 If you need to store integers \u2265264, use Big Integer21 (see Section 2.2.4).\n\u2013 There are n! permutations and 2n subsets (or combinations) of n distinct elements.\n\u2013 The best time complexity of a comparison-based sorting algorithm is \u2326(n log2 n).\n\u2013 The largest input size n for typical programming contest problems must be < 1M.\nBeyond that, the Input/Output (I/O) routine will be the bottleneck.", "mimetype": "text/plain", "start_char_idx": 99772, "end_char_idx": 103844, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ec9d5d5d-8344-4ec1-84a6-b6b4ea800749": {"__data__": {"id_": "ec9d5d5d-8344-4ec1-84a6-b6b4ea800749", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2644c642-bfaa-4c2e-81ec-4dcca17be037", "node_type": "1", "metadata": {}, "hash": "d51e9e721b1715dc3d3c844205771ba0d91b166d83dbee607634aafb78232f97", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7128023b-576e-4ec1-8821-d9181e48fc0c", "node_type": "1", "metadata": {}, "hash": "d87c11608f0cc885fdf6f1a21e64afa88a3198854ce4c756448e5145bb9b4c82", "class_name": "RelatedNodeInfo"}}, "text": "\u2013 Unsigned integers can be used if only non-negative numbers are required. 32-bit\nunsigned integers (unsigned int) and 64-bit unsigned integers (unsigned long\nlong) have upper limits of 232 \u22121 \u21e14 \u21e5109 and 264 \u22121 \u21e11 \u21e51019, respectively.\n\u2013 If you need to store integers \u2265264, use Big Integer21 (see Section 2.2.4).\n\u2013 There are n! permutations and 2n subsets (or combinations) of n distinct elements.\n\u2013 The best time complexity of a comparison-based sorting algorithm is \u2326(n log2 n).\n\u2013 The largest input size n for typical programming contest problems must be < 1M.\nBeyond that, the Input/Output (I/O) routine will be the bottleneck.\n\u2013 Usually, O(n log2 n) algorithms are su\ufb03cient to solve most contest problems for a\nsimple reason: O(n log2 n) and the theoretically better O(n) algorithms are hard\nto di\u21b5erentiate empirically under programming contest environment with strict\ntime limit, n < 1M, and the need to support > 1 programming languages.\n21gcc has built-in type\nint128 but this data type is rarely useful in competitive programming setting.\n11\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\nMany novice programmers would skip this phase and immediately implement the \ufb01rst (na\u00a8\u0131ve)\nalgorithm that they can think of only to realize that the chosen data structure and/or\nalgorithm is/are not e\ufb03cient enough (or wrong). Our advice for ICPC contestants22: refrain\nfrom coding until you are sure that your algorithm is both correct and fast enough.\nTo help you understand the growth of several common time complexities, and thus help\nyou judge how fast is \u2018enough\u2019, please refer to Table 1.4. Variants of such tables are also\nfound in many other books on data structures and algorithms. This table is written from\na programming contestant\u2019s perspective. Usually, the input size constraints are given in a\n(good) problem description. With the assumption that a typical year 2020 CPU can execute\na hundred million (108) operations in around 1 second23 (the typical time limit in most\nUVa/Kattis problems [44, 34]), we can predict the \u2018worst\u2019 algorithm that can still pass the\ntime limit24. Usually, the simplest algorithm has the poorest time complexity, but if it can\nalready pass the time limit, just use it!\nn\nWorst AC Algorithm\nComment\n\uf8ff[10..11]\nO(n!), O(n6)\ne.g., Enumerating permutations (Section 3.2)\n\uf8ff[17..19]\nO(2n \u21e5n2)\ne.g., DP TSP (Section 3.5.2)\n\uf8ff[18..22]\nO(2n \u21e5n)\ne.g., DP with bitmask technique (Book 2)\n\uf8ff[24..26]\nO(2n)\ne.g., try 2n possibilities with O(1) check each\n\uf8ff100\nO(n4)\ne.g., DP with 3 dimensions + O(n) loop, nCk=4\n\uf8ff450\nO(n3)\ne.g., Floyd-Warshall (Section 4.5)\n\uf8ff1.5K\nO(n2.5)\ne.g., Hopcroft-Karp (Book 2)\n\uf8ff2.5K\nO(n2 log n)\ne.g., 2-nested loops + a tree-related DS (Section 2.3)\n\uf8ff10K\nO(n2)\ne.g., Bubble/Selection/Insertion Sort (Section 2.2)\n\uf8ff200K\nO(n1.5)\ne.g., Square Root Decomposition (Book 2)\n\uf8ff4.5M\nO(n log n)\ne.g., Merge Sort (Section 2.2)\n\uf8ff10M\nO(n log log n)\ne.g., Sieve of Eratosthenes (Book 2)\n\uf8ff100M\nO(n), O(log n), O(1)\nMost contest problem have n \uf8ff1M (I/O bottleneck)\nTable 1.4: Rule of Thumb for the \u2018Worst AC Algorithm\u2019 for various single-test-case input\nsizes n, assuming that a year 2020 CPU can compute 100M operations in 1 second.\nFrom Table 1.4, we see the importance of using good algorithms with small orders of growth\nas they allow us to solve problems with larger input sizes25.", "mimetype": "text/plain", "start_char_idx": 103214, "end_char_idx": 106541, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7128023b-576e-4ec1-8821-d9181e48fc0c": {"__data__": {"id_": "7128023b-576e-4ec1-8821-d9181e48fc0c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ec9d5d5d-8344-4ec1-84a6-b6b4ea800749", "node_type": "1", "metadata": {}, "hash": "c2e2dc4ea6954a2a2a85a976883ebf2826b54615d8a1039096011a26f438e6ae", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f7829b03-f6e8-4e87-aa6b-3a7d12b7d21e", "node_type": "1", "metadata": {}, "hash": "c221042f0a966bb3e5e96a4eaa185073ea6c4b7f3863dc5731cfd62bba98a90f", "class_name": "RelatedNodeInfo"}}, "text": "From Table 1.4, we see the importance of using good algorithms with small orders of growth\nas they allow us to solve problems with larger input sizes25. But a faster algorithm is usually\nnon-trivial and sometimes substantially harder to implement. In Section 3.2.3, we discuss a\nfew tips that may allow the same class of algorithms to be used with larger input sizes. In\nsubsequent chapters, we also explain e\ufb03cient algorithms for various computing problems.\n22Unlike ICPC, the IOI tasks can usually be solved (partially or fully) using several possible solutions,\neach with di\u21b5erent time complexities and subtask scores. To gain valuable points, it may be good to initialy\nuse a brute force solution to score a few points especially if it is easy/short to code and to understand the\nproblem better. There will be no signi\ufb01cant time penalty as IOI is not a speed contest. Then, iteratively\nimprove the solution to gain more points.\n23In CP3, the previous assumption was 108 operations in 3s. Notice that CPU speed does not double\nevery one/two year(s) recently and Competitive Programming has not venture into multi-threading yet.\n24Try problem Kattis - tutorial *.\n25It will be hard for the programming contest judges to di\u21b5erentiate fast or slow solutions automatically\nwhen the highly variable I/O speed heavily in\ufb02uences the overall runtime speed measurements and hence\nthey will not set insanely large test cases (typically, n \uf8ff1M).\n12\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nExercise 1.3.3.1: Please answer the questions below using your current knowledge about\nclassic algorithms and their time complexities. After you have \ufb01nished reading this book\nonce, it may be bene\ufb01cial to attempt this exercise again.\n1. There are n webpages (1 \uf8ffn \uf8ff10M). Page i has a page rank ri. A new page can\nbe added or an existing page can be removed frequently. You want to pick the current\ntop 10 pages with the highest page ranks, in order. Which method is better?\n(a) Load all n webpages\u2019 page rank to memory, sort (Section 2.2) them in descending\npage rank order, and obtain the current top 10.\n(b) Use a Priority Queue data structure (Section 2.3).\n(c) Use the QuickSelect algorithm (Section 2.3.4).\n2. Given a list L with 100K integers, you need to frequently obtain sum(i, j), i.e., the\nsum of L[i] + L[i+1] + ...+ L[j]. Which data structure should you use?\n(a) Simple Array pre-processed with Dynamic Programming (Section 2.2 & 3.5).\n(b) Balanced Binary Search Tree (Section 2.3).\n(c) Segment Tree (Section 2.4.4).\n(d) Fenwick (Binary Indexed) Tree (Section 2.4.3).\n(e) Su\ufb03x Tree or its alternative, Su\ufb03x Array (Book 2).\n3. Given an M \u21e5N integer matrix Q (1 \uf8ffM, N \uf8ff70), determine if there exists a sub-\nmatrix S of Q of size A \u21e5B (1 \uf8ffA \uf8ffM, 1 \uf8ffB \uf8ffN) where mean(S) = 7. Which\nalgorithm will not exceed 100M operations per test case in the worst case?\n(a) Try all possible sub-matrices and check if the mean of each sub-matrix is 7.\nThis algorithm runs in O(M 3 \u21e5N 3).\n(b) Try all possible sub-matrices, but in O(M 2 \u21e5N 2) with this technique:\n.\n4. Given a multiset S of M = 100K integers, we want to know how many di\u21b5erent\nintegers that we can form if we pick two (not necessarily distinct) integers from S and\nsum them. The content of multiset S is prime numbers not more than 20K. Which\nalgorithm will not exceed 100M operations per test case in the worst case?\n(a) Try all possible O(M 2) pairs of integers and insert their sums into a hash table\n(O(1) per insertion). Finally, report the \ufb01nal size of the hash table.\n(b) Perform an algorithm as above, but after performing this technique:\n.\n5.", "mimetype": "text/plain", "start_char_idx": 106389, "end_char_idx": 109991, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f7829b03-f6e8-4e87-aa6b-3a7d12b7d21e": {"__data__": {"id_": "f7829b03-f6e8-4e87-aa6b-3a7d12b7d21e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7128023b-576e-4ec1-8821-d9181e48fc0c", "node_type": "1", "metadata": {}, "hash": "d87c11608f0cc885fdf6f1a21e64afa88a3198854ce4c756448e5145bb9b4c82", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5af3a4f7-6e9b-4156-bdf7-33156cdbf1b5", "node_type": "1", "metadata": {}, "hash": "8990648f4e75080dbc406b479cb0d7485d9d05f7936b038fe436cef96c550aae", "class_name": "RelatedNodeInfo"}}, "text": "This algorithm runs in O(M 3 \u21e5N 3).\n(b) Try all possible sub-matrices, but in O(M 2 \u21e5N 2) with this technique:\n.\n4. Given a multiset S of M = 100K integers, we want to know how many di\u21b5erent\nintegers that we can form if we pick two (not necessarily distinct) integers from S and\nsum them. The content of multiset S is prime numbers not more than 20K. Which\nalgorithm will not exceed 100M operations per test case in the worst case?\n(a) Try all possible O(M 2) pairs of integers and insert their sums into a hash table\n(O(1) per insertion). Finally, report the \ufb01nal size of the hash table.\n(b) Perform an algorithm as above, but after performing this technique:\n.\n5. You have to compute the shortest path between two vertices on a weighted Directed\nAcyclic Graph (DAG) with |V |, |E| \uf8ff100K. Which algorithm(s) can be used?\n(a) Dynamic Programming (Section 3.5, 4.2.6, & 4.6.1).\n(b) Breadth First Search (Section 4.2.3 & 4.4.2).\n(c) Dijkstra\u2019s (Section 4.4.3).\n(d) Bellman-Ford (Section 4.4.4).\n(e) Floyd-Warshall (Section 4.5).\n13\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n6. Which algorithm produces a list of the \ufb01rst 10M prime numbers with the best time\ncomplexity? (Book 2)\n(a) Sieve of Eratosthenes.\n(b) 8i 2 [1..10M], if isPrime(i) is true, add i in the list.\n7. How to test if the factorial of n, i.e., n! is divisible by an integer m? 1 \uf8ffn \uf8ff1014.\n(a) Test if n! % m == 0.\n(b) The na\u00a8\u0131ve approach above will not work, use:\n(Book 2).\n8. You want to enumerate all occurrences of a substring P (of length m) in a (long)\nstring T (of length n), if any.\nBoth n and m have a maximum of 1M characters.\nWhich algorithm is faster?\n(a) Use the following C++ code snippet:\nfor (int i = 0; i < n-m; ++i) {\nbool found = true;\nfor (int j = 0; (j < m) && found; ++j)\nif ((i+j >= n) || (P[j] != T[i+j]))\nfound = false;\nif (found)\nprintf(\"P is found at index %d in T\\n\", i);\n}\n(b) There are better algorithms, we can use:\n(Book 2).\n9. Given a set S of N points scattered on a 2D plane (2 \uf8ffN \uf8ff5 000), \ufb01nd two points\n2 S that have the greatest separating Euclidean distance. Is an O(N 2) complete search\nalgorithm that tries all possible pairs feasible?\n(a) Yes, such complete search is possible.\n(b) No, we must \ufb01nd another way. We must use:\n.\n10. See Question above, but now with a larger set of points: 2 \uf8ffN \uf8ff200K and one\nadditional constraint: The points are randomly scattered on a 2D plane.\n(a) The O(N 2) complete search can still be used.\n(b) The na\u00a8\u0131ve approach above will not work, use:\n(Book 2).\n11. See the same Question above. We still have a set of 2 \uf8ffN \uf8ff200K points. But this\ntime there is no guarantee that the points are randomly scattered on a 2D plane.\n(a) The O(n2) complete search can still be used.\n(b) The better solution using algorithm in Book 2 can still be used.\n(c) We need to use:\n14\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.3.4\nTip 4: Master Programming Languages\nThere are several programming languages supported in ICPC26, including C/C++, Java,\nand Python. Which programming languages should one aim to master?\nOur experience gives us this answer: we prefer C++ (std=gnu++17) with its built-in\nStandard Template Library (STL) but we still need to master Java and some knowledge\nof Python.", "mimetype": "text/plain", "start_char_idx": 109326, "end_char_idx": 112559, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5af3a4f7-6e9b-4156-bdf7-33156cdbf1b5": {"__data__": {"id_": "5af3a4f7-6e9b-4156-bdf7-33156cdbf1b5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f7829b03-f6e8-4e87-aa6b-3a7d12b7d21e", "node_type": "1", "metadata": {}, "hash": "c221042f0a966bb3e5e96a4eaa185073ea6c4b7f3863dc5731cfd62bba98a90f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2b246c2f-6e2d-49d3-89d8-8e5eb8475dbb", "node_type": "1", "metadata": {}, "hash": "a1737c0df86eafda2536bdb858dc06306e58ca7470a883c2347fb6a36a3e4aec", "class_name": "RelatedNodeInfo"}}, "text": "11. See the same Question above. We still have a set of 2 \uf8ffN \uf8ff200K points. But this\ntime there is no guarantee that the points are randomly scattered on a 2D plane.\n(a) The O(n2) complete search can still be used.\n(b) The better solution using algorithm in Book 2 can still be used.\n(c) We need to use:\n14\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.3.4\nTip 4: Master Programming Languages\nThere are several programming languages supported in ICPC26, including C/C++, Java,\nand Python. Which programming languages should one aim to master?\nOur experience gives us this answer: we prefer C++ (std=gnu++17) with its built-in\nStandard Template Library (STL) but we still need to master Java and some knowledge\nof Python. Even though it is slower, Java has powerful built-in libraries and APIs such as\nBigInteger/BigDecimal, GregorianCalendar, Regex, etc. Java programs are easier to debug\nwith the virtual machine\u2019s ability to provide a stack trace when it crashes (as opposed to\ncore dumps or segmentation faults in C/C++). Similarly, Python code can be surprisingly\nvery short for some suitable tasks.\nOn the other hand, C/C++ has its own merits as\nwell.\nDepending on the problem at hand, either language may be the better choice for\nimplementing a solution in the shortest time.\nSuppose that a problem requires you to compute 40! (the factorial of 40). The answer is\nvery large: 815 915 283 247 897 734 345 611 269 596 115 894 272 000 000 000. This far exceeds\nthe largest built-in primitive integer data type (unsigned long long: 264 \u22121). As there is\nno built-in arbitrary-precision arithmetic library in C/C++ as of yet, we would have needed\nto implement one from scratch. The Python code, however, is trivially short:\nimport math\nprint(math.factorial(40))\n# all built-in\nThe Java code for this task is also simple (more details in Section 2.2.4):\nimport java.util.Scanner;\nimport java.math.BigInteger;\nclass Main {\n// default class name\npublic static void main(String[] args) {\nBigInteger fac = BigInteger.ONE;\nfor (int i = 2; i <= 40; ++i)\nfac = fac.multiply(BigInteger.valueOf(i)); // it is in the library!\nSystem.out.println(fac);\n}\n}\nMastering and understanding the full capability of your favourite programming language is\nalso important. Take this problem with a non-standard input format: The \ufb01rst line of input\nis an integer N. This is followed by N lines, each starting with the character \u20180\u2019, followed\nby a dot \u2018.\u2019, then followed by an unknown number of target digits (up to 100 digits), and\n\ufb01nally terminated with three dots \u2018...\u2019. Your task is to extract these target digits.\n26[This is a personal opinion]. In IOI 2019 competition rules, the programming languages allowed in IOI\nare C++ and Java (two older programming languages: Pascal and C have been retired recently). The ICPC\nWorld Finals 2019 (and thus most Regionals) allows C, C++, Java, and Python (partially) to be used in the\ncontest. Therefore, it seems that the \u2018best\u2019 language to master as of year 2020 is still C++ (std=gnu++17)\nas it is supported in both competitions, a fast language, and has strong STL support. If IOI contestants\nchoose to master C++, they will have the bene\ufb01t of being able to use the same language (with an increased\nlevel of mastery) for ICPC in their University level pursuits. Note that OCaml is not currently used in the\nIOI or ICPC.\n15\n\n1.3.", "mimetype": "text/plain", "start_char_idx": 111833, "end_char_idx": 115192, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2b246c2f-6e2d-49d3-89d8-8e5eb8475dbb": {"__data__": {"id_": "2b246c2f-6e2d-49d3-89d8-8e5eb8475dbb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5af3a4f7-6e9b-4156-bdf7-33156cdbf1b5", "node_type": "1", "metadata": {}, "hash": "8990648f4e75080dbc406b479cb0d7485d9d05f7936b038fe436cef96c550aae", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ae652625-8732-4cdc-b7c9-7572925d2de7", "node_type": "1", "metadata": {}, "hash": "61dcbd3304bad3827bb6bc444a4a6b9e49f34c4e01fe6d3d01c5fbe5ddd89798", "class_name": "RelatedNodeInfo"}}, "text": "26[This is a personal opinion]. In IOI 2019 competition rules, the programming languages allowed in IOI\nare C++ and Java (two older programming languages: Pascal and C have been retired recently). The ICPC\nWorld Finals 2019 (and thus most Regionals) allows C, C++, Java, and Python (partially) to be used in the\ncontest. Therefore, it seems that the \u2018best\u2019 language to master as of year 2020 is still C++ (std=gnu++17)\nas it is supported in both competitions, a fast language, and has strong STL support. If IOI contestants\nchoose to master C++, they will have the bene\ufb01t of being able to use the same language (with an increased\nlevel of mastery) for ICPC in their University level pursuits. Note that OCaml is not currently used in the\nIOI or ICPC.\n15\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n3\n0.1227...\n0.517611738...\n0.7341231223444344389923899277...\nOne possible solution is as follows:\n#include <bits/stdc++.h>\n// include all\nusing namespace std;\nint main() {\nint N; scanf(\"%d\\n\", &N);\nwhile (N--) {\n// loop from N,N-1,...,0\nchar x[110];\n// set size a bit larger\nscanf(\"0.%[0-9]...\\n\", &x);\n// \u2018&\u2019 is optional here\n// note: if you are surprised with the technique above,\n// please check scanf details in https://en.cppreference.com/w/\nprintf(\"the digits are 0.%s\\n\", x);\n}\nreturn 0;\n}\nNot many C/C++ programmers are aware of partial regex capabilities built into the C\nstandard I/O library. Although scanf/printf are C-style I/O routines, they can still be\nused in C++ code. Many C++ programmers \u2018force\u2019 themselves to use cin/cout all the time\neven though it is sometimes not as \ufb02exible as scanf/printf and is also (far) slower27.\nOne more simple example. You are given a 2D matrix. Your job is to transpose the 2D\nmatrix and display the result. For example, Let 2D matrix A = [(1, 2, 3), (4, 5, 6)], i.e.,\na 2 \u21e53 matrix. For this input, we should output A0 = [(1, 4), (2, 5), (3, 6)], i.e., a 3 \u21e52\ntransposed matrix. If you are thinking of writing of a (2D nested for-) loop based solution,\nyou probably not aware of the following elegant Python solution:\nA = [(1, 2, 3), (4, 5, 6)]\n# list A = 2 tuples of 3\n[*zip(*A)]\n# [(1, 4), (2, 5), (3, 6)]\nIn programming contests, especially ICPCs, coding time should not be the primary bottle-\nneck. Once you \ufb01gure out the \u2018worst AC algorithm\u2019 that will pass the given time limit, you\nare expected to be able to translate it into a bug-free code quickly!\nSource code: ch1/factorial.py|java; ch1/scanf.cpp|ml; ch1/zip.py\nNow, try some of the exercises below! If you need more than 15 lines of code to solve any of\nthem (compare your answers with the modal solutions at Section 1.7), you should revisit and\nupdate your knowledge of your programming language(s)! A mastery of the programming\nlanguages that you use and their built-in routines is extremely important and will help you\na lot in programming contests.\n27One can use ios::sync with stdio(false); cin.tie(NULL); to avoid costly synchronization. This\nway, cin/cout can run faster albeit still a bit slower than scanf/printf.\n16\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nExercise 1.3.4.1: Produce a working code that is as concise as possible for the following\ntasks below. Unless explicitly stated, you are allowed to use any programming language that\nyou are most comfortable with.\n1. Using Java, read in a double\n(e.g., 1.4732, 15.324547327, etc.)", "mimetype": "text/plain", "start_char_idx": 114433, "end_char_idx": 117811, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ae652625-8732-4cdc-b7c9-7572925d2de7": {"__data__": {"id_": "ae652625-8732-4cdc-b7c9-7572925d2de7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2b246c2f-6e2d-49d3-89d8-8e5eb8475dbb", "node_type": "1", "metadata": {}, "hash": "a1737c0df86eafda2536bdb858dc06306e58ca7470a883c2347fb6a36a3e4aec", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73e17c4f-b629-46b8-aee0-f8c79ba84b14", "node_type": "1", "metadata": {}, "hash": "72176dec51591642c1a5e6aeb477f6bb8e3d067e330236eaedeadbb13c2b992b", "class_name": "RelatedNodeInfo"}}, "text": "A mastery of the programming\nlanguages that you use and their built-in routines is extremely important and will help you\na lot in programming contests.\n27One can use ios::sync with stdio(false); cin.tie(NULL); to avoid costly synchronization. This\nway, cin/cout can run faster albeit still a bit slower than scanf/printf.\n16\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nExercise 1.3.4.1: Produce a working code that is as concise as possible for the following\ntasks below. Unless explicitly stated, you are allowed to use any programming language that\nyou are most comfortable with.\n1. Using Java, read in a double\n(e.g., 1.4732, 15.324547327, etc.)\necho it, but with a minimum \ufb01eld width of 7 and 3 digits after the decimal point\n(e.g., ss1.473 (where \u2018s\u2019 denotes a space), s15.325, etc.)\n2. Given an integer n (n \uf8ff15), print \u21e1to n digits after the decimal point (rounded).\n(e.g., for n = 2, print 3.14; for n = 4, print 3.1416; for n = 5, prints 3.14159.)\n3. Given a date (in the past), determine the day of the week (Monday, . . . , Sunday) on\nthat day and the number of day(s) that has elapsed since that day until present.\n(e.g., 9 August 2010\u2014the launch date of the \ufb01rst edition of this book\u2014is a Monday.)\n4. Given n random integers, print the distinct (unique) integers in sorted order.\n5. Given the distinct and valid birthdates of n people as triples (DD, MM, YYYY), order\nthem \ufb01rst by ascending birth months (MM), then by ascending birth dates (DD), and\n\ufb01nally by ascending age.\n6. Given a list of sorted integers L of size up to 1M items, determine whether a value v\nexists in L with no more than 20 comparisons (more details in Section 2.2).\n7. Generate all possible permutations of {\u2018A\u2019, \u2018B\u2019, \u2018C\u2019, . . . , \u2018J\u2019}, the \ufb01rst N = 10 letters\nin the alphabet (see Section 3.2.1).\n8. Generate all possible subsets of {1, 2, . . . , 20}, the \ufb01rst N = 20 positive integers (see\nSection 3.2.1).\n9. Given a string that represents a base X number, convert it to an equivalent string in\nbase Y, 2 \uf8ffX, Y \uf8ff36. For example: \u201cFF\u201d in base X = 16 (hexadecimal) is \u201c255\u201d in\nbase Y1 = 10 (decimal) and \u201c11111111\u201d in base Y2 = 2 (binary). See Book 2.\n10. Let\u2019s de\ufb01ne a \u2018special word\u2019 as a lowercase alphabet followed by two consecutive digits.\nGiven a string, replace all \u2018special words\u2019 of length 3 with 3 stars \u201c***\u201d, e.g.,\nS = \u201cline: a70 and z72 will be replaced, aa24 and a872 will not\u201d\nshould be transformed into:\nS = \u201cline: *** and *** will be replaced, aa24 and a872 will not\u201d.\n11. Given an integer X that can contain up to 20 digits, output \u2018Prime\u2019 if X is a prime or\n\u2018Composite\u2019 otherwise.\n12. Given a valid mathematical expression involving \u2018+\u2019, \u2018-\u2019, \u2018*\u2019, \u2018/\u2019, \u2018(\u2019, and \u2018)\u2019 in a sin-\ngle line, evaluate that expression. (e.g., a rather complicated but valid expression 3\n+ (8 - 7.5) * 10 / 5 - (2 + 5 * 7) should produce -33.0 when evaluated with\nstandard operator precedence.)\n17\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n1.3.5\nTip 5: Master the Art of Testing Code\nYou thought you had nailed a particular problem. You had identi\ufb01ed its problem type,\ndesigned the algorithm for it, veri\ufb01ed that the algorithm (with the data structures it uses)\nwould run in time (and within memory limits) by considering the time (and space) complex-\nity, and implemented the algorithm, but your solution is still not Accepted (AC).", "mimetype": "text/plain", "start_char_idx": 117156, "end_char_idx": 120491, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "73e17c4f-b629-46b8-aee0-f8c79ba84b14": {"__data__": {"id_": "73e17c4f-b629-46b8-aee0-f8c79ba84b14", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ae652625-8732-4cdc-b7c9-7572925d2de7", "node_type": "1", "metadata": {}, "hash": "61dcbd3304bad3827bb6bc444a4a6b9e49f34c4e01fe6d3d01c5fbe5ddd89798", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "afa08a1f-7d79-44e1-9a98-42ed8daaec7c", "node_type": "1", "metadata": {}, "hash": "3bf3fb2b7ed14c927f9453cc3be163618949f0b0ae5fe3258c6cde0f3f30f143", "class_name": "RelatedNodeInfo"}}, "text": "(e.g., a rather complicated but valid expression 3\n+ (8 - 7.5) * 10 / 5 - (2 + 5 * 7) should produce -33.0 when evaluated with\nstandard operator precedence.)\n17\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n1.3.5\nTip 5: Master the Art of Testing Code\nYou thought you had nailed a particular problem. You had identi\ufb01ed its problem type,\ndesigned the algorithm for it, veri\ufb01ed that the algorithm (with the data structures it uses)\nwould run in time (and within memory limits) by considering the time (and space) complex-\nity, and implemented the algorithm, but your solution is still not Accepted (AC).\nDepending on the programming contest, you may or may not get credit for solving the\nproblem partially. In ICPC, you will only get points for a particular problem if your team\u2019s\ncode solves all the secret test cases for that problem. Other verdicts such as Presentation\nError (PE)28, Wrong Answer (WA), Time Limit Exceeded (TLE), Memory Limit Exceeded\n(MLE), Run Time Error (RTE), etc, do not increase your team\u2019s points. In current IOI (2010-\n2019), the subtask scoring system is used. Test cases are grouped into subtasks which are the\nsimpler variants of the original task with smaller input bounds or with special simplifying\nassumption(s). You are credited for solving a subtask if your code solves all test cases in it.\nYou can use the full feedback system to view the judge\u2019s evaluation of your code.\nIn either case, you will need to be able to design good, comprehensive, and tricky test\ncases. The sample input-output given in the problem description is by nature trivial and\nonly there to aid understanding of the problem statement. Therefore, the sample test cases\nare usually insu\ufb03cient for determining the correctness of your code.\nRather than wasting submissions (and thus accumulating time or score penalties) in\nICPC (not so much penalized in recent IOIs but still consume contest time), you may want\nto design tricky test cases for testing your code on your own machine29. Ensure that your\ncode is able to solve them correctly (otherwise, there is no point submitting your solution\nsince it is likely to be incorrect\u2014unless you want to test the test data bounds).\nSome coaches encourage their students to compete with each other by designing test\ncases. If student A\u2019s test cases can break student B\u2019s code, then A will get bonus points.\nYou may want to try this in your team training :).\nHere are some guidelines for designing good test cases from our experience. These are\ntypically the steps that have been taken by problem authors:\n1. Your test cases should include the sample test cases since the sample output is guar-\nanteed to be correct. Use \u2018fc\u2019 in Windows or \u2018diff\u2019 in UNIX to check your code\u2019s\noutput (when given the sample input) against the sample output. Avoid manual com-\nparison as humans are prone to error and are not good at performing such tasks,\nespecially for problems with strict output formats (e.g., blank line between test cases\nversus after every test cases). To do this, copy and paste the sample input and sample\noutput from the problem description, then save them to \ufb01les (named as \u2018in\u2019 and \u2018out\u2019\nor anything else that is sensible). Then, after compiling your program (let\u2019s assume\nthe executable\u2019s name is the \u2018g++\u2019 default \u2018a.out\u2019), execute it with an I/O redirec-\ntion: \u2018./a.out < in > myout\u2019. Finally, execute \u2018diff myout out\u2019 to highlight the\n(potentially subtle) di\u21b5erences, if any exist.\n2. For problems with multiple test cases in a single run (see Section 1.4.2), you should\ninclude two identical sample test cases consecutively in the same run.\nBoth must\noutput the same known correct answers. This helps to determine if you have forgotten\nto initialize any variables\u2014if the \ufb01rst instance produces the correct answer but the\nsecond one does not, it is likely that you have not reset your variables.\n28This verdict is now rare in modern Online Judges, e.g., Kattis [34].\n29[This is a personal opinion]. Programming contest environments di\u21b5er from one contest to another. This\ncan disadvantage contestants who rely too much on fancy Integrated Development Environment (IDE) (e.g.,\nVisual Studio, IntelliJ Idea, Eclipse, NetBeans, etc) for debugging.", "mimetype": "text/plain", "start_char_idx": 119882, "end_char_idx": 124096, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "afa08a1f-7d79-44e1-9a98-42ed8daaec7c": {"__data__": {"id_": "afa08a1f-7d79-44e1-9a98-42ed8daaec7c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73e17c4f-b629-46b8-aee0-f8c79ba84b14", "node_type": "1", "metadata": {}, "hash": "72176dec51591642c1a5e6aeb477f6bb8e3d067e330236eaedeadbb13c2b992b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bed8ed10-c3f3-43d7-a759-c6d8530e4501", "node_type": "1", "metadata": {}, "hash": "022eb0488d5e66e2c721d04076d6fd2300a1a2c0b09acd88539fdca71610f426", "class_name": "RelatedNodeInfo"}}, "text": "2. For problems with multiple test cases in a single run (see Section 1.4.2), you should\ninclude two identical sample test cases consecutively in the same run.\nBoth must\noutput the same known correct answers. This helps to determine if you have forgotten\nto initialize any variables\u2014if the \ufb01rst instance produces the correct answer but the\nsecond one does not, it is likely that you have not reset your variables.\n28This verdict is now rare in modern Online Judges, e.g., Kattis [34].\n29[This is a personal opinion]. Programming contest environments di\u21b5er from one contest to another. This\ncan disadvantage contestants who rely too much on fancy Integrated Development Environment (IDE) (e.g.,\nVisual Studio, IntelliJ Idea, Eclipse, NetBeans, etc) for debugging. It may be a good idea to practice coding\nwith just a text editor and a compiler!\n18\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n3. Your test cases should include tricky corner cases. Think like the problem author and\ntry to come up with the worst possible input for your algorithm by identifying cases\nthat are \u2018hidden\u2019 or implied within the problem description. These cases are usually\nincluded in the judge\u2019s secret test cases but not in the sample input and output.\nCorner cases typically occur at extreme values such as N = 0, N = 1, negative\nvalues, large \ufb01nal (and/or intermediate) values that do not \ufb01t 32-bit signed integer,\nempty/line/tree/bipartite/cyclic/acyclic/complete/disconnected graph, etc.\n4. Your test cases should include large cases. Increase the input size incrementally up to\nthe maximum input bounds stated in the problem description. Use large test cases with\ntrivial structures that are easy to verify with manual computation and large random\ntest cases to test if your code terminates in time and still produces reasonable output\n(since the correctness would be di\ufb03cult to verify here). Sometimes your program may\nwork for small test cases, but produces wrong answer, crashes, or exceeds the time\nlimit when the input size increases. If that happens, check for over\ufb02ows, out of bound\nerrors, or improve your algorithm.\n5. Though this is rare in modern programming contests, do not assume that the input\nwill always be nicely formatted if the problem description does not explicitly state it\n(especially for a badly written problem). Try inserting additional whitespace (spaces,\ntabs) in the input and test if your code is still able to obtain the values correctly\nwithout crashing.\nHowever, after carefully following all these steps, you may still get non-AC verdicts. In ICPC,\nyou (and your team) can actually consider the judge\u2019s verdict and the scoreboard (usually\navailable for the \ufb01rst four hours of the contest) in determining your next course of action. In\nrecent IOIs (2015-present), contestants can actually check the correctness of their submitted\ncode against the secret test cases due to the informative full feedback system. With more\nexperience in such contests, you will be able to make better judgments and choices.\nExercise 1.3.5.1: Situational awareness\n(mostly applicable in the ICPC setting\u2014this is not as relevant in IOI).\n1. You receive a WA verdict for a very easy problem. What should you do?\n(a) Abandon this problem for another.\n(b) Improve the performance of your solution (code optimizations/better algorithm).\n(c) Carefully re-read the problem description again.\n(d) Create tricky test cases to \ufb01nd the bug.\n(e) (In team contest): Ask your team mate to re-do the problem.\n2. You receive a TLE verdict for your O(N 3) solution.\nHowever, the maximum N is just 100. What should you do?\n(a) Abandon this problem for another.\n(b) Improve the performance of your solution (code optimizations/better algorithm).\n(c) Create tricky test cases to \ufb01nd the bug.\n3. Follow up to Question above: What if the maximum N is 100 000?\n19\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n4. Another follow up Question: What if the maximum N is 5000, the output only depends\non the size of input N, and you still have four hours of competition time left?\n5. You receive an RTE verdict. Your code (seems to) execute perfectly on your machine.\nWhat should you do?\n6. Thirty minutes into the contest, you take a glance at the scoreboard.", "mimetype": "text/plain", "start_char_idx": 123334, "end_char_idx": 127579, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bed8ed10-c3f3-43d7-a759-c6d8530e4501": {"__data__": {"id_": "bed8ed10-c3f3-43d7-a759-c6d8530e4501", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "afa08a1f-7d79-44e1-9a98-42ed8daaec7c", "node_type": "1", "metadata": {}, "hash": "3bf3fb2b7ed14c927f9453cc3be163618949f0b0ae5fe3258c6cde0f3f30f143", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9d06f407-cadd-463b-bb56-f36f7f1afa22", "node_type": "1", "metadata": {}, "hash": "a4f055b77d529634842bd99efc43dd99b87c66a265475adf8e48fea708d1a69d", "class_name": "RelatedNodeInfo"}}, "text": "However, the maximum N is just 100. What should you do?\n(a) Abandon this problem for another.\n(b) Improve the performance of your solution (code optimizations/better algorithm).\n(c) Create tricky test cases to \ufb01nd the bug.\n3. Follow up to Question above: What if the maximum N is 100 000?\n19\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\n4. Another follow up Question: What if the maximum N is 5000, the output only depends\non the size of input N, and you still have four hours of competition time left?\n5. You receive an RTE verdict. Your code (seems to) execute perfectly on your machine.\nWhat should you do?\n6. Thirty minutes into the contest, you take a glance at the scoreboard. There are many\nother teams that have solved a problem X that your team has not attempted. What\nshould you do?\n7. Midway through the contest, you take a glance at the scoreboard. The leading team\n(assume that it is not your team) has just solved problem Y . What should you do?\n8. Your team has spent two hours on a nasty problem. You have submitted several im-\nplementations by di\u21b5erent team members. All submissions have been judged incorrect.\nYou have no idea what\u2019s wrong. What should you do?\n9. There is one hour to go before the end of the contest. You have 1 WA code and 1 fresh\nidea for another problem. What should you (or your team) do?\n(a) Abandon the problem with the WA code, switch to the other problem in an\nattempt to solve one more problem.\n(b) Insist that you have to debug the WA code. There is not enough time to start\nworking on a new problem.\n(c) (In ICPC): Print the WA code. Ask two other team members to scrutinize it while\nyou switch to that other problem in an attempt to solve two more problems.\nExercise 1.3.5.2: Find the subtle bug inside the following short C++ code:\n1. Find the Least Signi\ufb01cant One bit of a 32-bit signed integer (7 \u22125) using\n#define LSOne(S) (S & -S).\n2. Using\nbuiltin ctz(v) to count the number of trailing zeroes in a 64-bit signed int\nlong long v.\n3. Using ms.erase(v) to delete just one copy of value v from a multiset<int> ms that\nmay contain 0, 1, or more copies of v.\n4. Assume that v is a vector<int> that contains a few random integers.\nfor (int i = 1; i <= 4; ++i) v.push back(i); // try changing 4 to 5\nvector<int>::iterator it = v.begin();\ncout << *it << \"\nn\"; // should output v[0] = 1\nv.push back(rand()); // increase vector size by 1\ncout << *it << \"\nn\"; // isn\u2019t v[0] should remain 1?\n5. Similar subtle bug as above.\nfor (int i = 1; i <= 4; ++i) v.push back(i); // try changing 4 to 5\nauto &front = v[0]; // pass by reference\ncout << front << \"\nn\"; // should output v[0] = 1\nv.push back(rand()); // increase vector size by 1\ncout << front << \"\nn\"; // isn\u2019t v[0] should remain 1?\n20\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.3.6\nTip 6: Practice and More Practice\nCompetitive programmers, like real athletes, must train regularly and keep \u2018programming-\n\ufb01t\u2019. Thus in our second last tip, we provide a list of several websites with resources that\ncan help improve your problem solving skill. We believe that success comes as a result of a\ncontinuous e\u21b5ort to better yourself.\nThe University of Valladolid (UVa, from Spain) Online Judge30 (https://onlinejudge.\norg, [44]) contains past (older) ICPC contest problems (Locals, Regionals, and up to World\nFinals) plus problems from other sources, including various problems from custom contests.\nYou can solve these problems and submit your solutions to the Online Judge. The correctness\nof your program will be reported as soon as possible. Try solving the problems mentioned\nin this book and you might see your name on the top-500 authors rank list someday :-).", "mimetype": "text/plain", "start_char_idx": 126887, "end_char_idx": 130562, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9d06f407-cadd-463b-bb56-f36f7f1afa22": {"__data__": {"id_": "9d06f407-cadd-463b-bb56-f36f7f1afa22", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bed8ed10-c3f3-43d7-a759-c6d8530e4501", "node_type": "1", "metadata": {}, "hash": "022eb0488d5e66e2c721d04076d6fd2300a1a2c0b09acd88539fdca71610f426", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "eef3ba66-0dc6-4d5e-b329-2c2b136989b5", "node_type": "1", "metadata": {}, "hash": "06e67f1fd9a8f62fe51fea54b833b09a93850129ada48fcc787380433bd83f5c", "class_name": "RelatedNodeInfo"}}, "text": "Thus in our second last tip, we provide a list of several websites with resources that\ncan help improve your problem solving skill. We believe that success comes as a result of a\ncontinuous e\u21b5ort to better yourself.\nThe University of Valladolid (UVa, from Spain) Online Judge30 (https://onlinejudge.\norg, [44]) contains past (older) ICPC contest problems (Locals, Regionals, and up to World\nFinals) plus problems from other sources, including various problems from custom contests.\nYou can solve these problems and submit your solutions to the Online Judge. The correctness\nof your program will be reported as soon as possible. Try solving the problems mentioned\nin this book and you might see your name on the top-500 authors rank list someday :-).\nAs of 19 July 2020, one needs to solve \u2265699 problems to be in the top-500. Steven is\nranked 39 (for solving 2074 problems), Felix is ranked 72 (for solving 1550 problems), and\nSuhendry is ranked 124 (for solving 1262 problems) out of \u21e1365 857 users (and a total of \u21e1\n4965 problems), i.e., all three of us are actually at the top 99.9-th percentile.\nThis (UVa) Online Judge, being one of the oldest online judge, has many third party\ntools built to help its users, e.g., our own uHunt (https://uhunt.onlinejudge.org/) and\nUDebug (https://www.udebug.com/).\nFigure 1.2: Left: (UVa) Online Judge; Right: Kattis\nKattis (https://open.kattis.com, [34]) is the recent ICPC World Finals judging system. It\nhas a public (open) online judge that contains interesting problems from recent ICPC World\nFinals/Regional Contests, and other good quality contests. Instead of ranking users by raw\nnumber of problems solved as with (UVa) Online Judge, Kattis uses her own \u2018dynamic\u2019\nproblem di\ufb03culty rating classi\ufb01cation. That is, a very good competitive programmer can\nquickly move up in ranks by purposely solving harder/higher rating problems than the\ncompetitors who can only solve trivial/easy/lower rating problems. As of 19 July 2020, one\nneeds to get \u22651792.7 points to be in the top-100. Steven is ranked 9 (with 5742.7 points)\nout of \u21e1141 132 Kattis users, i.e., also at the top 99.9-th percentile.\nIn CP4, we use both (UVa) Online Judge and Kattis online judges as our primary source\nof inspiring problems.\nFigure 1.3: Left: USACO; Right: ICPC Live Archive\n30This Online Judge is no longer a\ufb03liated with the University of Valladolid (UVa) since year 2019. It\nis now simply called as \u2018Online Judge\u2019. However, for backwards compatibility, we still refer to its classic\nabbreviation \u2018UVa\u2019 in this book.\n21\n\n1.3.\nTIPS TO BE COMPETITIVE\nc\u20ddSteven, Felix, Suhendry\nThe USA Computing Olympiad has a very useful training website [43] with online contests\nto help you learn programming and problem solving skills. This is geared for IOI participants\nmore than for ICPC participants. Go straight to their website and train.\nUVa\u2019s \u2018sister\u2019 online judge is the ICPC Live Archive [30] that contains almost all recent\nICPC Regionals and World Final problem sets 1990-2018. Train here if you want to do well\nin future ICPCs. Some Live Archive problems are mirrored in the (UVa) Online Judge and\nmore recent World Finals problem sets are also available at Kattis.\nCodeforces [4] and Topcoder [29] arrange frequent online programming contests that are\nnot restricted by age. This online judge uses a rating system (red, orange, violet, blue, cyan,\netc coders) to reward contestants who are really good at problem solving under the tight and\nstressful contest environment with a higher rating as opposed to more diligent contestants\nwho happen to solve a higher number of easier problems over a (much) longer duration,\nwith less pressure, and perhaps with help from hints/problem solution editorials that may\nbecome available after a programming contest is concluded.", "mimetype": "text/plain", "start_char_idx": 129813, "end_char_idx": 133601, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eef3ba66-0dc6-4d5e-b329-2c2b136989b5": {"__data__": {"id_": "eef3ba66-0dc6-4d5e-b329-2c2b136989b5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9d06f407-cadd-463b-bb56-f36f7f1afa22", "node_type": "1", "metadata": {}, "hash": "a4f055b77d529634842bd99efc43dd99b87c66a265475adf8e48fea708d1a69d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "881d7beb-790c-4444-97d9-d8b22f1ec288", "node_type": "1", "metadata": {}, "hash": "4d5b3d45c5e9860208144b141eedcbaca33f0d2016c067ff45b31fc4bd18d787", "class_name": "RelatedNodeInfo"}}, "text": "Train here if you want to do well\nin future ICPCs. Some Live Archive problems are mirrored in the (UVa) Online Judge and\nmore recent World Finals problem sets are also available at Kattis.\nCodeforces [4] and Topcoder [29] arrange frequent online programming contests that are\nnot restricted by age. This online judge uses a rating system (red, orange, violet, blue, cyan,\netc coders) to reward contestants who are really good at problem solving under the tight and\nstressful contest environment with a higher rating as opposed to more diligent contestants\nwho happen to solve a higher number of easier problems over a (much) longer duration,\nwith less pressure, and perhaps with help from hints/problem solution editorials that may\nbecome available after a programming contest is concluded.\n1.3.7\nTip 7: Team Work (for ICPC)\nThis last tip is not something that is easy to teach, but here are some ideas that may be\nworth trying for improving your team\u2019s performance:\n\u2022 Practice coding (or writing pseudo-code) on a blank paper. This is useful when your\nteammate is using the computer. When it is your turn to use the computer, you can\nthen just type the code as fast as possible.\n\u2022 The \u2018submit and print\u2019 strategy: If your code gets an AC verdict, ignore the printout.\nIf it still is not AC, debug your code using that printout (and let your teammate uses\nthe computer for other problem). Beware: Debugging without the computer is not an\neasy skill to master. You may want to consider being a Teaching Assistant of a basic\nprogramming methodology course in your University to develop the skill of identifying\nvarious subtle bugs in others\u2019 code (and to avoid making them yourself).\n\u2022 If your teammate is currently coding (and you have no idea for other problems), then\nprepare hard corner-case test data (and hopefully your teammate\u2019s code passes all\nthose). With two team members agreeing on the (potential) correctness of a code, the\nlikelihood of having lesser (or no) penalty increases.\n\u2022 If you aware that your team mate is (signi\ufb01cantly) stronger on a certain problem type\nthan yourself and you are currently reading a problem with such type (especially at\nthe early stage of the contest), consider passing the problem to your teammate instead\nof insisting to solve it yourself.\n\u2022 Practice coding a rather long/complicated algorithm together as a pair or even as a\ntriple (with a coding time limit pressure) for the end-game situation where your team\nis aiming to get +1 more AC in the last few minutes.\n\u2022 The X-factor: Befriend your teammates outside of training sessions and contests.\n22\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.4\nGetting Started: The Easy Problems\nNote: You can skip this section if you are a veteran participant of programming contests.\nThis section is meant for readers who are (very) new to competitive programming.\n1.4.1\nAnatomy of a Programming Contest Problem\nA programming contest problem usually contains the following components:\n\u2022 Background story/problem description. Most problem descriptions are interest-\ning. However, the easier problems are usually written to deceive contestants and made\nto appear di\ufb03cult, for example by adding \u2018extra information\u2019 to create a diversion.\nContestants should be able to \ufb01lter out these unimportant details and focus on the\nessential ones. For example, the entire opening paragraphs except the last sentence in\nUVa 00579 - ClockHands are about the history of the clock and is completely unrelated\nto the actual problem. However, harder problems are usually written as succinctly as\npossible\u2014they are already di\ufb03cult enough without additional embellishment.\n\u2022 Input and Output (I/O) description. In this section, you will be given details\non how the input is formatted and on how you should format your output.\nThis\npart is usually written in a formal manner. A good problem should have clear input\nconstraints as the same problem might be solvable with di\u21b5erent algorithms for di\u21b5erent\ninput constraints (see Table 1.4).\n\u2022 Sample Input and Sample Output. Problem authors usually only provide trivial\ntest cases to contestants, e.g., see Exercise 1.1.1. The sample input/output is in-\ntended for contestants to check their basic understanding of the problem and to verify\nif their code can parse the given input using the given input format and produce the\ncorrect output using the given output format. Do not submit your code to the judge if\nit does not even pass the given sample input/output. See Section 1.3.5 about testing\nyour code before submission.", "mimetype": "text/plain", "start_char_idx": 132811, "end_char_idx": 137352, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "881d7beb-790c-4444-97d9-d8b22f1ec288": {"__data__": {"id_": "881d7beb-790c-4444-97d9-d8b22f1ec288", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "eef3ba66-0dc6-4d5e-b329-2c2b136989b5", "node_type": "1", "metadata": {}, "hash": "06e67f1fd9a8f62fe51fea54b833b09a93850129ada48fcc787380433bd83f5c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b8647d1c-cdee-4664-b486-bfecb4c4fd20", "node_type": "1", "metadata": {}, "hash": "165c595e6978b3cf928e6422a809edbad8b008613f4ad5be5d9fe044e8ad2f15", "class_name": "RelatedNodeInfo"}}, "text": "In this section, you will be given details\non how the input is formatted and on how you should format your output.\nThis\npart is usually written in a formal manner. A good problem should have clear input\nconstraints as the same problem might be solvable with di\u21b5erent algorithms for di\u21b5erent\ninput constraints (see Table 1.4).\n\u2022 Sample Input and Sample Output. Problem authors usually only provide trivial\ntest cases to contestants, e.g., see Exercise 1.1.1. The sample input/output is in-\ntended for contestants to check their basic understanding of the problem and to verify\nif their code can parse the given input using the given input format and produce the\ncorrect output using the given output format. Do not submit your code to the judge if\nit does not even pass the given sample input/output. See Section 1.3.5 about testing\nyour code before submission.\n\u2022 Hints or Footnotes. In some cases, the problem authors may drop hints or add\nfootnotes to further describe the problem.\n1.4.2\nTypical Input/Output Routines\nMultiple Test Cases\nIn a programming contest, the correctness of your code is usually determined by running\nyour code against several test cases. Rather than using many individual test case \ufb01les with\none test case per \ufb01le, some programming contest problems31 use one test case \ufb01le with\nmultiple test cases included. In this section, we use a very simple problem as an example of\na multiple-test-cases problem: Given two small positive integers (\uf8ff100) in one line, output\ntheir sum in one line. We will illustrate three32 possible input/output formats:\n1. The number of test cases is given in the \ufb01rst line of the input.\n2. The multiple test cases are terminated by special values (usually zero(es)), regardless\nwhether there are subsequent inputs afterwards.\n3. The multiple test cases are terminated by the EOF (end-of-\ufb01le) signal.\n31Kattis online judge [34] discourages this and prefers problem authors to specify one test case per \ufb01le.\n32Note that this list is not exhaustive!\n23\n\n1.4.\nGETTING STARTED: THE EASY PROBLEMS\nc\u20ddSteven, Felix, Suhendry\nC/C++ Source Code\n| Sample Input | Sample Output\n---------------------------------------------------------------------------\nint TC;\n| 3\n| 3\nscanf(\"%d\", &TC); // number of test cases\n| 1 2\n| 12\nwhile (TC--) { // shortcut to repeat until 0 | 5 7\n| 9\nint a, b; scanf(\"%d %d\", &a, &b);\n| 6 3\n|--------------\nprintf(\"%d\\n\", a+b); // compute on the fly |--------------|\n}\n|\n|\n---------------------------------------------------------------------------\nint a, b;\n| 1 2\n| 3\n// stop when both integers are 0\n| 5 7\n| 12\nwhile (scanf(\"%d %d\", &a, &b), (a || b))\n| 6 3\n| 9\nprintf(\"%d\\n\", a+b);\n| 0 0\n|--------------\n// do not process this extra line -> | 1 1\n|\n---------------------------------------------------------------------------\nint a, b;\n| 1 2\n| 3\n// scanf returns the number of items read\n| 5 7\n| 12\nwhile (scanf(\"%d %d\", &a, &b) == 2)\n| 6 3\n| 9\n// or you can check for EOF, i.e.,\n|--------------|--------------\n// while (scanf(\"%d %d\", &a, &b) != EOF)\n|\n|\nprintf(\"%d\\n\", a+b);\n|\n|\nCase Numbers and Blank Lines\nSome problems with multiple test cases require the output of each test case to be numbered\nsequentially. Some also require a blank line after each test case. Let\u2019s modify the simple\nproblem above to include the case number in the output (starting from one) with this output\nformat: \u201cCase [NUMBER]: [ANSWER]\u201d followed by a blank line for each test case.", "mimetype": "text/plain", "start_char_idx": 136492, "end_char_idx": 139923, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b8647d1c-cdee-4664-b486-bfecb4c4fd20": {"__data__": {"id_": "b8647d1c-cdee-4664-b486-bfecb4c4fd20", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "881d7beb-790c-4444-97d9-d8b22f1ec288", "node_type": "1", "metadata": {}, "hash": "4d5b3d45c5e9860208144b141eedcbaca33f0d2016c067ff45b31fc4bd18d787", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4ad7982f-7bd8-400d-b81d-b46e26fcee55", "node_type": "1", "metadata": {}, "hash": "83a93134c603bb7837852580bae0c75008242cd59d29f5b06192259cf6ac3816", "class_name": "RelatedNodeInfo"}}, "text": "Some also require a blank line after each test case. Let\u2019s modify the simple\nproblem above to include the case number in the output (starting from one) with this output\nformat: \u201cCase [NUMBER]: [ANSWER]\u201d followed by a blank line for each test case. Assuming\nthat the input is terminated by the EOF signal, we can use the following code:\nC/C++ Source Code\n| Sample Input | Sample Output\n---------------------------------------------------------------------------\nint a, b, c = 0;\n| 1 2\n| Case 1: 3\nwhile (scanf(\"%d %d\", &a, &b) != EOF)\n| 5 7\n|\n// notice the two \u2018\\n\u2019\n| 6 3\n| Case 2: 12\nprintf(\"Case %d: %d\\n\\n\", ++c, a+b);\n|--------------|\n|\n| Case 3: 9\n|\n|\n|\n|--------------\nSome other problems require us to output blank lines only between test cases. If we use the\napproach above, we will end up with an extra new line at the end of our output, producing\nan unnecessary \u2018Presentation Error\u2019 (PE) verdict33. We should use the following code:\n33Note that some online judges, e.g., Kattis, ignores this minor but annoying whitespace di\u21b5erences.\n24\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nC/C++ Source Code\n| Sample Input | Sample Output\n---------------------------------------------------------------------------\nint a, b, c = 0;\n| 1 2\n| Case 1: 3\nwhile (scanf(\"%d %d\", &a, &b) != EOF) {\n| 5 7\n|\nif (c > 0) printf(\"\\n\"); // 2nd/more cases | 6 3\n| Case 2: 12\nprintf(\"Case %d: %d\\n\", ++c, a+b);\n|--------------|\n}\n|\n| Case 3: 9\n|\n|--------------\nVariable Number of Inputs\nLet\u2019s change the simple problem above slightly. For each test case (each input line), we are\nnow given an integer k (k \u22651), followed by k integers. Our task is now to output the sum\nof these k integers. Assuming that the input is terminated by the EOF signal and we do not\nrequire case numbering, we can use the following code:\nC/C++ Source Code\n| Sample Input | Sample Output\n---------------------------------------------------------------------------\nint k;\n| 1 1\n| 1\nwhile (scanf(\"%d\", &k) != EOF) {\n| 2 3 4\n| 7\nint ans = 0, v;\n| 3 8 1 1\n| 10\nwhile (k--) { scanf(\"%d\", &v); ans += v; } | 4 7 2 9 3\n| 21\nprintf(\"%d\\n\", ans);\n| 5 1 1 1 1 1\n| 5\n}\n|--------------|--------------\nThe input routine can be a little bit more problematic if we are not given the convenient\ninteger k at the beginning of each test case/line. To perform the same task, assuming k \u22651\nand two integers in the same line are separated by exactly one space, we now need to read\nin pairs of an integer and a character and detect the end-of-line signal (EOLN), e.g.,:\nC/C++ Source Code\n| Sample Input | Sample Output\n---------------------------------------------------------------------------\nwhile (1) { // keep looping\n| 1\n| 1\nint ans = 0, v;\n| 3 4\n| 7\nchar dummy;\n| 8 1 1\n| 10\nwhile (scanf(\"%d%c\", &v, &dummy) != EOF) { | 7 2 9 3\n| 21\nans += v;\n| 1 1 1 1 1\n| 5\nif (dummy == \u2019\\n\u2019) break; // test EOLN\n|--------------|--------------\n}\n|\n|\nif (feof(stdin)) break; // test EOF\n|\n|\nprintf(\"%d\\n\", ans);\n|\n|\n}\n|\n|\nWe have written all sample I/O code in various programming languages. Please take a look at\nthem at our public GitHub repository: https://github.com/stevenhalim/cpbook-code,\nespecially if C/C++ is not your default programming language.\nSource code: ch1/IO.cpp|java|py|ml\n25\n\n1.4.", "mimetype": "text/plain", "start_char_idx": 139676, "end_char_idx": 142914, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4ad7982f-7bd8-400d-b81d-b46e26fcee55": {"__data__": {"id_": "4ad7982f-7bd8-400d-b81d-b46e26fcee55", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b8647d1c-cdee-4664-b486-bfecb4c4fd20", "node_type": "1", "metadata": {}, "hash": "165c595e6978b3cf928e6422a809edbad8b008613f4ad5be5d9fe044e8ad2f15", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "115bf630-860d-4919-b530-39d5df9da62e", "node_type": "1", "metadata": {}, "hash": "63ee3b8f4710ee3f22173c9a2aefac90d4393cdbade9fe60a498f59f800289e6", "class_name": "RelatedNodeInfo"}}, "text": "Please take a look at\nthem at our public GitHub repository: https://github.com/stevenhalim/cpbook-code,\nespecially if C/C++ is not your default programming language.\nSource code: ch1/IO.cpp|java|py|ml\n25\n\n1.4.\nGETTING STARTED: THE EASY PROBLEMS\nc\u20ddSteven, Felix, Suhendry\n1.4.3\nTime to Start the Journey\nThere is no better way to begin your journey in competitive programming than to solve a\nfew programming problems. To help you pick problems to start your journey among the \u21e1\n4965 problems in UVa online judge [44] and another \u21e12746 problems in Kattis online judge\n[34], we have listed some of the easiest Ad Hoc problems below. The \ufb01rst \ufb01ve categories are\namong the easiest programming contest problems that are suitable even for new (Computer\nScience) students who have just started learning the basics of Programming Methodologies\nbut have some basic understanding of mathematics (e.g., simple algebraic manipulation,\nsimple modular arithmetic) and logic (e.g., and, or, not). If you are new to (competitive)\nprogramming, we strongly recommend that you start your journey by solving some problems\nfrom this category after completing the previous Section 1.4.2.\nSince each category contains many problems which can still be overwhelming for begin-\nners, we have highlighted just one entry level (either a UVa or a Kattis online judge problem)\nplus preferably three (3) must try * UVa online judge problems and three (3) must try *\nKattis online judge problems in each category. These are the problems that, we think, are\nmore interesting or are of higher quality and don\u2019t have complicated I/O format. All other\nproblems in each category that we have solved are only listed as extras. The full list of hints\nfor the highlighted and the extras are available online at https://cpbook.net.\n\u2022 I/O and/or Sequences Only\nMost problems in this category have (near) one (or two) liner code.\n\u2022 Repetition Only\nAll problems in this category only deal with repetition statements (for loop, range-\nbased for loop, while loop, or do-while loop).\n\u2022 Selection Only\nAll problems in this category only deal with selection statements (if-else if-else or\nswitch-case statement).\n\u2022 Repetition+Selection Only\nThese essentially selection-related problems are given in multiple test cases format, so\nan outer loop (requires a repetition statement) is needed.\n\u2022 Control Flow\nNow we have I/O, Sequences, Selection, and Repetition commands mixed together.\nAll problems in this category can be solved without using 1D array.\n\u2022 Function\nThe problems in this category has part(s) that can be abstracted into (user-de\ufb01ned)\nfunction(s) (including recursive function(s)) that is/are called more than once.\n\u2022 1D Array Manipulation, Easier\nThe problems in this category are easier if we use 1-dimensional array data structure.\n\u2022 Easy, Still Easy, and Medium\nThe problems in the next three categories are easy, still easy, medium level, and still\ndon\u2019t have complicated34 I/O format. But from here onwards, the categorized problems\nuse a mix of basic programming methodology techniques listed above.\n34After we discuss basic string processing techniques in Section 1.5, we will show much more Ad Hoc\nproblems in Section 1.6\n26\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.4.4\nGetting Our First Accepted (AC) Verdict\nIn this subsection, we will guide you to get your \ufb01rst Accepted (AC) verdict for a simple\nonline judge problem. You can skip this subsection if have done this several times before.\nWe will use Kattis - moscowdream problem to illustrate the solving process step by step.\nTake 1\nAfter removing non important information, Kattis - moscowdream problem can be succinctly\ndescribed as follows: \u201cGiven 4 integers a, b, c, and n (0 \uf8ffa, b, c \uf8ff10, 1 \uf8ffn \uf8ff20), output\n\u2018YES\u2019 if a > 1, b > 1, c > 1, and a + b + c \u2265n, or output \u2018NO\u2019 otherwise\u201d.\nMost contestants who are new with competitive programming will quickly write a C/C++\ncode like this and submit it to the judge.", "mimetype": "text/plain", "start_char_idx": 142705, "end_char_idx": 146655, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "115bf630-860d-4919-b530-39d5df9da62e": {"__data__": {"id_": "115bf630-860d-4919-b530-39d5df9da62e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4ad7982f-7bd8-400d-b81d-b46e26fcee55", "node_type": "1", "metadata": {}, "hash": "83a93134c603bb7837852580bae0c75008242cd59d29f5b06192259cf6ac3816", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dab07ff0-9214-41ee-aec4-9f4cbe1dc276", "node_type": "1", "metadata": {}, "hash": "01a2f5f4982367e1753f6e81c02166e9a96c281255cd9c5f73fa326539af51d1", "class_name": "RelatedNodeInfo"}}, "text": "You can skip this subsection if have done this several times before.\nWe will use Kattis - moscowdream problem to illustrate the solving process step by step.\nTake 1\nAfter removing non important information, Kattis - moscowdream problem can be succinctly\ndescribed as follows: \u201cGiven 4 integers a, b, c, and n (0 \uf8ffa, b, c \uf8ff10, 1 \uf8ffn \uf8ff20), output\n\u2018YES\u2019 if a > 1, b > 1, c > 1, and a + b + c \u2265n, or output \u2018NO\u2019 otherwise\u201d.\nMost contestants who are new with competitive programming will quickly write a C/C++\ncode like this and submit it to the judge.\n#include <stdio.h>\nint main() {\nint a, b, c, n; scanf(\"%d %d %d %d\", &a, &b, &c, &n);\nif ((a >= 1) && (b >= 1) && (c >= 1) && (a+b+c >= n))\nprintf(\"YES\\n\");\nelse\nprintf(\"NO\\n\");\nreturn 0;\n}\nTake 2\nUnfortunately, submitting the code above will give us a Wrong Answer (WA) verdict. If\nyou participated in the actual contest, you would notice that many teams solved this simple\nproblem but a good number of those teams needed a second submission to get it right. This\nimplies that the problem author has likely put some corner cases that will caught some\ncontestants o\u21b5-guard. So let\u2019s try running our program above with a few random test cases\noutside the given sample. It turns out entering 1 1 1 1 gives us a \u2018YES\u2019. At this point we\nhave to be aware that the required answer should be a \u2018NO\u2019 as when n == 1, it is impossible\nto have at least 1 easy problem, at least 1 medium problem, and at least 1 hard problem. We\nmiss the case where 1 \uf8ffn < 3. Notice that the problem author cunningly wrote 1 \uf8ffn \uf8ff20\nas the input constraint of this variable n.\nWe call this kind of issue as \u201ccase analysis\u201d, i.e., the problem has cases that can (or have\nto) be treated separately. For this simple problem, debugging this bug is probably easy. For\nharder problems, it may not be that easy to unveil all the possible corner cases.\n#include <bits/stdc++.h>\n// a good practice in CP\nusing namespace std;\n// same as above\nint main() {\nint a, b, c, n; scanf(\"%d %d %d %d\", &a, &b, &c, &n);\n// the bug fix\nprintf(((a >= 1) && (b >= 1) && (c >= 1) && (a+b+c >= n) && (n >= 3)) ?\n\"YES\\n\" : \"NO\\n\");\n// use ternary operator\nreturn 0;\n// for shorter code\n}\nSource code: ch1/moscowdream.cpp|java|py|ml\n27\n\n1.4.\nGETTING STARTED: THE EASY PROBLEMS\nc\u20ddSteven, Felix, Suhendry\nProgramming Exercises to get you started35:\na. I/O + Sequences Only\n1. Entry Level: Kattis - hello * (just print \u201cHello World!\u201d)\n2. UVa 10071 - Back to High School ... * (super simple: output 2 \u21e5v \u21e5t)\n3. UVa 11614 - Etruscan Warriors ... * (root of a quadratic equation)\n4. UVa 13025 - Back to the Past * (giveaway, just print the one-line answer)\n5. Kattis - carrots * (just print P)\n6. Kattis - r2 * (just print 2 \u21e5S \u2212R1)\n7. Kattis - thelastproblem * (S can have space(s))\nExtra UVa: 11805. 12478.\nExtra Kattis: faktor, planina, romans.\nb. Repetition Only\n1. Entry Level: Kattis - timeloop * (just print \u2018num Abracadabra\u2019 N times)\n2. UVa 01124 - Celebrity Jeopardy * (LA 2681 - SouthEasternEurope06;\njust echo/re-print the input again)\n3. UVa 11044 - Searching for Nessy * (one liner code/formula exists)\n4. UVa 11547 - Automatic Answer * (a one liner O(1) solution exists)\n5.", "mimetype": "text/plain", "start_char_idx": 146109, "end_char_idx": 149280, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dab07ff0-9214-41ee-aec4-9f4cbe1dc276": {"__data__": {"id_": "dab07ff0-9214-41ee-aec4-9f4cbe1dc276", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "115bf630-860d-4919-b530-39d5df9da62e", "node_type": "1", "metadata": {}, "hash": "63ee3b8f4710ee3f22173c9a2aefac90d4393cdbade9fe60a498f59f800289e6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4229cd55-0250-4c4a-a793-95c7c0f060ae", "node_type": "1", "metadata": {}, "hash": "c6f0da931c8552cf088dd58403be81351b7e6499bb8295b74c0609ff0604ac80", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - carrots * (just print P)\n6. Kattis - r2 * (just print 2 \u21e5S \u2212R1)\n7. Kattis - thelastproblem * (S can have space(s))\nExtra UVa: 11805. 12478.\nExtra Kattis: faktor, planina, romans.\nb. Repetition Only\n1. Entry Level: Kattis - timeloop * (just print \u2018num Abracadabra\u2019 N times)\n2. UVa 01124 - Celebrity Jeopardy * (LA 2681 - SouthEasternEurope06;\njust echo/re-print the input again)\n3. UVa 11044 - Searching for Nessy * (one liner code/formula exists)\n4. UVa 11547 - Automatic Answer * (a one liner O(1) solution exists)\n5. Kattis - di\u21b5erent * (use abs function per test case)\n6. Kattis - qaly * (trivial loop)\n7. Kattis - tarifa * (one pass; array not needed)\nExtra UVa: 10055.\nc. Selection Only\n1. Entry Level: Kattis - moscowdream * (if-else; 2 cases; check n \u22653)\n2. Kattis - isithalloween * (if-else; 2 cases)\n3. Kattis - judgingmoose * (if-else if-else; 3 cases)\n4. Kattis - onechicken * (if-else if-else; 4 cases (piece vs pieces))\n5. Kattis - provincesandgold * (if-else if-else; 6 cases)\n6. Kattis - quadrant * (if-else if-else; 4 cases)\n7. Kattis - temperature * (if-else if-else; 3 cases; derive formula)\nd. Multiple Test Cases + Selection\n1. Entry Level: Kattis - oddities * (2 cases)\n2. UVa 11172 - Relational Operators * (very easy; one liner)\n3. UVa 12250 - Language Detection * (LA 4995 - KualaLumpur10; if-else)\n4. UVa 12372 - Packing for Holiday * (just check if all L, W, H \uf8ff20)\n5. Kattis - eligibility * (3 cases)\n6. Kattis - helpaphd * (2 cases)\n7. Kattis - leftbeehind * (4 cases)\nExtra UVa: 00621, 11723, 11727, 12289, 12468, 12577, 12646, 12917.\nExtra Kattis: nastyhacks, numberfun.\n35You will need to create free accounts at UVa [44] and Kattis [34] online judges if you have not done so.\n28\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\ne. Control Flow (solvable in under 7 minutes36)\n1. Entry Level: Kattis - statistics * (one pass; array not needed)\n2. UVa 11764 - Jumping Mario * (one linear scan to count high+low jumps)\n3. UVa 11799 - Horror Dash * (one linear scan; \ufb01nd max value)\n4. UVa 12279 - Emoogle Balance * (simple linear scan)\n5. Kattis - \ufb01zzbuzz * (actually just about easy divisibility properties)\n6. Kattis - licensetolaunch * (easy linear pass)\n7. Kattis - oddgnome * (linear pass)\nExtra UVa: 00272, 10300, 11364, 11498, 12403, 13012, 13034, 13130.\nExtra Kattis: babybites, cold, earlywinter, jobexpenses, speedlimit, starar-\nrangements, thanos, zanzibar.\nf. Function\n1. Entry Level: Kattis - mia * (just if-else check)\n2. UVa 10424 - Love Calculator * (just do as asked)\n3. UVa 11078 - Open Credit System * (one linear scan; max function)\n4. UVa 11332 - Summing Digits * (simple recursion)\n5. Kattis - artichoke * (LA 7150 - WorldFinals Marrakech15; linear scan; also\navailable at UVa 01709 - Amalgamated Artichokes)\n6.", "mimetype": "text/plain", "start_char_idx": 148753, "end_char_idx": 151525, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4229cd55-0250-4c4a-a793-95c7c0f060ae": {"__data__": {"id_": "4229cd55-0250-4c4a-a793-95c7c0f060ae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dab07ff0-9214-41ee-aec4-9f4cbe1dc276", "node_type": "1", "metadata": {}, "hash": "01a2f5f4982367e1753f6e81c02166e9a96c281255cd9c5f73fa326539af51d1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b917c4e6-8479-4744-877f-75eeebaf8262", "node_type": "1", "metadata": {}, "hash": "0cd35d38ad7da48e2b5e4a6909f80fbd6722a44e12aa98788b36f6b190ba6ff7", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: babybites, cold, earlywinter, jobexpenses, speedlimit, starar-\nrangements, thanos, zanzibar.\nf. Function\n1. Entry Level: Kattis - mia * (just if-else check)\n2. UVa 10424 - Love Calculator * (just do as asked)\n3. UVa 11078 - Open Credit System * (one linear scan; max function)\n4. UVa 11332 - Summing Digits * (simple recursion)\n5. Kattis - artichoke * (LA 7150 - WorldFinals Marrakech15; linear scan; also\navailable at UVa 01709 - Amalgamated Artichokes)\n6. Kattis - digits * (direct simulation; also available at UVa 11687 - Digits)\n7. Kattis - \ufb01lip * (create a \u2018reverse string\u2019 function; then if-else check)\nExtra Kattis: abc, combinationlock, treasurehunt.\ng. 1D Array Manipulation, Easier\n1. Entry Level: Kattis - lostlineup * (simple 1D array manipulation)\n2. UVa 01585 - Score * (LA 3354 - Seoul05; very easy one pass algorithm)\n3. UVa 11679 - Sub-prime * (simulate; see if all banks have \u22650 reserve)\n4. UVa 12015 - Google is Feeling Lucky * (traverse the list twice)\n5. Kattis - acm * (simple simulation; one pass; record #WA per problem)\n6. Kattis - cetiri * (sort 3 number helps; 3 cases)\n7. Kattis - lineup * (sort ascending/descending and compare)\nExtra UVa: 11942.\nExtra Kattis: basketballoneonone, hothike.\nh. Easy\n1. Entry Level: Kattis - hissingmicrophone * (simple loop)\n2. UVa 12503 - Robot Instructions * (easy simulation)\n3. UVa 12658 - Character Recognition? * (character recognition check)\n4. UVa 12696 - Cabin Baggage * (LA 6608 - Phuket13; easy problem)\n5. Kattis - batterup * (easy one loop)\n6. Kattis - hangingout * (simple loop)\n7. Kattis - pokerhand * (frequency count; report max)\nExtra UVa: 01641, 10963, 12554, 12750, 12798.\nExtra Kattis: armystrengtheasy, armystrengthhard, brokenswords, drinking-\nsong, mosquito, ptice, sevenwonders, volim, yinyangstones.\nOthers: IOI 2010 - Cluedo (3 pointers), IOI 2010 - Memory (2 linear pass).\n36Seven minutes is just an arbitrary short amount of time chosen by the main author of this book (Steven).\n29\n\n1.4.\nGETTING STARTED: THE EASY PROBLEMS\nc\u20ddSteven, Felix, Suhendry\ni. Still Easy\n1. Entry Level: Kattis - bubbletea * (simple simulation)\n2. UVa 11559 - Event Planning * (one linear pass)\n3. UVa 11683 - Laser Sculpture * (one linear pass is enough)\n4. UVa 11786 - Global Raining ... * (need to observe the pattern)\n5. Kattis - bossbattle * (trick question)\n6. Kattis - peasoup * (one linear pass)\n7. Kattis - vote * (follow the requirements)\nExtra UVa: 10114, 10141, 10324, 11586, 11661, 12614, 13007.\nExtra Kattis:\nboundingrobots, climbingstairs, deathtaxes, driversdilemma,\neventplanning, exactlyelectrical, missingnumbers, prerequisites, sok.\nj. Medium\n1. Entry Level: Kattis - basicprogramming1 * (a nice summative problem for\nprogramming examination of a basic programming methodology course)\n2. UVa 11507 - Bender B. Rodriguez ... * (simulation; if-else)\n3. UVa 12157 - Tari\u21b5Plan * (LA 4405 - KualaLumpur08; compute and\ncompare the two plans)\n4. UVa 12643 - Tennis Rounds * (it has tricky test cases)\n5. Kattis - battlesimulation * (one pass; special check on 3!", "mimetype": "text/plain", "start_char_idx": 151054, "end_char_idx": 154109, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b917c4e6-8479-4744-877f-75eeebaf8262": {"__data__": {"id_": "b917c4e6-8479-4744-877f-75eeebaf8262", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4229cd55-0250-4c4a-a793-95c7c0f060ae", "node_type": "1", "metadata": {}, "hash": "c6f0da931c8552cf088dd58403be81351b7e6499bb8295b74c0609ff0604ac80", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f023453c-c045-4644-aea6-aeb80c792cc2", "node_type": "1", "metadata": {}, "hash": "374eb5d351fd1f0862a1f19dd497c5b4a7f2659778523c272ba0ed3b64cc9b76", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis:\nboundingrobots, climbingstairs, deathtaxes, driversdilemma,\neventplanning, exactlyelectrical, missingnumbers, prerequisites, sok.\nj. Medium\n1. Entry Level: Kattis - basicprogramming1 * (a nice summative problem for\nprogramming examination of a basic programming methodology course)\n2. UVa 11507 - Bender B. Rodriguez ... * (simulation; if-else)\n3. UVa 12157 - Tari\u21b5Plan * (LA 4405 - KualaLumpur08; compute and\ncompare the two plans)\n4. UVa 12643 - Tennis Rounds * (it has tricky test cases)\n5. Kattis - battlesimulation * (one pass; special check on 3! = 6 possible com-\nbinations of 3 combo moves)\n6. Kattis - bitsequalizer * (analyzing patterns; also available at UVa 12545 -\nBits Equalizer)\n7. Kattis - fastfood * (eventually just one pass due to the constraints)\nExtra UVa: 00119, 00573, 00661, 01237, 11956.\nExtra Kattis:\nanotherbrick, beekeeper, bottledup, carousel, climbingworm,\ncodecleanups, cowcrane, howl, shatteredcake.\nOthers: IOI 2009 - Garage (simulation), IOI 2009 - POI (sort).\nTips: After solving a number of programming problems, you begin to realize a pattern\nin your solutions. Certain idioms are used frequently enough in competitive program-\nming implementation for shortcuts to be useful.\nFrom a C/C++ perspective, these idioms might include:\n\u2022 Various libraries to be included (iostream, cstdio, cmath, cstring, etc, which\ncan now be all-included by using #include <bits/stdc++.h> if the program-\nming contest that you join uses GNU C++ compiler and allows it),\n\u2022 Various data type shortcuts (ll, ii, vi, vii, etc),\n\u2022 Various common constants (1e9 for INF, 1e-9 for EPS, etc),\n\u2022 Various basic I/O routines (freopen, multiple input format, turning o\u21b5synchro-\nnization with stdio for C++ users, etc).\nA competitive programmer can choose to save his/her frequently used idioms in a\ntemplate \ufb01le. Then when solving another problem, he/she can copy paste the entire\ncode from that template \ufb01le into a new code to speed up the implementation time.\nHowever, note that many of these tips should not be used beyond competitive pro-\ngramming, especially in software engineering.\n30\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.5\nBasic String Processing Skills\nNow we introduce several basic string processing skills that every competitive programmer\nmust have as not all input and/or output format(s) of a programming contest problem involve\nonly integers and/or simple strings.\nIn this section, we give a series of mini tasks that you should solve one after another\nwithout skipping. You can use any programming languages: C/C++37, Python38, Java,\nand/or OCaml. Try your best to come up with the shortest, most e\ufb03cient implementation\nthat you can think of. Then, compare your implementations with ours (see the answers\nat the back of this chapter or see the source code at https://github.com/stevenhalim/\ncpbook-code). If you are not surprised with any of our implementations (or can even give\nsimpler implementations), then you are already in a good shape for tackling various string\nprocessing problems. Go ahead and read the next sections. Otherwise, please spend some\ntime studying our implementations.\n1. Given a text \ufb01le that contains only alphabet characters [A-Za-z], digits [0-9], spaces,\nand periods (\u2018.\u2019), write a program to read this text \ufb01le line by line until we encounter\na line that starts with seven periods (\u201c.......\u201d). Concatenate (combine) each line\ninto one long string T. When two lines are combined, give one space between them so\nthat the last word of the previous line is separated from the \ufb01rst word of the current\nline. There can be up to 30 characters per line and no more than 10 lines for this input\nblock. There are no trailing spaces at the end of each line and each line ends with a\nnewline character. Note that the sample input is shown inside a box after question\n1.(d) and before task 2.\n(a) Do you know how to store a string in your favorite programming language?\n(b) How to read a given text input line by line?", "mimetype": "text/plain", "start_char_idx": 153543, "end_char_idx": 157530, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f023453c-c045-4644-aea6-aeb80c792cc2": {"__data__": {"id_": "f023453c-c045-4644-aea6-aeb80c792cc2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b917c4e6-8479-4744-877f-75eeebaf8262", "node_type": "1", "metadata": {}, "hash": "0cd35d38ad7da48e2b5e4a6909f80fbd6722a44e12aa98788b36f6b190ba6ff7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "25acbd6a-0f97-436e-944b-ae5cd6317ec1", "node_type": "1", "metadata": {}, "hash": "5add0e12381b4be67fc5a857ca26a5df42b43b22109a9ed0b01fc9549cbd61a3", "class_name": "RelatedNodeInfo"}}, "text": "Concatenate (combine) each line\ninto one long string T. When two lines are combined, give one space between them so\nthat the last word of the previous line is separated from the \ufb01rst word of the current\nline. There can be up to 30 characters per line and no more than 10 lines for this input\nblock. There are no trailing spaces at the end of each line and each line ends with a\nnewline character. Note that the sample input is shown inside a box after question\n1.(d) and before task 2.\n(a) Do you know how to store a string in your favorite programming language?\n(b) How to read a given text input line by line?\n(c) How to concatenate (combine) two strings into a larger one?\n(d) How to check if a line starts with a string \u201c.......\u201d to stop reading input?\nI love CS3233 Competitive\nProgramming. i also love\nAlGoRiThM\n.......you must stop after reading this line as it starts with 7 dots\nafter the first input block, there will be one loooooooooooong line...\n2. Suppose that we have one long string T. We want to check if another string P can\nbe found in T. Report all the indices where P appears in T or report -1 if P cannot\nbe found in T. For example, if T = \u201cI love CS3233 Competitive Programming.\ni\nalso love AlGoRiThM\u201d and P = \u201cI\u201d, then the output is only {0} (0-based indexing)\nbecause uppercase \u2018I\u2019 and lowercase \u2018i\u2019 are considered di\u21b5erent and thus the character\n\u2018i\u2019 at index {39} is not part of the output. If P = \u201clove\u201d, then the output is {2, 46}.\nIf P = \u201cbook\u201d, then the output is {-1}.\n37Note that you can mix C-style character array and C++ string class in the same C++ code. Most of\nthe time, either way can be used to solve a string processing problem. The choice of either style will be\ndown to the coder\u2019s preference.\n38Python is usually very suitable to solve easy/basic string processing problems. Therefore, we put Python\nahead of Java and OCaml this time.\n31\n\n1.5.\nBASIC STRING PROCESSING SKILLS\nc\u20ddSteven, Felix, Suhendry\n(a) How to \ufb01nd the \ufb01rst occurrence of a substring in a string (if any)?\nDo we need to implement a string matching algorithm (e.g., Knuth-Morris-Pratt\nalgorithm discussed in Book 2, etc) or can we just use library functions?\n(b) How to \ufb01nd the next occurrence(s) of a substring in a string (if any)?\n3. Suppose we want to do some simple analysis of the characters in T and also to transform\neach character in T into lowercase. The required analysis are: How many digits, vowels\n[aeiouAEIOU], and consonants (other lowercase/UPPERCASE alphabet characters\nthat are not vowels) are there in T? Can you do all these in O(n) where n is the length\nof the string T?\n4. Next, we want to break this one long string T into tokens (substrings) and store them\ninto an array of strings called tokens. For this mini task, the delimiters of these tokens\nare spaces and periods (thus breaking sentences into words). For example, if we tok-\nenize the string T (in lowercase), we will have these tokens = {\u201ci\u201d, \u201clove\u201d, \u201ccs3233\u201d,\n\u201ccompetitive\u201d, \u201cprogramming\u201d, \u201ci\u201d, \u201calso\u201d, \u201clove\u201d, \u201calgorithm\u201d}. Then, we want\nto sort this array of strings lexicographically39 and then \ufb01nd the lexicographically small-\nest string. That is, we have sorted tokens: {\u201calgorithm\u201d, \u201calso\u201d, \u201ccompetitive\u201d,\n\u201ccs3233\u201d, \u201ci\u201d, \u201ci\u201d, \u201clove\u201d, \u201clove\u201d, \u201cprogramming\u201d}. Thus, the lexicographically\nsmallest string for this example is \u201calgorithm\u201d.\n(a) How to tokenize a string?\n(b) How to store the tokens (the shorter strings) in an array of strings?\n(c) How to sort an array of strings lexicographically?\n5. Now, identify which word appears the most in T. In order to answer this query, we\nneed to count the frequency of each word. For T, the output is either \u201ci\u201d or \u201clove\u201d,\nas both appear twice. Which data structure should be used for this mini task?\n6.", "mimetype": "text/plain", "start_char_idx": 156919, "end_char_idx": 160664, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "25acbd6a-0f97-436e-944b-ae5cd6317ec1": {"__data__": {"id_": "25acbd6a-0f97-436e-944b-ae5cd6317ec1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f023453c-c045-4644-aea6-aeb80c792cc2", "node_type": "1", "metadata": {}, "hash": "374eb5d351fd1f0862a1f19dd497c5b4a7f2659778523c272ba0ed3b64cc9b76", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a66a21f5-1094-478d-8536-4eb310b19dc8", "node_type": "1", "metadata": {}, "hash": "680ab50ac025e03ce56f18a6f6bc061a3f81b281d3a12e0529d7a7ee4d49b1ae", "class_name": "RelatedNodeInfo"}}, "text": "Then, we want\nto sort this array of strings lexicographically39 and then \ufb01nd the lexicographically small-\nest string. That is, we have sorted tokens: {\u201calgorithm\u201d, \u201calso\u201d, \u201ccompetitive\u201d,\n\u201ccs3233\u201d, \u201ci\u201d, \u201ci\u201d, \u201clove\u201d, \u201clove\u201d, \u201cprogramming\u201d}. Thus, the lexicographically\nsmallest string for this example is \u201calgorithm\u201d.\n(a) How to tokenize a string?\n(b) How to store the tokens (the shorter strings) in an array of strings?\n(c) How to sort an array of strings lexicographically?\n5. Now, identify which word appears the most in T. In order to answer this query, we\nneed to count the frequency of each word. For T, the output is either \u201ci\u201d or \u201clove\u201d,\nas both appear twice. Which data structure should be used for this mini task?\n6. The given text \ufb01le has one more line after a line that starts with \u201c.......\u201d but the\nlength of this last line is not constrained. Your task is to count how many characters\nthere are in the last line. How to read a string if its length is not known in advance?\nTasks and Source code: ch1/basic string.html|cpp|java|py|ml\n39Basically, this is a sorted order like the one used in our common dictionary.\n32\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.6\nThe Ad Hoc Problems\nWe will end this introduction chapter by discussing the \ufb01rst proper problem type in the IOIs\nand ICPCs: the Ad Hoc problems. According to USACO [43], the Ad Hoc problems are\nproblems that \u2018cannot be classi\ufb01ed anywhere else\u2019 since each problem description and its\ncorresponding solution are \u2018unique\u2019. Many Ad Hoc problems are easy (as shown in Section\n1.4), but this does not apply to all Ad Hoc problems.\nAd Hoc problems frequently appear in programming contests. In ICPC, \u21e11-2 problems\nout of every \u21e110-13 problems are Ad Hoc problems. If the Ad Hoc problem is easy, it\nwill usually be the \ufb01rst problem solved by the teams in a programming contest. However,\nthere are cases where solutions to the Ad Hoc problems are too complicated to implement,\ncausing some teams to strategically defer them to mid contest or to the last hour. In an\nICPC regional contest with about 60 teams, your team would rank in the lower half (rank\n30-60) if you can only solve (easy) Ad Hoc problems.\nIn recent IOIs40, there are more and more creative Ad Hoc tasks that require creativity\n[20]. Solving more Ad Hoc problems as practice may just widen your knowledge base that\nmay help you solve other Ad Hoc problems.\nWe have listed many Ad Hoc problems that we have solved in the UVa and Kattis Online\nJudges [44, 34] in the several categories below. We believe that you can solve most of these\nproblems without using the advanced data structures or algorithms that will be discussed\nin the later chapters, i.e., we just need to read the requirements in the problem description\ncarefully and then code the usually short solution. Many of these Ad Hoc problems are\n\u2018simple\u2019 but some of them maybe \u2018tricky\u2019. Some Ad Hoc problems may require basic string\nprocessing skills discussed in Section 1.5 earlier.\nTry to solve a few problems from each\ncategory before reading the next chapter.\nNote that a small number of problems, although eventually listed as part of Chapter 1,\nmay require knowledge from subsequent chapters, e.g., knowledge of linear data structures\n(arrays) in Section 2.2, knowledge of backtracking in Section 3.2, etc. You can revisit these\nharder Ad Hoc problems after you have understood the required concepts.\nThe categories:\n\u2022 Game (Card)\nThere are lots of Ad Hoc problems involving popular games. Many are related to card\ngames. You will usually need to parse the input strings (review the discussion of basic\nstring processing in Section 1.5 if you are not familiar with this technique) as playing\ncards have both suits (D/Diamond/}, C/Club/|, H/Heart/~, and S/Spades/\u2660) and\nranks (usually: 2 < 3 < . . . < 9 < T/Ten < J/Jack < Q/Queen < K/King < A/Ace41).\nIt may be a good idea to map these troublesome strings to integer indices.", "mimetype": "text/plain", "start_char_idx": 159939, "end_char_idx": 163872, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a66a21f5-1094-478d-8536-4eb310b19dc8": {"__data__": {"id_": "a66a21f5-1094-478d-8536-4eb310b19dc8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "25acbd6a-0f97-436e-944b-ae5cd6317ec1", "node_type": "1", "metadata": {}, "hash": "5add0e12381b4be67fc5a857ca26a5df42b43b22109a9ed0b01fc9549cbd61a3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "30b0c3c3-891f-428d-a037-6ebca59d31e8", "node_type": "1", "metadata": {}, "hash": "b47626c4eb209f83c7e32fe4b0a355dc71be050b7c4b28a6b9f33af890be3972", "class_name": "RelatedNodeInfo"}}, "text": "You can revisit these\nharder Ad Hoc problems after you have understood the required concepts.\nThe categories:\n\u2022 Game (Card)\nThere are lots of Ad Hoc problems involving popular games. Many are related to card\ngames. You will usually need to parse the input strings (review the discussion of basic\nstring processing in Section 1.5 if you are not familiar with this technique) as playing\ncards have both suits (D/Diamond/}, C/Club/|, H/Heart/~, and S/Spades/\u2660) and\nranks (usually: 2 < 3 < . . . < 9 < T/Ten < J/Jack < Q/Queen < K/King < A/Ace41).\nIt may be a good idea to map these troublesome strings to integer indices. For example,\none possible mapping is to map D2 ! 0, D3 ! 1, . . . , DA ! 12, C2 ! 13, C3 ! 14,\n. . . , SA ! 51. Then, you can work with the integer indices instead.\n40IOI now uses subtask system where the Subtask 1 of each task in each competition day is usually the\neasiest form of the given task. If you are an IOI contestant, you will likely not win any medal if you can\nonly solve some/all Subtask 1 of all tasks over the 2 competition days.\n41In some other arrangements, A/Ace < 2.\n33\n\n1.6.\nTHE AD HOC PROBLEMS\nc\u20ddSteven, Felix, Suhendry\n\u2022 Game (Chess)\nChess is another popular game that sometimes appears in programming contest prob-\nlems. Some of these problems are Ad Hoc and listed in this section. Some of them are\ncombinatorial, e.g., the task of counting how many ways there are to place 8-queens in\n8 \u21e58 chess board. These are listed in Chapter 3 and some other chapters.\n\u2022 Game (Others), easier and harder (or more tedious)\nOther than card and chess games, many other popular games have made their way into\nprogramming contests: Tic Tac Toe, Rock-Paper-Scissors, Snakes/Ladders, BINGO,\nBowling, etc. Knowing the details of these games may be helpful42, but most of the\ngame rules are given in the problem description to avoid disadvantaging contestants\nwho are unfamiliar with the games.\n\u2022 Interesting Real Life Problems, easier and harder (or more tedious)\nThis is one of the most interesting problem categories in UVa and Kattis Online Judges.\nWe believe that real life problems like these are interesting to those who are new to\nComputer Science. The fact that we write programs to solve real life problems can\nbe an additional motivational boost. Who knows, you might stand to gain new (and\ninteresting) information from the problem description!\n\u2022 Ad Hoc problems involving Time\nThese problems utilize time concepts such as dates, times, and calendars. These are\nalso real life problems.\nAs mentioned earlier, these problems can be a little more\ninteresting to solve. Some of these problems will be far easier to solve if you have\nmastered43 the Python datetime module or Java GregorianCalendar class as they\nhave many library functions that deal with time. For example: With Python datetime\nmodule we can + (add the date by a certain amount of time), - (\ufb01nd di\u21b5erence of two\ndates), format date as we wish, etc; With Java GregorianCalendar class, we can add,\nget (component of a date), compareTo (another date), etc.\n\u2022 Roman Numerals\nRoman Numerals is a number system used in ancient Rome. It is actually a Decimal\nnumber system but it uses a certain letters of the alphabet instead of digits [0..9]\n(described below), it is not positional, and it does not have a symbol for zero. Roman\nNumerals have these 7 basic letters and its corresponding Decimal values: I=1, V=5,\nX=10, L=50, C=100, D=500, and M=1000. Roman Numerals also have the following\nletter pairs: IV=4, IX=9, XL=40, XC=90, CD=400, CM=900. Programming prob-\nlems involving Roman Numerals usually deal with the conversion from Arabic numerals\n(the Decimal number system that we normally use everyday) to Roman Numerals and\nvice versa. Such problems only appear very rarely in programming contests and such\nconversion can be derived on the spot by reading the problem statement.", "mimetype": "text/plain", "start_char_idx": 163254, "end_char_idx": 167131, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "30b0c3c3-891f-428d-a037-6ebca59d31e8": {"__data__": {"id_": "30b0c3c3-891f-428d-a037-6ebca59d31e8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a66a21f5-1094-478d-8536-4eb310b19dc8", "node_type": "1", "metadata": {}, "hash": "680ab50ac025e03ce56f18a6f6bc061a3f81b281d3a12e0529d7a7ee4d49b1ae", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f0332119-eb61-4172-9e14-dd98d0c7e966", "node_type": "1", "metadata": {}, "hash": "b889367109b439c07ca9ede9fad80ca8843d0b407c618da991688d831ea56bbd", "class_name": "RelatedNodeInfo"}}, "text": "It is actually a Decimal\nnumber system but it uses a certain letters of the alphabet instead of digits [0..9]\n(described below), it is not positional, and it does not have a symbol for zero. Roman\nNumerals have these 7 basic letters and its corresponding Decimal values: I=1, V=5,\nX=10, L=50, C=100, D=500, and M=1000. Roman Numerals also have the following\nletter pairs: IV=4, IX=9, XL=40, XC=90, CD=400, CM=900. Programming prob-\nlems involving Roman Numerals usually deal with the conversion from Arabic numerals\n(the Decimal number system that we normally use everyday) to Roman Numerals and\nvice versa. Such problems only appear very rarely in programming contests and such\nconversion can be derived on the spot by reading the problem statement. If you are\ninterested to see our short solution, you can examine the given source code:\nSource code: ch1/UVa11616.cpp|java|py\n42Knowing the details of these games can sometimes be detrimental if the rules of the game are modi\ufb01ed\nfrom the standard one.\n43C++ has <ctime> library too, but it has less functionalities than the Python/Java counterparts.\n34\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n\u2022 Cipher/Encode/Encrypt/Decode/Decrypt\nIt is everyone\u2019s wish that their private digital communications are secure. That is,\ntheir (string) messages can only be read by the intended recipient(s). Many ciphers\nhave been invented for this purpose and many (of the simpler ones \u2013 usually only\ninvolve arrays and/or loops) end up as Ad Hoc programming contest problems, each\nwith their own encoding/decoding rules. There are many such problems in the UVa\n[44] and Kattis [34] online judges. Thus, we have further split this category into three:\neasier, medium, and harder ones (the harder ones are deferred until Book 2). Try\nsolving some of them, especially those that we classify as must try *. It is interesting\nto learn a bit about Computer Security/Cryptography by solving these problems.\n\u2022 Input Parsing (Iterative)\nThis group of problems is not for IOI contestants as the current IOI syllabus enforces\nthe input of IOI tasks to be formatted as simply as possible. However, there are no\nsuch restrictions in the ICPC. Parsing problems range from the simpler ones that can\nbe dealt with an iterative parser to the more complex ones involving grammars that\nrequire recursive descent parsers, C++ regexes, Java String/Pattern class, Python\nRegEx classes, or OCaml regular expression (the more complex ones are deferred until\nBook 2).\n\u2022 Output Formatting\nThis is another group of problems that is also not for IOI contestants. This time, the\noutput is the problematic one. In an ICPC problem set, such problems are used as\n\u2018coding warm up\u2019 or the \u2018time-waster problem\u2019 for the contestants. Practice your coding\nskills by solving these problems as fast as possible as such problems can di\u21b5erentiate\nthe penalty time for each team (the more complex ones are deferred until Book 2).\n\u2022 \u2018Time Waster\u2019 problems\nThese are Ad Hoc problems that are written speci\ufb01cally to make the required solution\nlong and tedious. These problems, if they do appear in a programming contest, would\ndetermine the team with the most e\ufb03cient coder\u2014someone who can implement com-\nplicated but still accurate solutions under time constraints. Coaches should consider\nadding such problems in their training programs.\n\u2022 Ad Hoc problems in other chapters\nThere are many other Ad Hoc problems which we have shifted to other chapters since\nthey require (much more) knowledge above basic programming skills but it may be a\ngood idea to take a look at them after reading this Chapter 1.\n\u2013 Ad Hoc problems involving the usage of basic linear data structures (especially\n1D and multidimensional arrays) are listed in Section 2.2,\n\u2013 Ad Hoc problems involving mathematical computation in Book 2,\n\u2013 Ad Hoc problems involving harder string processing in Book 2,\n\u2013 Ad Hoc problems involving basic geometry in Book 2,\n\u2013 (Now) rare Ad Hoc problems, e.g., Tower of Hanoi, etc in Chapter 9.\n35\n\n1.6.\nTHE AD HOC PROBLEMS\nc\u20ddSteven, Felix, Suhendry\nProgramming Exercises about Ad Hoc problems:\na. Game (Card)\n1. Entry Level: UVa 10646 - What is the Card?", "mimetype": "text/plain", "start_char_idx": 166381, "end_char_idx": 170537, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f0332119-eb61-4172-9e14-dd98d0c7e966": {"__data__": {"id_": "f0332119-eb61-4172-9e14-dd98d0c7e966", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "30b0c3c3-891f-428d-a037-6ebca59d31e8", "node_type": "1", "metadata": {}, "hash": "b47626c4eb209f83c7e32fe4b0a355dc71be050b7c4b28a6b9f33af890be3972", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "72f21f4e-2596-4943-bf96-8bd3780ce7d6", "node_type": "1", "metadata": {}, "hash": "993db7e78a5082d7ac9713328d68f787e4193cdbec52539e4325932d71c439cc", "class_name": "RelatedNodeInfo"}}, "text": "\u2013 Ad Hoc problems involving the usage of basic linear data structures (especially\n1D and multidimensional arrays) are listed in Section 2.2,\n\u2013 Ad Hoc problems involving mathematical computation in Book 2,\n\u2013 Ad Hoc problems involving harder string processing in Book 2,\n\u2013 Ad Hoc problems involving basic geometry in Book 2,\n\u2013 (Now) rare Ad Hoc problems, e.g., Tower of Hanoi, etc in Chapter 9.\n35\n\n1.6.\nTHE AD HOC PROBLEMS\nc\u20ddSteven, Felix, Suhendry\nProgramming Exercises about Ad Hoc problems:\na. Game (Card)\n1. Entry Level: UVa 10646 - What is the Card? * (shu\u270fe cards with some\nrules and then get a certain card)\n2. UVa 10388 - Snap * (card simulation; uses random number to determine\nmoves; need data structure to maintain the face-up and face-down cards)\n3. UVa 11678 - Card\u2019s Exchange * (just an array manipulation problem)\n4. UVa 12247 - Jollo * (interesting card game; simple, but requires good\nlogic to get all test cases correct)\n5. Kattis - bela * (simple card scoring problem)\n6. Kattis - shu\u270fing * (simulate card shu\u270fing operation)\n7. Kattis - memorymatch * (interesting simulation game; many corner cases)\nExtra UVa: 00162, 00462, 00555, 10205, 10315, 11225, 12366, 12952.\nExtra Kattis: karte.\nb. Game (Chess)\n1. Entry Level: UVa 00278 - Chess * (basic chess knowledge is needed; derive\nthe closed form formulas)\n2. UVa 00255 - Correct Move * (check the validity of chess moves)\n3. UVa 00696 - How Many Knights * (ad hoc; chess)\n4. UVa 10284 - Chessboard in FEN * (FEN = Forsyth-Edwards Notation\nis a standard notation for describing board positions in a chess game)\n5. Kattis - chess * (bishop movements; either impossible, 0, 1, or 2 ways - one\nof this can be invalid; just use brute force)\n6. Kattis - empleh * (the reverse problem of Kattis - helpme *)\n7. Kattis - helpme * (convert the given chess board into chess notation)\nExtra UVa: 10196, 10849, 11494.\nExtra Kattis: bijele.\nAlso see N-Queens Problem (Section 3.2.2 and Book 2) and Knight Moves\n(Section 4.4.2) for other chess related problems.\nc. Game (Others), Easier\n1. Entry Level: UVa 10189 - Minesweeper * (simulate the classic Minesweeper\ngame; similar to UVa 10279)\n2. UVa 00489 - Hangman Judge * (just do as asked)\n3. UVa 00947 - Master Mind Helper * (similar to UVa 00340)\n4. UVa 11459 - Snakes and Ladders * (simulate it; similar to UVa 00647)\n5. Kattis - connectthedots * (classic children game; output formatting)\n6. Kattis - gamerank * (simulate the ranking update process)\n7. Kattis - guessinggame * (use a 1D \ufb02ag array; also available at UVa 10530 -\nGuessing Game)\nExtra UVa: 00340, 10279, 10409, 12239.\nExtra Kattis: trik.\n36\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nd. Game (Others), Harder (more tedious)\n1. Entry Level: Kattis - rockpaperscissors * (count wins and losses; output win\naverage; also available at UVa 10903 - Rock-Paper-Scissors ...)\n2. UVa 00584 - Bowling * (simulation; games; reading comprehension)\n3. UVa 10813 - Traditional BINGO * (follow the problem description)\n4. UVa 11013 - Get Straight * (check permutations of 5 cards to determine\nthe best run; brute force the 6th card and replace one of your card with it)\n5. Kattis - battleship * (simulation; reading comprehension; many corner cases)\n6.", "mimetype": "text/plain", "start_char_idx": 169984, "end_char_idx": 173202, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "72f21f4e-2596-4943-bf96-8bd3780ce7d6": {"__data__": {"id_": "72f21f4e-2596-4943-bf96-8bd3780ce7d6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f0332119-eb61-4172-9e14-dd98d0c7e966", "node_type": "1", "metadata": {}, "hash": "b889367109b439c07ca9ede9fad80ca8843d0b407c618da991688d831ea56bbd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "096c2e4b-4d6a-4c89-9fba-aaa0adc1d2e6", "node_type": "1", "metadata": {}, "hash": "ad15c8087da16b064338189ae8d080f86805ab51e47084d752f80e63bad57ff3", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: trik.\n36\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nd. Game (Others), Harder (more tedious)\n1. Entry Level: Kattis - rockpaperscissors * (count wins and losses; output win\naverage; also available at UVa 10903 - Rock-Paper-Scissors ...)\n2. UVa 00584 - Bowling * (simulation; games; reading comprehension)\n3. UVa 10813 - Traditional BINGO * (follow the problem description)\n4. UVa 11013 - Get Straight * (check permutations of 5 cards to determine\nthe best run; brute force the 6th card and replace one of your card with it)\n5. Kattis - battleship * (simulation; reading comprehension; many corner cases)\n6. Kattis - tictactoe2 * (check validity of Tic Tac Toe game; tricky; also available\nat UVa 10363 - Tic Tac Toe)\n7. Kattis - turtlemaster * (interesting board game to teach programming for\nchildren; simulation)\nExtra UVa: 00114, 00141, 00220, 00227, 00232, 00339, 00379, 00647.\nExtra Kattis: rockscissorspaper.\ne. Interesting Real Life Problems, Easier\n1. Entry Level: Kattis - wertyu * (use 2D mapper array to simplify the problem;\nalso available at UVa 10082 - WERTYU)\n2. UVa 00637 - Booklet Printing * (application in printer driver software)\n3. UVa 01586 - Molar mass * (LA 3900 - Seoul07; basic Chemistry)\n4. UVa 13151 - Rational Grading * (marking programming exam; ad hoc;\nstraightforward)\n5. Kattis - chopin * (you can learn a bit of music with this problem)\n6. Kattis - compass * (your typical smartphone\u2019s compass function usually has\nthis small feature)\n7. Kattis - trainpassengers * (create a veri\ufb01er; be careful of corner cases)\nExtra UVa: 00362, 11530, 11744, 11945, 11984, 12195, 12808.\nExtra Kattis: calories, fbiuniversal, heartrate, measurement, parking, tran-\nsitwoes.\nf. Interesting Real Life Problems, Medium\n1. Entry Level: Kattis - luhnchecksum * (very similar (\u21e195%) to UVa 11743)\n2. UVa 00161 - Tra\ufb03c Lights * (this is a typical situation on the road)\n3. UVa 10528 - Major Scales * (music knowledge in problem description)\n4. UVa 11736 - Debugging RAM * (this is a (simpli\ufb01ed) introduction to\nComputer Organization on how computer stores data in memory)\n5. Kattis - beatspread * (be careful with boundary cases; also available at UVa\n10812 - Beat the Spread)\n6. Kattis - toilet * (simulation; be careful of corner cases)\n7. Kattis - wordcloud * (just a simulation; but be careful of corner cases)\nExtra UVa: 00187, 00447, 00457, 00857, 10191, 11743, 12555,\nExtra Kattis: musicalscales, recipes, score.\n37\n\n1.6.\nTHE AD HOC PROBLEMS\nc\u20ddSteven, Felix, Suhendry\ng. Interesting Real Life Problems, Harder (more tedious)\n1. Entry Level: UVa 00706 - LC-Display * (like in old digital display)\n2. UVa 01061 - Consanguine Calc... * (LA 3736 - WorldFinals Tokyo07;\ntry all eight possible blood + Rh types with the information given)\n3. UVa 01091 - Barcodes * (LA 4786 - WorldFinals Harbin10; tedious sim-\nulation and reading comprehension)\n4. UVa 11279 - Keyboard Comparison * (extension of UVa 11278 problem;\ninteresting to compare QWERTY and DVORAK keyboard layout)\n5. Kattis - creditcard * (real life issue; precision error issue if we do not convert\ndouble (with just 2 digits after decimal point) into long long)\n6. Kattis - touchscreenkeyboard * (follow the requirements; sort)\n7.", "mimetype": "text/plain", "start_char_idx": 172575, "end_char_idx": 175800, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "096c2e4b-4d6a-4c89-9fba-aaa0adc1d2e6": {"__data__": {"id_": "096c2e4b-4d6a-4c89-9fba-aaa0adc1d2e6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "72f21f4e-2596-4943-bf96-8bd3780ce7d6", "node_type": "1", "metadata": {}, "hash": "993db7e78a5082d7ac9713328d68f787e4193cdbec52539e4325932d71c439cc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8615ed30-6595-4da8-bf62-9e4edff63f7a", "node_type": "1", "metadata": {}, "hash": "87f0888726a5de2512b7ddc2ca26c8d1b619fcd93cc76294f8db2060450e761f", "class_name": "RelatedNodeInfo"}}, "text": "Entry Level: UVa 00706 - LC-Display * (like in old digital display)\n2. UVa 01061 - Consanguine Calc... * (LA 3736 - WorldFinals Tokyo07;\ntry all eight possible blood + Rh types with the information given)\n3. UVa 01091 - Barcodes * (LA 4786 - WorldFinals Harbin10; tedious sim-\nulation and reading comprehension)\n4. UVa 11279 - Keyboard Comparison * (extension of UVa 11278 problem;\ninteresting to compare QWERTY and DVORAK keyboard layout)\n5. Kattis - creditcard * (real life issue; precision error issue if we do not convert\ndouble (with just 2 digits after decimal point) into long long)\n6. Kattis - touchscreenkeyboard * (follow the requirements; sort)\n7. Kattis - workout * (gym simulation; use 1D arrays to help you simulate the\ntime quickly)\nExtra UVa: 00139, 00145, 00333, 00346, 00403, 00448, 00449, 00538, 10659,\n11223, 12342, 12394.\nExtra Kattis: bungeejumping, saxophone, tenis.\nh. Time, Easier\n1. Entry Level: Kattis - marswindow * (simple advancing of year and month\nby 26 months or 2 years+2 months each; direct formula exists)\n2. UVa 00579 - Clock Hands * (be careful with corner cases)\n3. UVa 12136 - Schedule of a Marr... * (LA 4202 - Dhaka08; check time)\n4. UVa 12148 - Electricity * (easy with GregorianCalendar; use \u2018add\u2019 method\nto add 1 day to previous date; see if it is the same as the current date)\n5. Kattis - friday * (the answer depends on the start day of the month)\n6. Kattis - justaminute * (linear pass; total seconds/(total minutes*60))\n7. Kattis - savingdaylight * (convert hh:mm to minute; compute di\u21b5erence of\nending and starting; then convert minute to hh:mm again)\nExtra UVa: 00893, 10683, 11219, 11356, 11650, 11677, 11958, 12019, 12531,\n13275.\nExtra Kattis: datum, spavanac.\ni. Time, Harder\n1. Entry Level: Kattis - timezones * (follow the description, tedious; also avail-\nable at UVa 10371 - Time Zones)\n2. UVa 10942 - Can of Beans * (try all 3! = 6 permutations of 3 integers\nto form YY MM DD; check validity of the date; pick the earliest valid date)\n3. UVa 11947 - Cancer or Scorpio * (relatively easy but tedious; use Java\nGregorianCalendar)\n4. UVa 12822 - Extraordinarily large LED * (convert hh:mm:ss to second\nto simplify the problem; then this is just a tedious simulation problem)\n5. Kattis - bestbefore * (tedious; 3! = 6 possibilities to check)\n6. Kattis - birthdayboy * (convert mm-dd into [0..364]; use DAT; \ufb01nd largest\ngap via brute force)\n7. Kattis - natrij * (convert hh:mm:ss to seconds; make sure the second time is\nlarger than the \ufb01rst time; corner case: 24:00:00)\nExtra UVa: 00150, 00158, 00170, 00300, 00602, 10070, 10339, 12439.\nExtra Kattis: busyschedule, dst, semafori, tgif.\n38\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nj. Roman Numerals\n1. Entry Level: UVa 00759 - The Return of the ... * (validation problem)\n2. UVa 00185 - Roman Numerals * (also involving backtracking)\n3. UVa 00344 - Roman Digititis * (count Roman chars used in [1..N])\n4. UVa 11616 - Roman Numerals * (Roman numeral conversion problem)\n5. UVa 12397 - Roman Numerals * (each Roman digit has a value)\n6. Kattis - rimski * (to Roman/to Decimal conversion problem; use next per-\nmutation to be sure)\n7.", "mimetype": "text/plain", "start_char_idx": 175142, "end_char_idx": 178287, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8615ed30-6595-4da8-bf62-9e4edff63f7a": {"__data__": {"id_": "8615ed30-6595-4da8-bf62-9e4edff63f7a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "096c2e4b-4d6a-4c89-9fba-aaa0adc1d2e6", "node_type": "1", "metadata": {}, "hash": "ad15c8087da16b064338189ae8d080f86805ab51e47084d752f80e63bad57ff3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9c0daa2d-6cab-41af-ba67-2eaef05b7afb", "node_type": "1", "metadata": {}, "hash": "a6f21ec317f715e913d2a884dd37053f2afeccaab069de9344c4c098e298b5f8", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: busyschedule, dst, semafori, tgif.\n38\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nj. Roman Numerals\n1. Entry Level: UVa 00759 - The Return of the ... * (validation problem)\n2. UVa 00185 - Roman Numerals * (also involving backtracking)\n3. UVa 00344 - Roman Digititis * (count Roman chars used in [1..N])\n4. UVa 11616 - Roman Numerals * (Roman numeral conversion problem)\n5. UVa 12397 - Roman Numerals * (each Roman digit has a value)\n6. Kattis - rimski * (to Roman/to Decimal conversion problem; use next per-\nmutation to be sure)\n7. Kattis - romanholidays * (generate and sort the \ufb01rst 1K Roman strings; \u201cM\u201d\nis at index 945; append pre\ufb01x \u2018M\u2019 for numbers larger than 1K)\nk. Cipher/Encode/Encrypt/Decode/Decrypt, Easier\n1. Entry Level: UVa 13145 - Wuymul Wixcha * (shift alphabet values by\n+6 characters to read the problem statement; simple Caesar Cipher problem)\n2. UVa 10851 - 2D Hieroglyphs ... * (ignore border; treat \u2018\\/\u2019 as 1/0)\n3. UVa 11278 - One-Handed Typist * (map QWERTY keys to DVORAK)\n4. UVa 12896 - Mobile SMS * (simple cipher; use mapper)\n5. Kattis - conundrum * (simple cipher)\n6. Kattis - encodedmessage * (simple 2D grid cipher)\n7. Kattis - t9spelling * (similar to (the reverse of) UVa 12896)\nExtra UVa: 00444, 00641, 00795, 00865, 01339, 10019, 10222, 10878, 10896,\n10921, 11220, 11541, 11946, 13107.\nExtra Kattis: drmmessages, drunkvigenere, kemija08, keytocrypto, reverserot,\nrunlengthencodingrun.\nl. Cipher/Encode/Encrypt/Decode/Decrypt, Medium\n1. Entry Level: Kattis - secretmessage * (just do as asked; use 2D grid)\n2. UVa 00245 - Uncompress * (LA 5184 - WorldFinals Nashville95)\n3. UVa 00492 - Pig Latin * (ad hoc; similar to UVa 00483)\n4. UVa 11787 - Numeral Hieroglyphs * (follow the description)\n5. Kattis - anewalphabet * (simple cipher; 26 characters)\n6. Kattis - piglatin * (simple; check the vowels that include \u2018y\u2019 and process it)\n7. Kattis - tajna * (simple 2D grid cipher)\nExtra UVa: 00483, 00632, 00739, 00740, 11716.\nExtra Kattis: falsesecurity, permcode.\nm. Input Parsing (Iterative)\n1. Entry Level: UVa 11878 - Homework Checker * (expression parsing)\n2. UVa 00397 - Equation Elation * (iteratively perform the next operation)\n3. UVa 01200 - A DP Problem * (LA 2972 - Tehran03; tokenize input)\n4. UVa 10906 - Strange Integration * (BNF parsing; iterative solution)\n5. Kattis - autori * (simple string tokenizer problem)\n6. Kattis - pervasiveheartmonitor * (simple parsing; then \ufb01nding average)\n7. Kattis - timebomb * (just a tedious input parsing problem; divisibility by 6)\nExtra UVa: 00271, 00327, 00391, 00442, 00486, 00537, 11148, 12543, 13047,\n13093.\nExtra Kattis: genealogical, tripletexting.\n39\n\n1.6.\nTHE AD HOC PROBLEMS\nc\u20ddSteven, Felix, Suhendry\nn. Output Formatting, Easier\n1. Entry Level: UVa 00488 - Triangle Wave * (use several loops)\n2. UVa 01605 - Building for UN * (LA 4044 - NortheasternEurope07; we\ncan answer this problem with just h = 2 levels)\n3.", "mimetype": "text/plain", "start_char_idx": 177734, "end_char_idx": 180659, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9c0daa2d-6cab-41af-ba67-2eaef05b7afb": {"__data__": {"id_": "9c0daa2d-6cab-41af-ba67-2eaef05b7afb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8615ed30-6595-4da8-bf62-9e4edff63f7a", "node_type": "1", "metadata": {}, "hash": "87f0888726a5de2512b7ddc2ca26c8d1b619fcd93cc76294f8db2060450e761f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "36697aaf-12f2-4dd0-a2cb-0bee99087d57", "node_type": "1", "metadata": {}, "hash": "103dae1822c9d0ebc2e08ccd9199ce0a980e63552c2a91f3690d769a8d0fd672", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - pervasiveheartmonitor * (simple parsing; then \ufb01nding average)\n7. Kattis - timebomb * (just a tedious input parsing problem; divisibility by 6)\nExtra UVa: 00271, 00327, 00391, 00442, 00486, 00537, 11148, 12543, 13047,\n13093.\nExtra Kattis: genealogical, tripletexting.\n39\n\n1.6.\nTHE AD HOC PROBLEMS\nc\u20ddSteven, Felix, Suhendry\nn. Output Formatting, Easier\n1. Entry Level: UVa 00488 - Triangle Wave * (use several loops)\n2. UVa 01605 - Building for UN * (LA 4044 - NortheasternEurope07; we\ncan answer this problem with just h = 2 levels)\n3. UVa 10500 - Robot maps * (simulate; output formatting)\n4. UVa 12364 - In Braille * (2D array check; check all possible digits [0..9])\n5. Kattis - display * (unordered map; map a digit ! enlarged 7x5 version)\n6. Kattis - musicalnotation * (simple but tedious)\n7. Kattis - skener * (enlarging 2D character array)\nExtra UVa: 00110, 00320, 00445, 00490, 10146, 10894, 11074, 11482, 11965,\n13091.\nExtra Kattis: krizaljka, mirror, multiplication, okvir, okviri.\no. Time Waster Problems, Easier\n1. Entry Level: Kattis - asciiaddition * (a+b problem in text format; total\ngimmick; time waster)\n2. UVa 11638 - Temperature Monitoring * (simulation; needs to use bit-\nmask for parameter C)\n3. UVa 12085 - Mobile Casanova * (LA 2189 - Dhaka06; watch out for PE)\n4. UVa 12608 - Garbage Collection * (simulation with several corner cases)\n5. Kattis - glitchbot * (time waster; O(n2) simulation; do not output more than\none possible answer)\n6. Kattis - pachydermpeanutpacking * (time waster; simple one loop simulation)\n7. Kattis - printingcosts * (clear time waster; the hard part is in parsing the\ncosts of each character in the problem description)\nExtra UVa: 00144, 00214, 00335, 00349, 00556, 10028, 10033, 10134, 10850,\n12060, 12700.\nExtra Kattis: averagespeed, gerrymandering.\np. Time Waster Problems, Harder\n1. Entry Level: UVa 10188 - Automated Judge Script * (simulation)\n2. UVa 00405 - Message Routing * (simulation)\n3. UVa 11717 - Energy Saving Micro... * (tricky simulation)\n4. UVa 12280 - A Digital Satire of ... * (a tedious problem)\n5. Kattis - froggie * (just a simulation; but many corner cases; S can be 0)\n6. Kattis - functionalfun * (just follow the description; 5 cases; tedious parsing\nproblem; requires a kind of mapper)\n7. Kattis - windows * (LA 7162 - WorldFinals Marrakech15; tedious simulation\nproblem; also available at UVa 01721 - Window Manager)\nExtra UVa: 00337, 00381, 00603, 00618, 00830, 00945, 10142, 10267, 10961,\n11140.\nExtra Kattis: interpreter, lumbercraft, sabor, touchdown.\n40\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.7\nSolutions to Non-Starred Exercises\nExercise 1.1.1: A simple test case to break greedy algorithm is N = 2, {(2, 0), (2, 1), (0, 0),\n(4, 0)}.", "mimetype": "text/plain", "start_char_idx": 180116, "end_char_idx": 182858, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "36697aaf-12f2-4dd0-a2cb-0bee99087d57": {"__data__": {"id_": "36697aaf-12f2-4dd0-a2cb-0bee99087d57", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9c0daa2d-6cab-41af-ba67-2eaef05b7afb", "node_type": "1", "metadata": {}, "hash": "a6f21ec317f715e913d2a884dd37053f2afeccaab069de9344c4c098e298b5f8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "66db4153-a9a4-4486-a152-60d2363d841c", "node_type": "1", "metadata": {}, "hash": "a1e8d78f141a72708be631bfc04d202040c9c3b75d74093d24267a078e1e587d", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - windows * (LA 7162 - WorldFinals Marrakech15; tedious simulation\nproblem; also available at UVa 01721 - Window Manager)\nExtra UVa: 00337, 00381, 00603, 00618, 00830, 00945, 10142, 10267, 10961,\n11140.\nExtra Kattis: interpreter, lumbercraft, sabor, touchdown.\n40\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.7\nSolutions to Non-Starred Exercises\nExercise 1.1.1: A simple test case to break greedy algorithm is N = 2, {(2, 0), (2, 1), (0, 0),\n(4, 0)}. A greedy algorithm will incorrectly pair {(2, 0), (2, 1)} and {(0, 0), (4, 0)} with a 5.00\ncost while the optimal solution is to pair {(0, 0), (2, 0)} and {(2, 1), (4, 0)} with cost 4.24.\nExercise 1.1.2: For a Na\u00a8\u0131ve Complete Search like the one outlined in the body text, one\nneeds up to 16C2 \u21e514 C2 \u21e5. . .\u21e52 C2 = 16!\n2!8 \u21e18\u21e51010 for the largest test case with N = 8\u2014far\ntoo large. However, there are ways to prune the search space so that Complete Search can\nstill work. For an extra challenge, attempt Exercise 1.1.3*!\nExercise 1.3.2.1: Table 1.3 (minus UVa 10360) is shown below.\nUVa/Kattis\nTitle\nProblem Type\nHint\nwordcloud\nWord Cloud\nAd Hoc\nSection 1.6\nturbo\nTurbo\nFenwick Tree; RSQ\nSection 2.4\nhindex\nH-Index\nBSTA + binary search\nSection 3.3\n11292\nDragon of Loowater\nGreedy (Non Classical)\nSection 3.4\n11450\nWedding Shopping\nDP (Non Classical)\nSection 3.5\n11512\nGATTACA\nString (Su\ufb03x Array, LRS)\nBook 2\n10065\nUseless Tile Packers\nGeometry (CH + Area of Polygon)\nBook 2\n11506\nAngry Programmer\nGraph (Min Cut)\nBook 2\nbilateral\nBilateral Projects\nMVC; Bipartite; MCBM\nBook 2\ncarpool\nCarpool\nAPSP; Complete Search; DP\nBook 2\nExercise 1.3.3.1: The answers are:\n1. (b) Use a bBST as Priority Queue (for dynamic add/delete) (Section 2.3).\n2. If list L is static, (a) Simple Array that is pre-processed with Dynamic Programming\n(Section 2.2 & 3.5). If list L is dynamic, then (d) Fenwick Tree is a better answer\n(easier to implement than (c) Segment Tree).\n3. (b) Use 2D Range Sum Query (Section 3.5.2).\n4. (b) See the solution at Section 3.2.3.\n5. (a) O(V + E) Dynamic Programming (Section 3.5, 4.2.6, & 4.6.1).\nHowever, (c) O((V + E) log V ) Dijkstra\u2019s algorithm is also OK. The extra O(log V )\nfactor is \u2018small\u2019 for V \uf8ff100K and it is hard to separate this extra log factor.\n6. (a) Sieve of Eratosthenes (Book 2).\n7. (b) The na\u00a8\u0131ve approach above will not work. See Legendre\u2019s formula at Book 2.\n8. (b) The na\u00a8\u0131ve approach is too slow. Use KMP/Su\ufb03x Array/Rabin-Karp (Book 2)!\n9. (a) Yes, a complete search is possible (Section 3.2).\n10. (b) No, we must \ufb01nd another way. First, \ufb01nd the Convex Hull of the N points in\nO(N log N) (Book 2).", "mimetype": "text/plain", "start_char_idx": 182393, "end_char_idx": 184995, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "66db4153-a9a4-4486-a152-60d2363d841c": {"__data__": {"id_": "66db4153-a9a4-4486-a152-60d2363d841c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "36697aaf-12f2-4dd0-a2cb-0bee99087d57", "node_type": "1", "metadata": {}, "hash": "103dae1822c9d0ebc2e08ccd9199ce0a980e63552c2a91f3690d769a8d0fd672", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "49f087de-9be7-4150-9afb-39916233a484", "node_type": "1", "metadata": {}, "hash": "d621328f49358da01fac444f25492ce5cb02e28c9d56fda493e4bb5a191352f1", "class_name": "RelatedNodeInfo"}}, "text": "However, (c) O((V + E) log V ) Dijkstra\u2019s algorithm is also OK. The extra O(log V )\nfactor is \u2018small\u2019 for V \uf8ff100K and it is hard to separate this extra log factor.\n6. (a) Sieve of Eratosthenes (Book 2).\n7. (b) The na\u00a8\u0131ve approach above will not work. See Legendre\u2019s formula at Book 2.\n8. (b) The na\u00a8\u0131ve approach is too slow. Use KMP/Su\ufb03x Array/Rabin-Karp (Book 2)!\n9. (a) Yes, a complete search is possible (Section 3.2).\n10. (b) No, we must \ufb01nd another way. First, \ufb01nd the Convex Hull of the N points in\nO(N log N) (Book 2). Let the number of points in CH(S) = k. As the points are\nrandomly scattered, k will be much smaller than N. Then, \ufb01nd the two farthest points\nby examining all pairs of points in the CH(S) in O(k2).\n41\n\n1.7.\nSOLUTIONS TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\n11. (c) When the points may not be randomly scattered, k can be N, i.e., all points lie in\nthe Convex Hull. To solve this variant, we need the O(n) Rotating Caliper technique.\nExercise 1.3.4.1: The selected solutions are shown below and some alternative solutions\nat https://github.com/stevenhalim/cpbook-code/tree/master/ch1/Ex_1.3.4.1:\nimport java.util.*;\n// Java code for task 1\nclass Main {\npublic static void main(String[] args) {\nScanner sc = new Scanner(System.in);\ndouble d = sc.nextDouble();\nSystem.out.printf(\"%7.3f\\n\", d);\n// Java has printf too!\n}\n}\n#include <bits/stdc++.h>\n// C++ code for task 2\nusing namespace std;\nint main() {\nint n; scanf(\"%d\", &n);\nprintf(\"%.*lf\\n\", n, M_PI);\n// adjust field width\n}\nfrom datetime import date\n# Python code for task 3\ns = date(2010, 8, 9)\n# CP1 launch date\nt = date.today()\nprint(s.strftime(\"%a\"))\n# \u2019Mon\u2019, %A for \u2019Monday\u2019\nprint(\"{} day(s) ago\".format((t-s).days))\n# ans grows over time\nprint(*sorted(set(input().split())), sep=\u2019\\n\u2019)\n# Python code for task 4\n#include <bits/stdc++.h>\n// C++ code for task 5\nusing namespace std;\ntypedef tuple<int, int, int> iii;\n// use natural order\nint main() {\nvector<iii> birthdays;\nbirthdays.emplace_back(5, 24, -1980);\n// reorder DD/MM/YYYY\nbirthdays.emplace_back(5, 24, -1982);\n// to MM, DD, and then\nbirthdays.emplace_back(11, 13, -1983);\n// use NEGATIVE YYYY\nsort(birthdays.begin(), birthdays.end());\n// that\u2019s all :)\nfor (auto &[mm, dd, yyyy] : birthdays)\n// C++17 style\nprintf(\"%d %d %d\\n\", dd, mm, -yyyy);\n}\n#include <bits/stdc++.h>\n// C++ code for task 6\nusing namespace std;\nint main() {\nint n = 5, L[] = {10, 7, 5, 20, 8}, v = 7;\nsort(L, L+n);\nprintf(\"%d\\n\", binary_search(L, L+n, v));\n// should be index 1\n}\n42\n\nCHAPTER 1.", "mimetype": "text/plain", "start_char_idx": 184470, "end_char_idx": 186987, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "49f087de-9be7-4150-9afb-39916233a484": {"__data__": {"id_": "49f087de-9be7-4150-9afb-39916233a484", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "66db4153-a9a4-4486-a152-60d2363d841c", "node_type": "1", "metadata": {}, "hash": "a1e8d78f141a72708be631bfc04d202040c9c3b75d74093d24267a078e1e587d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a921c7e4-1eec-4fc2-aabe-1074dcc07d31", "node_type": "1", "metadata": {}, "hash": "791cccfa012f314e7e10299146d58a6afca15aa2fc3d74495eeb204a9644dc8f", "class_name": "RelatedNodeInfo"}}, "text": "INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n#include <bits/stdc++.h>\n// C++ code for task 7\nusing namespace std;\nint main() {\nint p[10], N = 10;\nfor (int i = 0; i < N; ++i) p[i] = i;\ndo {\nfor (int i = 0; i < N; ++i) printf(\"%c \", \u2019A\u2019+p[i]);\nprintf(\"\\n\");\n}\nwhile (next_permutation(p, p+N));\n}\n#include <bits/stdc++.h>\n// C++ code for task 8\nusing namespace std;\n#define LSOne(S) ((S) & -(S))\n// notice the brackets\nint main() {\nint N = 20;\nfor (int i = 0; i < (1<<N); ++i) {\nint pos = i;\nwhile (pos) {\nint ls = LSOne(pos);\npos -= ls;\nprintf(\"%d \", __builtin_ctz(ls));\n// this idx is part of set\n}\nprintf(\"\\n\");\n}\n}\nimport java.math.*;\n// Java code for task 9\nclass Main {\npublic static void main(String[] args) {\nString str = \"FF\"; int X = 16, Y = 10;\nSystem.out.println(new BigInteger(str, X).toString(Y));\n}\n}\nclass Main {\n// Java code for task 10\npublic static void main(String[] args) {\nString S = \"line: a70 and z72 will be replaced, aa24 and a872 won\u2019t\";\nSystem.out.println(S.replaceAll(\"\\\\b+[a-z][0-9][0-9]\\\\b+\", \"***\"));\n}\n}\nimport java.math.*;\n// Java code for task 11\nclass Main {\npublic static void main(String[] args) throws Exception {\nBigInteger x = new BigInteger(\"48112959837082048697\"); // Big Integer\nSystem.out.println(x.isProbablePrime(10) ? \"Prime\" : \"Composite\");\n}\n}\n43\n\n1.7.\nSOLUTIONS TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\neval(input())\n# Python code for task 12\nExercise 1.3.5.1: Situational considerations are in brackets:\n1. You receive a WA verdict for a very easy problem. What should you do?\n(a) Abandon this problem for another. (Not ok, your team will lose out.)\n(b) Improve the performance of your solution. (Not useful.)\n(c) Carefully re-read the problem description again. (Good idea.)\n(d) Create tricky test cases to \ufb01nd the bug. (The most logical answer.)\n(e) (In team contest): Ask your team mate to re-do the problem.\n(This could\nbe feasible as you might have had some wrong assumptions about the\nproblem. Thus, you should refrain from telling the details about the\nproblem to your team mate who will re-do the problem.\nStill, your\nteam will lose precious time.)\n2. You receive a TLE verdict for your O(N 3) solution.\nHowever, the maximum N is just 100. What should you do?\n(a) Abandon this problem for another. (Not ok, your team will lose out.)\n(b) Improve the performance of your solution. (Not ok, we should not get TLE\nwith an O(N 3) algorithm if N \uf8ff400.)\n(c) Create tricky test cases to \ufb01nd the bug. (This is the answer\u2014maybe your\nprogram runs into an accidental in\ufb01nite loop in some test cases.)\n3. Follow up to Question above: What if the maximum N is 100 000?\n(If N > 400, you may have no choice but to improve the performance of the\ncurrent algorithm or use another faster algorithm. You should not submit\nthe code in the \ufb01rst place.)\n4. Another follow up Question: What if the maximum N is 5000, the output only depends\non the size of input N, and you still have four hours of competition time left?\n(If the output only depends on N, you may be able to pre-calculate all\npossible solutions by running your O(N 3) algorithm in the background for\na few minutes, letting your team mate use the computer \ufb01rst. Once your\nO(N 3) solution terminates, you have all the answers. Submit the O(1) answer\ninstead if it does not exceed \u2018source code size limit\u2019 imposed by the judge.)\n5. You receive an RTE verdict. Your code (seems to) execute perfectly on your machine.\nWhat should you do?\n(The most common causes of RTEs are usually array sizes that are too\nsmall or stack over\ufb02ow/in\ufb01nite recursion errors.", "mimetype": "text/plain", "start_char_idx": 186988, "end_char_idx": 190541, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a921c7e4-1eec-4fc2-aabe-1074dcc07d31": {"__data__": {"id_": "a921c7e4-1eec-4fc2-aabe-1074dcc07d31", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "49f087de-9be7-4150-9afb-39916233a484", "node_type": "1", "metadata": {}, "hash": "d621328f49358da01fac444f25492ce5cb02e28c9d56fda493e4bb5a191352f1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5870f848-a410-46df-9219-2fb7430a1c17", "node_type": "1", "metadata": {}, "hash": "0d0ce317f3ee2ddb953be132b9a4d15308a54fa3f1204cad5b3667dd87bdcd2c", "class_name": "RelatedNodeInfo"}}, "text": "4. Another follow up Question: What if the maximum N is 5000, the output only depends\non the size of input N, and you still have four hours of competition time left?\n(If the output only depends on N, you may be able to pre-calculate all\npossible solutions by running your O(N 3) algorithm in the background for\na few minutes, letting your team mate use the computer \ufb01rst. Once your\nO(N 3) solution terminates, you have all the answers. Submit the O(1) answer\ninstead if it does not exceed \u2018source code size limit\u2019 imposed by the judge.)\n5. You receive an RTE verdict. Your code (seems to) execute perfectly on your machine.\nWhat should you do?\n(The most common causes of RTEs are usually array sizes that are too\nsmall or stack over\ufb02ow/in\ufb01nite recursion errors. Design test cases that can\ntrigger these errors in your code.)\n6. Thirty minutes into the contest, you take a glance at the scoreboard. There are many\nother teams that have solved a problem X that your team has not attempted. What\nshould you do?\n(One team member should immediately attempt problem X as it may be\nrelatively easy. Such a situation is really a bad news for your team as it is\na major set-back to getting a good rank in the contest.)\n44\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n7. Midway through the contest, you take a glance at the scoreboard. The leading team\n(assume that it is not your team) has just solved problem Y . What should you do?\n(If your team is not the \u2018pace-setter\u2019, then it is a good idea to \u2018ignore\u2019 what\nthe leading team is doing and concentrate instead on solving the problems\nthat your team has identi\ufb01ed to be \u2018solvable\u2019. By mid-contest, your team\nmust have read all the problems in the problem set and roughly identi\ufb01ed\nthe problems that are (likely) solvable with your team\u2019s current abilities.)\n8. Your team has spent two hours on a nasty problem. You have submitted several im-\nplementations by di\u21b5erent team members. All submissions have been judged incorrect.\nYou have no idea what\u2019s wrong. What should you do?\n(It is time to give up solving this problem. Do not hog the computer, let\nyour teammate solve another problem. Either your team has really misun-\nderstood the problem or in a very rare case, the judge solution is actually\nwrong. In any case, this is not a good situation for your team.)\n9. There is one hour to go before the end of the contest. You have 1 WA code and 1 fresh\nidea for another problem. What should you (or your team) do?\n(In chess terminology, this is called the \u2018end game\u2019 situation.)\n(a) Abandon the problem with the WA code, switch to the other problem in an\nattempt to solve one more problem.(OK in individual contests like IOI.)\n(b) Insist that you have to debug the WA code. There is not enough time to start\nworking on a new problem. (If the idea for another problem involves com-\nplex and tedious code, then deciding to focus on the WA code may be\na good idea rather than having two incomplete/\u2018non AC\u2019 solutions.)\n(c) (In ICPC): Print the WA code. Ask two other team members to scrutinize it while\nyou switch to that other problem in an attempt to solve two more problems.\n(If the solution for the other problem can be coded in less than 30\nminutes, then implement it while your team mates try to \ufb01nd the bug\nfor the WA code by studying the printed copy.)\nExercise 1.3.5.2:\n1. #define LSOne(S) (S & -S) will cause a very hard to kill bug, e.g.,:\n(7-5 & -7-5) = (2 & -12) = 0.\nUse #define LSOne(S) ((S) & -(S)) instead and compute:\n(7-5) & -(7-5) = 2 & -2 = 2.\n2.\nbuiltin ctz(v) is for 32-bit int, use\nbuiltin ctzl(v) instead for 64-bit int.\n3. Doing that will erase all copies of v, use ms.erase(ms.find(v)) instead.\n4. Iterator is invalidated when the vector has to double its size and reallocate its contents.\nBe careful of such potentially subtle iterator invalidation cases.\n5. Similarly, be careful when using the pass by reference symbol & for such subtle bugs.", "mimetype": "text/plain", "start_char_idx": 189780, "end_char_idx": 193699, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5870f848-a410-46df-9219-2fb7430a1c17": {"__data__": {"id_": "5870f848-a410-46df-9219-2fb7430a1c17", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a921c7e4-1eec-4fc2-aabe-1074dcc07d31", "node_type": "1", "metadata": {}, "hash": "791cccfa012f314e7e10299146d58a6afca15aa2fc3d74495eeb204a9644dc8f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0a8914b0-ce95-4dbd-9dc8-6b802701792e", "node_type": "1", "metadata": {}, "hash": "816edfca248cd36efde24b1f61e92c20736d8fc290f64436a2639b5c9f12b346", "class_name": "RelatedNodeInfo"}}, "text": "Exercise 1.3.5.2:\n1. #define LSOne(S) (S & -S) will cause a very hard to kill bug, e.g.,:\n(7-5 & -7-5) = (2 & -12) = 0.\nUse #define LSOne(S) ((S) & -(S)) instead and compute:\n(7-5) & -(7-5) = 2 & -2 = 2.\n2.\nbuiltin ctz(v) is for 32-bit int, use\nbuiltin ctzl(v) instead for 64-bit int.\n3. Doing that will erase all copies of v, use ms.erase(ms.find(v)) instead.\n4. Iterator is invalidated when the vector has to double its size and reallocate its contents.\nBe careful of such potentially subtle iterator invalidation cases.\n5. Similarly, be careful when using the pass by reference symbol & for such subtle bugs.\n45\n\n1.7.\nSOLUTIONS TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\nC Solutions for Section 1.5\nExercise 1.5.1:\n(a) A string is stored as an array of characters terminated by null, e.g., char str[30*10+50],\nline[30+50];. It is a good practice to declare array size slightly bigger than requirement\nto avoid \u201co\u21b5by one\u201d bug.\n(b) To read the input line by line, we use44 gets(line); or fgets(line, line length,\nstdin); in string.h (or cstring) library.\n(c) We \ufb01rst set str to be an empty string, and then we combine the lines that we read\ninto a longer string using strcat function. If the current line is not the last one, we\nappend a space to the back of str so that the last word from this line is not accidentally\ncombined with the \ufb01rst word of the next line.\n(d) We stop reading the input when strncmp(line, \".......\", 7) == 0.\nNote that\nstrncmp(str1, str2, num) only compares the \ufb01rst num characters.\nExercise 1.5.2:\n(a) For \ufb01nding a substring in a relatively short string (the standard string matching prob-\nlem), we can just use library function. We can use p = strstr(str, substr);\nThe value of p will be NULL if substr is not found in str.\n(b) If there are multiple copies of substr in str, we can use pos = strstr(str+pos,\nsubstr). Initially pos = 0, i.e., we search from the \ufb01rst character of str. After \ufb01nding\none occurrence of substr in str, we can call pos = strstr(str+pos, substr) again\nwhere this time pos is the index of the current occurrence of substr in str plus one so\nthat we can get the next occurrence. We repeat this process until pos == NULL. This C\nsolution requires understanding of the memory address of a C array.\nExercise 1.5.3: In many string processing tasks, we are required to iterate through every\ncharacter in str once. If there are n characters in str, then such scan requires O(n). In both\nC/C++, we can use tolower(ch) and toupper(ch) in ctype.h to convert a character to its\nlower and uppercase version. There are also isalpha(ch)/isdigit(ch) to check whether\na given character is alphabet [A-Za-z]/digit, respectively. To test whether a character is a\nvowel, one method is to prepare a string vowel = \"aeiou\"; and check if the given character\nis one of the \ufb01ve characters in vowel. To check whether a character is a consonant, simply\ncheck if it is an alphabet but not a vowel.\nExercise 1.5.4: Combined C and C++ solutions:\n(a) To tokenize a string, we can either use strtok(str, delimiters); in C or stringstream\nin C++.\n(b) These tokens can then be stored in a C++ vector<string> tokens.\n(c) We can use C++ STL sort(first, last) to sort vector<string> tokens. When\nneeded, we can convert C++ string back to C string by using str.c str().\nExercise 1.5.5: See the C++ solution.\nExercise 1.5.6: Read the input character by character and count incrementally, look for\nthe presence of \u2018\\n\u2019 that signals the end of a line. Pre-allocating a \ufb01xed-sized bu\u21b5er is not\na good idea as the problem author can set a ridiculously long string to break your code.", "mimetype": "text/plain", "start_char_idx": 193088, "end_char_idx": 196691, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0a8914b0-ce95-4dbd-9dc8-6b802701792e": {"__data__": {"id_": "0a8914b0-ce95-4dbd-9dc8-6b802701792e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5870f848-a410-46df-9219-2fb7430a1c17", "node_type": "1", "metadata": {}, "hash": "0d0ce317f3ee2ddb953be132b9a4d15308a54fa3f1204cad5b3667dd87bdcd2c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7eb778d0-b5ac-41fe-a7e8-7ede998fa443", "node_type": "1", "metadata": {}, "hash": "1bc32baf3f9828a92bc7431856b9fc051e6e26e2f348b987f4c693a431c2a46a", "class_name": "RelatedNodeInfo"}}, "text": "Exercise 1.5.4: Combined C and C++ solutions:\n(a) To tokenize a string, we can either use strtok(str, delimiters); in C or stringstream\nin C++.\n(b) These tokens can then be stored in a C++ vector<string> tokens.\n(c) We can use C++ STL sort(first, last) to sort vector<string> tokens. When\nneeded, we can convert C++ string back to C string by using str.c str().\nExercise 1.5.5: See the C++ solution.\nExercise 1.5.6: Read the input character by character and count incrementally, look for\nthe presence of \u2018\\n\u2019 that signals the end of a line. Pre-allocating a \ufb01xed-sized bu\u21b5er is not\na good idea as the problem author can set a ridiculously long string to break your code.\n44Note: Function gets is actually unsafe because it does not perform bound checking on input size.\n46\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nC++ Solutions for Section 1.5\nExercise 1.5.1:\n(a) We can use class string.\n(b) We can use getline(cin, string name);\n(c) We can use the \u2018+\u2019 operator directly to concatenate strings.\n(d) We can use string name.rfind(\".......\", 0) == 0.\nExercise 1.5.2:\n(a) We can use function find(str) in class string.\n(b) Same idea as in C language. We can set the o\u21b5set value in the second parameter of\nfunction find(str, pos) in class string.\nExercise 1.5.3-4: Same solutions as in C language.\nExercise 1.5.5: We can use C++ STL unordered map<string, int> to keep track the\nfrequency of each word. Every time we encounter a new token (which is a string), we increase\nthe corresponding frequency of that token by one. Finally, we scan through all tokens and\ndetermine the one with the highest frequency. This will be discussed in Section 2.3.\nExercise 1.5.6: Same solution as in C language or use the \ufb02exible length string class.\nPython Solutions for Section 1.5\nExercise 1.5.1:\n(a) Store the string in a Python variable.\n(b) We can use input() method in Python to read one line.\n(c) We can use the \u2018+\u2019 operator directly to concatenate strings.\n(d) We can use the startswith(prefix) method in Python.\nExercise 1.5.2:\n(a) We can use function find(sub) of a string.\n(b) Same idea as in C language. We can set the o\u21b5set value in the second parameter of\nfunction find(sub, start) of a string.\nExercise 1.5.3: We can use lower() to convert a string to its lowercase version. In many\nstring processing tasks, we are required to iterate through every character in str once. If\nthere are n characters in str, then such scan requires O(n). We can use ternary operation in\nPython 1 if (c in the digit) else 0 where the digit = list(\"0123456789\"). Simi-\nlarly for counting number of alphabets and vowels.\nExercise 1.5.4:\n(a) We can use split(separator) method, e.g., token = \"quick brown fox\".split(\" \").\n47\n\n1.7.\nSOLUTIONS TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\n(b) We can use list (see above).\n(c) We can use tokens.sort().\nExercise 1.5.5: Same solution as in C++ language, but we use freq = defaultdict(int)\nafter we call from collections import defaultdict. This will be discussed in Section 2.3.\nExercise 1.5.6: It is not trivial to read input character by character in Python, so we will\njust load all into memory via longline = input() (Python adjusts the bu\u21b5er size by itself)\nand report the length.\nJava Solutions for Section 1.5\nExercise 1.5.1:\n(a) We can use class String, StringBuffer, or StringBuilder (this one is faster than\nStringBuffer).\n(b) We can use the nextLine() method in Java Scanner. For faster I/O, we can consider\nusing the readLine() method in Java BufferedReader.\n(c) We can use the append(str) method in StringBuilder. We should not concatenate\nJava Strings with the \u2018+\u2019 operator as Java String class is immutable and thus such\noperation is (very) costly.", "mimetype": "text/plain", "start_char_idx": 196021, "end_char_idx": 199716, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7eb778d0-b5ac-41fe-a7e8-7ede998fa443": {"__data__": {"id_": "7eb778d0-b5ac-41fe-a7e8-7ede998fa443", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0a8914b0-ce95-4dbd-9dc8-6b802701792e", "node_type": "1", "metadata": {}, "hash": "816edfca248cd36efde24b1f61e92c20736d8fc290f64436a2639b5c9f12b346", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "40d136a9-d91c-4b5e-bfa5-5d144e3d4948", "node_type": "1", "metadata": {}, "hash": "8c186ef73c501293852eef1b6249e2d327b8d466192bbddbbd018e894b731988", "class_name": "RelatedNodeInfo"}}, "text": "This will be discussed in Section 2.3.\nExercise 1.5.6: It is not trivial to read input character by character in Python, so we will\njust load all into memory via longline = input() (Python adjusts the bu\u21b5er size by itself)\nand report the length.\nJava Solutions for Section 1.5\nExercise 1.5.1:\n(a) We can use class String, StringBuffer, or StringBuilder (this one is faster than\nStringBuffer).\n(b) We can use the nextLine() method in Java Scanner. For faster I/O, we can consider\nusing the readLine() method in Java BufferedReader.\n(c) We can use the append(str) method in StringBuilder. We should not concatenate\nJava Strings with the \u2018+\u2019 operator as Java String class is immutable and thus such\noperation is (very) costly.\n(d) We can use the startsWith(str) method in Java String.\nExercise 1.5.2:\n(a) We can use the indexOf(str) method in class String.\n(b) Same idea as in C language. We can set the o\u21b5set value in the second parameter of\nindexOf(str, fromIndex) method in class String.\nExercise 1.5.3: Use Java StringBuilder and Character classes for these operations.\nExercise 1.5.4:\n(a) We can use Java StringTokenizer class or split(regex) method in Java String class.\n(b) We can use Java ArrayList of Strings.\n(c) We can use Java Collections.sort.\nExercise 1.5.5: Same idea as in C++ language.\nWe can use Java HashMap<String, Integer>. This will be discussed in Section 2.3.\nExercise 1.5.6: We need to use the read() method in Java BufferedReader class.\n48\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\nOCaml Solutions for Section 1.5\nExercise 1.5.1:\n(a) We can use string.\n(b) We can use read line() in the Stdlib module.\n(c) We can use concat in String module.\n(d) We can use regular expression test.\nExercise 1.5.2:\n(a) We can use search forward in Str module.\n(b) We can adjust the start parameter of search forward.\nExercise 1.5.3: We can use lowercase ascii to \ufb01rst convert the input string to lowercase.\nThen, we can use to seq iterator to iterate the string and use an anonymous function so\nthat encountering a [\u20180\u2019 .. \u20189\u2019] increases number of digits, encountering a [\u2018a\u2019 .. \u2018z\u2019] that is\nalso a vowel (\u201caeiou\u201d)/not increase the number of vowels/consonants, respectively.\nExercise 1.5.4:\n(a) We can use split in Str module, specifying the required regular expression for a split.\n(b) We can use List module.\n(c) We can use sort in List module.\nExercise 1.5.5: We can use Hashtbl. This will be discussed in Section 2.3.\nExercise 1.5.6: We will just load all into memory via let longline = read line() in\n(OCaml adjusts the bu\u21b5er size by itself) and report the length.\n49\n\n1.7.\nSOLUTIONS TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\nFigure 1.4: Some references that inspired the authors to write this book\n50\n\nCHAPTER 1. INTRODUCTION\nc\u20ddSteven, Felix, Suhendry\n1.8\nChapter Notes\nThis chapter, as well as subsequent chapters are supported by many textbooks (see Figure\n1.4 in the previous page) and Internet resources. Here are some additional references:\n\u2022 To improve your typing skill as mentioned in Tip 1, you may want to play the many\ntyping games available online.\n\u2022 Tip 2 is adapted from the introduction text in USACO training gateway [43].\n\u2022 More details about Tip 3 can be found in many CS books, e.g., Chapter 1-5, 17 of [5].\n\u2022 Online references for Tip 4:\nhttps://en.cppreference.com/w/ for C++;\nhttps://docs.oracle.com/en/java/javase/11/docs/api/index.html for Java;\nhttps://docs.python.org/3/reference/ for Python;\nhttp://caml.inria.fr/pub/docs/manual-ocaml/ for OCaml.\nIt is useful to memorize functions that you frequently use.\n\u2022 For more insights on better testing (Tip 5), a slight detour to software engineering\nbooks may be worth trying.", "mimetype": "text/plain", "start_char_idx": 198993, "end_char_idx": 202670, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "40d136a9-d91c-4b5e-bfa5-5d144e3d4948": {"__data__": {"id_": "40d136a9-d91c-4b5e-bfa5-5d144e3d4948", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7eb778d0-b5ac-41fe-a7e8-7ede998fa443", "node_type": "1", "metadata": {}, "hash": "1bc32baf3f9828a92bc7431856b9fc051e6e26e2f348b987f4c693a431c2a46a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a2b41182-5217-4261-bf9d-d115c43d6299", "node_type": "1", "metadata": {}, "hash": "c3d4cc075582309623fca243cbf93709068ccece618ca36a34a86830f8d536b9", "class_name": "RelatedNodeInfo"}}, "text": "Here are some additional references:\n\u2022 To improve your typing skill as mentioned in Tip 1, you may want to play the many\ntyping games available online.\n\u2022 Tip 2 is adapted from the introduction text in USACO training gateway [43].\n\u2022 More details about Tip 3 can be found in many CS books, e.g., Chapter 1-5, 17 of [5].\n\u2022 Online references for Tip 4:\nhttps://en.cppreference.com/w/ for C++;\nhttps://docs.oracle.com/en/java/javase/11/docs/api/index.html for Java;\nhttps://docs.python.org/3/reference/ for Python;\nhttp://caml.inria.fr/pub/docs/manual-ocaml/ for OCaml.\nIt is useful to memorize functions that you frequently use.\n\u2022 For more insights on better testing (Tip 5), a slight detour to software engineering\nbooks may be worth trying.\n\u2022 There are many other Online Judges apart from those mentioned in Tip 6, e.g.,\n\u2013 hackerearth, https://www.hackerearth.com/,\n\u2013 HackerRank, https://www.hackerrank.com/,\n\u2013 URI Online Judge, https://www.urionlinejudge.com.br/,\n\u2013 Ural State University (Timus) Online Judge, https://acm.timus.ru,\n\u2013 Peking University Online Judge, (POJ) http://poj.org,\n\u2013 Zhejiang University Online Judge, (ZOJ) https://zoj.pintia.cn/home, etc.\n\u2022 For a note regarding team contest (Tip 7), read [12].\nIn this chapter, we have introduced the world of competitive programming to you. However,\na competitive programmer must be able to solve more than just Ad Hoc problems in a\nprogramming contest. We hope that you will enjoy the ride and fuel your enthusiasm by\nreading up on and learning new concepts in the other chapters of this book. Once you have\n\ufb01nished reading the book, re-read it once more. On the second time, attempt and solve the\n\u21e1258 written exercises and the \u21e13458 programming exercises.\nStatistics\n1st\n2nd\n3rd\n4th\nNumber of Pages\n13\n19\n32\n51 (+59%)\nWritten Exercises\n4\n4\n9\n8+2*=10 (+11%)\nProgramming Exercises\n34\n160\n173\n431 (+149%)\nThe breakdown of the number of programming exercises from each section is shown below:\nSection\nTitle\nAppearance\n% in Chapter\n% in Book\n1.4\nGetting Started\n155\n\u21e136%\n\u21e14.5%\n1.6\nThe Ad Hoc Problems\n276\n\u21e164%\n\u21e18.0%\nTotal\n431\n\u21e112.5%\n51\n\n1.8.\nCHAPTER NOTES\nc\u20ddSteven, Felix, Suhendry\nThis page is intentionally left blank to keep the number of pages per chapter even.\n52\n\nChapter 2\nData Structures and Libraries\nIf I have seen further it is only by standing on the shoulders of giants.\n\u2014 Isaac Newton\n2.1\nOverview and Motivation\nA data structure (DS) is a means of storing and organizing data. Di\u21b5erent data structures\nhave di\u21b5erent strengths and weaknesses. So when designing an algorithm, it is important\nto pick one that allows for e\ufb03cient insertions, searches/queries, deletions, and/or updates,\ndepending on what your algorithm needs. Although a data structure does not in itself solve a\n(programming contest) problem (the algorithm operating on it does), using an appropriately\ne\ufb03cient data structure for a problem may be the di\u21b5erence between passing or exceeding the\nproblem\u2019s time limit. There can be many ways to organize the same data and sometimes one\nway is better than the other in some contexts. We will illustrate this several times in this\nchapter. A keen familiarity with the data structures and libraries discussed in this chapter\nis important for understanding the algorithms that use them in subsequent chapters.\nAs stated in the preface of this book, we assume that you are familiar with the basic data\nstructures listed in Section 2.2-2.3 and thus we will not review them in depth in this book\n(with exception of bitmask and Big Integer). Instead, we highlight the fact that there exist\nbuilt-in implementations for these elementary data structures in the C++ STL, Java API,\nand Python/OCaml Standard Library.", "mimetype": "text/plain", "start_char_idx": 201932, "end_char_idx": 205618, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a2b41182-5217-4261-bf9d-d115c43d6299": {"__data__": {"id_": "a2b41182-5217-4261-bf9d-d115c43d6299", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "40d136a9-d91c-4b5e-bfa5-5d144e3d4948", "node_type": "1", "metadata": {}, "hash": "8c186ef73c501293852eef1b6249e2d327b8d466192bbddbbd018e894b731988", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4a22fb06-f827-4bd3-a09b-4a0f882e6e36", "node_type": "1", "metadata": {}, "hash": "c64523953d8d976efa1071b662a7aa85afc6df726c61060331fd46f01870a492", "class_name": "RelatedNodeInfo"}}, "text": "There can be many ways to organize the same data and sometimes one\nway is better than the other in some contexts. We will illustrate this several times in this\nchapter. A keen familiarity with the data structures and libraries discussed in this chapter\nis important for understanding the algorithms that use them in subsequent chapters.\nAs stated in the preface of this book, we assume that you are familiar with the basic data\nstructures listed in Section 2.2-2.3 and thus we will not review them in depth in this book\n(with exception of bitmask and Big Integer). Instead, we highlight the fact that there exist\nbuilt-in implementations for these elementary data structures in the C++ STL, Java API,\nand Python/OCaml Standard Library. If you feel that you are not entirely familiar with any\nof the terms or data structures mentioned in Section 2.2-2.3, please review those particular\nterms and concepts in the various reference books1 that cover them, including classics such as\nthe \u201cIntroduction to Algorithms\u201d [5], \u201cData Abstraction and Problem Solving\u201d [3, 48], \u201cData\nStructures and Algorithms\u201d [9], etc. Continue reading this book only when you understand\nat least the basic concepts behind these data structures.\nNote that for competitive programming, you only need to know enough about these data\nstructures to be able to select and to use the correct data structures for each given contest\nproblem. You should understand the strengths, weaknesses, and time/space complexities\nof typical data structures.\nThe theory behind them is de\ufb01nitely good reading, but can\noften be skipped or skimmed through, since the built-in libraries provide ready-to-use and\nhighly reliable implementations of otherwise complex data structures. This is not a good\npractice, but you will \ufb01nd that it is often su\ufb03cient. Many (younger) contestants have been\nable to utilize the e\ufb03cient C++ STL priority queue (Java PriorityQueue or Python\nheapq) to order a queue of items without understanding that the underlying data structure\n1Materials in Section 2.2-2.3 are usually covered in year one/two Data Structures CS curriculae. High\nschool students aspiring to take part in the IOI are encouraged to engage in independent study on them.\n53\n\n2.1.\nOVERVIEW AND MOTIVATION\nc\u20ddSteven, Felix, Suhendry\nis a (usually Binary) Heap; or use C++ STL unordered map/map (Java HashMap/TreeMap,\nPython dict/no equivalent version in Python, or OCaml Hashtbl) implementations to store\ndynamic collections of key-data pairs without an understanding that the underlying data\nstructure is a Hash Table/balanced Binary Search Tree, respectively.\nThis chapter is divided into three parts. Section 2.2 contains linear data structures and\nthe basic operations they support. The discussion of each data structure in Section 2.2 is\nbrief, with an emphasis on the important library routines that exist for manipulating the data\nstructures. However, two special data structures (bitmask and Big Integer) plus two special\ntopics on sorting and stack are discussed in more detail due to their important applications\nin Competitive Programming world. Section 2.3 covers non-linear data structures such as\n(Binary) Heaps, Hash Tables, (balanced) Binary Search Trees (BSTs), and Order Statistics\nTree, as well as their basic operations (using library routines) plus some extended operations\n(that require some modi\ufb01cations). Section 2.4 contains more data structures for which there\nexist no built-in implementations yet, and thus require us to build our own libraries. Section\n2.4 has a more in-depth discussion than Section 2.2-2.3.\nValue-Added Features of this Book\nAs this chapter is the \ufb01rst that dives into the heart of competitive programming, we will\nnow take the opportunity to highlight several value-added features of this book that you will\nsee in this and the following chapters.\nA key feature of this book is its accompanying collection of e\ufb03cient, fully-implemented\nexamples2 in C/C++, Java, Python, and/or OCaml that many other Computer Science\nbooks lack, stopping at the \u2018pseudo-code level\u2019 in their demonstration of data structures and\nalgorithms. This feature has been in the book since the very \ufb01rst edition (2010) and we\nalways strive to use the latest known implementation technique at the time of publication\nof those data structures and algorithms. The important parts of the source code especially\nfor Section 2.4 have been included in the book and the full source code is available in the\npublic GitHub repository of this book: https://github.com/stevenhalim/cpbook-code.", "mimetype": "text/plain", "start_char_idx": 204883, "end_char_idx": 209429, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4a22fb06-f827-4bd3-a09b-4a0f882e6e36": {"__data__": {"id_": "4a22fb06-f827-4bd3-a09b-4a0f882e6e36", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a2b41182-5217-4261-bf9d-d115c43d6299", "node_type": "1", "metadata": {}, "hash": "c3d4cc075582309623fca243cbf93709068ccece618ca36a34a86830f8d536b9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b2d38d6b-69fe-4bd0-bf05-389b1ba783cb", "node_type": "1", "metadata": {}, "hash": "d6baf7966efdf05e6ab73159bcf6c288df7b4c657a854d54f45c5f41f6783a5d", "class_name": "RelatedNodeInfo"}}, "text": "A key feature of this book is its accompanying collection of e\ufb03cient, fully-implemented\nexamples2 in C/C++, Java, Python, and/or OCaml that many other Computer Science\nbooks lack, stopping at the \u2018pseudo-code level\u2019 in their demonstration of data structures and\nalgorithms. This feature has been in the book since the very \ufb01rst edition (2010) and we\nalways strive to use the latest known implementation technique at the time of publication\nof those data structures and algorithms. The important parts of the source code especially\nfor Section 2.4 have been included in the book and the full source code is available in the\npublic GitHub repository of this book: https://github.com/stevenhalim/cpbook-code.\nThe reference to each source \ufb01le is indicated in the body text as a box like below.\nSource code: chx/[optional subfolder/]filename.cpp|java|py|ml\nAnother strength of this book is the collection of both (hundreds) written and (thousands)\nprogramming exercises (mostly supported by the (UVa) Online Judge [44] with uHunt inte-\ngration and Kattis Online Judge [34]). We also have lots of written exercises, classi\ufb01ed into\nnon-starred and starred ones. The non-starred written exercises are meant to be used mainly\nfor self-checking purposes; solutions are given at the back of each chapter. The starred writ-\nten exercises can be used for extra challenges; we do not provide solutions for these but may\ninstead provide some helpful hints.\nAnother important feature of this book is its close integration with our own VisuAlgo, a\nweb-based visualization and animation tool for many data structures and algorithms covered\nin this book [24]. We believe that these visualizations will be a huge bene\ufb01t to the visual\nlearners in our reader base. VisuAlgo is hosted at: https://visualgo.net. The reference\nto each visualization is included in the body text as a box like the one shown below.\nVisualization: https://visualgo.net/en/[name-of-the-module]\n2We strive to provide working implementations in as many programming languages as possible. However,\nsome data structure or algorithm implementation is only applicable for certain languages. Our primary\nprogramming language is C++. Note that as of year 2020, Python is slower than Java and (much) slower\nthan C++. Thus, we usually do not use Python to solve a (heavy) data structure problem.\n54\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.2\nLinear DS with Built-in Libraries\nA data structure is conceptually classi\ufb01ed as a linear data structure if its elements form a\nlinear sequence, i.e., its elements are arranged from left to right (or top to bottom). Mastery\nof these basic linear data structures below is critical in today\u2019s programming contests. We\ndivide this section into six sub-sections.\n2.2.1\nArray\nStatic (Fixed-size) Array\nLibrary:\nNative support in C/C++ and Java.\nNo built-in support for static array in Python.\nOCaml Array module (not resizeable).\nThis is the most commonly used data structure in programming contests. Whenever there\nis a collection of homogenous sequential data to be stored and later accessed using their\nindices, the static array is the most natural data structure to use. As the maximum input\nsize is usually mentioned in the problem statement, the array size can be declared to be the\nmaximum input size, with a small extra bu\u21b5er (sentinel) for safety\u2014to avoid the unnecessary\n\u2018o\u21b5by one\u2019 RTE.\nTypically, 1D and 2D arrays are used in programming contests (3D or higher dimensional\narrays are rare). Typical 1D array operations that will be discussed in more details soon\ninclude accessing elements by their indices, sorting elements, performing a linear scan on the\narray, or performing a binary search on a sorted array. Some interesting 2D array operations\ninclude rotating, transposing, or mirroring the 2D array.\nDynamic (Resizeable) Array\nLibrary:\nC++ STL vector.\nJava ArrayList (preferred in Competitive Programming, as it is faster) or Vector.\nPython list/array3.\nThis data structure is similar to the static array, except that it is designed to handle runtime\nresizing natively4. It is better to use a vector in place of an array if the size of the sequence\nof items is unknown at compile-time.\nUsually, we initialize the size (using custom constructor, reserve(), or resize()) with\nthe estimated (or maximum) size of the collection for better performance (to minimize dou-\nbling).", "mimetype": "text/plain", "start_char_idx": 208724, "end_char_idx": 213125, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b2d38d6b-69fe-4bd0-bf05-389b1ba783cb": {"__data__": {"id_": "b2d38d6b-69fe-4bd0-bf05-389b1ba783cb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4a22fb06-f827-4bd3-a09b-4a0f882e6e36", "node_type": "1", "metadata": {}, "hash": "c64523953d8d976efa1071b662a7aa85afc6df726c61060331fd46f01870a492", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c40dd641-061f-4420-b550-23ce55093235", "node_type": "1", "metadata": {}, "hash": "8d80d1a534458bf836e2648691b1184d50dcfdfdd8a534ac91af78c5dba5f805", "class_name": "RelatedNodeInfo"}}, "text": "Typical 1D array operations that will be discussed in more details soon\ninclude accessing elements by their indices, sorting elements, performing a linear scan on the\narray, or performing a binary search on a sorted array. Some interesting 2D array operations\ninclude rotating, transposing, or mirroring the 2D array.\nDynamic (Resizeable) Array\nLibrary:\nC++ STL vector.\nJava ArrayList (preferred in Competitive Programming, as it is faster) or Vector.\nPython list/array3.\nThis data structure is similar to the static array, except that it is designed to handle runtime\nresizing natively4. It is better to use a vector in place of an array if the size of the sequence\nof items is unknown at compile-time.\nUsually, we initialize the size (using custom constructor, reserve(), or resize()) with\nthe estimated (or maximum) size of the collection for better performance (to minimize dou-\nbling).\nTypical C++ STL vector operations used in competitive programming include\npush back(), at(), the [] operator, assign(), clear(), erase(), and iterators for\ntraversing the contents of vectors. You can also directly do lexicographical comparison\nof the values in two vectors using the ==, !=, <, <=, >, and >= operators if the underlying\ndata type has built-in comparison function (e.g., int, double, string, etc).\nIn the sample code at our public GitHub repository: https://github.com/stevenhalim/\ncpbook-code, we demonstrate a few of these resizeable array operations.\nSource code: ch2/lineards/resizeable array.cpp|java|py\n3Python array is not really needed as Python list is simpler to use.\n4The usual C++ vector implementation when it is full is to double its size and copy the content from\nthe old and full vector into a new, twice larger, vector. This retains O(1) amortized time complexity for\ncrucial vector operations, i.e., push back and [].\n55\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nSorting\nIt is appropriate to discuss two operations commonly performed on arrays: Sorting and\nSearching. These two operations are well supported in C/C++, Java, and Python.\nThere are many sorting algorithms mentioned in CS books [5, 3, 48, 9, 38, 51], e.g.,\n1. O(n2) comparison-based sorting algorithms: Bubble/Selection/Insertion Sort, etc.\nThese algorithms are (awfully) slow and usually avoided in programming contests,\nthough understanding them might help you solve a few speci\ufb01c problems, e.g., Insertion\nSort actually runs in O(n) when the input array is almost sorted.\n2. O(n log n) comparison-based sorting algorithms: Merge/Quick5/Heap Sort, etc.\nThese algorithms are the default choice in programming contests as an O(n log n) com-\nplexity is optimal for comparison-based sorting. Therefore, these sorting algorithms\nrun in the \u2018best possible\u2019 time in most cases (see below for special purpose sorting\nalgorithms). In addition, these algorithms are well-known and hence we do not need\nto \u2018reinvent the wheel\u20196\u2014we can simply use sort, stable sort, or partial sort\nin C++ STL algorithm (Java Collections.sort; Python sorted(list name) or\nlist name.sort(); OCaml List.sort compare list name) for basic sorting tasks.\nWe only need to specify the required comparison function (which can be a lambda\nexpression) and these e\ufb03cient sorting library routines will handle the rest.\nA simple sorting exercise using C++ STL sort library is shown below. In this exercise,\nwe are given a vector<int> A that contains n integers in random order. Our task is\nto sort A in decreasing (to be precise, in non-increasing if there are duplicates) order.\n// technique 1, create a custom comparison function\nbool cmp(const int a, const int b) {\nreturn a > b;\n}\n// inside int main()\nsort(A.begin(), A.end(), cmp);\n// technique 2, use an anonymous function (lambda expression)\nsort(A.begin(), A.end(), [](const int a, const int b) {\nreturn a > b;\n});\n// technique 3, use reverse iterator\nsort(A.rbegin(), A.rend());\n3. Special purpose sorting algorithms: O(n) Counting/Radix/Bucket Sort, etc.\nAlthough rarely used, these special purpose algorithms are good to know as they can\nreduce the required sorting time if the data has certain special characteristics, e.g.,\nCounting Sort and Radix Sort (see Section 2.2.2).\n5We refer to the randomized version of Quick Sort that has O(n log n) time complexity in expectation.", "mimetype": "text/plain", "start_char_idx": 212235, "end_char_idx": 216545, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c40dd641-061f-4420-b550-23ce55093235": {"__data__": {"id_": "c40dd641-061f-4420-b550-23ce55093235", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b2d38d6b-69fe-4bd0-bf05-389b1ba783cb", "node_type": "1", "metadata": {}, "hash": "d6baf7966efdf05e6ab73159bcf6c288df7b4c657a854d54f45c5f41f6783a5d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "62d527f0-310e-4f9a-89ce-a3fdd9d3296f", "node_type": "1", "metadata": {}, "hash": "3ebc08bb8a14ed0f88f25a21dd870c246a021561583087aca772a8ca331062be", "class_name": "RelatedNodeInfo"}}, "text": "// technique 1, create a custom comparison function\nbool cmp(const int a, const int b) {\nreturn a > b;\n}\n// inside int main()\nsort(A.begin(), A.end(), cmp);\n// technique 2, use an anonymous function (lambda expression)\nsort(A.begin(), A.end(), [](const int a, const int b) {\nreturn a > b;\n});\n// technique 3, use reverse iterator\nsort(A.rbegin(), A.rend());\n3. Special purpose sorting algorithms: O(n) Counting/Radix/Bucket Sort, etc.\nAlthough rarely used, these special purpose algorithms are good to know as they can\nreduce the required sorting time if the data has certain special characteristics, e.g.,\nCounting Sort and Radix Sort (see Section 2.2.2).\n5We refer to the randomized version of Quick Sort that has O(n log n) time complexity in expectation.\n6But sometimes we do need to \u2018reinvent the wheel\u2019, e.g., the Inversion Index problem in Section 2.2.2.\n56\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nIf you are interested to explore more details about various sorting algorithms, please visit\nVisuAlgo, Sorting visualization, select the sorting algorithm to be visualized, enter your own\nset of (small, not necessarily distinct) integers (in any order), and view the animation of the\nsorting algorithm steps. You can see a static snapshot of this visualization at Figure 2.1.\nFor the animation of the sorting visualization, please go to this URL:\nVisualization: https://visualgo.net/en/sorting\nFigure 2.1: Sorting Visualization, Example of First Partition of Quick Sort\nSearching\nThere are generally three common methods to search for an item in an array:\n1. O(n) Linear Search: Consider every item from index 0 to index n-1 (try to avoid this).\n2. O(log n) Binary Search: Use lower bound, upper bound, or binary search in C++\nSTL algorithm (Java Collections.binarySearch or Python bisect). If the input\narray is unsorted, it is necessary to sort the array at least once (using one of the\nO(n log n) sorting algorithms above) before executing one/many Binary Search(es).\n3. O(1) with Hashing: This is a useful technique to use when fast access to known values\nis required but the ordering of the values is not important. A few time critical problems\nmay need this O(1) hashing performance. We will discuss hashing/hash table in more\ndetails in Section 2.3 and in Book 2.\nIn the sample code, we demonstrate a few of these classic algorithms on array.\nSource code: ch2/lineards/array algorithms.cpp|java|py\nArray of Booleans\nLibrary:\nC++ STL bitset.\nJava BitSet.\nIf our array needs only to contain Boolean values (1/true and 0/false), we can use an alterna-\ntive data structure other than a plain array\u2014a C++ STL bitset (Java BitSet). This C++\nSTL bitset supports useful operations like reset(), set(), the [] operator and test().\nHowever if our array of Booleans is small (not more than 62 Booleans), it is bene\ufb01cial to\nuse bitmask data structure that is discussed in Section 2.2.3.\n57\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nExercise 2.2.1.1*: Sort the following array of N elements. Use built-in library if possible.\n1. N tuples (integer age \", string last name # (descending order), string \ufb01rst name \").\n2*. N fractions ( numerator\ndenominator) in \" (ascending order).\nExercise 2.2.1.2*: The partition algorithm of Quick Sort visualized in Figure 2.1 seems to\nput elements that are < p on the left side and elements that are \u2265p on the right side. Notice\nthat elements that are equal to p are always put on the right side in that implementation.\nProvide a test case such that a Quick Sort algorithm that uses such a partition algorithm to\nrun in O(n2) time, even with pivot randomization! Then, suggest a quick \ufb01x!\nExercise 2.2.1.3*: Suppose you are given an unsorted array S of n 32-bit signed integers.\nSolve each of the following tasks below with the best possible algorithms that you can think of\nand analyze their time complexities. Let\u2019s assume the following constraints: 1 \uf8ffn \uf8ff100K\nso that O(n2) solutions are theoretically infeasible in a contest environment.", "mimetype": "text/plain", "start_char_idx": 215787, "end_char_idx": 219814, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "62d527f0-310e-4f9a-89ce-a3fdd9d3296f": {"__data__": {"id_": "62d527f0-310e-4f9a-89ce-a3fdd9d3296f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c40dd641-061f-4420-b550-23ce55093235", "node_type": "1", "metadata": {}, "hash": "8d80d1a534458bf836e2648691b1184d50dcfdfdd8a534ac91af78c5dba5f805", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dbf4cbd1-7037-460a-948c-79cea6f16272", "node_type": "1", "metadata": {}, "hash": "2c564e3aa50a6c84d814ceb1675ffa5dd1b1735b529195e0d1c2fef546947b79", "class_name": "RelatedNodeInfo"}}, "text": "Exercise 2.2.1.2*: The partition algorithm of Quick Sort visualized in Figure 2.1 seems to\nput elements that are < p on the left side and elements that are \u2265p on the right side. Notice\nthat elements that are equal to p are always put on the right side in that implementation.\nProvide a test case such that a Quick Sort algorithm that uses such a partition algorithm to\nrun in O(n2) time, even with pivot randomization! Then, suggest a quick \ufb01x!\nExercise 2.2.1.3*: Suppose you are given an unsorted array S of n 32-bit signed integers.\nSolve each of the following tasks below with the best possible algorithms that you can think of\nand analyze their time complexities. Let\u2019s assume the following constraints: 1 \uf8ffn \uf8ff100K\nso that O(n2) solutions are theoretically infeasible in a contest environment.\n1. Determine if S contains one or more pairs of duplicate integers.\n2*. Given an integer v, \ufb01nd two integers a, b 2 S such that a + b = v.\n3*. Follow-up to Question 2: What if the given array S is already sorted?\n4*. Print the integers in S that fall between a range [a..b] (inclusive) in sorted order.\n5*. Determine the length of the longest increasing contiguous sub-array in S.\n6. Determine the median (50th percentile) of S. Assume that n is odd.\n7*. Find the item that appears > n/2 times in the array.\nExercise 2.2.1.4*: Suppose you are given a 2D square integer array A of size n \u21e5n. Solve\neach of the following tasks below with the best possible algorithms that you can think of\nand analyze their time complexities. Let\u2019s assume the following constraints: 1 \uf8ffn \uf8ff10K\nso that O(n2) solutions are feasible.\n1*. Rotate the 2D array 90 degrees (counter)clockwise.\n2*. Transpose the 2D array (switch rows and columns).\n3*. Mirror the 2D array along a certain x- (or y-) axis.\n58\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.2.2\nSpecial Sorting Problems\na. Inversion Index\nInversion index problem is de\ufb01ned as follows: Given a list of numbers, count the minimum\nnumber of \u2018bubble sort\u2019 swaps (swap between pair of consecutive items) that are needed to\nmake the list sorted in (usually ascending) order.\nFor example, if the content of the list is {3, 2, 1, 4}, we need 3 \u2018bubble sort\u2019 swaps to\nmake this list sorted in ascending order, i.e., swap (3, 2) to get {2, 3, 1, 4}, swap (3, 1) to\nget {2, 1, 3, 4}, and \ufb01nally swap (2, 1) to get {1, 2, 3, 4}.\nO(n2) solution\nThe most obvious solution is to count how many swaps are needed during the actual running\nof the O(n2) bubble sort algorithm, but this is clearly too slow.\nO(n log n) solution\nOne better O(n log n) Divide and Conquer solution for this inversion index problem is to\nmodify merge sort. During the merge process of merge sort, if the front of the right (sorted)\nsublist is taken \ufb01rst rather than the front of the left (sorted) sublist, we say that \u2018inversion\noccurs\u2019 and add inversion index counter by the size of the current left sublist (as all of the\ncurrent left sublist have to be swapped with the front of the right sublist). When merge sort\nis completed, we report the value of this counter. As we only add O(1) steps to merge sort,\nthis solution has the same time complexity as merge sort, i.e., O(n log n).\nOn the example above, we \ufb01rst have: {3, 2, 1, 4}. Merge sort will split this into sublist\n{3, 2} and {1, 4}. The left sublist will cause one inversion as we have to swap 3 and 2 to\nget {2, 3}. The right sublist {1, 4} will not cause any inversion as it is already sorted. Now,\nwe merge {2, 3} with {1, 4}.", "mimetype": "text/plain", "start_char_idx": 219017, "end_char_idx": 222525, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dbf4cbd1-7037-460a-948c-79cea6f16272": {"__data__": {"id_": "dbf4cbd1-7037-460a-948c-79cea6f16272", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "62d527f0-310e-4f9a-89ce-a3fdd9d3296f", "node_type": "1", "metadata": {}, "hash": "3ebc08bb8a14ed0f88f25a21dd870c246a021561583087aca772a8ca331062be", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4f49f486-d93d-4f73-beec-228e10ae1996", "node_type": "1", "metadata": {}, "hash": "32a93b9e1c9f841a59b63c17684088fed71b5c83347a0ca6f03b1c2003b48658", "class_name": "RelatedNodeInfo"}}, "text": "When merge sort\nis completed, we report the value of this counter. As we only add O(1) steps to merge sort,\nthis solution has the same time complexity as merge sort, i.e., O(n log n).\nOn the example above, we \ufb01rst have: {3, 2, 1, 4}. Merge sort will split this into sublist\n{3, 2} and {1, 4}. The left sublist will cause one inversion as we have to swap 3 and 2 to\nget {2, 3}. The right sublist {1, 4} will not cause any inversion as it is already sorted. Now,\nwe merge {2, 3} with {1, 4}. The \ufb01rst number to be taken is 1 from the front of the right\nsublist. We have two more inversions because the left sublist has two members: {2, 3} that\nboth have to be swapped with 1 (see Figure 2.2). There is no more inversion after this.\nTherefore, there are a total of 3 inversions for this example.\nFigure 2.2: Sorting Visualization, Example of the Merge Operation of Merge Sort\n59\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nb. Sorting in Linear Time\nGiven an (unsorted) array of n elements, can we sort them in O(n) time?\nTheoretical Limit\nIn general case, the lower bound of comparison-based sorting algorithm is \u2326(n log n) (see the\nproof using decision tree model in other references, e.g., [5]). However, if there is a special\nproperty about the n elements, we can have a faster, linear, O(n) sorting algorithm by not\ndoing comparison between elements. We will see two examples below.\nSolution(s)\nO(n + k) Counting Sort\nIf the array A contains n integers with small range [L..R] (e.g., \u2018human age\u2019 of [1..99]\nyears in UVa 11462 - Age Sort), we can use the Counting Sort algorithm. For the explanation\nbelow, assume that array A is {2a, 5, 2b, 2c, 3a, 3b}. The a/b/c subscript is to highlight stable\nsorting feature of Counting Sort that will be needed in the next subsection. The idea of\nCounting Sort is as follows:\n1. Prepare a \u2018frequency array\u2019 f with size k = R-L+1 and initialize f with zeroes.\nOn the example array above, we have L = 2, R = 5, and k = 4.\n2. We do one pass through array A and update the frequency of each integer that we see,\ni.e., 8i 2 [0..n-1], we do ++f[A[i]-L].\nOn the example array above, we have f[0] = 3, f[1] = 2, f[2] = 0, f[3] = 1.\nRemember: f[i] refers to the frequency of integer L+i; not the frequency of integer i.\n3. Once we know the frequency of each integers in that small range,\nwe compute the pre\ufb01x sums of each i, i.e., f[i] = f[i-1] + f[i] 8i 2 [1..k-1].\nNow, f[i] contains the number of elements less than or equal to i.\nOn the example array above, we have f[0] = 3, f[1] = 5, f[2] = 5, f[3] = 6.\n4. Next, go backwards from i = n-1 down to i = 0.\nWe place A[i] at index f[A[i]-L]-1 as it is the correct location for A[i].\nWe decrement f[A[i]-L] by one so that the next copy of A[i]\u2014if any\u2014will be placed\nright before the current A[i].\nOn the example array above, we \ufb01rst put A[5] = 3b in index f[A[5]-2]-1 = f[1]-1\n= 5-1 = 4 and decrement f[1] to 4.\nNext, we put A[4] = 3a\u2014the same value as A[5] = 3b but comes earlier in the input\u2014\nnow in index f[A[4]-2]-1 = f[1]-1 = 4-1 = 3 and decrement f[1] to 3.", "mimetype": "text/plain", "start_char_idx": 222036, "end_char_idx": 225103, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4f49f486-d93d-4f73-beec-228e10ae1996": {"__data__": {"id_": "4f49f486-d93d-4f73-beec-228e10ae1996", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dbf4cbd1-7037-460a-948c-79cea6f16272", "node_type": "1", "metadata": {}, "hash": "2c564e3aa50a6c84d814ceb1675ffa5dd1b1735b529195e0d1c2fef546947b79", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a92cd5b3-2750-480e-8458-d8827a917cc7", "node_type": "1", "metadata": {}, "hash": "e7463d5e1f3f8747f4a8355065b974a7ff10fc339dd9b175893659eb01e4700b", "class_name": "RelatedNodeInfo"}}, "text": "4. Next, go backwards from i = n-1 down to i = 0.\nWe place A[i] at index f[A[i]-L]-1 as it is the correct location for A[i].\nWe decrement f[A[i]-L] by one so that the next copy of A[i]\u2014if any\u2014will be placed\nright before the current A[i].\nOn the example array above, we \ufb01rst put A[5] = 3b in index f[A[5]-2]-1 = f[1]-1\n= 5-1 = 4 and decrement f[1] to 4.\nNext, we put A[4] = 3a\u2014the same value as A[5] = 3b but comes earlier in the input\u2014\nnow in index f[A[4]-2]-1 = f[1]-1 = 4-1 = 3 and decrement f[1] to 3.\nThen, we put A[3] = 2c in index f[A[3]-2]-1 = 2 and decrement f[0] to 2.\nWe repeat the next three steps until we obtain a sorted array: {2a, 2b, 2c, 3a, 3b, 5}.\nIf implemented correctly, Counting Sort is a stable sorting algorithm.\nThe time complexity of Counting Sort is O(n+k). When k = O(n), this algorithm theoreti-\ncally runs in linear time by not doing comparison of the integers. However, in programming\ncontest environment, usually k cannot be too large in order to avoid Memory Limit Ex-\nceeded. For example, Counting Sort will have problem sorting this array A with n = 3 that\ncontains {1, 1 000 000 000, 2} as it has large k.\n60\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nO(d \u21e5(n + k)) Radix Sort\nIf the array A contains n non-negative integers with relatively wide range [L..R] but it has\na relatively small number of digits, we can use the Radix Sort algorithm.\nThe idea of Radix Sort is simple. First, we make all integers have d digits\u2014where d is the\nlargest number of digits in the largest integer in A\u2014by appending zeroes if necessary. Then,\nRadix Sort will sort these integers digit by digit, starting with the least signi\ufb01cant digit to\nthe most signi\ufb01cant digit. To correctly sort n integers digit by digit, Radix Sort must use a\nstable sort algorithm as a sub-routine to sort the digits, such as the O(n + k) Counting Sort\nshown above. For example:\nInput\n| Append | Sort by the\n| Sort by the | Sort by the\n| Sort by the\nd = 4\n| Zeroes | fourth digit | third digit | second digit | first digit\n323\n| 0323\n| 032(2)\n| 00(1)3\n| 0(0)13\n| (0)013\n1257\n| 1257\n| 032(3)\n| 03(2)2\n| 1(2)57\n| (0)322\n13\n| 0013\n| 001(3)\n| 03(2)3\n| 0(3)22\n| (0)323\n322\n| 0322\n| 125(7)\n| 12(5)7\n| 0(3)23\n| (1)257\nFor an array of n d-digits integers, we will do an O(d) passes of Counting Sorts which\nhave time complexity of O(n + k) each. Therefore, the time complexity of Radix Sort is\nO(d \u21e5(n + k)). If we use Radix Sort for sorting n 32-bit signed integers (\u21e1d = 10 digits)\nand k = 10, this Radix Sort algorithm runs in O(10 \u21e5(n + 10)). It can still be considered\nas running in linear time but it has high constant factor.\nConsidering the hassle of writing the complex Radix Sort routine compared to calling the\nstandard O(n log n) C++ STL sort (Java Collections.sort, Python list name.sort(),\nor OCaml List.sort compare list name), this Radix Sort algorithm is rarely used in\nprogramming contests. So far, we only use this Radix + Counting Sort combo in our Su\ufb03x\nArray implementation (see Book 2).\nExercise 2.2.2.1*: In Section 2.4.3, we discuss the Fenwick Tree data structure.", "mimetype": "text/plain", "start_char_idx": 224599, "end_char_idx": 227699, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a92cd5b3-2750-480e-8458-d8827a917cc7": {"__data__": {"id_": "a92cd5b3-2750-480e-8458-d8827a917cc7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4f49f486-d93d-4f73-beec-228e10ae1996", "node_type": "1", "metadata": {}, "hash": "32a93b9e1c9f841a59b63c17684088fed71b5c83347a0ca6f03b1c2003b48658", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2228205c-6c56-4f82-8adc-cf2239eace53", "node_type": "1", "metadata": {}, "hash": "564cae44b26cc402f808e7000dffb24048fcc75c3a2c8eefa811f397f27a917d", "class_name": "RelatedNodeInfo"}}, "text": "If we use Radix Sort for sorting n 32-bit signed integers (\u21e1d = 10 digits)\nand k = 10, this Radix Sort algorithm runs in O(10 \u21e5(n + 10)). It can still be considered\nas running in linear time but it has high constant factor.\nConsidering the hassle of writing the complex Radix Sort routine compared to calling the\nstandard O(n log n) C++ STL sort (Java Collections.sort, Python list name.sort(),\nor OCaml List.sort compare list name), this Radix Sort algorithm is rarely used in\nprogramming contests. So far, we only use this Radix + Counting Sort combo in our Su\ufb03x\nArray implementation (see Book 2).\nExercise 2.2.2.1*: In Section 2.4.3, we discuss the Fenwick Tree data structure.\nThe\nInversion Index problem mentioned in this section can also be solved in O(n log n) using\nFenwick Tree. Show how to do it!\nExercise 2.2.2.2*: What should we do if we want to use Radix Sort but the array A contains\n(at least one) negative number(s)?\nExercise 2.2.2.3*: In the discussion above, we show Radix Sort using radix (base) 10 (digit\nby digit). Actually, we can use di\u21b5erent (larger) radix (base) to minimize O(d \u21e5(n + k)).\nWhat is the appropriate radix (base) to solve Kattis - magicsequence?\n61\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.2.3\nBitmask\nLibrary: Native support in C/C++, Java, and Python.\nBitmasks a.k.a. lightweight, small sets of Booleans has native support in most programming\nlanguages. An integer is stored in computer memory as a sequence/string of bits. Thus, we\ncan use integers to represent a lightweight small set of Boolean values. All set operations\nthen involve only the bitwise manipulation of the corresponding integer, which makes it a\nmuch more e\ufb03cient choice when compared with the C++ STL vector<bool>, bitset,\nor set<int> options, especially when used as a parameter of a recursive (or Dynamic\nProgramming) algorithm (see Book 2). Such speed is important in competitive programming.\nSome important bitmask operations are shown below. All are O(1) operations.\n1. Representation: A 32 (or 64)-bit signed integer for up to 32 (or 64) items7. Without\nloss of generality, all examples below use a 32-bit signed integer called S.\nExample:\n5| 4| 3| 2| 1| 0 <- 0-based indexing from right\n32|16| 8| 4| 2| 1 <- power of 2\nS = 34 (base 10) = 1| 0| 0| 0| 1| 0 (base 2)\nF| E| D| C| B| A <- alternative alphabet label\nIn the example above, the integer S = 34 or 100010 in binary also represents a small\nset {1, 5} with a 0-based indexing scheme in increasing digit signi\ufb01cance (or {B, F}\nusing the alternative alphabet label) because the second and the sixth bits (counting\nfrom the right) of S are on.\n2. To multiply/divide an integer by 2, we only need to shift all8 bits in the integer\nleft/right, respectively. This operation (especially the shift left operation) is important\nfor the next few examples below. Notice that the truncation in the shift right operation\nautomatically rounds the division-by-2 down, e.g., 17/2 = 8.\nS\n= 34 (base 10) =\n100010 (base 2)\nS = S<<1 = S*2 = 68 (base 10) = 1000100 (base 2)\nS = S>>2 = S/4 = 17 (base 10) =\n10001 (base 2)\nS = S>>1 = S/2 =\n8 (base 10) =\n1000 (base 2) <- LSB is gone\n(LSB = Least Significant Bit)\n3. To set/turn on the j-th item (0-based indexing) of the set,\nuse the bitwise OR operation S |= (1<<j).", "mimetype": "text/plain", "start_char_idx": 227019, "end_char_idx": 230313, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2228205c-6c56-4f82-8adc-cf2239eace53": {"__data__": {"id_": "2228205c-6c56-4f82-8adc-cf2239eace53", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a92cd5b3-2750-480e-8458-d8827a917cc7", "node_type": "1", "metadata": {}, "hash": "e7463d5e1f3f8747f4a8355065b974a7ff10fc339dd9b175893659eb01e4700b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5c10c372-7baa-4d65-8af0-3437081adb09", "node_type": "1", "metadata": {}, "hash": "478e925ed991ba597b19abf04d5e392a520315421dae248bdb34168f6745a725", "class_name": "RelatedNodeInfo"}}, "text": "This operation (especially the shift left operation) is important\nfor the next few examples below. Notice that the truncation in the shift right operation\nautomatically rounds the division-by-2 down, e.g., 17/2 = 8.\nS\n= 34 (base 10) =\n100010 (base 2)\nS = S<<1 = S*2 = 68 (base 10) = 1000100 (base 2)\nS = S>>2 = S/4 = 17 (base 10) =\n10001 (base 2)\nS = S>>1 = S/2 =\n8 (base 10) =\n1000 (base 2) <- LSB is gone\n(LSB = Least Significant Bit)\n3. To set/turn on the j-th item (0-based indexing) of the set,\nuse the bitwise OR operation S |= (1<<j).\nS = 34 (base 10) = 100010 (base 2)\nj = 3, 1<<j\n= 001000 <- bit \u20181\u2019 is shifted to the left 3 times\n-------- OR (true if either of the bits is true)\nS = 42 (base 10) = 101010 (base 2) // update S to this new value 42\n7To avoid issues with the two\u2019s complement representation, use a 32-bit/64-bit signed integer to represent\nbitmasks of up to 30/62 items only, respectively.\n8Most CPUs can do this bit shifting operation in O(1), much faster than O(k) where k is the number of\nbits in the integer.\n62\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nFigure 2.3: Bitmask Visualization, Example of CheckBit(j) Operation\n4. To check if the j-th item of the set is on,\nuse the bitwise AND operation T = S & (1<<j).\nIf T = 0, then the j-th item of the set is o\u21b5.\nIf T != 0 (to be precise, T = (1<<j)), then the j-th item of the set is on.\nSee Figure 2.3 for one such example.\nS = 42 (base 10) = 101010 (base 2)\nj = 3, 1<<j\n= 001000 <- bit \u20181\u2019 is shifted to the left 3 times\n-------- AND (only true if both bits are true)\nT = 8 (base 10)\n= 001000 (base 2) -> not zero, the 3rd item is on\nS = 42 (base 10) = 101010 (base 2)\nj = 2, 1<<j\n= 000100 <- bit \u20181\u2019 is shifted to the left 2 times\n-------- AND\nT = 0 (base 10)\n= 000000 (base 2) -> zero, the 2nd item is off\n5. To clear/turn o\u21b5the j-th item of the set,\nuse9 the bitwise AND operation S &= \u21e0(1<<j).\nS = 42 (base 10) = 101010 (base 2)\nj = 1, ~(1<<j)\n= 111101 <- \u2018~\u2019 is the bitwise NOT operation\n-------- AND\nS = 40 (base 10) = 101000 (base 2) // update S to this new value 40\n6. To toggle (\ufb02ip the status of) the j-th item of the set,\nuse the bitwise XOR operation S ^= (1<<j).\nS = 40 (base 10) = 101000 (base 2)\nj = 2, (1<<j)\n= 000100 <- bit \u20181\u2019 is shifted to the left 2 times\n-------- XOR <- true if both bits are different\nS = 44 (base 10) = 101100 (base 2) // update S to this new value 44\nS = 40 (base 10) = 101000 (base 2)\nj = 3, (1<<j)\n= 001000 <- bit \u20181\u2019 is shifted to the left 3 times\n-------- XOR <- true if both bits are different\nS = 32 (base 10) = 100000 (base 2) // update S to this new value 32\n9Use parentheses when doing bit manipulation to avoid accidental bugs due to operator precedence.\n63\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n7.", "mimetype": "text/plain", "start_char_idx": 229772, "end_char_idx": 232555, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c10c372-7baa-4d65-8af0-3437081adb09": {"__data__": {"id_": "5c10c372-7baa-4d65-8af0-3437081adb09", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2228205c-6c56-4f82-8adc-cf2239eace53", "node_type": "1", "metadata": {}, "hash": "564cae44b26cc402f808e7000dffb24048fcc75c3a2c8eefa811f397f27a917d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d564279a-159a-49ed-95de-6c89d7e5ea8f", "node_type": "1", "metadata": {}, "hash": "0e8e561a9310c8c66dd739c191e16fa72b42caba6a2d8f7ad739435fcdf9adb6", "class_name": "RelatedNodeInfo"}}, "text": "63\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n7. To get the value of the least signi\ufb01cant bit of S that is on (\ufb01rst from the right),\nuse T = ((S) & -(S)). This operation is abbreviated as LSOne(S)10.\nS\n=\n40 (base 10) =\n000...000101000 (32 bits, base 2)\n-S\n= -40 (base 10) =\n111...111011000 (two\u2019s complement)\n----------------- AND\nT\n=\n8 (base 10) =\n000...000001000 (3rd bit from right is on)\nNotice that T = LSOne(S) is a power of 2, i.e., 2j.\nTo get the actual index j (from the right), we can use\nbuiltin ctz(T) below.\n8. To turn on all bits in a set of size n, use S = (1<<n) - 1\nExample for n = 3\nS+1 = 8 (base 10) = 1000 <- bit \u20181\u2019 is shifted to left 3 times\n1\n------ -\nS\n= 7 (base 10) =\n111 (base 2)\n9. To enumerate all proper subsets of a given a bitmask, e.g., if mask = (18)10 = (10010)2,\nthen its proper subsets are {(18)10 = (10010)2, (16)10 = (10000)2, (2)10 = (00010)2},\nwe can use:\nint mask = 18;\nfor (int subset = mask; subset; subset = (mask & (subset-1)))\ncout << subset << \"\\n\";\n10. Finally, we highlight two important GNU C++ compiler11 built-in bit manipulation\nfunctions12:\nbuiltin popcount(S) to count how many bits that are on in S and\nbuiltin ctz(S) to count how many trailing zeroes in S.\n__builtin_popcount(32)\n// 100000 (base 2), only 1 bit is on\n__builtin_popcount(30)\n//\n11110 (base 2), 4 bits are on\n__builtin_popcountl((1l<<62)-1l) // 2^62-1 has 62 bits on (near limit)\n__builtin_ctz(32)\n// 100000 (base 2), 5 trailing zeroes\n__builtin_ctz(30)\n//\n11110 (base 2), 1 trailing zero\n__builtin_ctzl(1l<<62)\n// 2^62 has 62 trailing zeroes\nPlease visit VisuAlgo, Bitmask visualization, to enter your own (small) integer (in Decimal),\nsee the corresponding binary representation of that integer, and perform various bit ma-\nnipulation operations on them. We also demonstrate these bit manipulation operations in\nour sample code below. Many bit manipulation operations are written as (slightly faster)\npreprocessor macros in our C/C++ example source code (but written as normal functions\nin our Java/Python/OCaml example code).\nVisualization: https://visualgo.net/en/bitmask\nSource code: ch2/lineards/bit manipulation.cpp|java|py|ml\n10This LSOne(S) operation is quite versatile and is used several times in this book.\n11Java has Integer class that has these functionalities too, e.g., bitCount, numberOfTrailingZeros.\n12Notice the di\u21b5erence between the 32-bit and the 64-bit versions.\n64\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nExercise 2.2.3.1: There are several other \u2018cool\u2019 techniques possible with bit manipulation\ntechniques but these are rarely used. Please implement these tasks with bit manipulation:\n1. Obtain the remainder (modulo) of S when it is divided by N (N is a power of 2)\ne.g., S = (7)10 % (4)10 = (111)2 % (100)2 = (11)2 = (3)10.\n2. Determine if S is a power of 2.\ne.g., S = (7)10 = (111)2 is not a power of 2, but (8)10 = (1000)2 is a power of 2.\n3. Turn o\u21b5the last one in S, e.g., S = (40)10 = (101000)2 ! S = (32)10 = (100000)2.\n4. Turn on the last zero in S, e.g., S = (41)10 = (101001)2 !", "mimetype": "text/plain", "start_char_idx": 232484, "end_char_idx": 235570, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d564279a-159a-49ed-95de-6c89d7e5ea8f": {"__data__": {"id_": "d564279a-159a-49ed-95de-6c89d7e5ea8f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5c10c372-7baa-4d65-8af0-3437081adb09", "node_type": "1", "metadata": {}, "hash": "478e925ed991ba597b19abf04d5e392a520315421dae248bdb34168f6745a725", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "04c3c39d-0dea-46c0-bfd4-cff92937b41a", "node_type": "1", "metadata": {}, "hash": "afc8b891b00a5001d7bec8ac8c5411d2532360b8219b838beb6a25d7c3c24cfa", "class_name": "RelatedNodeInfo"}}, "text": "Please implement these tasks with bit manipulation:\n1. Obtain the remainder (modulo) of S when it is divided by N (N is a power of 2)\ne.g., S = (7)10 % (4)10 = (111)2 % (100)2 = (11)2 = (3)10.\n2. Determine if S is a power of 2.\ne.g., S = (7)10 = (111)2 is not a power of 2, but (8)10 = (1000)2 is a power of 2.\n3. Turn o\u21b5the last one in S, e.g., S = (40)10 = (101000)2 ! S = (32)10 = (100000)2.\n4. Turn on the last zero in S, e.g., S = (41)10 = (101001)2 ! S = (43)10 = (101011)2.\n5. Turn o\u21b5the last consecutive run of ones in S\ne.g., S = (39)10 = (100111)2 ! S = (32)10 = (100000)2.\n6. Turn on the last consecutive run of zeroes in S\ne.g., S = (36)10 = (100100)2 ! S = (39)10 = (100111)2.\n7*. Solve UVa 11173 - Grey Codes with a one-liner bit manipulation expression for each\ntest case, i.e., \ufb01nd the k-th Gray code.\n8*. Let\u2019s reverse the UVa 11173 problem above. Given a gray code, \ufb01nd its position k\nusing bit manipulation.\nPro\ufb01le of Data Structure Inventor\nGeorge Boole (1815-1864) was an English mathematician, philosopher, and logician. He is\nbest known to Computer Scientists as the founder of Boolean logic, the foundation of modern\ndigital computers. Boole is regarded as the founder of the \ufb01eld of Computer Science.\n65\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.2.4\nBig Integer (Python & Java)\nWhen the intermediate and/or the \ufb01nal result of an integer-based mathematical computa-\ntion cannot be stored inside the largest built-in integer data type and the given problem\ncannot be solved with any prime-power factorization or modular arithmetic techniques (see\nthe details in Book 2), we have no choice but to resort to Big Integer (a.k.a. bignum) li-\nbraries. An example: compute the precise value of 40! (the factorial of 40). The result is\n815 915 283 247 897 734 345 611 269 596 115 894 272 000 000 000 (48 digits). This is clearly too\nlarge to \ufb01t in a 64-bit C/C++ unsigned long long13, Java long14, or OCaml Int64.\nOne way to implement Big Integer library is to store the Big Integer as a (long) string15.\nFor example, we can store 1021 inside a string num1 = \u201c1,000,000,000,000,000,000,000\u201d with-\nout any problem whereas this is already over\ufb02ow in a 64-bit C/C++ unsigned long long,\nJava long, or OCaml Int64. Then, for common mathematical operations, we can use digit\nby digit operations to process the two Big Integer operands. For example, with num2 =\n\u201c173\u201d, we can compute num1 + num2 as:\nnum1\n=\n1,000,000,000,000,000,000,000\nnum2\n=\n173\n------------------------------- +\nnum1 + num2 =\n1,000,000,000,000,000,000,173\nWe can also compute num1 * num2 as:\nnum1\n=\n1,000,000,000,000,000,000,000\nnum2\n=\n173\n------------------------------ *\n3,000,000,000,000,000,000,000\n70,000,000,000,000,000,000,00\n100,000,000,000,000,000,000,0\n------------------------------- +\nnum1 * num2 = 173,000,000,000,000,000,000,000\nAddition and subtraction are the two simplest operations in Big Integer. Multiplication takes\na bit more programming, as seen in the example above. Implementing e\ufb03cient division and\nraising an integer to a certain power (see details in Book 2) are more complicated.", "mimetype": "text/plain", "start_char_idx": 235114, "end_char_idx": 238227, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04c3c39d-0dea-46c0-bfd4-cff92937b41a": {"__data__": {"id_": "04c3c39d-0dea-46c0-bfd4-cff92937b41a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d564279a-159a-49ed-95de-6c89d7e5ea8f", "node_type": "1", "metadata": {}, "hash": "0e8e561a9310c8c66dd739c191e16fa72b42caba6a2d8f7ad739435fcdf9adb6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6e6fb7b4-caf7-41dc-914c-335ef093838b", "node_type": "1", "metadata": {}, "hash": "9e9c5cc95747aa8c2834e192072a4b80909a299dabf8b8461e2be62bff38b976", "class_name": "RelatedNodeInfo"}}, "text": "Multiplication takes\na bit more programming, as seen in the example above. Implementing e\ufb03cient division and\nraising an integer to a certain power (see details in Book 2) are more complicated. Coding\nthese library routines in C/C++ (or OCaml) under a stressful contest environment can\nbe a buggy a\u21b5air, even if we can bring notes containing such C/C++ library in ICPC16.\nFortunately, Python has native support and Java has a BigInteger class that we can use for\nthis purpose. As of year 2020, the C++ STL does not17 have such a feature and thus it is a\ngood idea to use Python or Java to deal with these Big Integer problems.\n13GCC has a 128-bit integer type\nint128 but it won\u2019t help here.\n14Note that Java long is a 64-bit signed integer that ranges from [-263..263-1]. To deal with 64-bit unsigned\nintegers in Java, we have no choice but to use Java BigInteger.\n15Actually, a primitive data type also stores numbers as limited strings of bits in computer memory. For\nexample, a 32-bit int data type stores an integer as 32 bits of binary. The basic Big Integer technique is\njust a generalization of this technique that uses decimal form (base 10) and longer strings of digits. Note:\nJava BigInteger class and Python likely use more e\ufb03cient methods than the one shown in this section.\n16Good news for IOI contestants. IOI tasks usually do not require contestants to deal with Big Integer.\n17Pure C++ users must built own custom Big Integer data structure.\n66\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nPython\u2019s native support for Big Integer makes it the most preferred programming lan-\nguage to solve Big Integer problems as illustrated in this section.\nJava route is just slightly longer. The Java BigInteger (we abbreviate it as BI) class\nsupports basic integer operations: addition \u2014 add(BI), subtraction \u2014 subtract(BI), mul-\ntiplication \u2014 multiply(BI), power \u2014 pow(int exponent), division \u2014 divide(BI), re-\nmainder \u2014 remainder(BI), modulo \u2014 mod(BI) (di\u21b5erent from remainder(BI)), division\nand remainder \u2014 divideAndRemainder(BI), and a few other interesting functions discussed\nlater. All are just \u2018one liner\u2019.\nHowever, we need to remark that all Big Integer operations are inherently slower than\nthe same operations on standard 32/64-bit integer data types. Rule of Thumb: if you can use\nanother algorithm that only requires built-in integer data type to solve your mathematical\nproblem, then use it instead of resorting to Big Integer. Note that by year 2020, Big Integer\nproblems are less frequent than in the previous decade as more problem authors prefer to\nuse the fast modular arithmetic techniques instead (see the details in Book 2).\nFor those who are new to Python or Java BigInteger class, we provide the following\nshort Python and Java code, which is the solution for UVa 10925 - Krakovia. This problem\nrequires Big Integer addition (to sum N large bills) and division (to divide the large sum to\nF friends). Observe how short and clear the code is compared to if you have to write your\nown Big Integer routines.\nFirst, we show the short Python code. Notice that in our Python code, we read all inputs\n\ufb01rst into memory to speed up the execution (see Section 3.2.3).\nimport sys\ninputs = sys.stdin.read().splitlines()\n# make Python I/O faster\ncaseNo = 1\nln = 0\nwhile True:\nN, F = map(int, inputs[ln].split())\n# N bills, F friends\nln += 1\nif N == 0 and F == 0: break\nsum = 0\n# native support\nfor _ in range(N):\n# sum the N large bills\nsum += int(inputs[ln])\n# native Big Integer\nln += 1\nprint(\"Bill #%d costs %d: each friend should pay %d\\n\"\n% (caseNo, sum, sum//F))\n# integer division\ncaseNo += 1\n67\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nNext, we present the slightly longer Java code (but still much shorter than if we have to write\nour own Big Integer routine in C++). In our code, we use the fast Java I/O: Bu\u21b5eredReader\nand PrintWriter instead of Scanner and System.out.println.\nimport java.io.*;\nimport java.util.", "mimetype": "text/plain", "start_char_idx": 238035, "end_char_idx": 242021, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6e6fb7b4-caf7-41dc-914c-335ef093838b": {"__data__": {"id_": "6e6fb7b4-caf7-41dc-914c-335ef093838b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "04c3c39d-0dea-46c0-bfd4-cff92937b41a", "node_type": "1", "metadata": {}, "hash": "afc8b891b00a5001d7bec8ac8c5411d2532360b8219b838beb6a25d7c3c24cfa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5e3bb644-fe1a-43e5-b19a-051a233098d0", "node_type": "1", "metadata": {}, "hash": "79517477f207d866bc8c4c1cc932c7e16a7383e098f706bb9c2e2557d5a052ac", "class_name": "RelatedNodeInfo"}}, "text": "LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nNext, we present the slightly longer Java code (but still much shorter than if we have to write\nour own Big Integer routine in C++). In our code, we use the fast Java I/O: Bu\u21b5eredReader\nand PrintWriter instead of Scanner and System.out.println.\nimport java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\n// in package java.math\nclass Main {\n// UVa 10925 - Krakovia\npublic static void main(String[] args) throws Exception {\nBufferedReader br = new BufferedReader(\n// use BufferedReader\nnew InputStreamReader(System.in));\nPrintWriter pw = new PrintWriter(\n// and PrintWriter\nnew BufferedWriter(new OutputStreamWriter(System.out))); // = fast IO\nint caseNo = 0;\nwhile (true) {\nStringTokenizer st = new StringTokenizer(br.readLine());\nint N = Integer.parseInt(st.nextToken());\n// N bills\nint F = Integer.parseInt(st.nextToken());\n// F friends\nif (N == 0 && F == 0) break;\nBigInteger sum = BigInteger.ZERO;\n// built-in constant\nfor (int i = 0; i < N; ++i) {\n// sum the N large bills\nBigInteger V = new BigInteger(br.readLine()); // string constructor\nsum = sum.add(V);\n// BigInteger addition\n}\npw.printf(\"Bill #%d costs \", ++caseNo);\npw.printf(sum.toString());\npw.printf(\": each friend should pay \");\npw.printf(sum.divide(BigInteger.valueOf(F)).toString());\npw.printf(\"\\n\\n\");\n// divide to F friends\n}\npw.close();\n}\n}\nSource code: ch2/lineards/UVa10925.java|py\nExercise 2.2.4.1: Compute the last non zero digit of 25!; can we use built-in data types?\nExercise 2.2.4.2: Check if 25! is divisible by 9317; can we use built-in data types?\nExercise 2.2.4.2*: As of year 2020, programming contest problems involving arbitrary pre-\ncision decimal numbers (not necessarily integers) are still rare. Solve UVa 10464, UVa 11821,\nand UVa 12930 problems using another library: Java BigDecimal class! See https://docs.\noracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html.\n68\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.2.5\nLinked Data Structures\nLinked List\nLibrary:\nC++ STL list or forward list18.\nJava LinkedList.\nPython list.\nOCaml List module.\nAlthough this data structure almost always appears in data structure and algorithm text-\nbooks, the Linked List is usually avoided in typical (contest) problems. This is due to the\nine\ufb03ciency in accessing items (a linear scan has to be performed from the head or the tail of\na list) and the usage of pointers makes it prone to runtime errors if not implemented prop-\nerly. In this book, almost all forms of Linked List have been replaced by the more \ufb02exible19\nC++ STL vector, Java ArrayList, or Python list.\nThe few exceptions are UVa 11988 - Broken Keyboard (a.k.a. Beiju Text)\u2014where you\nare required to dynamically maintain a (linked) list of characters and e\ufb03ciently insert a new\ncharacter anywhere in the list, i.e., at front (head), current, or back (tail) of the (linked) list,\nKattis - joinstrings, Kattis - sim, and Kattis - teque. Out of \u21e13458 UVa/Kattis problems\nthat the authors have solved, these few problems are the rare linked list problem we have\nencountered thus far\u2014some are our own proposed problems.\nStack\nLibrary:\nC++ STL stack.\nJava Stack.\nPython list.\nOCaml List/Stack module.\nA stack can be viewed as a \u2018restricted list\u2019 that only allows for insertion (push) and\ndeletion (pop) from the top. This behavior is usually referred to as Last In First Out (LIFO)\nand is reminiscent of literal stacks in the real world.\nTypical C++ STL stack operations include push()/pop() (insert/remove from the top\nof stack), top() (obtain content from the top of stack), and empty(). All stack operations\nare very e\ufb03cient, i.e., in O(1).", "mimetype": "text/plain", "start_char_idx": 241681, "end_char_idx": 245370, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e3bb644-fe1a-43e5-b19a-051a233098d0": {"__data__": {"id_": "5e3bb644-fe1a-43e5-b19a-051a233098d0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6e6fb7b4-caf7-41dc-914c-335ef093838b", "node_type": "1", "metadata": {}, "hash": "9e9c5cc95747aa8c2834e192072a4b80909a299dabf8b8461e2be62bff38b976", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "72062330-c47b-437f-8883-1369d75e870d", "node_type": "1", "metadata": {}, "hash": "a4563a3c2eee0e8cba3137c249ec3064e10bf4157cc50561c9da15db29bee8d0", "class_name": "RelatedNodeInfo"}}, "text": "Out of \u21e13458 UVa/Kattis problems\nthat the authors have solved, these few problems are the rare linked list problem we have\nencountered thus far\u2014some are our own proposed problems.\nStack\nLibrary:\nC++ STL stack.\nJava Stack.\nPython list.\nOCaml List/Stack module.\nA stack can be viewed as a \u2018restricted list\u2019 that only allows for insertion (push) and\ndeletion (pop) from the top. This behavior is usually referred to as Last In First Out (LIFO)\nand is reminiscent of literal stacks in the real world.\nTypical C++ STL stack operations include push()/pop() (insert/remove from the top\nof stack), top() (obtain content from the top of stack), and empty(). All stack operations\nare very e\ufb03cient, i.e., in O(1).\nThis data structure is often used as part of algorithms that solve certain problems,\ne.g., bracket (parenthesis) matching in Section 2.2.6, Post\ufb01x calculator and In\ufb01x to Post\ufb01x\nconversion also in Section 2.2.6, \ufb01nding Strongly Connected Components (SCCs) in Section\n4.2.10, and part of Graham\u2019s scan algorithm in Book 2.\nQueue\nLibrary:\nC++ STL queue.\nJava Queue (interface20).\nPython list.\nOCaml Queue module.\n18This forward list library is very rarely used as its space saving feature is not usually needed.\n19OCaml does not have built-in resizeable array.\n20The Java Queue is only an interface that is usually instantiated with Java LinkedList.\n69\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nA queue can be viewed as another \u2018restricted list\u2019 that only allows for insertion (enqueue)\nfrom the back (tail) and deletion (dequeue) from the front (head). This behavior is similarly\nreferred to as First In First Out (FIFO), just like actual queues in the real world.\nTypical C++ STL queue operations include push()/pop() (insert from back/remove\nfrom front of queue), front()/back() (obtain content from the front/back of queue), and\nempty(). All queue operations are also very e\ufb03cient, i.e., in O(1).\nThis data structure is used in algorithms like Breadth First Search (BFS) in Section 4.2.3\nand certain FIFO simulations.\nDouble-ended Queue (Deque)\nLibrary:\nC++ STL deque.\nJava Deque (interface21).\nPython deque.\nNo built-in support for deque in OCaml.\nThis data structure is very similar to queue above, except that deque supports fast O(1)\ninsertions and deletions at both the beginning and the end of the deque.\nTypical C++ STL deque operations include push back(), pop front() (just like the\nnormal queue), but now with addition of push front() and pop back() (speci\ufb01c for deque).\nMost deque operations are also very e\ufb03cient, i.e., in O(1). Note that C++ STL deque is not\nimplemented using Doubly Linked List and it also has fast O(1) random access capability,\ni.e., the at() or [] operators. This way, you can view C++ STL deque as a more \ufb02exible\u2013\nalbeit slightly slower\u2013version of C++ STL vector.\nThis data structure is important in certain algorithms, e.g., the special BFS to solve\nthe SSSP problem on 0/1-Weighted Graph in Section 4.4.2 and inside some Sliding Window\nalgorithm variants in Book 2.\nIf you are interested to explore more details about Linked List and its variants, please visit\nVisuAlgo, Linked List visualization. You will see that the four recent data structures: (Singly\nor Doubly) Linked List, Stack, Queue, Deque are actually closely related. The URL for the\nLinked List visualization and source code example are shown below.\nVisualization: https://visualgo.net/en/list\nSource code: ch2/lineards/list.cpp|java|py|ml\nExercise 2.2.5.1*: We can also use a resizeable array (C++ STL vector/Java ArrayList)\nto implement an e\ufb03cient22 stack. Figure out how to achieve this. Follow up question: Can\nwe use a static array, linked list, or deque instead? Why or why not?\nExercise 2.2.5.2*: We can use a linked list (C++ STL list or Java LinkedList) to\nimplement an e\ufb03cient23 queue (or deque).\nFigure out how to achieve this.", "mimetype": "text/plain", "start_char_idx": 244668, "end_char_idx": 248535, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "72062330-c47b-437f-8883-1369d75e870d": {"__data__": {"id_": "72062330-c47b-437f-8883-1369d75e870d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5e3bb644-fe1a-43e5-b19a-051a233098d0", "node_type": "1", "metadata": {}, "hash": "79517477f207d866bc8c4c1cc932c7e16a7383e098f706bb9c2e2557d5a052ac", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "53f0463a-e472-49c2-a787-599301a971b4", "node_type": "1", "metadata": {}, "hash": "fab87fe65986a65b4c8689f2bb41f65d84a9df5297e6637ce0cc346088eeceeb", "class_name": "RelatedNodeInfo"}}, "text": "You will see that the four recent data structures: (Singly\nor Doubly) Linked List, Stack, Queue, Deque are actually closely related. The URL for the\nLinked List visualization and source code example are shown below.\nVisualization: https://visualgo.net/en/list\nSource code: ch2/lineards/list.cpp|java|py|ml\nExercise 2.2.5.1*: We can also use a resizeable array (C++ STL vector/Java ArrayList)\nto implement an e\ufb03cient22 stack. Figure out how to achieve this. Follow up question: Can\nwe use a static array, linked list, or deque instead? Why or why not?\nExercise 2.2.5.2*: We can use a linked list (C++ STL list or Java LinkedList) to\nimplement an e\ufb03cient23 queue (or deque).\nFigure out how to achieve this.\nFollow up\nquestion: Can we use a resizeable array instead? Why or why not?\nExercise 2.2.5.3*: How to implement an e\ufb03cient24 queue using two resizeable arrays?\n21The Java Deque is also an interface that is usually instantiated with Java LinkedList.\n22Where all operations remain O(1).\n23Where all operations remain O(1).\n24Where all operations remain O(1) in amortized sense.\n70\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.2.6\nSpecial Stack-based Problems\na. Bracket (Parenthesis) Matching\nProgrammers are very familiar with various form of braces: \u2018()\u2019 (parentheses), \u2018[]\u2019 (square\nbrackets), \u2018{}\u2019 (curly braces), etc as they use braces quite often in their code especially\nwhen dealing with if statements and loops. Braces can be nested and/or mixed, e.g., \u2018(())\u2019,\n\u2018{{}}\u2019, \u2018[[]]\u2019, \u2018([])\u2019, etc. A well-formed code must have a matched set of braces. The Bracket\n(Parenthesis) Matching problem usually involves a question on whether a given set of braces\nis properly nested. For example, \u2018(())\u2019, \u2018({})\u2019, \u2018(){}[]\u2019 are correctly matched braces whereas\n\u2018(()\u2019, \u2018(}\u2019, \u2018)(\u2019 are not correctly matched.\nO(n) with Stack\nWe read the brackets one by one from left to right. Every time we encounter a close bracket,\nwe need to match it with the latest open bracket (of the same type). This matched pair is\nthen removed from consideration and the process is continued. This requires a \u2018Last In First\nOut\u2019 data structure: a Stack (see Section 2.2.5).\nWe start from an empty stack. When we encounter an open bracket, we push it into the\nstack. When we encounter a close bracket, we check if it is of the same type with the top of\nthe stack. This is because the top of the stack is the one that has to be matched with the\ncurrent close bracket. Once we have a match, we pop the topmost bracket from the stack to\nremove it from future consideration. Only if we manage to reach the last bracket and \ufb01nd\nthat the stack is back to empty, then we know that all the brackets are properly matched.\nAs we examine each of the n braces only once and all stack operations are O(1), this\nalgorithm clearly runs in O(n).\nAn example of bracket (parenthesis) matching is shown in Table 2.1.\nBraces\nStack (bottom to top)\nRemarks\n( ) { [ ] }\n(\nAn open (normal) parenthesis\n( ) { [ ] }\nA close (normal) parenthesis, matched with \u2018(\u2019\n( ) { [ ] }\n{\nAn open (curly) brace\n( ) { [ ] }\n{ [\nAn open (square) bracket\n( ) { [ ] }\n{\nA close (square) bracket, matched with \u2018[\u2019\n( ) { [ ] }\nA close (curly) brace, matched with \u2018{\u2019, all OK\nTable 2.1: Example of Bracket (Parenthesis) Matching\nBracket Matching Variant(s)\nThe number of ways n pairs of parentheses can be correctly matched can be found with\nCatalan formula (see Book 2). The optimal way to multiply matrices (i.e., the Matrix Chain\nMultiplication problem) also involves bracketing. This variant can be solved with Dynamic\nProgramming (see Book 2).\n71\n\n2.2.", "mimetype": "text/plain", "start_char_idx": 247831, "end_char_idx": 251433, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "53f0463a-e472-49c2-a787-599301a971b4": {"__data__": {"id_": "53f0463a-e472-49c2-a787-599301a971b4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "72062330-c47b-437f-8883-1369d75e870d", "node_type": "1", "metadata": {}, "hash": "a4563a3c2eee0e8cba3137c249ec3064e10bf4157cc50561c9da15db29bee8d0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e939f213-d4c0-4734-9263-499221f5c85f", "node_type": "1", "metadata": {}, "hash": "91ed4bbc44465ea5e0f73b14d80e38afd3aa336db14bfbdbffcd0cbb03b89fca", "class_name": "RelatedNodeInfo"}}, "text": "The optimal way to multiply matrices (i.e., the Matrix Chain\nMultiplication problem) also involves bracketing. This variant can be solved with Dynamic\nProgramming (see Book 2).\n71\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nb. Post\ufb01x Calculator\nAlgebraic Expressions and Post\ufb01x Calculator\nThere are three types of algebraic expressions: In\ufb01x (the natural way for human to write\nalgebraic expressions), Pre\ufb01x (Polish notation), and Post\ufb01x (Reverse Polish notation). In\nIn\ufb01x/Pre\ufb01x/Post\ufb01x expressions, an operator is located (in the middle of)/before/after two\noperands, respectively. In Table 2.2, we show three In\ufb01x expressions, their corresponding\nPre\ufb01x/Post\ufb01x expressions, and their values.\nIn\ufb01x\nPre\ufb01x\nPost\ufb01x\nValue\n2 + 6 * 3\n+ 2 * 6 3\n2 6 3 * +\n20\n( 2 + 6 ) * 3\n* + 2 6 3\n2 6 + 3 *\n24\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* 4 - + 1 * 2 / 9 3 5\n4 1 2 9 3 / * + 5 - *\n8\nTable 2.2: Examples of In\ufb01x, Pre\ufb01x, and Post\ufb01x expressions\nO(n) Post\ufb01x Calculator\nPost\ufb01x expressions are more computationally e\ufb03cient than In\ufb01x expressions. First, we do\nnot need (complex) parentheses as the precedence rules are already embedded in the Post\ufb01x\nexpression. Second, we can also compute partial results as soon as an operator is speci\ufb01ed.\nThese two features are not found in In\ufb01x expressions.\nPost\ufb01x expression can be computed in O(n) using Post\ufb01x calculator algorithm. Initially,\nwe start with an empty stack. We read the expression from left to right, one token at a time.\nIf we encounter an operand, we will push it to the stack. If we encounter an operator, we\nwill pop the top two items of the stack, do the required operation, and then put the result\nback to the stack. Finally, when all tokens have been read, we return the top (the only item)\nof the stack as the \ufb01nal answer.\nAs each of the n tokens is only processed once and all stack operations are O(1), this\nPost\ufb01x Calculator algorithm runs in O(n).\nAn example of a Post\ufb01x calculation is shown in Table 2.3.\nPost\ufb01x\nStack (bottom to top)\nRemarks\n4 1 2 9 3 / * + 5 - *\n4 1 2 9 3\nThe \ufb01rst \ufb01ve tokens are operands\n4 1 2 9 3 / * + 5 - *\n4 1 2 3\nTake 3 and 9, compute 9 / 3, push 3\n4 1 2 9 3 / * + 5 - *\n4 1 6\nTake 3 and 2, compute 2 * 3, push 6\n4 1 2 9 3 / * + 5 - *\n4 7\nTake 6 and 1, compute 1 + 6, push 7\n4 1 2 9 3 / * + 5 - *\n4 7 5\nAn operand\n4 1 2 9 3 / * + 5 - *\n4 7 5\nTake 5 and 7, compute 7 - 5, push 2\n4 1 2 9 3 / * + 5 - *\n4 2\nTake 2 and 4, compute 4 * 2, push 8\n4 1 2 9 3 / * + 5 - *\n8\nReturn 8 as the answer\nTable 2.3: Example of a Post\ufb01x Calculation\n72\n\nCHAPTER 2.", "mimetype": "text/plain", "start_char_idx": 251248, "end_char_idx": 253779, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e939f213-d4c0-4734-9263-499221f5c85f": {"__data__": {"id_": "e939f213-d4c0-4734-9263-499221f5c85f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "53f0463a-e472-49c2-a787-599301a971b4", "node_type": "1", "metadata": {}, "hash": "fab87fe65986a65b4c8689f2bb41f65d84a9df5297e6637ce0cc346088eeceeb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "daa38e64-5d54-42be-8375-5958dea13124", "node_type": "1", "metadata": {}, "hash": "ff8b0cc97522ca0e8bebfdb322783e3e9182c6e37b59db7cd927bf61336d5635", "class_name": "RelatedNodeInfo"}}, "text": "DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nc. In\ufb01x to Post\ufb01x Conversion with O(n) Shunting-yard Algorithm\nKnowing that Post\ufb01x expressions are more computationally e\ufb03cient than In\ufb01x expressions,\nmany compilers will convert In\ufb01x expressions in the source code (most programming lan-\nguages use In\ufb01x expressions25) into Post\ufb01x expressions. To use the e\ufb03cient Post\ufb01x Calculator\nas shown earlier, we need to be able to convert In\ufb01x expressions into Post\ufb01x expressions ef-\n\ufb01ciently. One of the possible algorithm is the \u2018Shunting-yard\u2019 algorithm invented by Edsger\nWybe Dijkstra (the inventor of Dijkstra\u2019s algorithm in Section 4.4.3).\nShunting-yard algorithm has similar \ufb02avor with Bracket (Parenthesis) Matching discussed\nearlier and Post\ufb01x Calculator. The algorithm also uses a stack, which is initially empty. We\nread the expression from left to right, one token at a time. If we encounter an operand,\nwe will immediately output it. If we encounter an open bracket, we will push it to the\nstack. If we encounter a close bracket, we will output the topmost items of the stack until\nwe encounter an open bracket (but we do not output the open bracket). If we encounter an\noperator, we will keep outputting and then popping the topmost item of the stack if it has\ngreater than or equal precedence with this operator, or until we encounter an open bracket,\nthen push this operator to the stack. At the end, we will keep outputting and then popping\nthe topmost item of the stack until the stack is empty.\nAs each of the n tokens is only processed once and all stack operations are O(1), this\nShunting-yard algorithm runs in O(n).\nAn example of a Shunting-yard algorithm execution is shown in Table 2.4.", "mimetype": "text/plain", "start_char_idx": 253780, "end_char_idx": 255488, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "daa38e64-5d54-42be-8375-5958dea13124": {"__data__": {"id_": "daa38e64-5d54-42be-8375-5958dea13124", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e939f213-d4c0-4734-9263-499221f5c85f", "node_type": "1", "metadata": {}, "hash": "91ed4bbc44465ea5e0f73b14d80e38afd3aa336db14bfbdbffcd0cbb03b89fca", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c7bf8e0f-6c52-4568-aaa6-b9197b41b246", "node_type": "1", "metadata": {}, "hash": "76409a32705607ea4e423560d3aa509ba619476127aba53ca2a2792c4e8ba040", "class_name": "RelatedNodeInfo"}}, "text": "If we encounter an operand,\nwe will immediately output it. If we encounter an open bracket, we will push it to the\nstack. If we encounter a close bracket, we will output the topmost items of the stack until\nwe encounter an open bracket (but we do not output the open bracket). If we encounter an\noperator, we will keep outputting and then popping the topmost item of the stack if it has\ngreater than or equal precedence with this operator, or until we encounter an open bracket,\nthen push this operator to the stack. At the end, we will keep outputting and then popping\nthe topmost item of the stack until the stack is empty.\nAs each of the n tokens is only processed once and all stack operations are O(1), this\nShunting-yard algorithm runs in O(n).\nAn example of a Shunting-yard algorithm execution is shown in Table 2.4.\nIn\ufb01x\nStack\nPost\ufb01x\nRemarks\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n4\nImmediately output\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n*\n4\nPut to stack\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* (\n4\nPut to stack\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* (\n4 1\nImmediately output\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( +\n4 1\nPut to stack\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( +\n4 1 2\nImmediately output\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( + *\n4 1 2\nPut to stack\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( + * (\n4 1 2\nPut to stack\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( + * (\n4 1 2 9\nImmediately output\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( + * ( /\n4 1 2 9\nPut to stack\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( + * ( /\n4 1 2 9 3\nImmediately output\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( + *\n4 1 2 9 3 /\nOnly output \u2018/\u2019\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( -\n4 1 2 9 3 / * +\nOutput \u2018*\u2019 then \u2018+\u2019\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n* ( -\n4 1 2 9 3 / * + 5\nImmediately output\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n*\n4 1 2 9 3 / * + 5 -\nOnly output \u2018-\u2019\n4 * ( 1 + 2 * ( 9 / 3 ) - 5 )\n4 1 2 9 3 / * + 5 - *\nEmpty the stack\nTable 2.4: Example of an Execution of Shunting-yard Algorithm\nExercise 2.2.6.1*: What if we are given Pre\ufb01x expressions instead?\nHow to evaluate a Pre\ufb01x expression in O(n)?\n25One programming language that uses Pre\ufb01x expressions is Scheme.\n73\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nProgramming exercises involving linear data structures with libraries:\na. 1D Array Manipulation, Medium\n1. Entry Level: Kattis - jollyjumpers * (1D Boolean \ufb02ags to check [1..n-1]; also\navailable at UVa 10038 - Jolly Jumpers)\n2. UVa 12150 - Pole Position * (simple manipulation)\n3. UVa 12356 - Army Buddies * (similar to deletion in doubly linked lists\nbut we can still use a 1D array for the underlying data structure)\n4. UVa 13181 - Sleeping in hostels * (\ufb01nd the largest gap between two Xs;\nspecial corner cases at the two end points)\n5.", "mimetype": "text/plain", "start_char_idx": 254665, "end_char_idx": 257344, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c7bf8e0f-6c52-4568-aaa6-b9197b41b246": {"__data__": {"id_": "c7bf8e0f-6c52-4568-aaa6-b9197b41b246", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "daa38e64-5d54-42be-8375-5958dea13124", "node_type": "1", "metadata": {}, "hash": "ff8b0cc97522ca0e8bebfdb322783e3e9182c6e37b59db7cd927bf61336d5635", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a22dc1c5-b431-4fa2-9f0b-a3ac38ad0e43", "node_type": "1", "metadata": {}, "hash": "83c255f3d7cae1ec16c3c29dca2c5848c4eebf3f2b56632ad9849bbbc214f102", "class_name": "RelatedNodeInfo"}}, "text": "73\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nProgramming exercises involving linear data structures with libraries:\na. 1D Array Manipulation, Medium\n1. Entry Level: Kattis - jollyjumpers * (1D Boolean \ufb02ags to check [1..n-1]; also\navailable at UVa 10038 - Jolly Jumpers)\n2. UVa 12150 - Pole Position * (simple manipulation)\n3. UVa 12356 - Army Buddies * (similar to deletion in doubly linked lists\nbut we can still use a 1D array for the underlying data structure)\n4. UVa 13181 - Sleeping in hostels * (\ufb01nd the largest gap between two Xs;\nspecial corner cases at the two end points)\n5. Kattis - baloni * (clever use of 1D histogram array to decompose the shots\nas per requirement)\n6. Kattis - downtime * (1D array; use Fenwick Tree-like operation for Range\nUpdate Point Query)\n7. Kattis - greedilyincreasing * (just 1D array manipulation; this is not the DP-\nLIS problem)\nExtra UVa: 00414, 00482, 00591, 10050, 11192, 11496, 11608, 11875, 12854,\n12959, 12996, 13026.\nExtra Kattis: erase.\nb. 1D Array Manipulation, Harder\n1. Entry Level: UVa 10978 - Let\u2019s Play Magic * (1D string array)\n2. UVa 11222 - Only I did it * (use several 1D arrays)\n3. UVa 12662 - Good Teacher * (1D array manipulation; brute force)\n4. UVa 13048 - Burger Stand * (use 1D Boolean array; simulate)\n5. Kattis - divideby100 * (big 1D character array processing; be careful)\n6. Kattis - mastermind * (1D array manipulation to count r and s)\n7. Kattis - pivot * (static range min/max query problem; special condition\nallows this problem to be solvable in O(n) using help of 1D arrays)\nExtra UVa: 00230, 00394, 00467, 00665, 00946, 11093, 11850.\nExtra Kattis: astro, \ufb02ippingpatties, inverteddeck, physicalmusic, piperotation,\nqueens, rockband, tra\ufb03c, upsanddownso\ufb01nvesting.\nAlso see: Direct Addressing Table (Section 2.3.2).\nc. 2D Array Manipulation, Easier\n1. Entry Level: Kattis - epigdanceo\u21b5* (count number of CCs on 2D grid;\nsimpler solution exists: count the number of blank columns plus one)\n2. UVa 11581 - Grid Successors * (simulate the process)\n3. UVa 12187 - Brothers * (simulate the process)\n4. UVa 12667 - Last Blood * (1D+2D arrays to store submission status)\n5. Kattis - \ufb02owshop * (interesting 2D array manipulation)\n6. Kattis - imageprocessing * (interesting 2D array manipulation)\n7. Kattis - nineknights * (2D array checks; 8 directions)\nExtra UVa: 00541, 00585, 10703, 10920, 11040, 11349, 11835, 12981.\nExtra Kattis: compromise, thisaintyourgrandpascheckerboard.\n74\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nd. 2D Array Manipulation, Harder\n1. Entry Level: Kattis - 2048 * (just a 2D array manipulation problem; utilize\nsymmetry using 90 degrees rotation(s) to reduce 4 cases into 1)\n2. UVa 00466 - Mirror Mirror * (core functions: rotate and re\ufb02ect)\n3. UVa 11360 - Have Fun with Matrices * (do as asked)\n4. UVa 12291 - Polyomino Composer * (do as asked; a bit tedious)\n5. Kattis - \ufb02agquiz * (array of array of strings; be careful; duplicates may exists)\n6.", "mimetype": "text/plain", "start_char_idx": 256736, "end_char_idx": 259729, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a22dc1c5-b431-4fa2-9f0b-a3ac38ad0e43": {"__data__": {"id_": "a22dc1c5-b431-4fa2-9f0b-a3ac38ad0e43", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c7bf8e0f-6c52-4568-aaa6-b9197b41b246", "node_type": "1", "metadata": {}, "hash": "76409a32705607ea4e423560d3aa509ba619476127aba53ca2a2792c4e8ba040", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "83f5682c-3881-4658-9c71-18f247e7939e", "node_type": "1", "metadata": {}, "hash": "dd5e0bc9a842a2b8f71532d877511d8fa8bcdbf81cf09946c9f626946bd92bda", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: compromise, thisaintyourgrandpascheckerboard.\n74\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nd. 2D Array Manipulation, Harder\n1. Entry Level: Kattis - 2048 * (just a 2D array manipulation problem; utilize\nsymmetry using 90 degrees rotation(s) to reduce 4 cases into 1)\n2. UVa 00466 - Mirror Mirror * (core functions: rotate and re\ufb02ect)\n3. UVa 11360 - Have Fun with Matrices * (do as asked)\n4. UVa 12291 - Polyomino Composer * (do as asked; a bit tedious)\n5. Kattis - \ufb02agquiz * (array of array of strings; be careful; duplicates may exists)\n6. Kattis - funhouse * (2D array manipulation; note the direction update)\n7. Kattis - rings2 * (more challenging 2D array manipulation; special output\nformatting style)\nExtra UVa: 00101, 00434, 00512, 00707, 10016, 10855, 12398.\nExtra Kattis: apples, falcondive, keypad, prva, tetris.\ne. Sorting, Easier\n1. Entry Level: Kattis - basicprogramming2 * (a nice problem about basic sort-\ning applications)\n2. UVa 10107 - What is the Median? * (\ufb01nd median of a growing/dynamic\nlist of integers; we can use multiple calls of nth element in algorithm)\n3. UVa 12541 - Birthdates * (LA 6148 - HatYai12; sort; youngest + oldest)\n4. UVa 12709 - Falling Ants * (LA 6650 - Dhaka13; although the problem\nhas a complicated story, it has a very easy solution with sort routine)\n5. Kattis - height * (insertion sort simulation)\n6. Kattis - mjehuric * (a direct simulation of a bubble sort algorithm)\n7. Kattis - sidewayssorting * (stable sort or sort multi-\ufb01elds of columns of a 2D\narray; ignore case)\nExtra UVa: 00400, 00855, 10880, 10905, 11039, 11588, 11777, 11824, 12071,\n12861, 13113.\nExtra Kattis: closingtheloop, cups, judging.\nf. Sorting, Harder\n1. Entry Level: Kattis - sortofsorting * (stable sort or sort multi-\ufb01elds)\n2. UVa 01610 - Party Games * (LA 6196 - MidAtlanticUSA12; median)\n3. UVa 10258 - Contest Scoreboard * (multi-\ufb01elds sorting; use sort; sim-\nilar to UVa 00790)\n4. UVa 11321 - Sort Sort and Sort * (be careful with negative mod!)\n5. Kattis - classy * (sort using modi\ufb01ed comparison function; a bit of string\nparsing/tokenization)\n6. Kattis - dyslectionary * (sort the reverse of original string; output formatting)\n7. Kattis - musicyourway * (stable sort; custom comparison function)\nExtra UVa: 00123, 00450, 00790, 10194, 10698, 11300.\nExtra Kattis: addemup, booking, chartingprogress, dirtydriving, gearchang-\ning, includescoring, lawnmower, longswaps, retribution, zipfsong.\nAlso see: Dynamic Sorting with Priority Queue/bBST (set/map) (Section\n2.3.1/2.3.3), Order Statistics Tree (Section 2.3.4), Binary Search Algorithm\nthat requires pre-sorting (Section 3.3.1), and Greedy Algorithm involving\nsorting (Section 3.4).\n75\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\ng. Special Sorting Problems\n1. Entry Level: UVa 11462 - Age Sort * (standard Counting Sort problem)\n2. UVa 00612 - DNA Sorting * (needs O(n2) stable sort)\n3. UVa 11495 - Bubbles and Buckets * (requires O(n log n) merge sort)\n4. UVa 13212 - How many inversions?", "mimetype": "text/plain", "start_char_idx": 259149, "end_char_idx": 262185, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "83f5682c-3881-4658-9c71-18f247e7939e": {"__data__": {"id_": "83f5682c-3881-4658-9c71-18f247e7939e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a22dc1c5-b431-4fa2-9f0b-a3ac38ad0e43", "node_type": "1", "metadata": {}, "hash": "83c255f3d7cae1ec16c3c29dca2c5848c4eebf3f2b56632ad9849bbbc214f102", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5c71451f-7e77-4ba3-92d0-63b3fe268459", "node_type": "1", "metadata": {}, "hash": "2e436289d3b69d6775935c056f19fb9f748e1bbbda555569c944bbf616bd7f48", "class_name": "RelatedNodeInfo"}}, "text": "Also see: Dynamic Sorting with Priority Queue/bBST (set/map) (Section\n2.3.1/2.3.3), Order Statistics Tree (Section 2.3.4), Binary Search Algorithm\nthat requires pre-sorting (Section 3.3.1), and Greedy Algorithm involving\nsorting (Section 3.4).\n75\n\n2.2.\nLINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\ng. Special Sorting Problems\n1. Entry Level: UVa 11462 - Age Sort * (standard Counting Sort problem)\n2. UVa 00612 - DNA Sorting * (needs O(n2) stable sort)\n3. UVa 11495 - Bubbles and Buckets * (requires O(n log n) merge sort)\n4. UVa 13212 - How many inversions? * (requires O(n log n) merge sort)\n5. Kattis - bread * (inversion index; hard to derive)\n6. Kattis - magicsequence * (Radix Sort in custom base to avoid TLE)\n7. Kattis - mali * (Counting Sort two arrays; greedy matching largest+smallest\nat that point)\nExtra UVa: 00299, 10327.\nExtra Kattis: excursion, froshweek, gamenight, sort, ultraquicksort.\nh. Bit Manipulation\n1. Entry Level: UVa 11933 - Splitting Numbers * (simple bit exercise)\n2. UVa 10264 - The Most Potent Corner * (heavy bitmask manipulation)\n3. UVa 12571 - Brother & Sisters * (precalculate AND operations)\n4. UVa 12720 - Algorithm of Phil * (observe the pattern in this binary to\ndecimal conversion variant; involves modular arithmetic)\n5. Kattis - bitbybit * (be very careful with and + or corner cases)\n6. Kattis - deathstar * (can be solved with bit manipulation)\n7. Kattis - snapperhard * (bit manipulation; \ufb01nd the pattern; the easier version\nis also available at Kattis - snappereasy *)\nExtra UVa: 00594, 00700, 01241, 10469, 11173, 11760, 11926.\nExtra Kattis: bits, hypercube, iboard, zebrasocelots.\nOthers: IOI 2011 - Pigeons (simpler with bit manipulation).\ni. Big Integer26\n1. Entry Level: UVa 10925 - Krakovia * (Big Integer addition and division)\n2. UVa 00713 - Adding Reversed ... * (use StringBu\u21b5er reverse())\n3. UVa 10523 - Very Easy * (Big Integer addition, multiplication, power)\n4. UVa 11879 - Multiple of 17 * (Big Integer: mod, divide, subtract, equals)\n5. Kattis - primaryarithmetic * (not a Big Integer problem but a simulation of\nbasic addition)\n6. Kattis - simpleaddition * (that A+B on Big Integer question)\n7. Kattis - wizardofodds * (if K is bigger than 350, the answer is clear; else just\ncheck if 2K \u2265N)\nExtra UVa: 00424, 00465, 00619, 00748, 01226, 01647, 10013, 10083, 10106,\n10198, 10430, 10433, 10464, 10494, 10519, 10992, 11448, 11664, 11821,\n11830, 12143, 12459, 12930.\nExtra Kattis: disastrousdoubling, generalizedrecursivefunctions, threepowers.\n26Notice the shift of trend. There are much more older UVa problems (before 2010) involving Big Integer\ncompared to more recent Kattis problems (after 2010).\n76\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nj. Stack\n1. Entry Level: Kattis - evenup * (use stack to solve this problem)\n2. UVa 00514 - Rails * (use stack to simulate the process)\n3. UVa 01062 - Containers * (LA 3752 - WorldFinals Tokyo07; simulation\nwith stack; maximum answer is 26 stacks; O(n) solution exists)\n4. UVa 13055 - Inception * (nice problem about stack)\n5.", "mimetype": "text/plain", "start_char_idx": 261612, "end_char_idx": 264688, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c71451f-7e77-4ba3-92d0-63b3fe268459": {"__data__": {"id_": "5c71451f-7e77-4ba3-92d0-63b3fe268459", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "83f5682c-3881-4658-9c71-18f247e7939e", "node_type": "1", "metadata": {}, "hash": "dd5e0bc9a842a2b8f71532d877511d8fa8bcdbf81cf09946c9f626946bd92bda", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e4dc2d94-b8ee-4dc0-a3bb-d00b48d4a41f", "node_type": "1", "metadata": {}, "hash": "466d5a9833ae31d74b3b4afd7cec13833152f4673536702abff5b6933e2f6ede", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: disastrousdoubling, generalizedrecursivefunctions, threepowers.\n26Notice the shift of trend. There are much more older UVa problems (before 2010) involving Big Integer\ncompared to more recent Kattis problems (after 2010).\n76\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nj. Stack\n1. Entry Level: Kattis - evenup * (use stack to solve this problem)\n2. UVa 00514 - Rails * (use stack to simulate the process)\n3. UVa 01062 - Containers * (LA 3752 - WorldFinals Tokyo07; simulation\nwith stack; maximum answer is 26 stacks; O(n) solution exists)\n4. UVa 13055 - Inception * (nice problem about stack)\n5. Kattis - pairingsocks * (simulation using two stacks; just do as asked)\n6. Kattis - restaurant * (simulation with stack-based concept; drop plates at\nstack 2 (LIFO); use move 2->1 to reverse order; take from stack 1 (FIFO))\n7. Kattis - throwns * (use stack of egg positions to help with the undo operation;\nbe careful of corner cases involving modulo operation)\nExtra UVa: 00127, 00732, 10858.\nExtra Kattis: dream, reversebinary, symmetricorder, thegrandadventure.\nAlso see: implicit stacks in recursive function calls and the next category.\nk. Special Stack-based Problems\n1. Entry Level: UVa 00551 - Nesting a Bunch of ... * (bracket matching;\nuse stack)\n2. UVa 00673 - Parentheses Balance * (similar to UVa 00551; classic)\n3. UVa 00727 - Equation * (In\ufb01x to Post\ufb01x conversion problem)\n4. UVa 11111 - Generalized Matrioshkas * (bracket matching with twists)\n5. Kattis - bungeebuilder * (clever usage of stack; linear pass; bracket (moun-\ntain) matching variant)\n6. Kattis - circuitmath * (post\ufb01x calculator problem)\n7. Kattis - delimitersoup * (bracket matching; stack)\nl. List/Queue/Deque\n1. Entry Level: Kattis - joinstrings * (all \u2018+\u2019 operations must be O(1))\n2. UVa 11988 - Broken Keyboard ... * (rare linked list problem)\n3. UVa 10172 - The Lonesome Cargo ... * (use both queue and stack)\n4. UVa 12108 - Extraordinarily Tired ... * (simulation with N queues)\n5. Kattis - integerlists * (use deque for fast deletion from front (normal) & back\n(reversed list); use stack to reverse the \ufb01nal list if it is reversed at the end)\n6. Kattis - sim * (use list and its iterator)\n7. Kattis - teque * (all operations must be O(1))\nExtra UVa: 00246, 00540, 10935, 11797, 12100, 12207.\nExtra Kattis: backspace, ferryloading3, ferryloading4, foosball, server, trend-\ningtopic.\nAlso see: queue/deque in BFS (see Section 4.2.3, 4.4.2, and in Book 2),\ndeque in some sliding window variants in Book 2.\n77\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.3\nNon-Linear DS with Built-in Libraries\nFor some problems, a linear data structure is not the best way to organize data. With the\ne\ufb03cient implementations of non-linear data structures shown below, we can operate on the\ndata in a quicker fashion, thereby speeding up the algorithms that rely on them.\nFor example, if we need a dynamic27 ordering of keys based on priorities, using C++\nSTL priority queue can provide us O(log n) performance for enqueue/dequeue with just\na few lines of code (that we still have to write ourself), whereas doing the same with a\n(static) array may require O(n) enqueue/deqeue, and we will need to write a rather long\ncode to do so. Similarly if we need to maintain a dynamic collection of key !", "mimetype": "text/plain", "start_char_idx": 264055, "end_char_idx": 267378, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4dc2d94-b8ee-4dc0-a3bb-d00b48d4a41f": {"__data__": {"id_": "e4dc2d94-b8ee-4dc0-a3bb-d00b48d4a41f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5c71451f-7e77-4ba3-92d0-63b3fe268459", "node_type": "1", "metadata": {}, "hash": "2e436289d3b69d6775935c056f19fb9f748e1bbbda555569c944bbf616bd7f48", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2584ed75-4493-4a8d-a06c-0c99dc1846d6", "node_type": "1", "metadata": {}, "hash": "d15171714deb76674a4b9e7ea44f96c9fb604c83dfe1544029d1c45ec6d51755", "class_name": "RelatedNodeInfo"}}, "text": "NON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.3\nNon-Linear DS with Built-in Libraries\nFor some problems, a linear data structure is not the best way to organize data. With the\ne\ufb03cient implementations of non-linear data structures shown below, we can operate on the\ndata in a quicker fashion, thereby speeding up the algorithms that rely on them.\nFor example, if we need a dynamic27 ordering of keys based on priorities, using C++\nSTL priority queue can provide us O(log n) performance for enqueue/dequeue with just\na few lines of code (that we still have to write ourself), whereas doing the same with a\n(static) array may require O(n) enqueue/deqeue, and we will need to write a rather long\ncode to do so. Similarly if we need to maintain a dynamic collection of key ! value pairs,\nusing C++ STL map28 can provide us O(log n) performance for insertion/search/deletion\noperations with just a few lines of code, whereas storing the same information inside a static\narray of structs may require O(n) insertion/search/deletion, and longer to code.\n2.3.1\nBinary Heap (Priority Queue)\nLibrary:\nC++ STL priority queue.\nJava PriorityQueue.\nPython heapq.\nOCaml Set module (see the details in Section 2.3.3).\nQuick Review\nThe Binary (Max) Heap is a way to organize data in a tree. In this section, when we refer\nto Heap, we are referring to Binary (Max) Heap. The Heap is also a binary tree like the\nBinary Search Tree (BST, discussed in Section 2.3.3), except that it must be a complete29\ntree. Complete binary trees can be stored e\ufb03ciently in a compact 1-indexed array of size\nn + 1 (extra one cell for easier implementation), which is often preferred to an explicit tree\nrepresentation. For example, the array A = {-, 90, 19, 36, 17, 3, 25, 1, 2, 7} is the\ncompact array representation of Figure 2.4 with index 0 ignored. One can navigate from\na certain index (vertex) i to its parent, left child, and right child by using simple index\nmanipulation: b i\n2c, 2 \u21e5i, and 2 \u21e5i + 1, respectively. These navigation can be made faster\nusing bit manipulation (see Section 2.2): i>>1, i<<1, and (i<<1) + 1, respectively.\nFigure 2.4: Example of a Binary (Max) Heap with Max Item (90) Highlighted\nThe Heap enforces Heap property: In each subtree rooted at x, items on the left and right\nsubtrees of x are smaller than (or equal to) x (see Figure 2.4).\nThis is an application\n27The contents of a dynamic data structure is frequently modi\ufb01ed via insert/delete/update operations.\n28We can also use the faster C++ STL unordered map with O(1) performance if the keys do not have to\nbe ordered.\n29A complete binary tree is a binary tree in which every level, except possibly the last, is completely \ufb01lled.\nAll vertices in the last level must also be \ufb01lled from left-to-right.\n78\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nof the Divide (Reduce) and Conquer concept (see Section 3.3). The property guarantees\nthat the top (or root) of the Heap is always the maximum item. There is no notion of\na \u2018search\u2019 in the (basic implementation of a) Heap. The Heap instead allows for the fast\nextraction (and deletion) of the maximum item: ExtractMax() and insertion of new items:\nInsert(v)\u2014both of which can be achieved by in a O(log n) root-to-leaf or leaf-to-root\ntraversal, performing swapping operations to maintain the (Max) Heap property whenever\nnecessary (see [5, 3, 48, 9] or VisuAlgo for details/animations).\nPriority Queue ADT and Its Library Solutions\nThe Heap is a useful data structure for modeling a Priority Queue Abstract Data Type\n(ADT), where the item with the highest priority (the maximum item) can be dequeued\n(ExtractMax()) and a new item v can be enqueued (Insert(v)), both in e\ufb03cient30 O(log n)\ntime. The implementation31 of priority queue is available in the C++ STL queue library\n(Java PriorityQueue or Python heapq).", "mimetype": "text/plain", "start_char_idx": 266589, "end_char_idx": 270445, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2584ed75-4493-4a8d-a06c-0c99dc1846d6": {"__data__": {"id_": "2584ed75-4493-4a8d-a06c-0c99dc1846d6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e4dc2d94-b8ee-4dc0-a3bb-d00b48d4a41f", "node_type": "1", "metadata": {}, "hash": "466d5a9833ae31d74b3b4afd7cec13833152f4673536702abff5b6933e2f6ede", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "757736e5-bdba-42a9-938b-d6cfc7a30f4b", "node_type": "1", "metadata": {}, "hash": "ec91f58fad13868576d2ec2a412c497efe929afc1c3d2477c6ded3581d327ff2", "class_name": "RelatedNodeInfo"}}, "text": "The Heap instead allows for the fast\nextraction (and deletion) of the maximum item: ExtractMax() and insertion of new items:\nInsert(v)\u2014both of which can be achieved by in a O(log n) root-to-leaf or leaf-to-root\ntraversal, performing swapping operations to maintain the (Max) Heap property whenever\nnecessary (see [5, 3, 48, 9] or VisuAlgo for details/animations).\nPriority Queue ADT and Its Library Solutions\nThe Heap is a useful data structure for modeling a Priority Queue Abstract Data Type\n(ADT), where the item with the highest priority (the maximum item) can be dequeued\n(ExtractMax()) and a new item v can be enqueued (Insert(v)), both in e\ufb03cient30 O(log n)\ntime. The implementation31 of priority queue is available in the C++ STL queue library\n(Java PriorityQueue or Python heapq).\nTypical C++ STL priority queue operations include push(), pop(), top() (obtain\nthe greatest element of the priority queue), and empty().\nPriority Queue is an important component in algorithms like Prim\u2019s (and Kruskal\u2019s)\nalgorithms for the Minimum Spanning Tree (MST) problem (see Section 4.3), Dijkstra\u2019s\nalgorithm for the Single-Source Shortest Paths (SSSP) problem (see Section 4.4.3), and the\nA* Search algorithm (see Book 2).\nPartial Sort and Heap Sort\nThis data structure is also used to perform partial sort in the C++ STL algorithm\nlibrary. One possible implementation32 is by processing the items one by one and creating\na Max33 Heap of k items, removing the largest item whenever its size exceeds k (k is the\nnumber of items requested by user). The smallest k items can then be obtained in descending\norder by dequeuing the remaining items in the Max Heap. As each dequeue operation is\nO(log k), partial sort has O(n log k) time complexity34. When k = n, this algorithm is\nequivalent to a heap sort. Note that although the time complexity of a heap sort is also\nO(n log n), heap sort is often slower than quick sort because heap operations access data\nstored in distant indices and are thus not cache-friendly.\nUpdateKey(oldKey, newKey) and RemoveKey(key) Operations\nThere are two possible extra operations of Priority Queue ADT that are currently not directly\nsupported by the C++ STL priority queue (and Java PriorityQueue).\n30There are theoretically faster (and complex) heap structures but our experiments suggest that we can\nlive with O(log n) performance of Binary Heap data structure for most Priority Queue-based problems.\n31The default C++ STL priority queue is a Max Heap (dequeuing yields items in descending key order)\nwhereas the default Java PriorityQueue is a Min Heap (yields items in ascending key order). Tips: A Max\nHeap containing numbers can be converted into a Min Heap (and vice versa) by inserting the negated keys.\nThis is because negating a set of numbers will reverse their order when sorted. This technique is used several\ntimes in this book. However, if the priority queue is used to store 32-bit signed integers, an over\ufb02ow will\noccur if \u2212231 is negated as 231 \u22121 is the maximum value of a 32-bit signed integer.\n32Alternative partial sort implementation is to create the (Min) Heap in O(n) and then remove the\nsmallest k items from the (Min) Heap in O(k log n), resulting in overall time complexity of O(n + k log n).\n33The default partial sort produces the smallest k items in ascending order.\n34Notice that the time complexity is O(n log k) where k is the output size and n is the input size. This\nmeans that the algorithm is \u2018output-sensitive\u2019 since its running time depends not only on the input size but\nalso on the amount of items that it has to output.\n79\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nThe \ufb01rst extra operation is the UpdateKey(oldKey, newKey) operation, which allows\nthe (Max) Heap item oldKey (that can be anywhere inside the Heap, not necessarily at the\nroot) to be updated to newKey that can be either smaller or larger than oldKey. Dijkstra\u2019s\nalgorithm needs this extra operation (see Section 4.4.3 for detailed explanation).\nThe second extra operation is the RemoveKey(key) operation, which allows removal of\nHeap item key (that can be anywhere inside the Heap, not necessarily at the root).\nThere are several possible ways to implement these two extra operations e\ufb03ciently, i.e.,\nin O(log n).", "mimetype": "text/plain", "start_char_idx": 269656, "end_char_idx": 273932, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "757736e5-bdba-42a9-938b-d6cfc7a30f4b": {"__data__": {"id_": "757736e5-bdba-42a9-938b-d6cfc7a30f4b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2584ed75-4493-4a8d-a06c-0c99dc1846d6", "node_type": "1", "metadata": {}, "hash": "d15171714deb76674a4b9e7ea44f96c9fb604c83dfe1544029d1c45ec6d51755", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a96fccec-1e0d-4682-b3e4-692f102c8440", "node_type": "1", "metadata": {}, "hash": "b723e76c711608a67637962b088da902e8b4737ab4165895fb96d8d8b2365cfb", "class_name": "RelatedNodeInfo"}}, "text": "79\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nThe \ufb01rst extra operation is the UpdateKey(oldKey, newKey) operation, which allows\nthe (Max) Heap item oldKey (that can be anywhere inside the Heap, not necessarily at the\nroot) to be updated to newKey that can be either smaller or larger than oldKey. Dijkstra\u2019s\nalgorithm needs this extra operation (see Section 4.4.3 for detailed explanation).\nThe second extra operation is the RemoveKey(key) operation, which allows removal of\nHeap item key (that can be anywhere inside the Heap, not necessarily at the root).\nThere are several possible ways to implement these two extra operations e\ufb03ciently, i.e.,\nin O(log n). The easiest solution is shown in Section 2.3.3.\nIf you are interested to explore more details about Binary (Max) Heap, please visit Visu-\nAlgo, Binary Heap visualization, that shows visualizations of Binary Heap and its operations.\nThe URL for the Binary Heap visualization and source code example for several Priority\nQueue operations are shown below.\nVisualization: https://visualgo.net/en/heap\nSource code: ch2/nonlineards/priority queue.cpp|java|py|ml\nExercise 2.3.1.1: We will not discuss the basics of Heap operations in this book. Instead,\nwe will use a series of questions to verify your understanding of Heap concepts. You are\nencouraged to use https://visualgo.net/en/heap when attempting this exercise.\n1. With Figure 2.4 as the initial Heap, display the steps taken by Insert(26).\n2. After answering question 1 above, display the steps taken by ExtractMax().\n3. After answering question 1+2 above, display the steps taken by Heap Sort (perform\nsuccessive ExtractMax() operations until the Heap is empty).\nExercise 2.3.1.2: Is the structure represented by a 1-based compact array (ignoring index\n0) sorted in descending order a Max Heap?\nExercise 2.3.1.3*: Prove or disprove this statement: \u201cThe second largest item in a Max\nHeap with n \u22653 distinct items is always one of the direct children of the root\u201d. Follow up\nquestion: What about the third largest item? Where is/are the potential location(s) of the\nthird largest item in a Max Heap?\nExercise 2.3.1.4*: Prove or disprove this statement: \u201cThe smallest item in a Max Heap\nwith n \u22653 distinct items is always one of the leaf\u201d.\nExercise 2.3.1.5*: Given a 1-based compact array A containing n integers (1 \uf8ffn \uf8ff100K)\nthat are guaranteed to satisfy the Max Heap property, output the items in A that are greater\nthan an integer v. What is the best algorithm?\nExercise 2.3.1.6*: Given an unsorted array S of n distinct integers (2k \uf8ffn \uf8ff100K), \ufb01nd\nthe largest and smallest k (1 \uf8ffk \uf8ff32) integers in S in O(n log k). Note: For this written\nexercise, assume that an O(n log n) algorithm is not acceptable.\nExercise 2.3.1.7*: Suppose that we only need the DecreaseKey(oldKey, newKey) oper-\nation, i.e., an UpdateKey operation where the update always makes newKey smaller than\noldKey. Can we have a simpler solution than if we have to support general update cases?\nHint: Use lazy deletion, we will use this technique in our Dijkstra\u2019s code in Section 4.4.3.\nExercise 2.3.1.8*: Is there a better way to implement a Priority Queue if the keys are all\nintegers within a small range, e.g., [0..100]? We are expecting an O(1) enqueue and dequeue\nperformance. If yes, how? If no, why? What if the range is just [0..1]?\n80\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.3.2\nHash Table\nLibrary:\nC++ STL unordered map/unordered set/unordered multimap/unordered multiset.\nJava HashMap/HashSet/HashTable.\nPython dict/set (or curly braces {}).\nOCaml Hashtbl module.", "mimetype": "text/plain", "start_char_idx": 273246, "end_char_idx": 276860, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a96fccec-1e0d-4682-b3e4-692f102c8440": {"__data__": {"id_": "a96fccec-1e0d-4682-b3e4-692f102c8440", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "757736e5-bdba-42a9-938b-d6cfc7a30f4b", "node_type": "1", "metadata": {}, "hash": "ec91f58fad13868576d2ec2a412c497efe929afc1c3d2477c6ded3581d327ff2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b3197541-d5da-46a3-998c-a159675ba1f9", "node_type": "1", "metadata": {}, "hash": "6aad7f04730d005b3c5215f21322b0b4143d7e5862c771d8dba5ba3c662618f8", "class_name": "RelatedNodeInfo"}}, "text": "Hint: Use lazy deletion, we will use this technique in our Dijkstra\u2019s code in Section 4.4.3.\nExercise 2.3.1.8*: Is there a better way to implement a Priority Queue if the keys are all\nintegers within a small range, e.g., [0..100]? We are expecting an O(1) enqueue and dequeue\nperformance. If yes, how? If no, why? What if the range is just [0..1]?\n80\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.3.2\nHash Table\nLibrary:\nC++ STL unordered map/unordered set/unordered multimap/unordered multiset.\nJava HashMap/HashSet/HashTable.\nPython dict/set (or curly braces {}).\nOCaml Hashtbl module.\nTable ADT and Quick Review of Hash Table Concepts\nHash Table35 is an e\ufb03cient non-linear data structure to implement Table Abstract Data\nType (ADT) that require very fast (expected) O(1) insertion, search/retrieval/update, or\nremoval of keys if the keys do not have to be sorted.\nThe main components of a Hash Table are a good hash function and a good collision\nresolution mechanism. Designing a well-performing O(1) hash function is often tricky for\ncomplex objects36 like a pair, a tuple, a class, etc, but C++ (since C++11), Java, Python,\nand OCaml already have relatively good support if the data/keys are just standard data\ntypes like integers or strings. Unless the hash function is perfect (no collision), we may have\ncollision, i.e., two (or more) distinct keys hashed into the same index. This has to be resolved.\nThere are several well-known collision resolution mechanism ranging from Open Addressing\ntechniques (e.g., Double Hashing) and Closed Addressing technique (e.g., Separate Chaining,\ncurrently shown at Figure 2.5).\nFigure 2.5: Search of Key 7 in a Hash Table with m = 11 and using Separate Chaining\nIf you are interested to explore more details about the basic ideas of Hash Table, please visit\nVisuAlgo, Hash Table visualization, that shows visualizations of several Hash Table collision\nresolution techniques. The URL for the Hash Table visualization is shown below.\nVisualization: https://visualgo.net/en/hashtable\nLibrary Solutions\nIn competitive programming, we normally do not write our own Hash Table, but rather rely\non library solutions. C++ (since C++ 11) has unordered set and unordered map. The\ndi\u21b5erence between these two libraries is simple: the C++ STL unordered map stores key\n! satellite37 data pairs whereas the C++ STL unordered set only stores the keys. We\n35Note that questions about hashing frequently appear in interviews for IT jobs.\n36But if those complex objects are still easy to be compared, we can use balanced BST (see Section 2.3.3).\n37Satellite data refers to any data which you want to store in your data structure. Satellite data is not\npart of the structure of the data structure, its associated key is. Satellite data moves together with its key\n81\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nuse unordered map when we need to map keys to satellite data and the keys do not have to\nbe ordered. We use unordered set when we need an e\ufb03cient check for the existence of a\ncertain key and the keys do not have to be ordered.\nTypical C++ STL unordered set operations include insert(), find(), count() (usu-\nally to test if the frequency of a key is 0 (does not exist) or 1 (exist) in the (unordered)\nset38), erase(), and clear(). Typical C++ STL unordered map operations are similar to\nunordered set operations but we will frequently use the [] operator.\nIt is true that C++ STL map or set that will be discussed in Section 2.3.3 is usually\nalready fast enough as the typical input size of (programming contest) problems is usually\nnot more than 1M. Within these bounds, the expected39 O(1) performance of Hash Tables\nand O(log n) performance for balanced BSTs where n \uf8ff1M do not di\u21b5er by much. However,\nfor a very time critical problem where the ordering of the keys is not important, the small\n(O(log n) factor) runtime saving o\u21b5ered by Hash Table is still useful.", "mimetype": "text/plain", "start_char_idx": 276249, "end_char_idx": 280203, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b3197541-d5da-46a3-998c-a159675ba1f9": {"__data__": {"id_": "b3197541-d5da-46a3-998c-a159675ba1f9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a96fccec-1e0d-4682-b3e4-692f102c8440", "node_type": "1", "metadata": {}, "hash": "b723e76c711608a67637962b088da902e8b4737ab4165895fb96d8d8b2365cfb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1d1381ce-7f54-4530-8a45-1930ddaad0a6", "node_type": "1", "metadata": {}, "hash": "d263d1a0737b02e3cd9e703aac064701d0a79c20c4fa4e527c3cbc1ff15861e4", "class_name": "RelatedNodeInfo"}}, "text": "Typical C++ STL unordered map operations are similar to\nunordered set operations but we will frequently use the [] operator.\nIt is true that C++ STL map or set that will be discussed in Section 2.3.3 is usually\nalready fast enough as the typical input size of (programming contest) problems is usually\nnot more than 1M. Within these bounds, the expected39 O(1) performance of Hash Tables\nand O(log n) performance for balanced BSTs where n \uf8ff1M do not di\u21b5er by much. However,\nfor a very time critical problem where the ordering of the keys is not important, the small\n(O(log n) factor) runtime saving o\u21b5ered by Hash Table is still useful. For illustration, just\nby changing the library used from set<int> into unordered set<int> for UVa 11849 -\nCD (also available at Kattis - cd) solution shaves approximately half the runtime from \u21e1\n0.8s down to \u21e10.4s.\nNote that for most programming contest problems, the input constraints are clearly\nspeci\ufb01ed. Thus we will (roughly) know the maximum number of items M that will ever\nbe in the Hash Table at the same time. Therefore, we can pre-set the initial size of Hash\nTable to be approximately40 2 \u21e5M to reduce the amount of \u2018re-hashing\u2019 and keep the load\nfactor of the Hash Table to be in the \u2018optimum range\u2019. In C++, we use the alternative\nconstructor of unordered set/unordered map that speci\ufb01es the initial bucket count or\ncall the reserve(count) method.\nDirect Addressing Table\nWe do not always have to use a complex Hash Table data structure. Some programming\ncontest problems can already be solved using the simplest form of Hash Tables: \u2018Direct\nAddressing Table\u2019 (DAT).\nDAT can be considered as a Hash Table where the keys themselves are the indices, or\nwhere the \u2018hash function\u2019 is the identity function (no collision). For example, we may need\nto assign all possible ASCII characters [0..255] to integer key values, e.g., \u2018a\u2019 ! 3, \u2018W\u2019 !\n10, . . . , \u2018I\u2019 ! 13, etc. For this purpose, we do not need the C++ STL map, unordered map,\nor any form of hashing as the key itself (the value of the ASCII character [0..255]) is unique\nand already su\ufb03cient to determine the appropriate index in an array of size 256.\nCommon cases where DAT technique may be applicable are when the keys are English\nalphabets (lowercase/UPPERCASE only [0..25] or both [0..51]), DNA characters (\u2018A\u2019, \u2018C\u2019,\n\u2018G\u2019, and \u2018T\u2019), digits (binary [0..1], octal [0..7], decimal [0..9], or hexadecimal [0..15]), day of\na week ([0..6])/month ([0..28/29/30/31])/year ([0..364/365]), and a few others that you will\nencounter as you solve more programming problems involving this special data structure.\nIn the sample code, we demonstrate a few of these Hash Table operations.\nSource code: ch2/nonlineards/unordered map unordered set.cpp|java|py|ml\nwhen the key is re-organized by the underlying data structure. An analogy: key is planet earth and satellite\ndata is moon that orbits the earth; both earth and moon move together when earth orbits the sun.\n38There is no duplicate element in a set. If we need to cater for duplicate elements, then we should use\nthe C++ STL unordered multimap or unordered multiset instead.\n39The worst case performance of Hash Table operations is O(n) but it is very di\ufb03cult to create test cases\nthat cause this worst case performance, especially when one sets good initial Hash Table size.\n40The required extra table size to improve typical Hash Table performance depends on the implementation.\nJava HashMap has default load factor bound of 0.75, i.e., if we know the maximum number of items M, we\nshall set initial size of Hash Table to be \u21e11.33 \u21e5M.\n82\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nExercise 2.3.2.1: We will not discuss the basics of Hash Table collision resolution tech-\nniques and operations in this book. Instead, we will use a series of questions to verify your\nunderstanding of Hash Table concepts, especially the Closed Addressing (Separate Chain-\ning) technique that is likely used inside C++ STL unordered map/unordered set.", "mimetype": "text/plain", "start_char_idx": 279567, "end_char_idx": 283573, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1d1381ce-7f54-4530-8a45-1930ddaad0a6": {"__data__": {"id_": "1d1381ce-7f54-4530-8a45-1930ddaad0a6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b3197541-d5da-46a3-998c-a159675ba1f9", "node_type": "1", "metadata": {}, "hash": "6aad7f04730d005b3c5215f21322b0b4143d7e5862c771d8dba5ba3c662618f8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "90d3e703-2125-4d39-9aa8-efa943425a53", "node_type": "1", "metadata": {}, "hash": "144e3511e29070ebc7b9938e38193c964bd0a6972c89e2e523f8ed0cf6ea7162", "class_name": "RelatedNodeInfo"}}, "text": "40The required extra table size to improve typical Hash Table performance depends on the implementation.\nJava HashMap has default load factor bound of 0.75, i.e., if we know the maximum number of items M, we\nshall set initial size of Hash Table to be \u21e11.33 \u21e5M.\n82\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nExercise 2.3.2.1: We will not discuss the basics of Hash Table collision resolution tech-\nniques and operations in this book. Instead, we will use a series of questions to verify your\nunderstanding of Hash Table concepts, especially the Closed Addressing (Separate Chain-\ning) technique that is likely used inside C++ STL unordered map/unordered set. You are\nencouraged to use https://visualgo.net/en/hashtable when attempting this exercise.\n1. With Figure 2.5 as the current Hash Table with m = 11 cells/slots (the hash function\nis assumed to be typical one, i.e., h(key) = key%m) and n = 13 keys, display the steps\ntaken by Search(8), Search(35), Search(77).\n2. After answering question 1 above, display the steps taken by Insert(77), Insert(13),\nInsert(19), one after another.\n3. After answering question 1+2 above, display the steps taken by Remove(9), Remove(7),\nRemove(13), one after another.\nExercise 2.3.2.2: Someone suggested that it is possible to store the key ! value pairs in\na sorted array of structs so that we can use the O(log n) binary search. Is this approach\nfeasible? If no, what is the issue?\nExercise 2.3.2.3: There are M strings. N of them are unique (N \uf8ffM). Which non-linear\ndata structure discussed in this section should you use if you have to index (label) these M\nstrings with integers from [0..N-1]? The indexing criteria is as follows: The \ufb01rst string\nmust be given an index of 0; The next di\u21b5erent string must be given index 1, and so on.\nHowever, if a string is re-encountered, it must be given the same index as its earlier copy!\nOne application of this task is in constructing the connection graph from a list of city names\ngiven as strings and a list of \ufb02ights between these cities (see Section 2.4.1). One possible\nway to do this is to map these city names into integer indices as asked in this exercise.\nExercise 2.3.2.4*: We have mentioned that by using the 10 characters longer C++ STL\nunordered set<int> instead of C++ STL set<int>, we managed to approximate halve\nthe runtime needed to solve Kattis - cd (also available at UVa 11849 - CD) without changing\nanything else. Please do similar experiments with other Online Judge problems where the\nkeys do not need to be ordered and are of simple data type like integers or strings that already\nhave e\ufb03cient built-in hash functions. Do you experience similar runtime improvements?\nExercise 2.3.2.5*: In this section, we have mentioned that hashing a complex object is\ntricky. However, there is an easy way to hash a pair of integers that represents a cell (r, c)\nin a 2D array of size N \u21e5M. The question: how to hash a pair of integers?\nPro\ufb01le of Data Structure Inventor\nJohn William Joseph Williams (1929-2012) was a British-born Computer Scientist who\ninvented Heap Sort and the associated Binary Heap data structure in 1964.\n83\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.3.3\nBalanced Binary Search Tree (bBST)\nLibrary:\nC++ STL map/set/multiset/multimap.\nJava TreeMap/TreeSet.\nNo built-in support for balanced BST in Python yet as of year 2020.\nOCaml Map/Set module (immutable).\nQuick Review\nBinary Search Tree (BST) is another way to organize data in a tree structure.\nIn each\nsubtree rooted at x, the following BST property holds: items on the left subtree of x are\nsmaller than x and items on the right subtree of x are greater than (or equal to) x. This\nis essentially an application of the Divide and Conquer strategy (also see Section 3.3).", "mimetype": "text/plain", "start_char_idx": 282891, "end_char_idx": 286688, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "90d3e703-2125-4d39-9aa8-efa943425a53": {"__data__": {"id_": "90d3e703-2125-4d39-9aa8-efa943425a53", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1d1381ce-7f54-4530-8a45-1930ddaad0a6", "node_type": "1", "metadata": {}, "hash": "d263d1a0737b02e3cd9e703aac064701d0a79c20c4fa4e527c3cbc1ff15861e4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a737f9c4-c064-4793-b8a8-63171cab5780", "node_type": "1", "metadata": {}, "hash": "2c0f896264b9c0d39330b1ed464e2b60c050c44fa527f99f7419c5938f38428f", "class_name": "RelatedNodeInfo"}}, "text": "83\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.3.3\nBalanced Binary Search Tree (bBST)\nLibrary:\nC++ STL map/set/multiset/multimap.\nJava TreeMap/TreeSet.\nNo built-in support for balanced BST in Python yet as of year 2020.\nOCaml Map/Set module (immutable).\nQuick Review\nBinary Search Tree (BST) is another way to organize data in a tree structure.\nIn each\nsubtree rooted at x, the following BST property holds: items on the left subtree of x are\nsmaller than x and items on the right subtree of x are greater than (or equal to) x. This\nis essentially an application of the Divide and Conquer strategy (also see Section 3.3). Or-\nganizing the data like this (see Figure 2.6) allows for O(log n) search(key), insert(key),\nfindMin()/findMax(), successor(key)/predecessor(key), and remove(key) operations\nsince in the worst case, only O(log n) operations are required in a root-to-leaf scan (see\n[5, 3, 48, 9] for details). However, this only holds if the BST is balanced.\nFigure 2.6: Example of Searching a Key (7) in a balanced BST (bBST)\nBalanced Binary Search Tree (bBST) and Its Library Solutions\nImplementing bug-free balanced BSTs such as the Adelson-Velskii Landis (AVL)41 or Red-\nBlack (RB)42 Trees is a tedious task and is di\ufb03cult to achieve in a time-constrained con-\ntest environment (unless we have prepared a code library beforehand, see Section 2.3.4).\nFortunately, C++ STL has43 map and set (Java has TreeMap and TreeSet) which are\nusually implementations of the RB Tree that guarantee major BST operations like inser-\ntions/searches/removals are done in O(log n) time44. By mastering these two C++ STL\nlibraries (or Java APIs), we can save a lot of precious coding time during contests!\n41The AVL tree was the \ufb01rst self-balancing BST to be invented. AVL trees are essentially traditional\nBSTs with an additional property: The heights of the two subtrees of any vertex in an AVL tree can di\u21b5er\nby at most one. Rebalancing operations (rotations) are performed (when necessary) during insertions and\ndeletions to maintain this invariant property, hence keeping the tree roughly balanced.\n42The Red-Black tree is another self-balancing BST, in which every vertex has a color: red or black. In\nRB trees, the root vertex, all leaf vertices, and both children of every red vertex are black. Every simple\npath from a vertex to any of its descendant leaves contains the same number of black vertices. Throughout\ninsertions and deletions, an RB tree will maintain all these invariants to keep the tree balanced.\n43If there are duplicate elements, we may want to use the C++ STL multimap or multiset instead.\n44Only\nuse\nmap/set\nonly\nif\nwe\nreally\nneed\nthe\nkeys\nto\nbe\nsorted,\notherwise\nwe\nshall\nuse\nunordered map/unordered set by default. This is because the time complexity for map/set operations\n(insertions/searches/removals) is O(log n), while it is expected O(1) for unordered map/unordered set un-\nless severe hash collisions occur, in which it becomes O(n). But for most practical usage in programming\ncontest problems, the probability of hash collision occurring is relatively low.\n84\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nTypical C++ STL map/set operations are similar to unordered map/unordered set\noperations, but this time we can perform range operations like lower bound, upper bound,\nand iterating through the elements in sorted order.\nTree Sort\nAs the keys in a bBST are ordered, enumerating the keys from the smallest to largest will\nyield the sorted ordering of the keys45. For some programming problems that require the out-\nput to be unique and in sorted order, we can use C++ STL set (or map) to store the output,\nand then enumerate all keys in the set that will be \u2018auto-sorted\u2019 by the bBST inside C++\nSTL set. This is an overkill solution (unless there are frequent updates/insertions/deletions\nof the keys) as storing the output in a vector and then sort it before displaying the output\n(removing adjacent duplicates for uniqueness) is also possible (and faster).", "mimetype": "text/plain", "start_char_idx": 286039, "end_char_idx": 290080, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a737f9c4-c064-4793-b8a8-63171cab5780": {"__data__": {"id_": "a737f9c4-c064-4793-b8a8-63171cab5780", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "90d3e703-2125-4d39-9aa8-efa943425a53", "node_type": "1", "metadata": {}, "hash": "144e3511e29070ebc7b9938e38193c964bd0a6972c89e2e523f8ed0cf6ea7162", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "75c043fd-02e6-43a2-b834-fea90df8f100", "node_type": "1", "metadata": {}, "hash": "ba20c19aa5970e0fb518d2341d3f1a7b14ea65837527049fec1f28e23065b771", "class_name": "RelatedNodeInfo"}}, "text": "Tree Sort\nAs the keys in a bBST are ordered, enumerating the keys from the smallest to largest will\nyield the sorted ordering of the keys45. For some programming problems that require the out-\nput to be unique and in sorted order, we can use C++ STL set (or map) to store the output,\nand then enumerate all keys in the set that will be \u2018auto-sorted\u2019 by the bBST inside C++\nSTL set. This is an overkill solution (unless there are frequent updates/insertions/deletions\nof the keys) as storing the output in a vector and then sort it before displaying the output\n(removing adjacent duplicates for uniqueness) is also possible (and faster).\nIf you are interested to explore more details about Binary Search Tree or its balanced\nvariant: AVL Tree, please visit VisuAlgo, Binary Search Tree visualization, that shows\nvisualization of BST/AVL Tree and their operations. The URL for the BST visualization\nand source code example (excluding Python) are shown below.\nVisualization: https://visualgo.net/en/bst\nSource code: ch2/nonlineards/map set.cpp|java|ml\nUsing bBST as a Powerful Priority Queue ADT\nA bBST (e.g., C++ STL set/multiset) can be used to implement an e\ufb03cient Priority\nQueue ADT discussed earlier in Section 2.3.1. We can enqueue a new key by inserting that\nkey into a bBST (insert(key)) in O(log n) time. We can identify the item with the smallest\nkey (priority) by \ufb01nding the minimum/leftmost item in the bBST (begin()). As a bonus,\nwe can also identify the largest key of the same bBST by \ufb01nding the maximum/rightmost\nitem in the bBST (rbegin()). This essentially makes a bBST to be an e\ufb03cient dynamic\nMin-Max Priority Queue, more powerful46 than the standard Priority Queue ADT.\nNow with this revelation, we can now implement the two extra Priority Queue ADT op-\nerations mentioned in Section 2.3.1 e\ufb03ciently. The UpdateKey(oldkey, newkey) operation\nis now remove(oldkey) in bBST and then insert(newKey) into bBST. This is O(2\u21e5log n),\nwhich is still O(log n). The RemoveKey(key) operation where key is any key in the Priority\nQueue, is simply remove(key) in bBST, which is O(log n).\nOrder Statistics Tree: rank(v) and select(k) Operations\nA bBST can be augmented (add extra information at each vertex) so that we can sup-\nport two more operations rank(v) and select(k) operations. The operation rank(v) \ufb01rst\nsearch the key v inside the bBST and output its rank among all the keys in the bBST (usu-\nally 1-based, with rank(the-smallest-key) = 1 and rank(the-largest-key) = n). The\ncorresponding operation select(k) retrieves the key with rank k in the bBST (select(1)\n= the-smallest-key and select(n) = the-largest-key).\nHowever, there is a small drawback. If we use the library implementations (e.g., C++\nSTL set/map), it becomes di\ufb03cult or impossible to augment (add extra information to) the\nbBST. We will discuss this problem in more details in Section 2.3.4.\n45Note that the content of a Hash Table discussed in Section 2.3.2 is (usually) jumbled and iterating over\nthe keys in Hash Table will not yield a meaningful order unless our intention is really to process all keys.\n46One drawback is that C++ STL set is a few constant factor slower (but mostly negligible in most\nprogramming contest problems) than C++ STL priority queue due to its more general functionalities.\n85\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nExercise 2.3.3.1: We will not discuss the basics of BST operations in this book. Instead, we\nwill use a series of sub-tasks to verify your understanding of BST-related concepts. We will\nuse Figure 2.6 as an initial reference in all sub-tasks except sub-task 2. You are encouraged\nto use https://visualgo.net/en/bst when attempting this exercise.\n1. Display the steps taken by search(71), search(7), and then search(22).\n2.", "mimetype": "text/plain", "start_char_idx": 289444, "end_char_idx": 293224, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "75c043fd-02e6-43a2-b834-fea90df8f100": {"__data__": {"id_": "75c043fd-02e6-43a2-b834-fea90df8f100", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a737f9c4-c064-4793-b8a8-63171cab5780", "node_type": "1", "metadata": {}, "hash": "2c0f896264b9c0d39330b1ed464e2b60c050c44fa527f99f7419c5938f38428f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b5d5aac7-a068-43e0-bc4b-f800c6ef3f4a", "node_type": "1", "metadata": {}, "hash": "f81258f48a6a13ee41585fc04e3bb17afb7ccb630f761dde00fc6e8b264f8c36", "class_name": "RelatedNodeInfo"}}, "text": "46One drawback is that C++ STL set is a few constant factor slower (but mostly negligible in most\nprogramming contest problems) than C++ STL priority queue due to its more general functionalities.\n85\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nExercise 2.3.3.1: We will not discuss the basics of BST operations in this book. Instead, we\nwill use a series of sub-tasks to verify your understanding of BST-related concepts. We will\nuse Figure 2.6 as an initial reference in all sub-tasks except sub-task 2. You are encouraged\nto use https://visualgo.net/en/bst when attempting this exercise.\n1. Display the steps taken by search(71), search(7), and then search(22).\n2. From an empty BST, do insert(15), insert(4), insert(50), insert(2), insert(7),\ninsert(23), insert(71), insert(10), insert(65) one by one. What do we have?\n3. Display the steps taken by findMin() (and findMax()).\n4. Indicate the inorder traversal of this BST. Is the output sorted?\n5. Indicate the preorder, postorder, and level order traversals of this BST.\n6. Display the steps taken by successor(50), successor(10), and successor(71).\nSimilarly for predecessor(23), predecessor(7), and predecessor(71).\n7. Display the steps taken by remove(65) (a leaf), remove(71) (an internal vertex with\none child), and remove(15) (an internal vertex with two children) one after another.\nExercise 2.3.3.2: Which non-linear data structure should you use if you have to support\nthe these dynamic operations: 1) many insertions, 2) many deletions, and 3) many requests\nfor the data in sorted order? What if the sorted criteria is dropped from requirement 3?\nExercise 2.3.3.3*: Suppose you are given a reference to the root R of a binary tree T\ncontaining n vertices. You can access a vertex\u2019s left, right and parent vertices as well as\nits key through its reference. Solve each of the following tasks below with the best possible\nalgorithms that you can think of and analyze their time complexities. Let\u2019s assume the\nfollowing constraints: 1 \uf8ffn \uf8ff200K so that O(n2) solutions are theoretically infeasible.\n1. Check if T is a BST.\n2*. Output the items in T that are within a given range [a..b] in ascending order.\n3*. Output the contents of the leaves of T in descending order.\nExercise 2.3.3.4*: The inorder traversal (also see Section 4.6.2) of a standard (not neces-\nsarily balanced) BST is known to produce the BST\u2019s item in sorted order and runs in O(n).\nDoes the code below also produce the BST items in sorted order? Can it be made to run in\na total time of O(n) instead of O(log n + (n-1) \u21e5log n) = O(n log n)? If possible, how?\nint x = findMin(); cout << x << \"\\n\";\nfor (int i = 1; i < n; ++i) {\n// is this O(n log n)?\nint x = successor(x); cout << x << \"\\n\";\n}\nExercise 2.3.3.5*: Knowing the versatility of balanced BST (bBST), should we use bBST\nfor all our key to value mapping, sorting (use Tree Sort), and Priority Queue needs?\n86\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.3.4\nOrder Statistics Tree\nTwo Related Problems\nSelection problem is the problem of \ufb01nding the k-th smallest47 element of an array of n ele-\nments. Another name for selection problem is order statistics. Thus the minimum (smallest)\nelement is the 1-st order statistic (1-based indexing), the maximum (largest) element is the\nn-th order statistic, and the median element is the n\n2 order statistic (there are 2 medians if\nn is even but we can combine the two cases as (A[n/2] + A[(n-1)/2]) / 2).\nThe opposite of Selection problem is Ranking problem.", "mimetype": "text/plain", "start_char_idx": 292532, "end_char_idx": 296071, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b5d5aac7-a068-43e0-bc4b-f800c6ef3f4a": {"__data__": {"id_": "b5d5aac7-a068-43e0-bc4b-f800c6ef3f4a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "75c043fd-02e6-43a2-b834-fea90df8f100", "node_type": "1", "metadata": {}, "hash": "ba20c19aa5970e0fb518d2341d3f1a7b14ea65837527049fec1f28e23065b771", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2d74e6ae-bfb6-4566-9daa-9f5d5b2125fb", "node_type": "1", "metadata": {}, "hash": "93bcf81e5fa21fc4b847b6e354225f87b2fd4b9c058a7747b9bb580dc5a5f683", "class_name": "RelatedNodeInfo"}}, "text": "86\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.3.4\nOrder Statistics Tree\nTwo Related Problems\nSelection problem is the problem of \ufb01nding the k-th smallest47 element of an array of n ele-\nments. Another name for selection problem is order statistics. Thus the minimum (smallest)\nelement is the 1-st order statistic (1-based indexing), the maximum (largest) element is the\nn-th order statistic, and the median element is the n\n2 order statistic (there are 2 medians if\nn is even but we can combine the two cases as (A[n/2] + A[(n-1)/2]) / 2).\nThe opposite of Selection problem is Ranking problem. If the k-th smallest element in\nan array is v, i.e., Select(k) = v, then the ranking of v is k, i.e., Rank(v) = k. Both Select\nand Rank operations are supported in the Order Statistics Tree data structure (that can be\nimplemented in several ways).\nThis selection problem is used as a motivating example in the opening of Chapter 3 later.\nHere, we \ufb01rst discuss the selection problem on static data and its solutions, before we present\nthe Order Statistics Tree that can solve both the selection and rank problems e\ufb03ciently.\nSolution(s) for Selection Problem, static data\nSpecial Cases: k = 1 and k = n\nSearching for the minimum (k = 1) or maximum (k = n) element of an arbitrary array can\nbe done in n-1 comparisons: we set the \ufb01rst element to be the temporary answer, and then\nwe compare this temporary answer with the other n-1 elements one by one and keep the\nsmaller (or larger, depending on the requirement) one. Finally, we report the answer. \u2326(n)\ncomparisons is the lower bound, i.e., We cannot do better than this. While this problem\nis easy for k = 1 or k = n, \ufb01nding the other order statistics\u2014the general form of selection\nproblem\u2014is more di\ufb03cult.\nO(n2) algorithm\nA na\u00a8\u0131ve algorithm to \ufb01nd the k-th smallest element is to this: \ufb01nd the smallest element,\n\u2018discard\u2019 it (e.g., by setting it to a \u2018dummy large value\u2019), and repeat this process k times.\nWhen k is near 1 (or when k is near n), this O(kn) algorithm can still be treated as running\nin O(n), i.e., we treat k as a \u2018small constant\u2019. However, the worst case scenario is when we\nhave to \ufb01nd the median (k = n\n2) element where this algorithm runs in O( n\n2 \u21e5n) = O(n2).\nO(n log n) algorithm\nA better algorithm is to sort (that is, pre-process) the array \ufb01rst in O(n log n). Once the\narray is sorted, we can \ufb01nd the k-th smallest element in O(1) by simply returning the content\nof index k-1 (0-based indexing) of the sorted array. The main part of this algorithm is the\nsorting phase. Assuming that we use a good O(n log n) sorting algorithm, this algorithm\nruns in O(n log n) overall.\nExpected O(n) algorithm\nAn even better algorithm for the selection problem is to apply Divide and Conquer paradigm.\nThe key idea of this algorithm is to use the O(n) Partition algorithm (the randomized version)\nfrom Quick Sort as its sub-routine.\n47Note that \ufb01nding the k-th largest element is equivalent to \ufb01nding the (n-k+1)-th smallest element.\n87\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nA randomized partition algorithm: RandPartition(A, l, r) is an algorithm to parti-\ntion a given range [l..r] of the array A around a (random) pivot. Pivot A[p] is one of the\nelement of A where p 2 [l..r]. After partition, all elements < A[p] are placed before the\npivot and all elements \u2265A[p] are placed after the pivot (see Figure 2.1). The \ufb01nal index of\nthe pivot q is returned. This randomized partition algorithm can be done in O(n).\nAfter performing q = RandPartition(A, 0, n-1), all elements \uf8ffA[q] will be placed\nbefore the pivot and therefore A[q] is now in it\u2019s correct order statistic, which is q+1.", "mimetype": "text/plain", "start_char_idx": 295451, "end_char_idx": 299150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2d74e6ae-bfb6-4566-9daa-9f5d5b2125fb": {"__data__": {"id_": "2d74e6ae-bfb6-4566-9daa-9f5d5b2125fb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b5d5aac7-a068-43e0-bc4b-f800c6ef3f4a", "node_type": "1", "metadata": {}, "hash": "f81258f48a6a13ee41585fc04e3bb17afb7ccb630f761dde00fc6e8b264f8c36", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "42ecfd74-6f9d-4e60-93ab-67b0c41c35fd", "node_type": "1", "metadata": {}, "hash": "6dc7b22851ce27734404e147c2404d3698a97b63f42bac8b56d1ee61b9ca1cd4", "class_name": "RelatedNodeInfo"}}, "text": "NON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nA randomized partition algorithm: RandPartition(A, l, r) is an algorithm to parti-\ntion a given range [l..r] of the array A around a (random) pivot. Pivot A[p] is one of the\nelement of A where p 2 [l..r]. After partition, all elements < A[p] are placed before the\npivot and all elements \u2265A[p] are placed after the pivot (see Figure 2.1). The \ufb01nal index of\nthe pivot q is returned. This randomized partition algorithm can be done in O(n).\nAfter performing q = RandPartition(A, 0, n-1), all elements \uf8ffA[q] will be placed\nbefore the pivot and therefore A[q] is now in it\u2019s correct order statistic, which is q+1. Then,\nthere are only 3 possibilities:\n1. q+1 = k, A[q] is the desired answer. We return this value and stop.\n2. q+1 > k, the desired answer is inside the left partition, e.g., in A[0..q-1].\n3. q+1 < k, the desired answer is inside the right partition, e.g., in A[q+1..n-1].\nThis process can be repeated recursively on smaller range of search space until we \ufb01nd the\nrequired answer. A snippet of C++ code that implements this algorithm is shown below.\nint QuickSelect(int A[], int l, int r, int k) {\n// expected O(n)\nif (l == r) return A[l];\nint q = RandPartition(A, l, r);\n// also O(n)\nif (q+1 == k)\nreturn A[q];\nelse if (q+1 > k)\nreturn QuickSelect(A, l, q-1, k);\nelse\nreturn QuickSelect(A, q+1, r, k);\n}\nSource code: ch2/nonlineards/QuickSelect.cpp|java|py|ml\nThis QuickSelect algorithm runs in expected O(n) time and very unlikely to run in its worst\ncase O(n2) as it uses randomized pivot at each step. The full analysis involves probability\nand expected values. Interested readers are encouraged to read other references for the full\nanalysis e.g., [5].\nA simpli\ufb01ed (but not rigorous) analysis is to assume48 QuickSelect divides the array into\ntwo equal-sized subarrays at each step and n is a power of two. Thus it runs RandPartition\nin O(n) for the \ufb01rst round, in O( n\n2) in the second round, in O( n\n4) in the third round and\n\ufb01nally O(1) in the 1 + log2 n round. The cost of QuickSelect is mainly determined by the\ncost of RandPartition as all other steps of QuickSelect is O(1). Therefore the overall cost\nis O(n + n\n2 + n\n4 + ... + n\nn) = O(n \u21e5( 1\n1 + 1\n2 + 1\n4 + ... + 1\nn)) \uf8ffO(2n) = O(n).\nLibrary solution for the expected O(n) algorithm\nC++ STL has function nth element in <algorithm>. This nth element implements the\nexpected O(n) algorithm as shown above. However as of year 2020, we are not aware of\nJava/Python/OCaml equivalent for this function.\nNote that both QuickSelect and nth element may actually swap elements in the original\narray A into its \u201cmore sorted\u201d form (due to the usage of RandPartition). Sometimes, this\nis not the desired side e\u21b5ect, thus we need to copy the original array A in O(n) \ufb01rst into\nanother array.\n48There is an extension of this algorithm: worst-case O(n) selection algorithm that do partitioning around\nan approximate median of the current subarray. Interested readers can check [5].\n88\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nOrder Statistics Tree, dynamic data\nO(n log n) pre-processing and O(log n) algorithm using balanced BST\nAll solutions presented for the selection problem earlier assume that the given array is\nstatic\u2014unchanged for each query of the k-th smallest element. However, if the content of\nthe array is frequently modi\ufb01ed, i.e., a new element is added, an existing element is removed,\nor the value of an existing element is changed, the solutions above become ine\ufb03cient.", "mimetype": "text/plain", "start_char_idx": 298478, "end_char_idx": 302017, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "42ecfd74-6f9d-4e60-93ab-67b0c41c35fd": {"__data__": {"id_": "42ecfd74-6f9d-4e60-93ab-67b0c41c35fd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2d74e6ae-bfb6-4566-9daa-9f5d5b2125fb", "node_type": "1", "metadata": {}, "hash": "93bcf81e5fa21fc4b847b6e354225f87b2fd4b9c058a7747b9bb580dc5a5f683", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "24249ab0-2b7c-42c4-993d-f67e77dd96b0", "node_type": "1", "metadata": {}, "hash": "3f281f6176051c339093c1f3f6110535d13e13db60f12255f4818d9bc9c2c58a", "class_name": "RelatedNodeInfo"}}, "text": "48There is an extension of this algorithm: worst-case O(n) selection algorithm that do partitioning around\nan approximate median of the current subarray. Interested readers can check [5].\n88\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nOrder Statistics Tree, dynamic data\nO(n log n) pre-processing and O(log n) algorithm using balanced BST\nAll solutions presented for the selection problem earlier assume that the given array is\nstatic\u2014unchanged for each query of the k-th smallest element. However, if the content of\nthe array is frequently modi\ufb01ed, i.e., a new element is added, an existing element is removed,\nor the value of an existing element is changed, the solutions above become ine\ufb03cient.\nWhen the underlying data is dynamic, we need to use a balanced Binary Search Tree (see\nSection 2.3). First, we insert all n elements into a balanced BST in O(n log n) time. We\nalso augment (add information) about the size of each sub-tree rooted at each vertex so that\nwe can query the size of any sub-tree in O(1) despite any update (insertion/deletion). This\nway, we can \ufb01nd the k-th smallest element in O(log n) time by comparing k with q\u2014the size\nof the left sub-tree of the root:\n1. If q+1 = k, then the root is the desired answer. We return this value and stop.\n2. If q+1 > k, the desired answer is inside the left sub-tree of the root.\n3. If q+1 < k, the desired answer is inside the right sub-tree of the root and we are now\nsearching for the (k-q-1)-th smallest element in this right sub-tree. This adjustment of\nk is needed to ensure correctness.\nThis process\u2014which is similar with the expected O(n) algorithm for static selection problem\u2014\ncan be repeated recursively until we \ufb01nd the required answer. As checking the size of a\nsub-tree can be done in O(1) if we have properly augment the BST, this overall algorithm\nruns at worst in O(log n) time, from root to the deepest leaf of a balanced BST.\nNow with this sub-tree size augmentation, we can also solve the ranking problem easily.\nTo determine the rank of a given value v, we search for v in the balanced BST and perform\nthe following:\n1. If v is equal to the root of current sub-tree (we found v), then the rank is the size of\nleft sub-tree plus one (the root).\n2. If v is smaller than the root of the current sub-tree, then the rank of v can be determined\nby continuing the search on the left sub-tree.\n3. If v is greater than the root of the current sub-tree, then the rank of v can be determined\nby continuing the search on the right sub-tree and then adding the size of left sub-tree\nplus one (the root) to the \ufb01nal answer.\nHowever, as we need to augment a balanced BST, this algorithm cannot use built-in C++\nSTL <map>/<set> (or Java TreeMap/TreeSet) as these library code cannot be augmented.\nTherefore, we need to write our own balanced BST routine (e.g., AVL tree or Red Black\nTree, etc\u2014all of them take some time to code \u2014 see our example code) and therefore such\nselection problem and/or ranking problem on dynamic data can be quite painful to solve if\nyou are not aware of the alternative solutions: Fenwick Tree (see Section 2.4.3) or the next\npbds solution.\nVisualization: https://visualgo.net/en/avl\nSource code: ch2/nonlineards/AVL.cpp|java\n89\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nPolicy-Based Data Structures (pbds), C++ only\nThe gnu g++ compiler also supports policy-based data structures (pbds) that are not part\nof the C++ standard library (hence their relative obscurity compared to the more popular\nSTL). The one that we will use to solve the selection and ranking problems easily.", "mimetype": "text/plain", "start_char_idx": 301296, "end_char_idx": 304919, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24249ab0-2b7c-42c4-993d-f67e77dd96b0": {"__data__": {"id_": "24249ab0-2b7c-42c4-993d-f67e77dd96b0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "42ecfd74-6f9d-4e60-93ab-67b0c41c35fd", "node_type": "1", "metadata": {}, "hash": "6dc7b22851ce27734404e147c2404d3698a97b63f42bac8b56d1ee61b9ca1cd4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a905f101-515e-43d2-99e2-e0ac3a759970", "node_type": "1", "metadata": {}, "hash": "f8aa770adad0be0218d5a6365ba44a077361a5c25bf9111998620b4852554db3", "class_name": "RelatedNodeInfo"}}, "text": "Visualization: https://visualgo.net/en/avl\nSource code: ch2/nonlineards/AVL.cpp|java\n89\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nPolicy-Based Data Structures (pbds), C++ only\nThe gnu g++ compiler also supports policy-based data structures (pbds) that are not part\nof the C++ standard library (hence their relative obscurity compared to the more popular\nSTL). The one that we will use to solve the selection and ranking problems easily. We will\nexplain this library solution using an example code:\n#include <bits/stdc++.h>\nusing namespace std;\n#include <bits/extc++.h>\n// pbds\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag,\ntree_order_statistics_node_update> ost;\nint main() {\nint n = 9;\nint A[] = { 2, 4, 7,10,15,23,50,65,71};\n// as in Chapter 2\nost tree;\nfor (int i = 0; i < n; ++i)\n// O(n log n)\ntree.insert(A[i]);\n// O(log n) select\ncout << *tree.find_by_order(0) << \"\\n\";\n// 1-smallest = 2\ncout << *tree.find_by_order(n-1) << \"\\n\";\n// 9-smallest/largest = 71\ncout << *tree.find_by_order(4) << \"\\n\";\n// 5-smallest = 15\n// O(log n) rank\ncout << tree.order_of_key(2) << \"\\n\";\n// index 0 (rank 1)\ncout << tree.order_of_key(71) << \"\\n\";\n// index 8 (rank 9)\ncout << tree.order_of_key(15) << \"\\n\";\n// index 4 (rank 5)\nreturn 0;\n}\nSource code: ch2/nonlineards/pbds.cpp\nExercise 2.3.4.1*: The example code above assumes that the tree contains distinct integers.\nWhat should we do if there are duplicates?\nPro\ufb01le of Data Structure Inventors\nRudolf Bayer (born 1939) has been Professor (emeritus) of Informatics at the Technical\nUniversity of Munich. He invented the Red-Black (RB) tree used in the C++ STL map/set.\nGeorgii Adelson-Velskii (1922-2014) was a Soviet mathematician and computer scientist.\nAlong with Evgenii Mikhailovich Landis, he invented the AVL tree in 1962.\nEvgenii Mikhailovich Landis (1921-1997) was a Soviet mathematician. The name of the\nAVL tree is an abbreviation of the two inventors: Adelson-Velskii and Landis himself.\n90\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nProgramming exercises solvable with library of non-linear data structures:\na. Priority Queue\n1. Entry Level: Kattis - numbertree * (not a direct priority queue problem, but\nthe indexing strategy is similar to binary heap indexing)\n2. UVa 01203 - Argus * (LA 3135 - Beijing04; priority queue simulation)\n3. UVa 11997 - K Smallest Sums * (sort the lists; merge two sorted lists\nusing priority queue to keep the K-th smallest sum every time)\n4. UVa 13190 - Rockabye Tobby * (similar to UVa 01203; use PQ; use drug\nnumbering id as tie-breaker)\n5. Kattis - jugglingpatterns * (PQ simulation; reading comprehension)\n6. Kattis - knigsoftheforest * (PQ simulation after sorting the entries by year)\n7. Kattis - stockprices * (PQ simulation; both max and min PQ)\nExtra Kattis: alehouse, clinic, guessthedatastructure, janeeyre, rationalse-\nquence2, rationalsequence3.\nAlso see the usage of priority queue for some sorting problems (see Sec-\ntion 2.2.1), greedy problems (see Section 3.4), topological sorts (see Section\n4.2.2), Kruskal\u2019s49 (see Section 4.3.2), Prim\u2019s (see Section 4.3.3), Dijkstra\u2019s\n(see Section 4.4.3), and the A* Search algorithms (see Book 2).\nb. Direct Addressing Table (DAT), ASCII\n1.", "mimetype": "text/plain", "start_char_idx": 304455, "end_char_idx": 307726, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a905f101-515e-43d2-99e2-e0ac3a759970": {"__data__": {"id_": "a905f101-515e-43d2-99e2-e0ac3a759970", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "24249ab0-2b7c-42c4-993d-f67e77dd96b0", "node_type": "1", "metadata": {}, "hash": "3f281f6176051c339093c1f3f6110535d13e13db60f12255f4818d9bc9c2c58a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "24148f9a-3e02-4379-a425-f35959db7777", "node_type": "1", "metadata": {}, "hash": "36e2074583cc89e70a7c7196a6e6d6a0766dff154b856a82ce4d09bb39ead637", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - knigsoftheforest * (PQ simulation after sorting the entries by year)\n7. Kattis - stockprices * (PQ simulation; both max and min PQ)\nExtra Kattis: alehouse, clinic, guessthedatastructure, janeeyre, rationalse-\nquence2, rationalsequence3.\nAlso see the usage of priority queue for some sorting problems (see Sec-\ntion 2.2.1), greedy problems (see Section 3.4), topological sorts (see Section\n4.2.2), Kruskal\u2019s49 (see Section 4.3.2), Prim\u2019s (see Section 4.3.3), Dijkstra\u2019s\n(see Section 4.4.3), and the A* Search algorithms (see Book 2).\nb. Direct Addressing Table (DAT), ASCII\n1. Entry Level: UVa 00499 - What\u2019s The Frequency ... * (ASCII keys)\n2. UVa 10260 - Soundex * (DAT for soundex A-Z code mapping)\n3. UVa 11340 - Newspaper * (ASCII keys)\n4. UVa 11577 - Letter Frequency * (A-Z keys)\n5. UVa 12626 - I (love) Pizza * (A-Z keys)\n6. Kattis - alphabetspam * (count the frequencies of lowercase, uppercase, and\nwhitespace characters)\n7. Kattis - quickbrownfox * (pangram; frequency counting of 26 alphabets)\nExtra UVa: 00895, 10008, 10062, 10252, 10293, 10625, 12820.\nc. Direct Addressing Table (DAT), Others\n1. Entry Level: Kattis - princesspeach * (DAT; linear pass)\n2. UVa 01368 - DNA Consensus String * (for each column j, \ufb01nd the\nhighest frequency character among all j-th column of all m DNA strings)\n3. UVa 11203 - Can you decide it ... * (count frequency of x/y/z)\n4. UVa 12650 - Dangerous Dive * (use 1D Boolean array for each person)\n5. Kattis - bookingaroom * (only 100 rooms; use 1D Boolean array)\n6. Kattis - busnumbers * (only 1 000 bus numbers; use 1D Boolean array)\n7. Kattis - freefood * (only 365 days in a year)\nExtra UVa: 00755.\nExtra Kattis: \ufb02oppy, hardware, relocation.\n49This is another way to implement the edge sorting in Kruskal\u2019s algorithm. Our (C++) implementation\nshown in Section 4.3.2 uses vector + sort pre-processing step instead of priority queue (a heap sort).\n91\n\n2.3.\nNON-LINEAR DS WITH BUILT-IN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nd. Hash Table (set)\n1. Entry Level: Kattis - cd * (unordered set is faster than set here; or use\nmodi\ufb01ed merge as the input is sorted; also available at UVa 11849 - CD)\n2. UVa 10887 - Concatenation of ... * (Use O(MN) algorithm; concatenate\nall pairs of strings; put them in an unordered set; report set size)\n3. UVa 12049 - Just Prune The List * (manipulate unordered multiset)\n4. UVa 13148 - A Giveaway * (we can store all precomputed answers\u2014\nwhich are given\u2014into unordered set)\n5. Kattis - esej * (use unordered set to prevent duplicate)\n6. Kattis - greetingcard * (use unordered set; good question; major hint: only\n12 neighbors)\n7. Kattis - shiritori * (linear pass; use unordered set to keep track of words\nthat have been called)\nExtra Kattis: bard, boatparts, deduplicating\ufb01les, engineeringenglish, every-\nwhere, icpcawards, iwannabe, keywords, nodup, oddmanout, pizzahawaii, proofs,\nsecuredoors, whatdoesthefoxsay.\ne. Hash Table (map), Easier\n1. Entry Level: Kattis - recount * (use unordered map; frequency counting)\n2. UVa 00902 - Password Search * (read char by char; count word freq)\n3. UVa 11348 - Exhibition * (use unordered map and unordered set to\ncount frequency; check uniqueness)\n4.", "mimetype": "text/plain", "start_char_idx": 307142, "end_char_idx": 310319, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24148f9a-3e02-4379-a425-f35959db7777": {"__data__": {"id_": "24148f9a-3e02-4379-a425-f35959db7777", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a905f101-515e-43d2-99e2-e0ac3a759970", "node_type": "1", "metadata": {}, "hash": "f8aa770adad0be0218d5a6365ba44a077361a5c25bf9111998620b4852554db3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9a7a1d2b-b1b9-45dd-9d34-e51736138a24", "node_type": "1", "metadata": {}, "hash": "989f5791da9d1f52c657c3811e2bdaf70262395d531d7b6bc891ff27e70d3df5", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - greetingcard * (use unordered set; good question; major hint: only\n12 neighbors)\n7. Kattis - shiritori * (linear pass; use unordered set to keep track of words\nthat have been called)\nExtra Kattis: bard, boatparts, deduplicating\ufb01les, engineeringenglish, every-\nwhere, icpcawards, iwannabe, keywords, nodup, oddmanout, pizzahawaii, proofs,\nsecuredoors, whatdoesthefoxsay.\ne. Hash Table (map), Easier\n1. Entry Level: Kattis - recount * (use unordered map; frequency counting)\n2. UVa 00902 - Password Search * (read char by char; count word freq)\n3. UVa 11348 - Exhibition * (use unordered map and unordered set to\ncount frequency; check uniqueness)\n4. UVa 11629 - Ballot evaluation * (use unordered map)\n5. Kattis - competitivearcadebasketball * (use unordered map)\n6. Kattis - conformity * (use unordered map to count frequencies of the sorted\npermutations of 5 ids; also available at UVa 11286 - Conformity)\n7. Kattis - grandpabernie * (use unordered map plus (sorted) vector)\nExtra UVa: 00484, 00860, 10374, 10686, 12592.\nExtra Kattis: babel\ufb01sh, costumecontest, election2, haypoints, marko, metapro-\ngramming, rollcall, variablearithmetic.\nf. Hash Table (map), Harder\n1. Entry Level: Kattis - conversationlog * (use combo DS: unordered map, set,\nplus (sorted) vector)\n2. UVa 00417 - Word Index * (generate all words with brute force up to\ndepth 5 and give them appropriate indices; add to unordered map)\n3. UVa 10145 - Lock Manager * (use unordered map and unordered set)\n4. UVa 11860 - Document Analyzer * (use unordered set to get unique\nstrings and use unordered map with linear scan to get the answer)\n5. Kattis - addingwords * (use unordered map)\n6. Kattis - awkwardparty * (use unordered map to running max and running\nmin; report the largest di\u21b5erence)\n7. Kattis - basicinterpreter * (the harder version of Kattis - variablearithmetic;\ntedious; be careful; print string inside double quotes verbatim)\nExtra UVa: 10132, 11917.\nExtra Kattis: iforaneye, magicalcows, minorsetback, parallelanalysis, recenice,\nsnow\ufb02akes.\n92\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\ng. Balanced BST (set)\n1. Entry Level: UVa 10815 - Andy\u2019s First Dictionary * (use set and\nstring; sorted output)\n2. UVa 00978 - Lemmings Battle * (simulation; use multiset)\n3. UVa 11136 - Hoax or what * (use multiset)\n4. UVa 13037 - Chocolate * (we can use set or a sorted array)\n5. Kattis - bst * (simulate special BST [1..N] insertions using set)\n6. Kattis - candydivision * (complete search from 1 to\np\nN; insert all divisors\ninto set for automatic sorting and elimination of duplicates)\n7. Kattis - compoundwords * (use set extensively; iterator)\nExtra UVa: 00501, 11062.\nExtra Kattis: caching, ministryofmagic, missinggnomes, orphanbackups, palin-\ndromicpassword, raceday, raidteams.\nAlso check Sorting in Section 2.2.1.\nh. Balanced BST (map)\n1. Entry Level: Kattis - doctorkattis * (Max Priority Queue with frequent (in-\ncreaseKey) updates; use map)\n2. UVa 10138 - CDVII * (use map to map plates to bills, entrance time, and\nposition; sorted output)\n3. UVa 11308 - Bankrupt Baker * (use map and set)\n4. UVa 12504 - Updating a ... * (use map; string to string; order needed)\n5. Kattis - administrativeproblems * (use several maps as the output (of spy\nnames) has to be sorted; be careful of corner cases)\n6.", "mimetype": "text/plain", "start_char_idx": 309662, "end_char_idx": 312977, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9a7a1d2b-b1b9-45dd-9d34-e51736138a24": {"__data__": {"id_": "9a7a1d2b-b1b9-45dd-9d34-e51736138a24", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "24148f9a-3e02-4379-a425-f35959db7777", "node_type": "1", "metadata": {}, "hash": "36e2074583cc89e70a7c7196a6e6d6a0766dff154b856a82ce4d09bb39ead637", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1be4cee3-acc9-40a3-be4e-a0f0422f8422", "node_type": "1", "metadata": {}, "hash": "ce68fe1bbacd49dcd5d8b1bedf97270c47833f24ac4290d57f7f5f6b5c6f9c9c", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: caching, ministryofmagic, missinggnomes, orphanbackups, palin-\ndromicpassword, raceday, raidteams.\nAlso check Sorting in Section 2.2.1.\nh. Balanced BST (map)\n1. Entry Level: Kattis - doctorkattis * (Max Priority Queue with frequent (in-\ncreaseKey) updates; use map)\n2. UVa 10138 - CDVII * (use map to map plates to bills, entrance time, and\nposition; sorted output)\n3. UVa 11308 - Bankrupt Baker * (use map and set)\n4. UVa 12504 - Updating a ... * (use map; string to string; order needed)\n5. Kattis - administrativeproblems * (use several maps as the output (of spy\nnames) has to be sorted; be careful of corner cases)\n6. Kattis - kattissquest * (use map of priority queues; other solutions exist)\n7. Kattis - srednji * (go left and right of B; use fast data structure like map to\nhelp determine the result fast)\nExtra UVa: 00939, 10420.\nExtra Kattis: baconeggsandspam, cakeymccakeface, fantasydraft, hardwood-\nspecies, notamused, opensource, problemclassi\ufb01cation, warehouse, zoo.\nAlso check Sorting in Section 2.2.1.\ni. Order Statistics Tree\n1. Entry Level: UVa 10909 - Lucky Number * (involves dynamic selection;\nuse pb ds, Fenwick Tree, or augment balanced BST)\n2. Kattis - babynames * (dynamic rank problem; use two pb ds)\n3. Kattis - continuousmedian * (dynamic selection problem; speci\ufb01cally the\nmedian values; pb ds helps)\n4. Kattis - cookieselection * (map large integers to up to 600K integers; use\npb ds or Fenwick Tree and the select(median) operation of Fenwick Tree)\n5. Kattis - gcpc * (dynamic rank problem; pb ds helps)\n93\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.4\nDS with Our Own Libraries\nAs of year 2020, important data structures shown in this section do not have built-in support\nyet in C++ STL, Java API, or Python/OCaml Standard Library. Thus, to be competitive,\ncontestants should prepare bug-free implementations of these data structures. In this section,\nwe discuss the key ideas and example implementations of these data structures.\n2.4.1\nGraph\nGraph is a pervasive structure which appears in many Computer Science problems.\nA\ngraph (G = (V, E)) in its basic form is simply a set of vertices (V ) and edges (E; storing\nconnectivity information between vertices in V ). Later in Chapter 3, 4, 8, and 9, we will\nexplore many important graph problems and algorithms. To prepare ourselves, we will \ufb01rst\ndiscuss three basic ways (there are a few other rare graph data structures later) to represent\na graph G with V vertices and E edges in this book50.\nFigure 2.7: Graph Data Structure Visualization, Undirected/Unweighted Graph\nThe Adjacency Matrix AM\nUsually in the form of a 2D array (see Figure 2.7, bottom left).\nNative support in C++ STL and Java API.\nWe use list of lists in Python/t array array in OCaml.\nIn (competitive programming) problems involving graphs, the number of vertices V is usually\nknown. Thus, if V is small enough, we can build a \u2018connectivity table\u2019 by creating a static\n2D array (a square matrix): int AM[V ][V ]. This has an O(V 2) space51 complexity. For an\nunweighted graph, set AM[u][v] to a non-zero value (usually 1) if there is an edge between\nvertex u-v and zero otherwise52. For a weighted graph, set AM[u][v] = weight(u, v) if\nthere is an edge between vertex u-v with weight(u, v) and zero otherwise. (Standard)\n50The most appropriate notation for the cardinality of a set S is |S|. However, in this book, we will often\noverload the meaning of V or E to also mean |V | or |E|, depending on the context.\n51We di\u21b5erentiate between the space and time complexities of data structures.", "mimetype": "text/plain", "start_char_idx": 312341, "end_char_idx": 315914, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1be4cee3-acc9-40a3-be4e-a0f0422f8422": {"__data__": {"id_": "1be4cee3-acc9-40a3-be4e-a0f0422f8422", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9a7a1d2b-b1b9-45dd-9d34-e51736138a24", "node_type": "1", "metadata": {}, "hash": "989f5791da9d1f52c657c3811e2bdaf70262395d531d7b6bc891ff27e70d3df5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3638f542-4b64-4566-993c-e941e9d28f3b", "node_type": "1", "metadata": {}, "hash": "fa5f954285bf48c2c7793e6ddd254514f360e66b8ed45c9e0733e27fe6822694", "class_name": "RelatedNodeInfo"}}, "text": "This has an O(V 2) space51 complexity. For an\nunweighted graph, set AM[u][v] to a non-zero value (usually 1) if there is an edge between\nvertex u-v and zero otherwise52. For a weighted graph, set AM[u][v] = weight(u, v) if\nthere is an edge between vertex u-v with weight(u, v) and zero otherwise. (Standard)\n50The most appropriate notation for the cardinality of a set S is |S|. However, in this book, we will often\noverload the meaning of V or E to also mean |V | or |E|, depending on the context.\n51We di\u21b5erentiate between the space and time complexities of data structures. The space complexity is\nan asymptotic measure of the memory requirements of a data structure whereas the time complexity is an\nasymptotic measure of the time taken to run a certain algorithm or an operation on the data structure.\n52We assume that there is no 0-weighted edge in a typical input graph. Simply use alternative non-used\nvalue if such 0-weighted edge exists in your graph.\n94\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nAdjacency Matrix cannot be used to store a weighted multigraph53 that allows multiple\nedges between the same pair of vertices. For a simple graph without any self-loop, the main\ndiagonal of the matrix contains only zeroes, i.e., AM[u][u] = 0, 8u 2 [0..V-1].\nAn Adjacency Matrix is a good choice if the connectivity between two vertices in a small\ndense graph is frequently required. However, it is not recommended for large sparse graphs\nas it would require too much space (O(V 2)) and there would be many blank (zero) cells in\nthe 2D array. In a competitive setting, it is usually infeasible to use Adjacency Matrices\nwhen the given V is larger than \u21e15000. Another drawback of Adjacency Matrix is that it\nalso takes O(V ) time to enumerate the list of neighbors of a vertex u\u2014an operation common\nto many graph algorithms\u2014even if that vertex u only has a handful of neighbors. A more\ncompact and e\ufb03cient graph representation is the Adjacency List discussed below.\nThe Adjacency List AL\nUsually in the form of a vector of vector of pairs (see Figure 2.7, bottom middle).\nUsing the C++ STL: vector<vii> AL, with vii de\ufb01ned as in:\ntypedef pair<int, int> ii; typedef vector<ii> vii; // data type shortcuts\nUsing the Java API: ArrayList<ArrayList<IntegerPair>> AL.\nIntegerPair is a simple Java class that contains a pair of integers like pair<int, int>.\nUsing Python: AL = defaultdict(list), the values in list are grouped by pairs.\nUsing OCaml: (int * int) list array.\nIn an Adjacency List AL, we have a vector of vector of pairs, storing the list of neighbors\nof each vertex u as \u2018edge information\u2019 pairs. Each pair contains two pieces of information,\nthe index of the neighbouring vertex and the weight of the edge. If the graph is unweighted,\nsimply store the weight as 0, 1, or drop the weight attribute54 entirely. The space complexity\nof Adjacency List is O(V +E) because if there are E bidirectional edges in a (simple) graph,\nthis Adjacency List will only store 2E \u2018edge information\u2019 pairs.\nAs E is usually much\nsmaller than V \u21e5(V \u22121)/2 = O(V 2)\u2014the maximum number of edges in a complete (simple)\ngraph, Adjacency Lists are often more space-e\ufb03cient than Adjacency Matrices. Note that\nAdjacency List can be used to (easily) store a multigraph.\nWith Adjacency Lists, we can also enumerate the list of neighbors of a vertex v e\ufb03ciently.\nIf v has k neighbors, the enumeration will require O(k) time. Usually\u2013although not always\u2013\nthe neighbors are listed in ascending vertex numbers. Since this is one of the most common\noperations in most graph algorithms, it is advisable to use Adjacency Lists as your \ufb01rst\nchoice of graph representation. Unless otherwise stated, most graph algorithms discussed in\nthis book use the Adjacency List.\nThe Edge List EL\nUsually in the form of a vector of triples (see Figure 2.7, bottom right).\nUsing the C++ STL: vector<tuple<int, int, int>> EL.\nUsing the Java API: Vector<IntegerTriple> EL.", "mimetype": "text/plain", "start_char_idx": 315338, "end_char_idx": 319295, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3638f542-4b64-4566-993c-e941e9d28f3b": {"__data__": {"id_": "3638f542-4b64-4566-993c-e941e9d28f3b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1be4cee3-acc9-40a3-be4e-a0f0422f8422", "node_type": "1", "metadata": {}, "hash": "ce68fe1bbacd49dcd5d8b1bedf97270c47833f24ac4290d57f7f5f6b5c6f9c9c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "090b0a35-827e-4f04-a7ab-2f331a1f9e54", "node_type": "1", "metadata": {}, "hash": "9f9d077e5be10689b7b0126fd1b58fcf91013f2f97fd586a597c96d704af7c8e", "class_name": "RelatedNodeInfo"}}, "text": "Note that\nAdjacency List can be used to (easily) store a multigraph.\nWith Adjacency Lists, we can also enumerate the list of neighbors of a vertex v e\ufb03ciently.\nIf v has k neighbors, the enumeration will require O(k) time. Usually\u2013although not always\u2013\nthe neighbors are listed in ascending vertex numbers. Since this is one of the most common\noperations in most graph algorithms, it is advisable to use Adjacency Lists as your \ufb01rst\nchoice of graph representation. Unless otherwise stated, most graph algorithms discussed in\nthis book use the Adjacency List.\nThe Edge List EL\nUsually in the form of a vector of triples (see Figure 2.7, bottom right).\nUsing the C++ STL: vector<tuple<int, int, int>> EL.\nUsing the Java API: Vector<IntegerTriple> EL.\nIntegerTriple is a class that contains a triple of integers like tuple<int, int, int>.\nUsing Python: EL = [].\nThe edges are tuples55, usually (w, u, v), i.e., weight w plus the two endpoints u and v.\nUsing OCaml: (int * int * int) list.\n53Most programming problems involving graph deal with simple graphs. Simple graph has no self-loop or\nmultiple edges between the same pair of vertices. These two properties simplify most graph problems.\n54To simplify discussion, we will always assume that the second attribute exists in all graph implementa-\ntions in this book although it is not always used. Readers are free to customize these implementations.\n55If the graph is unweighted, you can drop w.\n95\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nIn an Edge List EL, we store a list of all E edges, usually in some sorted order. For directed\ngraphs, we store a bidirectional edge twice, one for each direction. The space complexity\nis O(E). This graph representation is very useful for Kruskal\u2019s algorithm for MST (Section\n4.3.2) where the collection of undirected edges need to be sorted56 by ascending (or non-\ndecreasing) weight.\nHowever, storing graph information in Edge List complicates many\ngraph algorithms that require the enumeration of edges incident to a vertex.\nIf you are interested to explore more details about these three classic Graph Data Struc-\ntures, please visit VisuAlgo, Graph Data Structures visualization, that shows visualiza-\ntions of Adjacency Matrix, Adjacency List, and Edge List for any (small) input graph,\nbe it directed or undirected and weighted or unweighted. In that visualization, we pro-\nvide many example graphs of varying properties (undirected/directed, unweighted/weighted,\ntree/bipartite/DAG/complete, sparse/dense, etc). Many of these example graphs are also\nused elsewhere in this book. The URL for the Graph Data Structures visualization and\nsource code example are shown below.\nVisualization: https://visualgo.net/en/graphds\nSource code: ch2/ourown/graph ds.cpp|java|py|ml\nVertex Labels that are not 2 [0..V -1]\nSo far, we assume that all vertices are labeled nicely, i.e., labeled with integer indices in a\nnice range of [0..V -1]. If the vertices of the graph are labeled with strings instead, e.g., a\ngraph of \ufb02ight connections that connect two cities identi\ufb01ed by their names (two strings),\nthen we need to do more work.\nThe \ufb01rst idea is to use unordered map to map those string labels into integers in range\n[0..V -1] (see Exercise 2.3.2.3), and then proceed as usual.\nBut we can also use unordered map<string, vector<string>> AL. This implemen-\ntation, albeit shorter to code, is slightly slower than working with pure integer indices.\nStoring Special Graphs\nWhen the graphs to be stored are special (details in Section 4.6), we may be able to use a\nsimpler graph data structure to store them. Below, we list down a few:\n1. The graph is an unweighted rooted tree (see Section 2.4.2 and Section 4.6.2).\nOne of the simplest way to store an unweighted tree structure is like the one used in\nUnion-Find Disjoint Sets data structure in Section 2.4.2 and DFS/BFS/MST/SSSP\nspanning tree in Chapter 4. Vertex i remembers just one information, its parent, i.e.,\np[i]. Thus, we only need a single array p of size V to store the unweighted tree.\n2.", "mimetype": "text/plain", "start_char_idx": 318549, "end_char_idx": 322598, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "090b0a35-827e-4f04-a7ab-2f331a1f9e54": {"__data__": {"id_": "090b0a35-827e-4f04-a7ab-2f331a1f9e54", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3638f542-4b64-4566-993c-e941e9d28f3b", "node_type": "1", "metadata": {}, "hash": "fa5f954285bf48c2c7793e6ddd254514f360e66b8ed45c9e0733e27fe6822694", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3de92378-8f37-4a4e-a806-80ce63529c50", "node_type": "1", "metadata": {}, "hash": "257087b1f5cc0a1e162b8eee5cb0dc03f5afe11d4988d56b23f2f32d3b99f400", "class_name": "RelatedNodeInfo"}}, "text": "This implemen-\ntation, albeit shorter to code, is slightly slower than working with pure integer indices.\nStoring Special Graphs\nWhen the graphs to be stored are special (details in Section 4.6), we may be able to use a\nsimpler graph data structure to store them. Below, we list down a few:\n1. The graph is an unweighted rooted tree (see Section 2.4.2 and Section 4.6.2).\nOne of the simplest way to store an unweighted tree structure is like the one used in\nUnion-Find Disjoint Sets data structure in Section 2.4.2 and DFS/BFS/MST/SSSP\nspanning tree in Chapter 4. Vertex i remembers just one information, its parent, i.e.,\np[i]. Thus, we only need a single array p of size V to store the unweighted tree.\n2. The graph is a complete binary tree (with weight on vertices).\nWe have seen in Section 2.3.1 that a complete binary tree structure with V vertices\ncan be stored e\ufb03ciently using an array of size V +1 (ignoring index 0) from top level to\nthe lowest level, from the leftmost vertex to the rightmost vertex of each level. Later,\nwe will reuse the same idea for Segment Tree data structure (see Section 2.4.4).\n3. The unweighted graph is very small (1 \uf8ffV \uf8ff62).\nFor a small unweighted graph with 1 \uf8ffV \uf8ff5000, we can use Adjacency Matrix data\n56pair objects in C++ and tuple objects in Python can be easily sorted. The default sorting criteria\nis to sort on the \ufb01rst item and then the second item for tie-breaking.\nIn Java, we can write our own\nIntegerPair/IntegerTriple class that implements Comparable.\n96\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nstructure. For a very small graph with 1 \uf8ffV \uf8ff62, we may even compress each row of\nzeroes and ones of the Adjacency Matrix into a bitmask (use 64-bit integer, e.g., long\nlong). This way, we only need a single 1D array AM of size V vertices and each AM[i]\nstores a bitmask of neighbors of vertex i. Since this neighbor list is a bitmask, all bit\nmanipulation operations discussed in Section 2.2.3 are applicable, i.e., we can delete\nall outgoing edges of a vertex i by setting AM[i] = 0, create all outgoing edges of a\nvertex i by setting AM[i] = (1<<V)-1, complement the graph by \ufb02ipping all bits in\neach row of AM, etc. This technique is used later in Book 2.\n4. The unweighted graph (V \uf8ff200K) is dense (E = (V \u21e5(V -1)/2) \u2212L; L \uf8ff10K).\nIf a rather large graph is unweighted and is known to be dense, it may be worthwhile\nto reverse our thinking process and store information of the L edges that are not in\nthe graph inside a hash table called NOTEXIST. That\u2019s it, we assume that our graph\nis a complete unweighted graph \ufb01rst and if an edge that we want to traverse is inside\nNOTEXIST, we know that such edge actually does not exist in the original graph.\nImplicit Graph\nSome graphs do not have to be stored in a graph data structure or explicitly generated for\nthe graph to be traversed or operated upon. Such graphs are called implicit graphs. We will\nencounter them in the subsequent chapters. Some example implicit graphs are:\nFigure 2.8: Implicit Graph Examples\n1. Navigating a 2D grid map (see Figure 2.8\u2014A). The vertices are the cells in the 2D\ncharacter grid where \u2018.\u2019 represents land and \u2018#\u2019 represents an obstacle. The edges can\nbe determined easily: there is an edge between two neighboring cells in the grid if they\nshare an N/E/S/W border57 and if both are \u2018.\u2019 (see Figure 2.8\u2014B).\n2. The graph of chess knight movements on an 8\u21e58 chessboard. The vertices are the cells\nin the chessboard. Two squares in the chessboard have an edge between them if they\ndi\u21b5er by two squares horizontally and one square vertically (or two squares vertically\nand one square horizontally).", "mimetype": "text/plain", "start_char_idx": 321891, "end_char_idx": 325546, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3de92378-8f37-4a4e-a806-80ce63529c50": {"__data__": {"id_": "3de92378-8f37-4a4e-a806-80ce63529c50", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "090b0a35-827e-4f04-a7ab-2f331a1f9e54", "node_type": "1", "metadata": {}, "hash": "9f9d077e5be10689b7b0126fd1b58fcf91013f2f97fd586a597c96d704af7c8e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "34f28792-d2e6-48b7-90f2-f3c2edba834c", "node_type": "1", "metadata": {}, "hash": "66370c5a47377ebabeb2f16c9c7ade36b99e13c78bdd901363e7d6152fe856d4", "class_name": "RelatedNodeInfo"}}, "text": "We will\nencounter them in the subsequent chapters. Some example implicit graphs are:\nFigure 2.8: Implicit Graph Examples\n1. Navigating a 2D grid map (see Figure 2.8\u2014A). The vertices are the cells in the 2D\ncharacter grid where \u2018.\u2019 represents land and \u2018#\u2019 represents an obstacle. The edges can\nbe determined easily: there is an edge between two neighboring cells in the grid if they\nshare an N/E/S/W border57 and if both are \u2018.\u2019 (see Figure 2.8\u2014B).\n2. The graph of chess knight movements on an 8\u21e58 chessboard. The vertices are the cells\nin the chessboard. Two squares in the chessboard have an edge between them if they\ndi\u21b5er by two squares horizontally and one square vertically (or two squares vertically\nand one square horizontally). The \ufb01rst three rows and four columns of a chessboard\nare shown in Figure 2.8\u2014C (many other vertices and edges are not shown). See the\ndetails about knight moves in Section 4.4.2.\n3. A graph with N vertices labeled with [1..N] and there is an edge between two vertices\nlabeled with i and j if and only if (i + j) is a prime. See Figure 2.8\u2014D for N = 5.\nNote: We will see several more examples of implicit graphs throughout this book.\nWhenever we encounter an implicit graph, we usually do not store it in an explicit graph\ndata structure (although we can), but we will instead run our graph algorithm \u2018on-the-\ufb02y\u2019,\ni.e., we determine the next vertex/edge to be processed as the graph algorithm runs.\n57Other variants have 8 directions: N/NE/E/SE/S/SW/W/NW.\n97\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nExercise 2.4.1.1: If the Adjacency Matrix (AM) of a (simple) graph has the property that\nit is equal to its transpose, what does this imply?\nExercise 2.4.1.2*: Given a (simple) graph represented by an AM, perform the following\ntasks in the most e\ufb03cient manner. Once you have \ufb01gured out how to do this for AM, perform\nthe same task with Adjacency List (AL) and then Edge List (EL).\n1. Count the number of vertices V and directed edges E (assume that a bidirectional\nedge is equivalent to two directed edges) of the graph.\n2*. Count the in-degree and the out-degree of a certain vertex v.\n3*. Transpose the graph (reverse the direction of each edge).\n4*. Create the complement of the graph.\n5*. Check if the graph is a complete graph Kn.\nNote: A complete graph is a simple\nundirected graph in which every pair of distinct vertices is connected by a single edge.\n6*. Check if the graph is a tree (a connected undirected graph with E = V \u22121 edges).\n7*. Check if the graph is a star graph Sk. Note: A star graph Sk is a complete bipartite\nK1,k graph. It is a tree with only one internal vertex and k leaves.\n8*. Delete a certain edge (u, v) from the graph.\n9*. Update the weight of a certain edge (u, v) of the graph from w to w0.\nExercise 2.4.1.3*: Create the Adjacency Matrix, Adjacency List, and Edge List represen-\ntations of the graphs shown in Figure 4.1 (Section 4.2.2) and in Figure 4.8 (Section 4.2.10).\nHint: Use the graph data structure visualization in VisuAlgo.\nExercise 2.4.1.4*: Given a (simple) graph in one representation (AM, AL, or EL), convert\nit into another graph representation in the most e\ufb03cient way possible! There are 6 possible\nconversions here: AM to AL, AM to EL, AL to AM, AL to EL, EL to AM, and EL to AL.\nExercise 2.4.1.5*: Research other possible methods of representing graphs other than the\nones discussed in this section, especially for storing special graphs!\nExercise 2.4.1.6*: In this section, we assume that the neighbors of a vertex are listed in\nincreasing vertex number for Adjacency List (as Adjacency Matrix somewhat enforces such\nordering and there is no notion of neighbors of a vertex in Edge List).", "mimetype": "text/plain", "start_char_idx": 324811, "end_char_idx": 328506, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "34f28792-d2e6-48b7-90f2-f3c2edba834c": {"__data__": {"id_": "34f28792-d2e6-48b7-90f2-f3c2edba834c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3de92378-8f37-4a4e-a806-80ce63529c50", "node_type": "1", "metadata": {}, "hash": "257087b1f5cc0a1e162b8eee5cb0dc03f5afe11d4988d56b23f2f32d3b99f400", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "58249bd0-3409-45a6-b57a-b91e60fae83d", "node_type": "1", "metadata": {}, "hash": "7b80ca345c74e3b91afa7d35037890fa187e6b581d97e6969323d397557618f6", "class_name": "RelatedNodeInfo"}}, "text": "Hint: Use the graph data structure visualization in VisuAlgo.\nExercise 2.4.1.4*: Given a (simple) graph in one representation (AM, AL, or EL), convert\nit into another graph representation in the most e\ufb03cient way possible! There are 6 possible\nconversions here: AM to AL, AM to EL, AL to AM, AL to EL, EL to AM, and EL to AL.\nExercise 2.4.1.5*: Research other possible methods of representing graphs other than the\nones discussed in this section, especially for storing special graphs!\nExercise 2.4.1.6*: In this section, we assume that the neighbors of a vertex are listed in\nincreasing vertex number for Adjacency List (as Adjacency Matrix somewhat enforces such\nordering and there is no notion of neighbors of a vertex in Edge List). What if the neighbors\nare not listed in increasing vertex number in the input but we prefer them to be in sorted\norder in our computation? What is your best implementation?\nExercise 2.4.1.7*: Follow up question, is it a good idea to always store vertex numbers in\nincreasing order inside the Adjacency List?\nExercise 2.4.1.8*: Think of a situation/problem where using two (or more) graph data\nstructures at the same time for the same graph can be useful!\n98\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.4.2\nUnion-Find Disjoint Sets\nMotivation\nThe Union-Find Disjoint Set (often abbreviated as UFDS) is a data structure to model a\ncollection of disjoint sets with the ability to e\ufb03ciently\u2014in \u21e1O(1)\u2014determine which set\nan item belongs to (or to test whether two items belong to the same set) and to unite two\ndisjoint sets into one larger set. Such data structure can be used to solve the problem of\n\ufb01nding connected components in an undirected graph (Section 4.2.4 and 4.3.2). Initialize\neach vertex into a separate disjoint set, then enumerate the graph\u2019s edges and union every\ntwo vertices/disjoint sets connected by an edge. We can then test if two vertices belong to\nthe same component/set easily. The number of disjoint sets that can be easily tracked also\ndenotes the number of connected components of the undirected graph.\nThese seemingly simple operations are not e\ufb03ciently supported by the C++ STL set,\nJava TreeSet, Python set, or OCaml Set as they are not designed for this speci\ufb01c purpose.\nHaving a vector of sets and looping through each one to \ufb01nd which set an item belongs\nto is expensive! C++ STL set union (in algorithm) will not be e\ufb03cient enough although\nit combines two sets in linear time as we still have to deal with shu\u270fing many contents\nof the vector of sets! To support these set operations e\ufb03ciently, we need a better data\nstructure\u2014the UFDS.\nThe Basic Ideas\nThe main innovation of this data structure is in choosing a representative \u2018parent\u2019 item to\nrepresent a set. If we can ensure that each set is represented by only one unique item, then\ndetermining if two items belong to the same set becomes far simpler: the representative \u2018par-\nent\u2019 item can be used as the identi\ufb01er for the set. To achieve this, the UFDS data structure\ncreates a conceptual58 tree structure where the disjoint sets form a forest of trees. Each tree\ncorresponds to a disjoint set. The root of the tree is determined to be the representative\nitem for a set. Thus, the representative set identi\ufb01er for an item can be obtained simply\nby following the chain of parents to the root of the tree, and since a tree can only have one\nroot, this representative item can be used as a unique identi\ufb01er for the set.\nTo do this e\ufb03ciently, we store the index of the parent item and (the upper bound of) the\nheight of the tree of each set (vi p and vi rank in our implementation). Remember that\nvi is our shortcut for a vector of integers. p[i] stores the immediate parent of item i. If\nitem i is the representative item of a certain disjoint set, then p[i] = i, i.e., a self-loop.\nrank[i] yields (the upper bound of) the height of the tree rooted at item i. We use vi\nrank to help us keep the trees rather short, as we will see below.", "mimetype": "text/plain", "start_char_idx": 327771, "end_char_idx": 331754, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "58249bd0-3409-45a6-b57a-b91e60fae83d": {"__data__": {"id_": "58249bd0-3409-45a6-b57a-b91e60fae83d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "34f28792-d2e6-48b7-90f2-f3c2edba834c", "node_type": "1", "metadata": {}, "hash": "66370c5a47377ebabeb2f16c9c7ade36b99e13c78bdd901363e7d6152fe856d4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3faad072-71fe-4728-95ba-2c86e29ba076", "node_type": "1", "metadata": {}, "hash": "d1e1d8b9ed473a3fd4533094ffdec55235715f55cd43cc632b997194d1c61e06", "class_name": "RelatedNodeInfo"}}, "text": "Thus, the representative set identi\ufb01er for an item can be obtained simply\nby following the chain of parents to the root of the tree, and since a tree can only have one\nroot, this representative item can be used as a unique identi\ufb01er for the set.\nTo do this e\ufb03ciently, we store the index of the parent item and (the upper bound of) the\nheight of the tree of each set (vi p and vi rank in our implementation). Remember that\nvi is our shortcut for a vector of integers. p[i] stores the immediate parent of item i. If\nitem i is the representative item of a certain disjoint set, then p[i] = i, i.e., a self-loop.\nrank[i] yields (the upper bound of) the height of the tree rooted at item i. We use vi\nrank to help us keep the trees rather short, as we will see below.\nIn this section, we will use 5 disjoint sets {0, 1, 2, 3, 4} to illustrate the usage of this\ndata structure. We initialize the data structure such that each item is a disjoint set by itself\nwith rank 0 and the parent of each item is initially set to itself, as illustrated in the simple\nFigure 2.9. As the tree grows taller, we will show the current rank values of vertices with\nrank > 0. Each edge (p[i], i) of the tree implies that the parent of vertex i is p[i]. In the\nvisualization, p[i] is placed higher in y-axis than i.\nFigure 2.9: Initial State: 5 Disjoint Sets = 5 Isolated Trees/Single Vertices\n58We actually implement the UFDS using vector, thus the tree structure is conceptual only.\n99\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nUFDS Operation: O(1) findSet(i)\nThe function findSet(i) simply calls findSet(p[i]) recursively to \ufb01nd the representative\nitem of a set, returning findSet(p[i]) if p[i] != i and i otherwise.\nThere is a technique that can vastly speed up the findSet(i) function: Path compres-\nsion. Whenever we \ufb01nd the representative (root) item of a disjoint set by following the chain\nof \u2018parent\u2019 edges from a given item, we can set the parent of all items traversed to point\ndirectly to the root. Any subsequent calls to findSet(i) on the a\u21b5ected items will then\nresult in only one edge being traversed. This changes the structure of the tree (to make\nfindSet(i) more e\ufb03cient) but yet preserves the actual constitution of the disjoint set.\nIn Figure 2.10 (which is the result of 4 calls of di\u21b5erent unionSet(i, j) operations that\nare shown later in Figure 2.11), we show this \u2018path compression\u2019. See that p[0] = 1 but\n1 is not the root. This is an indirect reference to the (true) representative item of the set,\ni.e., p[0] = 1 and p[1] = 3 where 3 is the actual root of this tree. Function findSet(i)\nmay require more than one step to traverse the chain of \u2018parent\u2019 edges to the root, especially\nwhen this chain is long (see Figure 2.10\u2014top). However, once it \ufb01nds the representative\nitem, (e.g., \u2018x\u2019) for that set, it will compress the path by setting p[i] = x 8i along the\nchain. In this example, findSet(0) sets p[0] = 3 directly. Therefore, subsequent calls of\nfindSet(i) will be just O(1) (see Figure 2.10\u2014bottom). This strategy is aptly named the\n\u2018path compression\u2019. Note that after such path compression, rank[3] = 2 now no longer\nre\ufb02ects the true height of the tree. This is why rank only re\ufb02ects the upper bound of the\nactual height of the tree. We don\u2019t bother updating these rank values as it is costly to do\nso and they are only used as \u2018guiding heuristic\u2019 during unionSet(i, j) operations.", "mimetype": "text/plain", "start_char_idx": 330992, "end_char_idx": 334401, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3faad072-71fe-4728-95ba-2c86e29ba076": {"__data__": {"id_": "3faad072-71fe-4728-95ba-2c86e29ba076", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "58249bd0-3409-45a6-b57a-b91e60fae83d", "node_type": "1", "metadata": {}, "hash": "7b80ca345c74e3b91afa7d35037890fa187e6b581d97e6969323d397557618f6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "89058d4e-e6c9-4560-9756-e798ac837423", "node_type": "1", "metadata": {}, "hash": "b84f511248d749219c90b8418ccbfed389297b62788e322722225e7fd1406872", "class_name": "RelatedNodeInfo"}}, "text": "However, once it \ufb01nds the representative\nitem, (e.g., \u2018x\u2019) for that set, it will compress the path by setting p[i] = x 8i along the\nchain. In this example, findSet(0) sets p[0] = 3 directly. Therefore, subsequent calls of\nfindSet(i) will be just O(1) (see Figure 2.10\u2014bottom). This strategy is aptly named the\n\u2018path compression\u2019. Note that after such path compression, rank[3] = 2 now no longer\nre\ufb02ects the true height of the tree. This is why rank only re\ufb02ects the upper bound of the\nactual height of the tree. We don\u2019t bother updating these rank values as it is costly to do\nso and they are only used as \u2018guiding heuristic\u2019 during unionSet(i, j) operations.\nPath compression technique used in the findSet(i) function combined with the \u2018union\nby rank\u2019 heuristic used in the unionSet(i, j) operation make the runtime of the M calls\nof findSet(i) (and also findSet(i) embedded inside unionSet(i, j)) operations to run\nin an extremely e\ufb03cient amortized O(M \u21e5\u21b5(n)) time.\nFor the purpose of competitive\nprogramming where n is reasonably small (n \uf8ff1M), we can treat the inverse Ackermann\nfunction \u21b5(n) as O(1) constant operation.\nFigure 2.10: Top: findSet(0), Bottom: The Subsequent Path Compression\nUFDS Operation: O(1) isSameSet(i, j)\nIn Figure 2.11\u2014bottom, isSameSet(0, 4) demonstrates another operation for this data\nstructure. Function isSameSet(i, j) simply calls O(1) findSet(i) and O(1) findSet(j)\nand checks if both refer to the same representative item. If they do, then i and j both\nbelong to the same set. Here, we see that findSet(0) = findSet(p[0]) = findSet(1) =\n1 is not the same as findSet(4) = findSet(p[4]) = findSet(3) = 3. Thus we return\nfalse, item 0 and item 4 belong to di\u21b5erent disjoint sets.\nOn the same Figure 2.11, bottom, if we ask isSameSet(2, 4) instead, we will return\ntrue as findSet(2) = findSet(p[2]) = findSet(3) = 3 is the same as findSet(4), i.e.,\nitem 2 and item 4 belong to the same disjoint set.\n100\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nUFDS Operation: O(1) unionSet(i, j)\nTo unite a disjoint set that contains item i with a di\u21b5erent disjoint set that contains item j\n(let x = findSet(i), y = findSet(j), and x != y), we set the parent of one representative\nitem of a disjoint set, i.e., x to be the representative item of the other disjoint set, i.e., y\n(that is, we set p[x] = y). This e\u21b5ectively merges the two previously disjoint trees into a\nbigger tree in the UFDS data structure. As such, unionSet(i, j) will cause item i, j, and\nall other members of the previously disjoint sets to have the same representative item y,\neither directly or indirectly.\nTo make the resulting tree as short as possible, we now use the information contained in\nvi rank to ensure that rank[x] \uf8ffrank[y], otherwise we swap x and y \ufb01rst.\nIf rank[x] < rank[y], then y\u2014the representative item of the disjoint set with higher\nrank (likely a taller tree) will be the new parent of the disjoint set with lower rank (likely a\nshorter tree), thereby maintaining the rank of the resulting combined tree.\nIf rank[x] == rank[y], we can arbitrarily choose one of them as the new parent and\nincrease the rank of the resultant root. In our implementation, we set p[x] = y and do\n++rank[y] in this case.\nThis is the \u2018union by rank\u2019 heuristic as the rank values do not always re\ufb02ect the current\nheights of the trees, but only re\ufb02ect the upper bound of how tall those trees before.\nIn Figure 2.11\u2014top, unionSet(0, 1) sets p[0] to 1 and rank[1] to 1.", "mimetype": "text/plain", "start_char_idx": 333742, "end_char_idx": 337224, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "89058d4e-e6c9-4560-9756-e798ac837423": {"__data__": {"id_": "89058d4e-e6c9-4560-9756-e798ac837423", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3faad072-71fe-4728-95ba-2c86e29ba076", "node_type": "1", "metadata": {}, "hash": "d1e1d8b9ed473a3fd4533094ffdec55235715f55cd43cc632b997194d1c61e06", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cc19f965-ea78-4393-9207-38dfa2c76166", "node_type": "1", "metadata": {}, "hash": "483f26d33ed361c50e1eed351b8844190dfd161c1aaa22a5756c6a595fb4cd7f", "class_name": "RelatedNodeInfo"}}, "text": "If rank[x] < rank[y], then y\u2014the representative item of the disjoint set with higher\nrank (likely a taller tree) will be the new parent of the disjoint set with lower rank (likely a\nshorter tree), thereby maintaining the rank of the resulting combined tree.\nIf rank[x] == rank[y], we can arbitrarily choose one of them as the new parent and\nincrease the rank of the resultant root. In our implementation, we set p[x] = y and do\n++rank[y] in this case.\nThis is the \u2018union by rank\u2019 heuristic as the rank values do not always re\ufb02ect the current\nheights of the trees, but only re\ufb02ect the upper bound of how tall those trees before.\nIn Figure 2.11\u2014top, unionSet(0, 1) sets p[0] to 1 and rank[1] to 1.\nIn Figure 2.11\u2014middle, unionSet(2, 3) sets p[2] to 3 and rank[3] to 1.\nFigure 2.11: unionSet(0, 1) ! (2, 3) ! (4, 3) and isSameSet(0, 4)\nIn Figure 2.11\u2014bottom, when we call unionSet(4, 3), we get rank[findSet(4)] = rank[4]\n= 0 which is smaller than rank[findSet(3)] = rank[3] = 1, so we set p[4] = 3 without\nchanging the height of the resulting tree (rank[3] = 1 does not change)\u2014this is the \u2018union\nby rank\u2019 heuristic at work. With this heuristic, the path taken from any vertex to the rep-\nresentative item by following the chain of \u2018parent\u2019 edges is minimized. We can show that\nusing this \u2018union by rank\u2019 heuristic without the \u2018path compression\u2019 technique (or without\nany call to findSet(i) thus no path is compressed) will yield a tree that is not taller than\nO(log n). Notice that if we do the reverse, i.e., if we set p[3] = 4 instead, we will create a\ntaller tree with rank[4] = 2 which will slow down future findSet(i) operations.\nFinally, to wrap up, we call unionSet(0, 3). p[0] = x = 1 (and rank[1] = 1) and\np[3] = y = 3 (and rank[3] = 1 too). As both trees have the same rank (or are deemed\nto have the same \u2018height\u2019), we set p[1] = 3 and update rank[3] = 2. Thus we have the\nresulting tree as shown in Figure 2.10\u2014top.\n101\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nOther UFDS Operations and Our Implementation\nWe implement UFDS data structure using Object-Oriented Programming (OOP) for easy\nintegration with any code that requires this data structure, e.g., Kruskal\u2019s MST algorithm\n(see Section 4.3.2). The constructor admits the initial size of disjoint sets = N and simply\ninitializes the p and rank vectors with their appropriate values.\nWe can also add two more simple features in UFDS (these two can be removed from the\ncode below if not needed). The \ufb01rst one is numDisjointSets() that returns the number of\ndisjoint sets currently in the UFDS data structure. We simply add one more internal counter\nvariable numSets that is initially set to N and reduce it by one every time a successful\nunionSet(i, j) is performed.\nThe second one is sizeOfSet(i) that returns the number of items (including item i) that\nthe set that contains item i has. We create additional vi setSize on top of vi p, rank\nand initialize all sets to have size 1 initially. Again, whenever a successful unionSet(i, j) is\nperformed, we sum the two sizes of the sets and store the information59 in the representative\nitem of the combined set.", "mimetype": "text/plain", "start_char_idx": 336529, "end_char_idx": 339668, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cc19f965-ea78-4393-9207-38dfa2c76166": {"__data__": {"id_": "cc19f965-ea78-4393-9207-38dfa2c76166", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "89058d4e-e6c9-4560-9756-e798ac837423", "node_type": "1", "metadata": {}, "hash": "b84f511248d749219c90b8418ccbfed389297b62788e322722225e7fd1406872", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7dc77a20-4081-4ae4-90fa-60f300b4c566", "node_type": "1", "metadata": {}, "hash": "fd06699757cab9507c498c1b405683f8d59201e44e04759d9a47f553d0deb1f2", "class_name": "RelatedNodeInfo"}}, "text": "We can also add two more simple features in UFDS (these two can be removed from the\ncode below if not needed). The \ufb01rst one is numDisjointSets() that returns the number of\ndisjoint sets currently in the UFDS data structure. We simply add one more internal counter\nvariable numSets that is initially set to N and reduce it by one every time a successful\nunionSet(i, j) is performed.\nThe second one is sizeOfSet(i) that returns the number of items (including item i) that\nthe set that contains item i has. We create additional vi setSize on top of vi p, rank\nand initialize all sets to have size 1 initially. Again, whenever a successful unionSet(i, j) is\nperformed, we sum the two sizes of the sets and store the information59 in the representative\nitem of the combined set.\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nclass UnionFind {\n// OOP style\nprivate:\nvi p, rank, setSize;\n// vi p is the key part\nint numSets;\npublic:\nUnionFind(int N) {\np.assign(N, 0); for (int i = 0; i < N; ++i) p[i] = i;\nrank.assign(N, 0);\n// optional speedup\nsetSize.assign(N, 1);\n// optional feature\nnumSets = N;\n// optional feature\n}\nint findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }\nbool isSameSet(int i, int j) { return findSet(i) == findSet(j); }\nint numDisjointSets() { return numSets; }\n// optional\nint sizeOfSet(int i) { return setSize[findSet(i)]; } // optional\nvoid unionSet(int i, int j) {\nif (isSameSet(i, j)) return;\n// i and j are in same set\nint x = findSet(i), y = findSet(j);\n// find both rep items\nif (rank[x] > rank[y]) swap(x, y);\n// keep x \u2019shorter\u2019 than y\np[x] = y;\n// set x under y\nif (rank[x] == rank[y]) ++rank[y];\n// optional speedup\nsetSize[y] += setSize[x];\n// combine set sizes at y\n--numSets;\n// a union reduces numSets\n}\n};\n59This idea is general: the representative set can also store other set\u2019s attribute other than its size.\n102\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nint main() {\nUnionFind UF(5); // create 5 disjoint sets\nprintf(\"%d\\n\", UF.numDisjointSets()); // 5\nUF.unionSet(0, 1);\nprintf(\"%d\\n\", UF.numDisjointSets()); // 4\nUF.unionSet(2, 3);\nprintf(\"%d\\n\", UF.numDisjointSets()); // 3\nUF.unionSet(4, 3);\nprintf(\"%d\\n\", UF.numDisjointSets()); // 2\nprintf(\"isSameSet(0, 3) = %d\\n\", UF.isSameSet(0, 3)); // 0 (false)\nprintf(\"isSameSet(4, 3) = %d\\n\", UF.isSameSet(4, 3)); // 1 (true)\nfor (int i = 0; i < 5; ++i) // 1 for {0, 1} and 3 for {2, 3, 4}\nprintf(\"findSet(%d) = %d, sizeOfSet(%d) = %d\\n\",\ni, UF.findSet(i), i, UF.sizeOfSet(i));\nUF.unionSet(0, 3);\nprintf(\"%d\\n\", UF.numDisjointSets()); // 1\nfor (int i = 0; i < 5; ++i) // 3 for {0, 1, 2, 3, 4}\nprintf(\"findSet(%d) = %d, sizeOfSet(%d) = %d\\n\",\ni, UF.findSet(i), i, UF.sizeOfSet(i));\nreturn 0;\n}\nTo further enhance your understanding of this data structure, please visit VisuAlgo, Union-\nFind Disjoint Sets visualization, that shows visualization of this UFDS data structure and\nall its operations. You can specify your own sequence of findSet(i) and unionSet(i, j)\nand then see the resulting UFDS trees. The URL for the UFDS visualization and source\ncode example are shown below.", "mimetype": "text/plain", "start_char_idx": 338895, "end_char_idx": 342021, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7dc77a20-4081-4ae4-90fa-60f300b4c566": {"__data__": {"id_": "7dc77a20-4081-4ae4-90fa-60f300b4c566", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cc19f965-ea78-4393-9207-38dfa2c76166", "node_type": "1", "metadata": {}, "hash": "483f26d33ed361c50e1eed351b8844190dfd161c1aaa22a5756c6a595fb4cd7f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cc6bb88c-c41a-4a95-b204-59176e916630", "node_type": "1", "metadata": {}, "hash": "1923a064dd8254ea0ad5b5a354d7c995a029e8eb295201699c163f33529eeef2", "class_name": "RelatedNodeInfo"}}, "text": "You can specify your own sequence of findSet(i) and unionSet(i, j)\nand then see the resulting UFDS trees. The URL for the UFDS visualization and source\ncode example are shown below.\nVisualization: https://visualgo.net/en/ufds\nSource code: ch2/ourown/unionfind ds.cpp|java|py|ml\nExercise 2.4.2.1: Given N disjoint sets: {0, 1, 2, . . . , N-1}, please create a sequence of\nunionSet(i, j) operations to create a tree with the shortest possible height. Note that the\n\u2018union by rank\u2019 heuristic is used.\nExercise 2.4.2.2: Given N disjoint sets: {0, 1, 2, . . . , N-1}, please create a sequence of\nunionSet(i, j) operations to create a tree with rank = log2(N). Is it possible to create a\ntree with rank > log2(N)? Note that the \u2018union by rank\u2019 heuristic is used.\nExercise 2.4.2.3: Given N disjoint sets: {0, 1, 2, . . . , N-1}, please create a sequence\nof unionSet(i, j) and findSet(i) operations to create a tree with the shortest possible\nheight. Note that this time the \u2018union by rank\u2019 heuristic is not used but \u2018path compression\u2019\ntechnique can be used.\nExercise 2.4.2.4: The implementation shown in this section uses a self loop p[i] == i to\nidentify whether item i is the representative item of the set. Can we avoid using self loop\nso that our UFDS graph is a simple graph?\n103\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.4.3\nFenwick (Binary Indexed) Tree\nMotivation\nFenwick Tree\u2014also known as Binary Indexed Tree (BIT)\u2014was invented by Peter M.\nFenwick in 1994 [14]. In this book, we will use the term Fenwick Tree as opposed to BIT\nin order to di\u21b5erentiate with the standard bit manipulations. The Fenwick Tree is a useful\ndata structure for implementing dynamic cumulative frequency tables. Suppose we have test\nscores60 of n = 11 students s = {2, 4, 5, 6, 5, 6, 8, 6, 7, 9, 7} where the test scores are integer\nvalues ranging from [1..m=10]. Table 2.5 shows the frequency of each individual test score\n2 [1..m=10] and the cumulative frequency of test scores ranging from [1..i] denoted by\ncf[i]\u2014that is, the sum of the frequencies of test scores 1, 2, ..., i.\nIndex/\nFrequency\nCumulative\nShort Comment\nScore\nf\nFrequency cf\n0\n-\n-\nIndex 0 is ignored (as the sentinel value).\n1\n0\n0\ncf[1] = f[1] = 0, base case.\n2\n1\n1\ncf[2] = cf[1]+f[2] = 0+1 = 1.\n3\n0\n1\ncf[3] = cf[2]+f[3] = 1+0 = 1.\n4\n1\n2\ncf[4] = cf[3]+f[4] = 1+1 = 2.\n5\n2\n4\ncf[5] = cf[4]+f[5] = 2+2 = 4.\n6\n3\n7\ncf[6] = cf[5]+f[6] = 4+3 = 7.\n7\n2\n9\ncf[7] = cf[6]+f[7] = 7+2 = 9.\n8\n1\n10\ncf[8] = cf[7]+f[8] = 9+1 = 10.\n9\n1\n11\ncf[9] = cf[8]+f[9] = 10+1 = 11.\n10 = m\n0\n11 = n\ncf[10] = cf[9]+f[10] = 11+0 = 11.\nTable 2.5: Example of a Cumulative Frequency Table\nThe cumulative frequency table can also be used as a solution to the Range Sum Query (RSQ)\nproblem61 as it stores RSQ(1, i) 8i 2 [1..m] where m is the largest integer index/score62.", "mimetype": "text/plain", "start_char_idx": 341840, "end_char_idx": 344642, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cc6bb88c-c41a-4a95-b204-59176e916630": {"__data__": {"id_": "cc6bb88c-c41a-4a95-b204-59176e916630", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7dc77a20-4081-4ae4-90fa-60f300b4c566", "node_type": "1", "metadata": {}, "hash": "fd06699757cab9507c498c1b405683f8d59201e44e04759d9a47f553d0deb1f2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cfd46ede-8865-49cb-b6fb-447cff08180f", "node_type": "1", "metadata": {}, "hash": "9e0befc10d9cccfa0c9d31cf20cf455ee991d1178141780049f721a97407dd30", "class_name": "RelatedNodeInfo"}}, "text": "7\n2\n9\ncf[7] = cf[6]+f[7] = 7+2 = 9.\n8\n1\n10\ncf[8] = cf[7]+f[8] = 9+1 = 10.\n9\n1\n11\ncf[9] = cf[8]+f[9] = 10+1 = 11.\n10 = m\n0\n11 = n\ncf[10] = cf[9]+f[10] = 11+0 = 11.\nTable 2.5: Example of a Cumulative Frequency Table\nThe cumulative frequency table can also be used as a solution to the Range Sum Query (RSQ)\nproblem61 as it stores RSQ(1, i) 8i 2 [1..m] where m is the largest integer index/score62.\nIn the example above, we have m = 10, RSQ(1, 1) = 0, RSQ(1, 2) = 1, . . . , RSQ(1, 6) =\n7, . . . , RSQ(1, 8) = 10, . . . , and RSQ(1, 10) = 11 (notice that RSQ(1, m) = n). We can\nthen obtain the answer to the RSQ for an arbitrary range RSQ(i, j) when i > 1 by using a\nsimple inclusion-exclusion principle: RSQ(1, j) - RSQ(1, i-1). For example, RSQ(4, 6)\n= RSQ(1, 6) - RSQ(1, 3) = 7-1 = 6.\nIf the frequencies are static, then the cumulative frequency table as in Table 2.5 can\nbe computed e\ufb03ciently with a simple O(m) loop. First, set cf[1] = f[1]. Then, 8i 2\n[2..m], compute cf[i] = cf[i-1]+f[i]. This cumulative frequencies (pre\ufb01x sum) will be\ndiscussed further in Section 3.5.2. However, when the frequencies are frequently updated\n(increased/decreased, changed to a speci\ufb01c value, or reset to 0) and the RSQs are frequently\nasked afterwards, it is better to use a dynamic data structure.\nThe Basic Ideas\nInstead of using a Segment Tree (see Section 2.4.4) to solve this RSQ problem, we can\nimplement the far simpler Fenwick Tree instead (compare the source code for both imple-\nmentations, provided in this section and in Section 2.4.4). This is perhaps one of the reasons\nwhy the Fenwick Tree is currently included in the IOI syllabus [16]. Fenwick Tree operations\nare also extremely e\ufb03cient as they use fast bit manipulation techniques (see Section 2.2).\n60The test scores do not have to be sorted.\n61RSQ(i, j) of an array A is the sum of A[i] + A[i+1] + ...\n+ A[j].\n62Note that n = the number of data points and m = the largest integer value among the n data points.\n104\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nIn this section, we will use the function LSOne(S) (which is actually ((S) & -(S)))\nextensively, naming it to match its usage in the original paper [14]. In Section 2.2, we have\nseen that the operation ((S) & (-S)) produces the \ufb01rst Least Signi\ufb01cant One-bit in S. For\nexample, LSOne(90) = LSOne((1 011 010)2) = (10)2 = 2.\nThe Fenwick Tree63 is typically implemented as an array (we use a vector for size\n\ufb02exibility). The Fenwick Tree is a tree that is indexed by the bits of its integer 64 keys. These\ninteger keys fall within the \ufb01xed range [1..m]\u2014skipping65 index 0. In a programming contest\nenvironment, m can approach \u21e11M so that the Fenwick Tree covers the range [1..1M]\u2014\nlarge enough for many practical (contest) problems. In Table 2.5 above, the scores [1..10]\nare the integer keys in the corresponding array with size m = 10 and n = 11 data points.\nLet the name of the Fenwick Tree array be ft.", "mimetype": "text/plain", "start_char_idx": 344247, "end_char_idx": 347190, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cfd46ede-8865-49cb-b6fb-447cff08180f": {"__data__": {"id_": "cfd46ede-8865-49cb-b6fb-447cff08180f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cc6bb88c-c41a-4a95-b204-59176e916630", "node_type": "1", "metadata": {}, "hash": "1923a064dd8254ea0ad5b5a354d7c995a029e8eb295201699c163f33529eeef2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f9fb01c4-28b8-4e22-80fe-61a5504ef95a", "node_type": "1", "metadata": {}, "hash": "accaa7915f56c57bf5304901a28752ab027cf648788b02dbeef65c5d1dd0a6b3", "class_name": "RelatedNodeInfo"}}, "text": "The Fenwick Tree63 is typically implemented as an array (we use a vector for size\n\ufb02exibility). The Fenwick Tree is a tree that is indexed by the bits of its integer 64 keys. These\ninteger keys fall within the \ufb01xed range [1..m]\u2014skipping65 index 0. In a programming contest\nenvironment, m can approach \u21e11M so that the Fenwick Tree covers the range [1..1M]\u2014\nlarge enough for many practical (contest) problems. In Table 2.5 above, the scores [1..10]\nare the integer keys in the corresponding array with size m = 10 and n = 11 data points.\nLet the name of the Fenwick Tree array be ft. Then, the item at index i of Fenwick\nTree ft is responsible for items in the range [(i-LSOne(i)+1)..i] of the frequency array\nf, i.e., ft[i] stores the cumulative frequency of items {i-LSOne(i)+1, i-LSOne(i)+2,\ni-LSOne(i)+3, .., i} of f. In Figure 2.12, the top side shows the query (or interrogation)\ntree of Fenwick Tree where the value of ft[i] is shown inside the circle above index i and\nthe range [i-LSOne(i)+1..i] is shown by the highlighted ranges. We can see that ft[4] =\n2 is responsible for range [(4-4+1)..4] = [1..4] of f, ft[6] = 5 is responsible for range\n[(6-2+1)..6] = [5..6] of f, ft[7] = 2 is responsible for range [(7-1+1)..7] = [7..7]\nof f, ft[8] = 10 is responsible for range [(8-8+1)..8] = [1..8] of f, etc66. In Figure\n2.12, the bottom side shows the raw frequency array f for each index i.\nOperation: O(log m) rsq(j)\nFigure 2.12: Example of rsq(6) on Fenwick (Interrogation/Query) Tree\nWith such an arrangement, if we want to obtain the cumulative frequency between [1..j],\ni.e., rsq(j), we simply add ft[j], ft[j\u2019], ft[j\u2019\u2019], . . . until index j is 0. This sequence\nof indices is obtained via subtracting the Least Signi\ufb01cant One-bit via the bit manipulation\nexpression: j\u2019 = j-LSOne(j). Iteration of this bit manipulation e\u21b5ectively strips o\u21b5the\nleast signi\ufb01cant one-bit of j at each step. As an integer j only has O(log j) bits, rsq(j)\nruns in O(log m) time when j = m.\nIn Figure 2.12, rsq(6) = ft[6]+ft[4] = 5+2 = 7. See that indices 4 and 6 are respon-\nsible for range [1..4] and [5..6], respectively. By combining them, we account for the\n63That is, similar with the UFDS \u2018Tree\u2019 and Segment \u2018Tree\u2019, we actually implement these data structures\nas arrays and the \u2018trees\u2019 are just in conceptual realm.\n64Recall that every (non-negative) integer has a unique binary representation.\n65We have chosen to follow the original implementation by [14] that ignores index 0 to facilitate an easier\nunderstanding of the bit manipulation operations of Fenwick Tree. Note that index 0 has no bit turned\non. Thus, the operation i +/- LSOne(i) simply returns i when i = 0 and will cause in\ufb01nite loop if a\nprogrammer is not careful with this classic corner case for Fenwick Tree implementation. Index 0 is also\nused as the terminating condition in the rsq function in our implementation, i.e., rsq(0) = 0.\n66In this book, we will not give detail on why this arrangement works and will instead show that it allows\nfor e\ufb03cient O(log m) update and RSQ operations. Interested readers are advised to read [14].\n105\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nentire range of [1..6].", "mimetype": "text/plain", "start_char_idx": 346610, "end_char_idx": 349794, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f9fb01c4-28b8-4e22-80fe-61a5504ef95a": {"__data__": {"id_": "f9fb01c4-28b8-4e22-80fe-61a5504ef95a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cfd46ede-8865-49cb-b6fb-447cff08180f", "node_type": "1", "metadata": {}, "hash": "9e0befc10d9cccfa0c9d31cf20cf455ee991d1178141780049f721a97407dd30", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "13a69172-f1fb-4bbe-b486-6705ca0dd3e0", "node_type": "1", "metadata": {}, "hash": "d6621dfa813734d4de5e7cc765d22511a49bcc8ad8303b2266e050434f6b72d2", "class_name": "RelatedNodeInfo"}}, "text": "Note that index 0 has no bit turned\non. Thus, the operation i +/- LSOne(i) simply returns i when i = 0 and will cause in\ufb01nite loop if a\nprogrammer is not careful with this classic corner case for Fenwick Tree implementation. Index 0 is also\nused as the terminating condition in the rsq function in our implementation, i.e., rsq(0) = 0.\n66In this book, we will not give detail on why this arrangement works and will instead show that it allows\nfor e\ufb03cient O(log m) update and RSQ operations. Interested readers are advised to read [14].\n105\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nentire range of [1..6]. The indices 6, 4, and 0 are related in their binary form: j = 610 =\n(110)2 can be transformed to j\u2019 = 410 = (100)2 and then to j\u2019\u2019 = 010 = (000)2.\nOperation: O(log m) rsq(i, j)\nWith rsq(j) available and rsq(0) = 0, obtaining the cumulative frequency between two in-\ndices [i..j] where 1 \uf8ffi \uf8ffj \uf8ffm is simple, just compute rsq(i, j) = rsq(j)-rsq(i-1),\nanother inclusion-exclusion principle. For example, if we want to compute rsq(4, 6), we\ncan simply return rsq(6)-rsq(3) = (5+2)-(0+1) = 7-1 = 6. Again, this operation runs\nin O(2 \u21e5log j) \u21e1O(log m) time when j = m. Figure 2.13 displays the value of rsq(3) =\nft[3]+ft[2] = 0+1 = 1. Combine Figure 2.12 and 2.13 for the computation of rsq(4, 6).\nFigure 2.13: Example of rsq(3) on Fenwick (Interrogation/Query) Tree\nOperation: O(log m) update(i, v)\nWhen updating the value of the item at index i by adding its value by v (note that v can\nbe either positive or negative), i.e., by calling update(i, v), we have to update ft[i],\nft[i\u2019], ft[i\u2019\u2019], . . . until this index exceeds m because all these indices are a\u21b5ected. This\nsequence of indices are obtained via this similar iterative bit manipulation expression: i\u2019\n= i+LSOne(i). Starting from any integer i, the operation update(i, v) will take at most\nO(log m) steps until i > m even if i = 1 at the beginning.\nFigure 2.14: Example of update(5, 2) on Fenwick (Updating) Tree\nIn Figure 2.14, the top side, we show the updating tree of Fenwick Tree with the edges\nshowing chain of vertices that have to be updated. For example, update(5, 2) will a\u21b5ect\n(add +2 to) ft at indices i = 510 = (101)2, i\u2019 = (101)2 + (001)2 = (110)2 = 610, and\ni\u2019\u2019 = (110)2 + (010)2 = (1000)2 = 810 via the expression given above.\n106\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nBasic Implementation\nThe very basic implementation of Fenwick Tree is short and sweet. The basic code can easily\nbe memorized. This basic version assumes that the keys are integers within range [1..m].\nIf the integer keys involved use index 0, we can get around this by setting +1 o\u21b5set for\nall indices, i.e., index 1/i/m in Fenwick Tree actually refers to original index 0/i-1/m-1 in\nthe actual array, respectively.", "mimetype": "text/plain", "start_char_idx": 349173, "end_char_idx": 351982, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "13a69172-f1fb-4bbe-b486-6705ca0dd3e0": {"__data__": {"id_": "13a69172-f1fb-4bbe-b486-6705ca0dd3e0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f9fb01c4-28b8-4e22-80fe-61a5504ef95a", "node_type": "1", "metadata": {}, "hash": "accaa7915f56c57bf5304901a28752ab027cf648788b02dbeef65c5d1dd0a6b3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "976a0b82-c220-4608-8717-f5fda40b589d", "node_type": "1", "metadata": {}, "hash": "3ef4485131e795973c5bbac20bc0c595544de6eba4f18c16b9b529e5332d5f80", "class_name": "RelatedNodeInfo"}}, "text": "106\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nBasic Implementation\nThe very basic implementation of Fenwick Tree is short and sweet. The basic code can easily\nbe memorized. This basic version assumes that the keys are integers within range [1..m].\nIf the integer keys involved use index 0, we can get around this by setting +1 o\u21b5set for\nall indices, i.e., index 1/i/m in Fenwick Tree actually refers to original index 0/i-1/m-1 in\nthe actual array, respectively.\nIf the keys are \ufb02oating point numbers but with small \ufb01xed precision, e.g., the test scores\nshown in Table 2.5 are s = {5.5, 7.5, 8.0, 10.0} (i.e., allowing either a 0 or a 5 after\nthe decimal point) or s = {5.53, 7.57, 8.10, 9.91} (i.e., allowing for two digits after\nthe decimal point), then we can simply convert those \ufb01xed precision \ufb02oating point numbers\nback into integers and work with the integer version instead. For the \ufb01rst task, we can\nmultiply every number by two. For the second case, we can multiply all numbers by one\nhundred. Obviously this strategy will signi\ufb01cantly increase the range of keys, but the keys\nwith non-zero frequencies will be sparse.\nIf the keys involve big range but only n (1 \uf8ffn \uf8ff1M) keys have frequency, e.g., the test\nscores shown in Table 2.5 are s = {1K, 1M, 1B, 1G}, then we can use data compression\ntechnique (see Section 3.2.3). We need help from an additional mapper data structure, e.g.,\nunordered map to map (compress) those gigantic numbers into n distinct indices [1..n], and\nthen use Fenwick Tree operations as per normal.\n#define LSOne(S) ((S) & -(S))\n// the key operation\ntypedef vector<int> vi;\nclass FenwickTree {\n// index 0 is not used\nprivate:\nvi ft;\npublic:\nFenwickTree(int m) { ft.assign(m+1, 0); }\n// create empty FT\nint rsq(int j) {\n// returns RSQ(1, j)\nint sum = 0;\nfor (; j; j -= LSOne(j))\nsum += ft[j];\nreturn sum;\n}\nint rsq(int i, int j) { return rsq(j) - rsq(i-1); } // inc/exclusion\n// updates value of the i-th element by v (v can be +ve/inc or -ve/dec)\nvoid update(int i, int v) {\nfor (; i < (int)ft.size(); i += LSOne(i))\nft[i] += v;\n}\n};\nOperation: O(n + m) build(frequency-array f)\nThere are many other things that we can do with Fenwick Tree.\nWe can build Fenwick Tree from an array of raw data that contains n items, do one\nlinear O(n) pass to create an array of frequencies with m keys/integer indices, and then call\nupdate(i, f[i]) 8i 2 [1..m]. If we do this, we will incur O(n + m log m) operations.\n107\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nHowever, we can do (slightly) better. After having the array of frequencies that have\nm keys/integer indices, we simply set ft[i] += f[i] and then check if its parent in the\nupdating tree of Fenwick Tree is still within range. If it is, we update its parent too. We do\nthis sequentially 8i 2 [1..m]. This build is slightly faster, i.e., in O(n + m) operations as\nwe only do the necessary updating work.\nOperation: O(log2 m) select(rank k)\nFenwick Tree supports an additional operation that can make it usable for order statistics\nqueries (see more details in Section 2.3.4): \ufb01nd the smallest index/key i so that the cu-\nmulative frequency in the range [1..i] \u2265k. For example, we may need to determine the\nminimum index/key/score i in Table 2.5 such that there are at least k = 7 students covered\nin the range [1..i] (index/score 6 in this case).", "mimetype": "text/plain", "start_char_idx": 351494, "end_char_idx": 354863, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "976a0b82-c220-4608-8717-f5fda40b589d": {"__data__": {"id_": "976a0b82-c220-4608-8717-f5fda40b589d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "13a69172-f1fb-4bbe-b486-6705ca0dd3e0", "node_type": "1", "metadata": {}, "hash": "d6621dfa813734d4de5e7cc765d22511a49bcc8ad8303b2266e050434f6b72d2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "97b42b37-b833-47db-b78a-6fcf958d82b8", "node_type": "1", "metadata": {}, "hash": "283949efecf311afcee7e86b6767505744d512c4dadae794b06cb872b34d6a7f", "class_name": "RelatedNodeInfo"}}, "text": "If it is, we update its parent too. We do\nthis sequentially 8i 2 [1..m]. This build is slightly faster, i.e., in O(n + m) operations as\nwe only do the necessary updating work.\nOperation: O(log2 m) select(rank k)\nFenwick Tree supports an additional operation that can make it usable for order statistics\nqueries (see more details in Section 2.3.4): \ufb01nd the smallest index/key i so that the cu-\nmulative frequency in the range [1..i] \u2265k. For example, we may need to determine the\nminimum index/key/score i in Table 2.5 such that there are at least k = 7 students covered\nin the range [1..i] (index/score 6 in this case). This operation is called the select(rank\nk) operation. The reverse operation of getting the ranking of a value v, i.e., rank(value v)\nis actually trivial as we can just call rsq(v).\nAs the cumulative frequencies are sorted, we can use binary search. In Section 3.3.1, we\nwill learn the \u2018Binary Search the Answer\u2019 (BSTA) technique. Basically, we test the middle\nindex i = m/2 from the initial range [1..m] and see if rsq(1, i) is less than k (we try larger\ni in binary search fashion) or not (we try smaller i in binary search fashion). The resulting\ntime complexity is O(log m \u21e5log m) = O(log2 m) as we need O(log m) for the binary search\nand each query is another O(log m) Fenwick Tree operation.\nRange Update Point Query (RUPQ) Fenwick Tree\nThe default Fenwick Tree that is widely known above is called the Point Update (Updating\nthe value of a single index only) and Range (Sum) Query (PURQ) Fenwick Tree.\nFor other applications, we may need to perform Range Update (Updating the values\nwithin a given range [lo..hi] by the same +v value) and Point Query (RUPQ) instead.\nFor example, given several intervals with small ranges (the boxes in Figure 2.15), determine\nthe number of intervals encompassing a single index i (the underlined index in Figure 2.15).\nIn Figure 2.15, (b, c, d, e), we add 4 intervals with ranges: [14-18], [12-16], [4-7] (this\ninterval does not encompass index i = 14), and [7-14]. If we query the number of intervals\nencompassing index i = 14 before and after insertion of an interval, we will have answer =\n0, 1, 2, 2, 3 (see Figure 2.15\u2014(a, b, c, d, e), respectively).\nFigure 2.15: RUPQ Example; Point Queries i = 14 are Underlined\nObviously, looping through each index i in the range [lo..hi] and call update(i, v) may\ncost up to O(n log n) per query as the range can be as big as [1..n]. This is not desirable.\nFortunately, we can can slightly modify the basic Fenwick Tree instead.\n108\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nOperations: O(log m) range update(ui, uj, v) and O(log m) point query(i)\nWe can use the PURQ Fenwick Tree this way: For range update(ui, uj, v), we only call\ntwo O(log m) PURQ Fenwick Tree point updates: update(ui, v) and update(uj+1, -v).\nFor point query(i), we simply return rsq(i) of the standard PURQ Fenwick Tree also in\nO(log m) time.\nUsed as such, update(ui, v) makes all indices in [ui, ui + 1, . . . , n] have +v value and\nupdate(uj+1, -v) makes all indices in [uj + 1, uj + 2, . . . , n] have -v value again, canceling\nthe previous update. Therefore, rsq(1, i) for all i 2 [ui, ui + 1, . . . , uj \u22121, uj] will be\ncorrectly updated by +v.", "mimetype": "text/plain", "start_char_idx": 354245, "end_char_idx": 357496, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97b42b37-b833-47db-b78a-6fcf958d82b8": {"__data__": {"id_": "97b42b37-b833-47db-b78a-6fcf958d82b8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "976a0b82-c220-4608-8717-f5fda40b589d", "node_type": "1", "metadata": {}, "hash": "3ef4485131e795973c5bbac20bc0c595544de6eba4f18c16b9b529e5332d5f80", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2eab4670-82a5-49ce-885f-89d05076d69c", "node_type": "1", "metadata": {}, "hash": "71dd63c9c0bc30e41ec1a36798a44cdce0f57aca1990d8031af808ac3c251ebd", "class_name": "RelatedNodeInfo"}}, "text": "For point query(i), we simply return rsq(i) of the standard PURQ Fenwick Tree also in\nO(log m) time.\nUsed as such, update(ui, v) makes all indices in [ui, ui + 1, . . . , n] have +v value and\nupdate(uj+1, -v) makes all indices in [uj + 1, uj + 2, . . . , n] have -v value again, canceling\nthe previous update. Therefore, rsq(1, i) for all i 2 [ui, ui + 1, . . . , uj \u22121, uj] will be\ncorrectly updated by +v.\nFigure 2.16: RUPQ Example; X denotes -1; Point Queries i = 14 are Underlined\nIn Figure 2.16, we show how this RUPQ Fenwick Tree works. In Figure 2.16\u2014(b, c, d, e),\nwe gradually add 4 intervals. For range [14-18], we add +1 at index 14 and -1 at index 18+1\n= 19. We do similar process for the other 3 ranges [12-16], [4-7], and [7-14]. If we now query\nthe number of intervals encompassing index i = 14 by calling rsq(1, 14), we will have the\ncorrect answer = 1+1+(-1)+1+1 = 3 (see Figure 2.16\u2014(e)).\nRange Update Range Query (RURQ) Fenwick Tree\nBut what if we need to do both Range Updates and Range Queries e\ufb03ciently? For example\nin Figure 2.17, we have the same 4 ranges added. If we ask what is the rsq(11, 14) like in\nFigure 2.17\u2014(e), we need to quickly answer 1+2+2+3 = 8.\nFigure 2.17: RURQ Example; Range Queries are Underlined\nThere is yet another clever usage of Fenwick Tree that allows it to do such RURQ operations\nin O(log m). To do this, we maintain two Fenwick trees - one is the RUPQ variant discussed\nearlier and the other is a default PURQ Fenwick Tree to help store the cancellation factor\nvalues. The details are shown below.\n109\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nOperations: O(log m) range update(ui, uj, v) and O(log m) rsq(i, j)\nRecall:\nStandard rsq(i, j) can be easily calculated with inclusion-exclusion principle\nrsq(i, j) = rsq(1, j) - rsq(1, i-1), So we will focus on rsq(1, j).\nAlso recall that in the RUPQ variant, a range update(ui, uj, v) can be broken down\ninto two pre\ufb01x updates: update(ui, v) and update(uj+1, -v).\nSo how a range update(ui, uj, v) is going to a\u21b5ect the value of a rsq(1, j). We \ufb01rst\nuse the rupq.range update(ui, uj, v) to increase the values in [ui, ui+1, .., uj] by\n+v. To simplify the calculation of rsq(1, j), we \ufb01rst assume that every index before j has\nchange equal to the value of j and will \ufb01x the \u2018mistakes\u2019 by canceling, so we set rsq(1, j) =\nrupq.point query(j)*j - cancellation factor. There are three cases that is explained\nwith a simple Figure 2.18 where we perform range update(3, 5, 1) operation:\nFigure 2.18: RURQ Explanation; Range Queries are Underlined\n1. if j < ui, then rsq(1, j) is not a\u21b5ected.\nBecause the range update starts from ui and index j < ui is not a\u21b5ected.\nSo, rsq(1, j) = rupq.point query(j)*j is correct and cancellation factor = 0.", "mimetype": "text/plain", "start_char_idx": 357089, "end_char_idx": 359839, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2eab4670-82a5-49ce-885f-89d05076d69c": {"__data__": {"id_": "2eab4670-82a5-49ce-885f-89d05076d69c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "97b42b37-b833-47db-b78a-6fcf958d82b8", "node_type": "1", "metadata": {}, "hash": "283949efecf311afcee7e86b6767505744d512c4dadae794b06cb872b34d6a7f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2ee4f07a-65ae-427d-aa18-bad8268671e6", "node_type": "1", "metadata": {}, "hash": "cdf5f846ebe236c440ca4b5a8c79a773484e9423dbadc084fd50bf77fa113051", "class_name": "RelatedNodeInfo"}}, "text": "To simplify the calculation of rsq(1, j), we \ufb01rst assume that every index before j has\nchange equal to the value of j and will \ufb01x the \u2018mistakes\u2019 by canceling, so we set rsq(1, j) =\nrupq.point query(j)*j - cancellation factor. There are three cases that is explained\nwith a simple Figure 2.18 where we perform range update(3, 5, 1) operation:\nFigure 2.18: RURQ Explanation; Range Queries are Underlined\n1. if j < ui, then rsq(1, j) is not a\u21b5ected.\nBecause the range update starts from ui and index j < ui is not a\u21b5ected.\nSo, rsq(1, j) = rupq.point query(j)*j is correct and cancellation factor = 0.\nIn Figure 2.18, for j < 3, we do not need to cancel anything, i.e.,\nrsq(1, 1) = rupq.point query(1)*1 = 0*1 = 0\nrsq(1, 2) = rupq.point query(2)*2 = 0*2 = 0 (see Figure 2.18\u2014(b))\nas both are not a\u21b5ected by the range update(3, 5, 1) operation.\n2. if ui \uf8ffj \uf8ffuj, then rsq(1, j) is changed by value v \u21e5(j \u2212ui + 1)\nor (v \u21e5j) \u2212(v \u21e5(ui \u22121)).\nrsq(1, j) = rupq.point query(j)*j already computes (v \u21e5j).\nBut we have to subtract this by (v \u21e5(ui \u22121)) as indices [1..ui-1] are not updated.\nThis is where the second PURQ Fenwick Tree helps.\nWe set cancellation factor = purq.update(ui, v*(ui-1)).\nIn Figure 2.18, for 3 \uf8ffj \uf8ff5, we need to cancel 1 \u21e5(3 \u22121) = 2 units, i.e.,\nrsq(1, 3) = rupq.point query(3)*3 - 2 = 1*3 - 2 = 1\nrsq(1, 4) = rupq.point query(4)*4 - 2 = 1*4 - 2 = 2 (see Figure 2.18\u2014(c))\nrsq(1, 5) = rupq.point query(5)*5 - 2 = 1*5 - 2 = 3\nas all three are a\u21b5ected by the range update(3, 5, 1) operation.\n3. if j > uj, then rsq(1, j) is changed by a constant v \u21e5(uj \u2212ui + 1)\nor (v \u21e5uj) \u2212(v \u21e5(ui \u22121)).\nAgain, rsq(1, j) = rupq.point query(j)*j already computes (v \u21e5j).\nBut now we have to subtract the answer by (v \u21e5(ui \u22121)) and add back (v \u21e5uj) as\nindices [1..ui-1] and [uj+1..j] are not updated.\nWe already set cancellation factor = purq.update(ui, v*(ui-1)) earlier, but\ndoing so we overdo the cancelation factor for [uj+1..j].\nSo we set cancellation factor = purq.update(uj+1, -v*uj) to undo the previous\ncancelation factor and gets the correct answer again for all three cases.\nIn Figure 2.18, for j > 5, we need to cancel 1 \u21e5(3 \u22121) + \u22121 \u21e55 = \u22123 units, i.e.,\nrsq(1, 6) = rupq.point query(6)*7 - (-3) = 0*6 + 3 = 3 (see Figure 2.18\u2014(d))\nas it is a\u21b5ected by the range update(3, 5, 1) operation.\n110\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nThe Complete Implementation\nThe basic version of PURQ Fenwick Tree supports both RSQ (range query) and (point)\nupdate operations in just O(m) space and O(log m) time per RSQ/Point Update given\na set of n integer keys that ranges from [1..m].", "mimetype": "text/plain", "start_char_idx": 359242, "end_char_idx": 361842, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ee4f07a-65ae-427d-aa18-bad8268671e6": {"__data__": {"id_": "2ee4f07a-65ae-427d-aa18-bad8268671e6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2eab4670-82a5-49ce-885f-89d05076d69c", "node_type": "1", "metadata": {}, "hash": "71dd63c9c0bc30e41ec1a36798a44cdce0f57aca1990d8031af808ac3c251ebd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6a6a26e0-0d81-48a9-8da1-f5ee8fff4301", "node_type": "1", "metadata": {}, "hash": "9f3b9200573fded94bb04d11736f71da0bc892b3effaf12c7c582923375f6a07", "class_name": "RelatedNodeInfo"}}, "text": "In Figure 2.18, for j > 5, we need to cancel 1 \u21e5(3 \u22121) + \u22121 \u21e55 = \u22123 units, i.e.,\nrsq(1, 6) = rupq.point query(6)*7 - (-3) = 0*6 + 3 = 3 (see Figure 2.18\u2014(d))\nas it is a\u21b5ected by the range update(3, 5, 1) operation.\n110\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nThe Complete Implementation\nThe basic version of PURQ Fenwick Tree supports both RSQ (range query) and (point)\nupdate operations in just O(m) space and O(log m) time per RSQ/Point Update given\na set of n integer keys that ranges from [1..m].\nIn the complete implementation, we\nadd the slightly more complex alternative constructors from frequency array, the O(log2 m)\nselect(k) operation, and the RUPQ and RURQ variants of Fenwick Tree.\nOur full C++ implementation is shown below. It is a bit long compared to the basic\nversion but you can remove parts that are not needed in order to simplify the code.\n#include <bits/stdc++.h>\nusing namespace std;\n#define LSOne(S) ((S) & -(S))\n// the key operation\ntypedef long long ll;\n// for extra flexibility\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\nclass FenwickTree {\n// index 0 is not used\nprivate:\nvll ft;\n// internal FT is an array\npublic:\nFenwickTree(int m) { ft.assign(m+1, 0); }\n// create an empty FT\nvoid build(const vll &f) {\nint m = (int)f.size()-1;\n// note f[0] is always 0\nft.assign(m+1, 0);\nfor (int i = 1; i <= m; ++i) {\n// O(m)\nft[i] += f[i];\n// add this value\nif (i+LSOne(i) <= m)\n// i has parent\nft[i+LSOne(i)] += ft[i];\n// add to that parent\n}\n}\nFenwickTree(const vll &f) { build(f); }\n// create FT based on f\nFenwickTree(int m, const vi &s) {\n// create FT based on s\nvll f(m+1, 0);\nfor (int i = 0; i < (int)s.size(); ++i)\n// do the conversion first\n++f[s[i]];\n// in O(n)\nbuild(f);\n// in O(m)\n}\nll rsq(int j) {\n// returns RSQ(1, j)\nll sum = 0;\nfor (; j; j -= LSOne(j))\nsum += ft[j];\nreturn sum;\n}\n111\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nll rsq(int i, int j) { return rsq(j) - rsq(i-1); } // inc/exclusion\n// updates value of the i-th element by v (v can be +ve/inc or -ve/dec)\nvoid update(int i, ll v) {\nfor (; i < (int)ft.size(); i += LSOne(i))\nft[i] += v;\n}\nint select(ll k) {\n// O(log^2 m)\nint lo = 1, hi = ft.size()-1;\nfor (int i = 0; i < 30; ++i) {\n// 2^30 > 10^9; usually ok\nint mid = (lo+hi) / 2;\n// BSTA\n(rsq(1, mid) < k) ?", "mimetype": "text/plain", "start_char_idx": 361314, "end_char_idx": 363619, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6a6a26e0-0d81-48a9-8da1-f5ee8fff4301": {"__data__": {"id_": "6a6a26e0-0d81-48a9-8da1-f5ee8fff4301", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2ee4f07a-65ae-427d-aa18-bad8268671e6", "node_type": "1", "metadata": {}, "hash": "cdf5f846ebe236c440ca4b5a8c79a773484e9423dbadc084fd50bf77fa113051", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8636d26e-b777-4881-8bd2-36070d66bde9", "node_type": "1", "metadata": {}, "hash": "aed66c03c75abcb17a1fca5b62705fef19bf8eea0b7bb83c881cdc3421447182", "class_name": "RelatedNodeInfo"}}, "text": "DS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nll rsq(int i, int j) { return rsq(j) - rsq(i-1); } // inc/exclusion\n// updates value of the i-th element by v (v can be +ve/inc or -ve/dec)\nvoid update(int i, ll v) {\nfor (; i < (int)ft.size(); i += LSOne(i))\nft[i] += v;\n}\nint select(ll k) {\n// O(log^2 m)\nint lo = 1, hi = ft.size()-1;\nfor (int i = 0; i < 30; ++i) {\n// 2^30 > 10^9; usually ok\nint mid = (lo+hi) / 2;\n// BSTA\n(rsq(1, mid) < k) ? lo = mid : hi = mid;\n// See Section 3.3.1\n}\nreturn hi;\n}\n};\nclass RUPQ {\n// RUPQ variant\nprivate:\nFenwickTree ft;\n// internally use PURQ FT\npublic:\nRUPQ(int m) : ft(FenwickTree(m)) {}\nvoid range_update(int ui, int uj, int v) {\nft.update(ui, v);\n// [ui, ui+1, .., m] +v\nft.update(uj+1, -v);\n// [uj+1, uj+2, .., m] -v\n}\n// [ui, ui+1, .., uj] +v\nll point_query(int i) { return ft.rsq(i); }\n// rsq(i) is sufficient\n};\nclass RURQ\n{\n// RURQ variant\nprivate:\n// needs two helper FTs\nRUPQ rupq;\n// one RUPQ and\nFenwickTree purq;\n// one PURQ\npublic:\nRURQ(int m) : rupq(RUPQ(m)), purq(FenwickTree(m)) {} // initialization\nvoid range_update(int ui, int uj, int v) {\nrupq.range_update(ui, uj, v);\n// [ui, ui+1, .., uj] +v\npurq.update(ui, v*(ui-1));\n// -(ui-1)*v before ui\npurq.update(uj+1, -v*uj);\n// +(uj-ui+1)*v after uj\n}\nll rsq(int j) {\nreturn rupq.point_query(j)*j -\n// initial calculation\npurq.rsq(j);\n// cancelation factor\n}\nll rsq(int i, int j) { return rsq(j) - rsq(i-1); } // standard\n};\n112\n\nCHAPTER 2.", "mimetype": "text/plain", "start_char_idx": 363173, "end_char_idx": 364621, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8636d26e-b777-4881-8bd2-36070d66bde9": {"__data__": {"id_": "8636d26e-b777-4881-8bd2-36070d66bde9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6a6a26e0-0d81-48a9-8da1-f5ee8fff4301", "node_type": "1", "metadata": {}, "hash": "9f3b9200573fded94bb04d11736f71da0bc892b3effaf12c7c582923375f6a07", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aeabf378-88c2-4ab0-a6e1-3bae6af8fcbe", "node_type": "1", "metadata": {}, "hash": "0281edb1be8a413822c39aa4ca4fb88d0bd9e122d78407453bfb7fa22974a05d", "class_name": "RelatedNodeInfo"}}, "text": "DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nint main() {\nvll f = {0,0,1,0,1,2,3,2,1,1,0};\n// index 0 is always 0\nFenwickTree ft(f);\nprintf(\"%lld\\n\", ft.rsq(1, 6)); // 7 => ft[6]+ft[4] = 5+2 = 7\nprintf(\"%d\\n\", ft.select(7)); // index 6, rsq(1, 6) == 7, which is >= 7\nft.update(5, 1); // update demo\nprintf(\"%lld\\n\", ft.rsq(1, 10)); // now 12\nprintf(\"=====\\n\");\nRUPQ rupq(10);\nRURQ rurq(10);\nrupq.range_update(2, 9, 7); // indices in [2, 3, .., 9] updated by +7\nrurq.range_update(2, 9, 7); // same as rupq above\nrupq.range_update(6, 7, 3); // indices 6&7 are further updated by +3 (10)\nrurq.range_update(6, 7, 3); // same as rupq above\n// idx = 0 (unused) | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10\n// val = -\n| 0 | 7 | 7 | 7 | 7 |10 |10 | 7 | 7 | 0\nfor (int i = 1; i <= 10; i++)\nprintf(\"%d -> %lld\\n\", i, rupq.point_query(i));\nprintf(\"RSQ(1, 10) = %lld\\n\", rurq.rsq(1, 10)); // 62\nprintf(\"RSQ(6, 7) = %lld\\n\", rurq.rsq(6, 7)); // 20\nreturn 0;\n}\nTo further enhance your understanding of this data structure, please visit VisuAlgo, Fenwick\nTree visualization, that shows visualization of this Fenwick Tree data structure and all its op-\nerations. You can specify your own frequency array f, perform various RSQs, point updates,\nRange Update Point Query (RUPQ), and Range Update Range Query (RURQ) variants,\nand then see the resulting Fenwick Tree. The URL for the Fenwick Tree visualization and\nsource code example are shown below.\nVisualization: https://visualgo.net/en/fenwicktree\nSource code: ch2/ourown/fenwicktree ds.cpp|java|py|ml\nExercise 2.4.3.1: The select(k) operation of Fenwick Tree can actually be implemented\nin O(log m) instead of O(log2 m) described in this section. How?\nExercise 2.4.3.2*: Extend the 1D Fenwick Tree to 2D!\nExercise 2.4.3.3*: In the next Section 2.4.4, we will study another data structure to answer\ndynamic Range Min/Max Query. Show how to use Fenwick Tree to answer dynamic pre\ufb01x\nRange Min/Max Query.\nExercise 2.4.3.4*: In this section, we have not discussed if Fenwick Tree can be used for\nDeletion/Insertion cases. Show how to implement delete(i)\u2014deleting an existing value i\nfrom an existing Fenwick Tree! Also show how to implement insert(i)\u2014inserting a value\ni that currently does not exist in the Fenwick Tree, i.e., rsq(i, i) = 0. What assumptions\nthat you need to make for insertion to work?\n113\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.4.4\nSegment Tree\nMotivation\nIn the previous Section 2.4.3 and in this section, we discuss two data structures which can\ne\ufb03ciently answer dynamic range queries where the data is frequently updated and queried.\nOne such range query is the problem of \ufb01nding the minimum value in an array within range\n[i..j]. This is known as the Range Minimum67 Query (RMQ) problem68.\nFor example, given an array A of size n = 7 below, RMQ(1, 3) = 13, as 13 is the minimum\nvalue among A[1], A[2], and A[3].", "mimetype": "text/plain", "start_char_idx": 364622, "end_char_idx": 367515, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aeabf378-88c2-4ab0-a6e1-3bae6af8fcbe": {"__data__": {"id_": "aeabf378-88c2-4ab0-a6e1-3bae6af8fcbe", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8636d26e-b777-4881-8bd2-36070d66bde9", "node_type": "1", "metadata": {}, "hash": "aed66c03c75abcb17a1fca5b62705fef19bf8eea0b7bb83c881cdc3421447182", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c675890d-a913-41fa-a267-900d2db8baf5", "node_type": "1", "metadata": {}, "hash": "aacedd5ad1a1e5e8d5a91d750f841c84d3b5f27bd213cf4634da7b6fd383b50b", "class_name": "RelatedNodeInfo"}}, "text": "What assumptions\nthat you need to make for insertion to work?\n113\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.4.4\nSegment Tree\nMotivation\nIn the previous Section 2.4.3 and in this section, we discuss two data structures which can\ne\ufb03ciently answer dynamic range queries where the data is frequently updated and queried.\nOne such range query is the problem of \ufb01nding the minimum value in an array within range\n[i..j]. This is known as the Range Minimum67 Query (RMQ) problem68.\nFor example, given an array A of size n = 7 below, RMQ(1, 3) = 13, as 13 is the minimum\nvalue among A[1], A[2], and A[3]. To check your understanding of RMQ, verify that in\nthe array A below, RMQ(3, 4) = 15, RMQ(0, 0) = 18, RMQ(0, 1) = 17, RMQ(4, 6) = 11,\nand RMQ(0, 6) = 11.\nArray\nValues\n18\n17\n13\n19\n15\n11\n20\nA\nIndices\n0\n1\n2\n3\n4\n5\n6\nIn order to simplify our discussion, we make A to have size a power of 2. Since n = 7, we\nappend a dummy value A[7] = 1 (shown here as 99) that will not change the RMQ(i, j)\nvalues for any pair of (i, j). Now n = 8, which is a power of 2.\nArray\nValues\n18\n17\n13\n19\n15\n11\n20\n1 = 99\nA\nIndices\n0\n1\n2\n3\n4\n5\n6\n7\nThere are several ways to solve the RMQ problem.\nOne na\u00a8\u0131ve algorithm is to simply iterate the array from index i to j and report the index\nwith the minimum value per query. But this algorithm will run in O(n) time per query.\nWhen n is large and there are many queries, such an algorithm may be infeasible.\nIf the data is static, i.e., the data is unchanged after it is instantiated, we can use the\nSparse Table data structure with O(n log n) Dynamic Programming pre-processing and O(1)\nper RMQ that we discuss in Book 2. But if the data is dynamic, the heavy O(n log n) pre-\nprocessing techniques used in Sparse Table data structure is too costly.\nThe Basic Ideas\nIn this section, we solve the dynamic RMQ problem on array A with a Segment Tree st,\nwhich is another way to arrange data in a binary tree. There are several ways to implement\nthe Segment Tree. Our implementation uses the same concept as the 1-based compact array\nin the Binary Heap where we use vi (our shortcut for vector<int>) st to represent the\nbinary tree. Index 1 (skipping index 0) is the root and the left and right children of index p\nare index 2 \u21e5p and (2 \u21e5p) + 1 respectively (also see Binary Heap discussion in Section 2.3).\nThe value of st[p] is the RMQ value of the segment associated with index p.\nThe root of Segment Tree represents the full segment [0, n-1] of array A. For each\nsegment [L, R] stored in index p where L != R, we split the segment into sub-segment\n[L, (L+R)/2] (stored in index 2 \u21e5p) and sub-segment [(L+R)/2+1, R] (stored in index\n(2 \u21e5p) + 1). We keep splitting the segments until each segment contains just one index of\nthe underlying array A, i.e., L = R.\n67The opposite Range Maximum Query problem is identical to this Range Minimum Query problem.\n68Segment Tree can also be used to answer dynamic Range Sum Query (RSQ(i, j)). However, Fenwick\nTree discussed earlier in Section 2.4.3 is an even simpler data structure for RSQ. Therefore in this Section\n2.4.4, we concentrate on the RMQ.\n114\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nSegment Tree Operation: O(n) build from an Array A\nGiven an array A, we can build Segment Tree on top of this array by repeating the following\nrecursive process.", "mimetype": "text/plain", "start_char_idx": 366902, "end_char_idx": 370257, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c675890d-a913-41fa-a267-900d2db8baf5": {"__data__": {"id_": "c675890d-a913-41fa-a267-900d2db8baf5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aeabf378-88c2-4ab0-a6e1-3bae6af8fcbe", "node_type": "1", "metadata": {}, "hash": "0281edb1be8a413822c39aa4ca4fb88d0bd9e122d78407453bfb7fa22974a05d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ca35db60-20eb-4da3-9813-e64de6027423", "node_type": "1", "metadata": {}, "hash": "8690857986633e930c78041389605df7567aab7ae542e19225f1cd7a8ef76540", "class_name": "RelatedNodeInfo"}}, "text": "We keep splitting the segments until each segment contains just one index of\nthe underlying array A, i.e., L = R.\n67The opposite Range Maximum Query problem is identical to this Range Minimum Query problem.\n68Segment Tree can also be used to answer dynamic Range Sum Query (RSQ(i, j)). However, Fenwick\nTree discussed earlier in Section 2.4.3 is an even simpler data structure for RSQ. Therefore in this Section\n2.4.4, we concentrate on the RMQ.\n114\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nSegment Tree Operation: O(n) build from an Array A\nGiven an array A, we can build Segment Tree on top of this array by repeating the following\nrecursive process.\nWhen L = R, it is clear that st[p] = A[L] (or A[R]).\nOtherwise, we will recursively build the Segment Tree. We compare the minimum values\nof the left and the right sub-segments (computed recursively) and update st[p] to be the\nsmaller value.\nThis process is implemented in the void build(int p, int L, int R) routine. This\nbuild routine creates up to O(1 + 2 + 4 + 8 + . . . + 2log2 n) = O(2 \u21e5n) (smaller) segments\nand therefore runs in O(n). If n is a power of 2, the resulting Segment Tree is a perfect\nbinary tree with log n levels and 2 \u21e5n \u22121 vertices that can be stored in vi st of size 2 \u21e5n\n(sacri\ufb01cing index 0). However, as n may not be a power of 2 in general, we need to make n to\nbe the next power of 2 using formula 2d(log2(n)e and set st to have size 2 \u21e52d(log2(n)e to avoid\nindex out of bound error. In our implementation, we simply use a loose space complexity of\nO(4n) = O(n) that always upperbound this precise formula 2 \u21e52d(log2(n)e.\nFor the sample array A, the corresponding Segment Tree is shown in Figure 2.19 and 2.20\nwhere the segment information (vertex p: [left index i of A, right index j of A], abbreviated\nas p:[L,R]) is shown below a Segment Tree vertex/circle p and its value, st[p], is shown\ninside the vertex/circle.\nSegment Tree Operation: O(log n) RMQ(i, j)\nWith the Segment Tree ready, answering an RMQ can be done in O(log n). The answer for\nRMQ(i, i) is trivial\u2014simply return A[i] itself. However, for the general case RMQ(i, j),\nfurther checks are needed. We de\ufb01ne a private function int RMQ(int p, int L, int R,\nint i, int j) and the wrapper RMQ(i, j) function starts with RMQ(1, 0, n-1, i, j),\ni.e., trying to \ufb01nd RMQ(i, j) from the root segment [L=0, R=n-1] (index p = 1).\nFigure 2.19: Segment Tree of A = {18, 17, 13, 19, 15, 11, 20, 1} and RMQ(1, 3) = 13\nTake for example the query RMQ(1, 3).\nThe process in Figure 2.19 is as follows: start\nfrom the root (index 1) which represents segment 1:[0,7].\nWe cannot use the stored\nminimum value of segment 1:[0,7] = st[1] = 11 as the answer for RMQ(1, 3) since it\nis the minimum value over a larger69 segment than the desired range in RMQ(1, 3). From\n69Segment p:[L,R] is said to be larger than query range [i,j] (and therefore requires a split) if [L,R]\nis not outside the query range and not inside query range (see the other footnotes).\n115\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nthe root, we only have to go to the left subtree as the root of the right subtree represents\nsegment 3:[4,7] which is outside70 the desired range in RMQ(1, 3).\nWe are now at the root of the left subtree (index 2) that represents segment 2:[0,3].", "mimetype": "text/plain", "start_char_idx": 369578, "end_char_idx": 372890, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ca35db60-20eb-4da3-9813-e64de6027423": {"__data__": {"id_": "ca35db60-20eb-4da3-9813-e64de6027423", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c675890d-a913-41fa-a267-900d2db8baf5", "node_type": "1", "metadata": {}, "hash": "aacedd5ad1a1e5e8d5a91d750f841c84d3b5f27bd213cf4634da7b6fd383b50b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "318eb557-470c-4488-a451-ad0d441fa2aa", "node_type": "1", "metadata": {}, "hash": "74df4a18b1c224c87a3159d395cc02d6030cd32dfd84ab97bb7b87818830547e", "class_name": "RelatedNodeInfo"}}, "text": "From\n69Segment p:[L,R] is said to be larger than query range [i,j] (and therefore requires a split) if [L,R]\nis not outside the query range and not inside query range (see the other footnotes).\n115\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nthe root, we only have to go to the left subtree as the root of the right subtree represents\nsegment 3:[4,7] which is outside70 the desired range in RMQ(1, 3).\nWe are now at the root of the left subtree (index 2) that represents segment 2:[0,3].\nThis segment 2:[0,3] is still larger than the desired range in RMQ(1, 3). In fact, RMQ(1, 3)\nintersects both the left sub-segment 4:[0,1] and the right sub-segment 5:[2,3] of segment\n2:[0,3], so we have to explore both subtrees (sub-segments).\nThe left segment 4:[0,1] of 2:[0,3] is not yet inside the desired range in RMQ(1, 3),\nso another split is necessary. From segment 4:[0,1], we move right to segment 9:[1,1],\nwhich is now inside71 the desired range in RMQ(1, 3). Now, we know that RMQ(1, 1) =\nst[9] = A[1] = 17 and we can return this value to the caller. The right segment 5:[2,3]\nof 2:[0,3] is also inside the desired range in RMQ(1, 3). From the stored value inside this\nvertex, we know that RMQ(2, 3) = st[5] = 13. We do not need to traverse further down.\nSo now, we are back in the call to segment 2:[0,3], we now have a = RMQ(1, 1) = 17 and\nb = RMQ(2, 3) = 13. Therefore, we now have RMQ(1, 3) = min(a, b) = min(17, 13)\n= 13. This is the \ufb01nal answer that is returned back to the root.\nNow let\u2019s see another example: RMQ(4, 7). The execution in Figure 2.20 is as follows:\nWe start from the root segment 1:[0,7]. Because it is larger than the desired range in\nRMQ(4, 7), we move right to segment 3:[4,7] as segment 2:[0,3] is outside. Since this\nsegment 3:[4,7] exactly represents RMQ(4, 7), we simply return the minimum value that\nis stored in this vertex, which is 11. Thus RMQ(4, 7) = st[3] = 11.\nFigure 2.20: Segment Tree of A = {18, 17, 13, 19, 15, 11, 20, 1} and RMQ(4, 7) = 11\nThe way data is structured allows us to avoid traversing the unnecessary parts of the tree!\nEach query will only involve at most four vertices per level and there are at most log n levels.\nThus, the total cost is O(4 log n) = O(log n). Example: in RMQ(1, 6), we have one half of\nthe path as depicted in Figure 2.19 combined with this \u2018mirror\u2019 path: 1:[0,7] ! 3:[4,7]\n! 6:[4,5] (backtracks once) ! 7:[6,7] ! 14:[6,6] (backtracks three times back to the\nroot). Because a = 13 (RMQ(1, 3)) and b = 11 (RMQ(4, 6)), then RMQ(1, 6) = min(a,\nb) = min(13, 11) = 11. Notice that there are four vertices (index {4, 5, 6, 7}) that are\naccessed in the second last level of the Segment Tree.\nSegment Tree Operation: O(log n) Point update(i, i, v)\nWe repeat that if the array A is static, then using a Segment Tree to solve the RMQ problem\nis overkill as Sparse Table data structure is more suitable.", "mimetype": "text/plain", "start_char_idx": 372389, "end_char_idx": 375271, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "318eb557-470c-4488-a451-ad0d441fa2aa": {"__data__": {"id_": "318eb557-470c-4488-a451-ad0d441fa2aa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ca35db60-20eb-4da3-9813-e64de6027423", "node_type": "1", "metadata": {}, "hash": "8690857986633e930c78041389605df7567aab7ae542e19225f1cd7a8ef76540", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "51ed877b-aecd-49d0-a93f-1c927ef760ba", "node_type": "1", "metadata": {}, "hash": "c0639d76f11049f0f792923fccdfa9e1b5e0689dcdbf1015d41afa7277db5d40", "class_name": "RelatedNodeInfo"}}, "text": "3:[4,7]\n! 6:[4,5] (backtracks once) ! 7:[6,7] ! 14:[6,6] (backtracks three times back to the\nroot). Because a = 13 (RMQ(1, 3)) and b = 11 (RMQ(4, 6)), then RMQ(1, 6) = min(a,\nb) = min(13, 11) = 11. Notice that there are four vertices (index {4, 5, 6, 7}) that are\naccessed in the second last level of the Segment Tree.\nSegment Tree Operation: O(log n) Point update(i, i, v)\nWe repeat that if the array A is static, then using a Segment Tree to solve the RMQ problem\nis overkill as Sparse Table data structure is more suitable.\n70Segment p:[L,R] is said to be outside query range [i,j] if i > j.\n71Segment p:[L,R] is said to be inside query range [i,j] if (L >= i) && (R <= j).\n116\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nSegment Tree is useful if the underlying array A is frequently updated (dynamic). There\nare two possible kinds of update: A single point (single index i) update, or a range (multiple\nindices between [i..j]) update. We \ufb01rst start with point update.\nFigure 2.21: Updating A to {18, 17, 13, 19, 15, 77, 20, 1}\nFor example, if A[5] is now changed from 11 to 77, then we just need to update the vertices\nalong the leaf-to-root path in O(log n). See path: 13:[5,5] (st[13] = 77 now) ! 6:[4,5]\n(st[6] = 15 as min(15, 77) = 15 now) ! 3:[4,7] (st[3] = 15 as min(15, 20) = 15\nnow) ! 1:[0,7] (st[1] = 13 as min(13, 15) = 13 now) in Figure 2.21.\nIn our implementation, since we already have range update(i, j, v), we can simulate\npoint update(i, j, v) by setting j = i.\nFor comparison, the Sparse Table data structure solution presented in Book 2 requires\nanother slow O(n log n) pre-processing to update the structure and is ine\u21b5ective if there are\nmany such dynamic updates.\nSegment Tree Operation: O(log n) Range update(i, j, v)\nIn some applications, we may need to update the values of a range [i..j] of array A in into\nthe same new value v. If we only know the O(log n) Point update(i, i, v) method above,\nwe may end up executing an O(n log n) algorithm as the range [i..j] can be as big as\n[0..n-1]. Fortunately, there is a better solution by using Lazy72 Propagation technique.\nThe Lazy Propagation is similar to RMQ operation in a way that it also visits at most (log n)\nvertices. But this time, instead of querying, it will just update the vertex that represents a\nrange that is inside the updated range and then backtrack.\nThis range update is clearer with an example: Assume that we now want to update\nthe values A[0..3] from Figure 2.21 from previously {18, 17, 13, 19} to all 30 (note that\nA[5] is still 77), then we just need to update at most O(log n) vertices along the a\u21b5ected\npaths. For this example, we only need a single path in Figure 2.22: 1:[0,7] ! 2:[0,3]\n(st[2] = 30, as A[0] = A[1] = A[2] = A[3] = 30 now), but this vertex has a lazy \ufb02ag\nas it has not yet propagate this information downwards), then we immediately backtrack to\n! 1:[0,7] (st[1] = 30 now as min(30, 77) = 30). If we now call RMQ(0, 3), we will\ntraverse 1:[0,7] !", "mimetype": "text/plain", "start_char_idx": 374745, "end_char_idx": 377736, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "51ed877b-aecd-49d0-a93f-1c927ef760ba": {"__data__": {"id_": "51ed877b-aecd-49d0-a93f-1c927ef760ba", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "318eb557-470c-4488-a451-ad0d441fa2aa", "node_type": "1", "metadata": {}, "hash": "74df4a18b1c224c87a3159d395cc02d6030cd32dfd84ab97bb7b87818830547e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b735c775-4891-4d95-bb6d-747bf379c53c", "node_type": "1", "metadata": {}, "hash": "332bfc93963b8694c4c79f1cb135d56adc2d2b6e3be80a48cd2d4c18903cc41f", "class_name": "RelatedNodeInfo"}}, "text": "For this example, we only need a single path in Figure 2.22: 1:[0,7] ! 2:[0,3]\n(st[2] = 30, as A[0] = A[1] = A[2] = A[3] = 30 now), but this vertex has a lazy \ufb02ag\nas it has not yet propagate this information downwards), then we immediately backtrack to\n! 1:[0,7] (st[1] = 30 now as min(30, 77) = 30). If we now call RMQ(0, 3), we will\ntraverse 1:[0,7] ! 2:[0,3] (st[2] = 30) and immediately report 30 although we have\nnot yet process these indices = {4, 5, 8, 9, 10, 11} in our Segment Tree.\n72This Lazy Technique appears several times in this book and is a worthwhile technique to be studied.\n117\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nFigure 2.22: Updating A to {30, 30, 30, 30, 15, 77, 20, 1}\nNow we will illustrate the full details of Lazy Propagation. Assume that we now want to\nupdate the values A[3] from Figure 2.22 from previously 30 (not yet propagated before) to\n7, then we just need to update at most O(log n) vertices along at a\u21b5ected paths. For this\nexample, see the paths in Figure 2.23.\nThe path is: 1:[0,7] ! 2:[0,3] \u2013 propagate the lazy \ufb02ag downwards to its two children\n4:[0,1] (st[4] = 30 now) and 5:[2,3] \u2013 then continues to ! 5:[2,3] (st[5] = 30\ntemporarily) \u2013 propagate the lazy \ufb02ag to its two children again 10:[2,2] (now we \ufb01nally\nupdate A[2] = st[10] = 30) and 11:[3,3] ! 11:[3,3] (now we \ufb01nally update A[3] =\nst[11] = 7) and then backtrack all the way to the root, updating the RMQ values of st[5],\nst[2], and st[1] to the correct value 7.\nFigure 2.23: Updating A to {30, 30, 30, 7, 15, 77, 20, 1}\nAs the behavior of this range update is similar as RMQ, we can conclude that it also runs\nin O(log n) time\u2014faster than multiple calls of individual point updates.\nThe Implementation\nOur Segment Tree code that implements Range Minimum Query (RMQ) and Range Update\nwith Lazy Propagation technique is shown below. To change this implementation to deal\nwith Range Maximum Query problem, simply edit the conquer function.\n118\n\nCHAPTER 2.", "mimetype": "text/plain", "start_char_idx": 377383, "end_char_idx": 379359, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b735c775-4891-4d95-bb6d-747bf379c53c": {"__data__": {"id_": "b735c775-4891-4d95-bb6d-747bf379c53c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "51ed877b-aecd-49d0-a93f-1c927ef760ba", "node_type": "1", "metadata": {}, "hash": "c0639d76f11049f0f792923fccdfa9e1b5e0689dcdbf1015d41afa7277db5d40", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6c2c430a-4ebe-4be8-876a-d61898dffd12", "node_type": "1", "metadata": {}, "hash": "30d6c8666bc14b4592289788cf093ce20967dcd07b3ef10f3b181cd6fd048f73", "class_name": "RelatedNodeInfo"}}, "text": "11:[3,3] (now we \ufb01nally update A[3] =\nst[11] = 7) and then backtrack all the way to the root, updating the RMQ values of st[5],\nst[2], and st[1] to the correct value 7.\nFigure 2.23: Updating A to {30, 30, 30, 7, 15, 77, 20, 1}\nAs the behavior of this range update is similar as RMQ, we can conclude that it also runs\nin O(log n) time\u2014faster than multiple calls of individual point updates.\nThe Implementation\nOur Segment Tree code that implements Range Minimum Query (RMQ) and Range Update\nwith Lazy Propagation technique is shown below. To change this implementation to deal\nwith Range Maximum Query problem, simply edit the conquer function.\n118\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nclass SegmentTree {\n// OOP style\nprivate:\nint n;\n// n = (int)A.size()\nvi A, st, lazy;\n// the arrays\nint l(int p) { return\np<<1; }\n// go to left child\nint r(int p) { return (p<<1)+1; }\n// go to right child\nint conquer(int a, int b) {\nif (a == -1) return b;\n// corner case\nif (b == -1) return a;\nreturn min(a, b);\n// RMQ\n}\nvoid build(int p, int L, int R) {\n// O(n)\nif (L == R)\nst[p] = A[L];\n// base case\nelse {\nint m = (L+R)/2;\nbuild(l(p), L\n, m);\nbuild(r(p), m+1, R);\nst[p] = conquer(st[l(p)], st[r(p)]);\n}\n}\nvoid propagate(int p, int L, int R) {\nif (lazy[p] != -1) {\n// has a lazy flag\nst[p] = lazy[p];\n// [L..R] has same value\nif (L != R)\n// not a leaf\nlazy[l(p)] = lazy[r(p)] = lazy[p];\n// propagate downwards\nelse\n// L == R, a single index\nA[L] = lazy[p];\n// time to update this\nlazy[p] = -1;\n// erase lazy flag\n}\n}\nint RMQ(int p, int L, int R, int i, int j) {\n// O(log n)\npropagate(p, L, R);\n// lazy propagation\nif (i > j) return -1;\n// infeasible\nif ((L >= i) && (R <= j)) return st[p];\n// found the segment\nint m = (L+R)/2;\nreturn conquer(RMQ(l(p), L\n, m, i\n, min(m, j)),\nRMQ(r(p), m+1, R, max(i, m+1), j\n));\n}\n119\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nvoid update(int p, int L, int R, int i, int j, int val) { // O(log n)\npropagate(p, L, R);\n// lazy propagation\nif (i > j) return;\nif ((L >= i) && (R <= j)) {\n// found the segment\nlazy[p] = val;\n// update this\npropagate(p, L, R);\n// lazy propagation\n}\nelse {\nint m = (L+R)/2;\nupdate(l(p), L\n, m, i\n, min(m, j), val);\nupdate(r(p), m+1, R, max(i, m+1), j\n, val);\nint lsubtree = (lazy[l(p)] != -1) ? lazy[l(p)] : st[l(p)];\nint rsubtree = (lazy[r(p)] != -1) ? lazy[r(p)] : st[r(p)];\nst[p] = (lsubtree <= rsubtree) ?", "mimetype": "text/plain", "start_char_idx": 378700, "end_char_idx": 381174, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c2c430a-4ebe-4be8-876a-d61898dffd12": {"__data__": {"id_": "6c2c430a-4ebe-4be8-876a-d61898dffd12", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b735c775-4891-4d95-bb6d-747bf379c53c", "node_type": "1", "metadata": {}, "hash": "332bfc93963b8694c4c79f1cb135d56adc2d2b6e3be80a48cd2d4c18903cc41f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b2fcd079-151e-4762-afb3-75e73662d773", "node_type": "1", "metadata": {}, "hash": "883870e6dbec975fc3b30a5aa3302ba11f403c8a23584ec782610925732572f7", "class_name": "RelatedNodeInfo"}}, "text": "lazy[l(p)] : st[l(p)];\nint rsubtree = (lazy[r(p)] != -1) ? lazy[r(p)] : st[r(p)];\nst[p] = (lsubtree <= rsubtree) ? st[l(p)] : st[r(p)];\n}\n}\npublic:\nSegmentTree(int sz) : n(sz), st(4*n), lazy(4*n, -1) {}\nSegmentTree(const vi &initialA) : SegmentTree((int)initialA.size()) {\nA = initialA;\nbuild(1, 0, n-1);\n}\nvoid update(int i, int j, int val) { update(1, 0, n-1, i, j, val); }\nint RMQ(int i, int j) { return RMQ(1, 0, n-1, i, j); }\n};\nint main() {\nvi A = {18, 17, 13, 19, 15, 11, 20, 99};\n// make n a power of 2\nSegmentTree st(A);\nprintf(\"\nidx\n0, 1, 2, 3, 4, 5, 6, 7\\n\");\nprintf(\"\nA is {18,17,13,19,15,11,20,oo}\\n\");\nprintf(\"RMQ(1, 3) = %d\\n\", st.RMQ(1, 3));\n// 13\nprintf(\"RMQ(4, 7) = %d\\n\", st.RMQ(4, 7));\n// 11\nprintf(\"RMQ(3, 4) = %d\\n\", st.RMQ(3, 4));\n// 15\nst.update(5, 5, 77);\n// update A[5] to 77\nprintf(\"\nidx\n0, 1, 2, 3, 4, 5, 6, 7\\n\");\nprintf(\"Now, modify A into {18,17,13,19,15,77,20,oo}\\n\");\nprintf(\"RMQ(1, 3) = %d\\n\", st.RMQ(1, 3));\n// remains 13\nprintf(\"RMQ(4, 7) = %d\\n\", st.RMQ(4, 7));\n// now 15\nprintf(\"RMQ(3, 4) = %d\\n\", st.RMQ(3, 4));\n// remains 15\n120\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nst.update(0, 3, 30);\n// update A[0..3] to 30\nprintf(\"\nidx\n0, 1, 2, 3, 4, 5, 6, 7\\n\");\nprintf(\"Now, modify A into {30,30,30,30,15,77,20,oo}\\n\");\nprintf(\"RMQ(1, 3) = %d\\n\", st.RMQ(1, 3));\n// now 30\nprintf(\"RMQ(4, 7) = %d\\n\", st.RMQ(4, 7));\n// remains 15\nprintf(\"RMQ(3, 4) = %d\\n\", st.RMQ(3, 4));\n// remains 15\nst.update(3, 3, 7);\n// update A[3] to 7\nprintf(\"\nidx\n0, 1, 2, 3, 4, 5, 6, 7\\n\");\nprintf(\"Now, modify A into {30,30,30, 7,15,77,20,oo}\\n\");\nprintf(\"RMQ(1, 3) = %d\\n\", st.RMQ(1, 3));\n// now 7\nprintf(\"RMQ(4, 7) = %d\\n\", st.RMQ(4, 7));\n// remains 15\nprintf(\"RMQ(3, 4) = %d\\n\", st.RMQ(3, 4));\n// now 7\nreturn 0;\n}\nTo further enhance your understanding of this rather advanced data structure, please visit\nVisuAlgo, Segment Tree visualization, that shows visualization of this Segment Tree data\nstructure and all its operations. You can specify your own array A, perform various Range\nMin/Max/Sum Queries, perform various Range Updates (recall that we can specify Point\nUpdates by setting L=R) with Lazy Propagation, and then see the resulting Segment Tree.\nThe URL for the Segment Tree visualization and source code example are shown below.", "mimetype": "text/plain", "start_char_idx": 381060, "end_char_idx": 383340, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b2fcd079-151e-4762-afb3-75e73662d773": {"__data__": {"id_": "b2fcd079-151e-4762-afb3-75e73662d773", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6c2c430a-4ebe-4be8-876a-d61898dffd12", "node_type": "1", "metadata": {}, "hash": "30d6c8666bc14b4592289788cf093ce20967dcd07b3ef10f3b181cd6fd048f73", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d8c40691-573b-4a8d-8fcd-055c94dd275c", "node_type": "1", "metadata": {}, "hash": "58529c04a1f39606579f6af581a34726c67269ae70216b935ccd8006c555db2e", "class_name": "RelatedNodeInfo"}}, "text": "You can specify your own array A, perform various Range\nMin/Max/Sum Queries, perform various Range Updates (recall that we can specify Point\nUpdates by setting L=R) with Lazy Propagation, and then see the resulting Segment Tree.\nThe URL for the Segment Tree visualization and source code example are shown below.\nVisualization: https://visualgo.net/en/segmenttree\nSource code: ch2/ourown/segmenttree ds.cpp|java|py|ml\nExercise 2.4.4.1: Using a similar Segment Tree as in the Exercise above, answer the queries\nRSQ(1, 7) and RSQ(3, 8). Is this a good approach to solve the problem if array A is never\nchanged? (also see Section 3.5.2). Is it a good approach if array A is frequently changed?\n(also see Section 2.4.3).\nExercise 2.4.4.2*: Draw the Segment Tree corresponding to array A = {10, 2, 47, 3,\n7, 9, 1, 98, 21}. Answer RMQ(1, 7) and RMQ(3, 8)! Hint: Use the Segment Tree visu-\nalization in VisuAlgo.\nExercise 2.4.4.3*: Modify the given Segment Tree implementation above so that it can be\nused to solve the RSQ problem.\nExercise 2.4.4.4*: The (point/range) update operation shown in this section only changes\nthe value of a certain index/consecutive indices in array A. What if we want to delete existing\nvalues of array A or insert a new value into array A? Can you explain what will happen with\nthe given Segment Tree code and what you should do to address it?\nExercise 2.4.4.5*: Solve this dynamic RSQ problem: UVa 12086 - Potentiometers (and\na few other dynamic RSQ problems) using both Fenwick Tree and Segment Tree. Which\nsolution is easier to implement in this case? Also see Table 2.6 for a comparison between\nthese two data structures.\n121\n\n2.4.\nDS WITH OUR OWN LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nFeature\nFenwick Tree\nSegment Tree\nBuild Tree from Array\nO(n + m)\nO(n)\nStatic RSQ\nOverkill\nOverkill\nDynamic RMin/MaxQ\nLimited\nYes\nDynamic RSQ\nYes\nYes\nRange Query Complexity\nO(log m)\nO(log n)\nPoint Update Complexity\nO(log m)\nO(log n)\nRange Update Complexity\nO(log m), RURQ variant\nO(log n), Lazy Update\nLength of Code (Basic)\nMuch shorter\nMuch longer\nLength of Code (Full)\nLong\nLong\nTable 2.6: Comparison Between Fenwick Tree and Segment Tree\nProgramming exercises that use the data structures discussed in this section:\na. Graph Data Structures Problems\n1. Entry Level: UVa 11991 - Easy Problem from ... * (Adjacency List)\n2. UVa 00599 - The Forrest for the Trees * (V \u2212E = number of CCs; use\na bitset of size 26 to count the number of vertices that have some edge)\n3. UVa 10895 - Matrix Transpose * (transpose adjacency list)\n4. UVa 11550 - Demanding Dilemma * (graph DS; incidence matrix)\n5. Kattis - abinitio * (combo: EL input, AM as working graph DS, AL output\n(in hash format); all operations must be O(V ) or better)\n6. Kattis - chopwood * (Pr\u00a8ufer sequence; use priority queue)\n7. Kattis - traveltheskies * ((graph) DS manipulation; an array of ALs (one per\neach day); simulate the number of people day by day)\nExtra UVa: 10928.\nExtra Kattis: alphabetanimals, \ufb02yingsafely, railroad, weakvertices.\nAlso see: Many more graph problems in Chapter 4 and 8.\nb. Union-Find Disjoint Sets\n1. Entry Level: Kattis - union\ufb01nd * (basic UFDS; similar to UVa 00793)\n2. UVa 01197 - The Suspects * (LA 2817 - Kaohsiung03; CCs)\n3. UVa 01329 - Corporative Network * (LA 3027 - SouthEasternEurope04;\ninteresting UFDS variant; modify the union and \ufb01nd routine)\n4. UVa 10685 - Nature * (\ufb01nd the set with the largest item)\n5.", "mimetype": "text/plain", "start_char_idx": 383028, "end_char_idx": 386449, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d8c40691-573b-4a8d-8fcd-055c94dd275c": {"__data__": {"id_": "d8c40691-573b-4a8d-8fcd-055c94dd275c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b2fcd079-151e-4762-afb3-75e73662d773", "node_type": "1", "metadata": {}, "hash": "883870e6dbec975fc3b30a5aa3302ba11f403c8a23584ec782610925732572f7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "68d3de96-3bda-4161-a2c6-831b02493bec", "node_type": "1", "metadata": {}, "hash": "506ae08d6fc3631e7829cb9ec19e12fd0b8fa19deb1031789359e05dc3bcd6e9", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: alphabetanimals, \ufb02yingsafely, railroad, weakvertices.\nAlso see: Many more graph problems in Chapter 4 and 8.\nb. Union-Find Disjoint Sets\n1. Entry Level: Kattis - union\ufb01nd * (basic UFDS; similar to UVa 00793)\n2. UVa 01197 - The Suspects * (LA 2817 - Kaohsiung03; CCs)\n3. UVa 01329 - Corporative Network * (LA 3027 - SouthEasternEurope04;\ninteresting UFDS variant; modify the union and \ufb01nd routine)\n4. UVa 10685 - Nature * (\ufb01nd the set with the largest item)\n5. Kattis - control * (LA 7480 - Singapore15; simulation of UFDS; size of set;\nnumber of disjoint sets)\n6. Kattis - ladice * (size of set; decrement one per usage)\n7. Kattis - almostunion\ufb01nd * (new operation: move; idea: do not destroy the\nparent array structure; also available at UVa 11987 - Almost Union-Find)\nExtra UVa: 00793, 10158, 10507, 10583, 10608, 11690.\nExtra Kattis: chatter, forests, more10, swaptosort, tildes, virtualfriends.\nAlso see: Kruskal\u2019s algorithm that uses UFDS data structure in Section 4.3\nand harder problems involving e\ufb03cient DS in Book 2.\n122\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nc. Tree-related Data Structures\n1. Entry Level: Kattis - fenwick * (basic Fenwick Tree; use long long)\n2. UVa 11402 - Ahoy, Pirates * (Segment Tree with lazy updates)\n3. UVa 11423 - Cache Simulator * (clever usage of Fenwick Tree and large\narray; important hint: look at the constraints carefully)\n4. UVa 12299 - RMQ with Shifts * (Segment Tree with a few point (not\nrange) updates; RMQs)\n5. Kattis - justforsidekicks * (use six Fenwick Trees, one for each gem type)\n6. Kattis - moviecollection * (LA 5902 - NorthWesternEurope11; not a stack\nbut a dynamic RSQ problem; also available at UVa 01513 - Movie collection)\n7. Kattis - supercomputer * (easy problem if we use Fenwick Tree)\nExtra UVa: 00297, 01232, 11235, 11297, 11350, 12086, 12532.\nExtra Kattis: turbo, worstweather.\nAlso see: Harder problems involving e\ufb03cient DS in Book 2.\nPro\ufb01le of Data Structure Inventor\nPeter M. Fenwick is a Honorary Associate Professor in the University of Auckland. He\ninvented the Binary Indexed Tree in 1994 [14] as \u201ccumulative frequency tables of arithmetic\ncompression\u201d. The BIT is included in the IOI syllabus [16] and used in quite a number of\ninteresting contest problems for its e\ufb03cient yet easy to implement data structure.\n123\n\n2.5.\nSOLUTION TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\n2.5\nSolution to Non-Starred Exercises\nExercise 2.2.1.1*: Sub-question 1: The sorting requirements for integer age and string\n\ufb01rst name are nice (ascending order), but we need to sort the N elements by decreasing\nstring last name if their ages are tied. It is not easy to reverse the sort order of a string, so\nwe need to come up with the following custom comparison function like this:\ntypedef tuple<int, string, string> iss;\n// combine the 3 fields\nbool cmp(iss &A, iss &B) {\nauto &[ageA, lastA, firstA] = A;\n// decompose the tuple\nauto &[ageB, lastB, firstB] = B;\nif (ageA != ageB) return ageA < ageB;\nif (lastA != lastB) return lastA > lastB;\n// the annoying one\nreturn firstA < firstB;\n}\nExercise 2.2.1.2*: Sub-question 1: First, sort S in O(n log n) and then do an O(n) linear\nscan starting from the second item to check if an integer and the previous integer are the\nsame.", "mimetype": "text/plain", "start_char_idx": 385976, "end_char_idx": 389255, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "68d3de96-3bda-4161-a2c6-831b02493bec": {"__data__": {"id_": "68d3de96-3bda-4161-a2c6-831b02493bec", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d8c40691-573b-4a8d-8fcd-055c94dd275c", "node_type": "1", "metadata": {}, "hash": "58529c04a1f39606579f6af581a34726c67269ae70216b935ccd8006c555db2e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e8777ce0-4e3d-4037-ade1-90c2954d1850", "node_type": "1", "metadata": {}, "hash": "5fee9ad340b8be9625d326e96744604cbf85f3a81ee267d8f52c3f13fd3ebbc9", "class_name": "RelatedNodeInfo"}}, "text": "It is not easy to reverse the sort order of a string, so\nwe need to come up with the following custom comparison function like this:\ntypedef tuple<int, string, string> iss;\n// combine the 3 fields\nbool cmp(iss &A, iss &B) {\nauto &[ageA, lastA, firstA] = A;\n// decompose the tuple\nauto &[ageB, lastB, firstB] = B;\nif (ageA != ageB) return ageA < ageB;\nif (lastA != lastB) return lastA > lastB;\n// the annoying one\nreturn firstA < firstB;\n}\nExercise 2.2.1.2*: Sub-question 1: First, sort S in O(n log n) and then do an O(n) linear\nscan starting from the second item to check if an integer and the previous integer are the\nsame. Alternatively, we can also use the faster Hash Table and O(n) linear scan to solve this\nsub-question 1. Sub-question 6: Read the opening paragraph of Chapter 3 and the detailed\ndiscussion in Book 2. Solutions for the other sub-questions are not shown.\nExercise 2.2.3.1: The answers (except sub-question 7 and 8):\n1. S & (N \u22121)\n2. (S & (S \u22121)) == 0\n3. S & (S \u22121)\n4. S | (S + 1)\n5. S & (S + 1)\n6. S | (S \u22121)\nExercise 2.2.4.1: Possible, keep the intermediate computations modulo 106. Keep chip-\nping away the trailing zeroes (either none or a few zeroes are added after a multiplication\nfrom n! to (n + 1)!).\nExercise 2.2.4.2: Possible. 9317 = 7 \u21e5113. We also list 25! as its prime factors. Then, we\ncheck if there are one factor 7 (yes) and three factors 11 (unfortunately no). So 25! is not\ndivisible by 9317. Alternative: use modular arithmetic (see the details in Book 2).\nExercise 2.3.1.1: The answers:\n1. Insert(26): Insert 26 as the left subtree of 3, swap 26 with 3, then swap 26 with 19\nand stop. The Max Heap array A now contains {-, 90, 26, 36, 17, 19, 25, 1, 2, 7, 3}.\n2. ExtractMax(): Swap 90 (maximum item which will be reported after we \ufb01x the Max\nHeap property) with 3 (the current bottom-most right-most leaf/the last item in the\nMax Heap), swap 3 with 36, swap 3 with 25 and stop. The Max Heap array A now\ncontains {-, 36, 26, 25, 17, 19, 3, 1, 2, 7} and we report 90 as the answer.\n3. Heap Sort will extract the values of array A in non-increasing order.\n124\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\nExercise 2.3.1.2: Yes, check that all indices (vertices) satisfy the Max Heap property.\nExercise 2.3.2.1: The answers:\n1. Search(8): Immediately go to cell/slot 8%11 = 8 and \ufb01nd 8 at the head of the list\nstored at cell 8,\nSearch(35): Immediately go to cell/slot 35%11 = 2 and iterate forward two times to\n\ufb01nd 35 in the list stored at cell 2,\nSearch(77): Immediately go to cell/slot 77%11 = 0 and iterate forward once to \ufb01nd\n77 is not in the list stored at cell 0, hence 77 is not in the Hash Table.\n2. Insert(77): Insert 77 at the back of list stored at cell 77%11 = 0,\nInsert(13): Because Search(13) \ufb01nds 13, we cannot insert another duplicate into the\nHash Table\u2014the default implementation is to maintain a set of integers (no duplicate),\nInsert(19): Insert 19 at the back of list stored at cell 19%11 = 8.\n3.", "mimetype": "text/plain", "start_char_idx": 388630, "end_char_idx": 391610, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e8777ce0-4e3d-4037-ade1-90c2954d1850": {"__data__": {"id_": "e8777ce0-4e3d-4037-ade1-90c2954d1850", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "68d3de96-3bda-4161-a2c6-831b02493bec", "node_type": "1", "metadata": {}, "hash": "506ae08d6fc3631e7829cb9ec19e12fd0b8fa19deb1031789359e05dc3bcd6e9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d2cd5c0d-e1fd-464a-b5fd-658275486540", "node_type": "1", "metadata": {}, "hash": "c8cba6efc1851b70588330b03545487fa69bba149f64d04545ad8e1a3171d154", "class_name": "RelatedNodeInfo"}}, "text": "2. Insert(77): Insert 77 at the back of list stored at cell 77%11 = 0,\nInsert(13): Because Search(13) \ufb01nds 13, we cannot insert another duplicate into the\nHash Table\u2014the default implementation is to maintain a set of integers (no duplicate),\nInsert(19): Insert 19 at the back of list stored at cell 19%11 = 8.\n3. Remove(9): Search(9) fails, so no change to the Hash Table,\nRemove(7): Search(7) (found inside list stored at cell 7%11 = 7) and remove it,\nRemove(13): Search(13) (found inside list stored at cell 13%11 = 2) and remove it.\nExercise 2.3.2.2: Since the collection is dynamic, we will encounter frequent insertion\nand deletion queries. An insertion can potentially change the sort order. If we store the\ninformation in a static array, we will have to use one O(n) iteration of an insertion sort after\neach insertion and deletion (to close the gap in the array). This is ine\ufb03cient!\nExercise 2.3.2.3: Use the C++ STL unordered map (Java HashMap) and a counter variable.\nThis technique is quite frequently used in various (contest) problems. Example usage:\nunordered_map<string, int> mapper;\nint idx = 0;\n// idx starts from 0\nfor (int i = 0; i < M; ++i) {\nchar str[1000]; scanf(\"%s\", &str);\nif (!mapper.count(str))\n// the first encounter\n// if (mapper.find(str) == mapper.end())\n// alternative way\nmapper[str] = idx++;\n// set idx to str, then ++\n}\nExercise 2.3.3.1:\n1. search(71): root (15) ! 50 ! 71 (found)\nsearch(7): root (15) ! 4 ! 7 (found)\nsearch(22): root (15) ! 50 ! 23 ! empty left subtree (not found).\n2. We will eventually have the same BST as in Figure 2.6.\n3. To \ufb01nd the min/max item, we can start from root and keep going left/right until we\nencounter a vertex with no left/right subtrees respectively. That vertex is the answer.\n4. We will obtain the sorted output: 2, 4, 7, 10, 15, 23, 50, 65, 71. See Section 4.6.2 if\nyou are not familiar with the inorder tree traversal algorithm.\n5. Pre-order: 15, 4, 2, 7, 10, 50, 23, 71, 65, Post-order: 2, 10, 7, 4, 23, 65, 71, 50, 15,\nLevel-order: 15, 4, 50, 2, 7, 23, 71, 10, 65.\n125\n\n2.5.\nSOLUTION TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\n6. successor(50): Find the minimum item of the subtree rooted at the right of 50, which\nis the subtree rooted at 71. The answer is 65.\nsuccessor(10): 10 has no right subtree, so 10 must be the maximum of a certain\nsubtree. That subtree is the subtree rooted at 4. The parent of 4 is 15 and 4 is the\nleft subtree of 15. By the BST property, 15 must be the successor of 10.\nsuccessor(71): 71 is the largest item and has no successor.\nNote that the algorithm to \ufb01nd the predecessor of a vertex is similar.\n7. remove(65): We simply remove 65, which is a leaf, from the BST\nremove(71): As 71 is an internal vertex with one (left) child (65), we cannot just\ndelete 71 as doing so will disconnect the BST into two components. We set the parent\nof 71 (which is 50) to have 65 as its right child.\nremove(15): As 15 is a vertex with two children, we cannot simply delete 15 as doing\nso will disconnect the BST into three components. We need to \ufb01nd the successor of\n15 (which is 23) and use the successor to replace 15. We then delete the old 23 from\nthe BST (not a problem now).", "mimetype": "text/plain", "start_char_idx": 391298, "end_char_idx": 394480, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d2cd5c0d-e1fd-464a-b5fd-658275486540": {"__data__": {"id_": "d2cd5c0d-e1fd-464a-b5fd-658275486540", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e8777ce0-4e3d-4037-ade1-90c2954d1850", "node_type": "1", "metadata": {}, "hash": "5fee9ad340b8be9625d326e96744604cbf85f3a81ee267d8f52c3f13fd3ebbc9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2fe778c2-016e-4e95-b2f8-b910574f4ff1", "node_type": "1", "metadata": {}, "hash": "fe0ce370382357637ce02353f32ba8e17771e5eb9dbdaf6d5b19bcc465c1ca15", "class_name": "RelatedNodeInfo"}}, "text": "Note that the algorithm to \ufb01nd the predecessor of a vertex is similar.\n7. remove(65): We simply remove 65, which is a leaf, from the BST\nremove(71): As 71 is an internal vertex with one (left) child (65), we cannot just\ndelete 71 as doing so will disconnect the BST into two components. We set the parent\nof 71 (which is 50) to have 65 as its right child.\nremove(15): As 15 is a vertex with two children, we cannot simply delete 15 as doing\nso will disconnect the BST into three components. We need to \ufb01nd the successor of\n15 (which is 23) and use the successor to replace 15. We then delete the old 23 from\nthe BST (not a problem now). As a note, we can also use predecessor(key) instead of\nsuccessor(key) during remove(key) for the case when the key has two children.\nExercise 2.3.3.2: Use the C++ STL set (or Java TreeSet) as it is a balanced BST that\nsupports O(log n) dynamic insertions and deletions. We can use the inorder traversal to\nprint the data in the BST in sorted order (simply use C++ iterators (C++11 auto) or\nJava Iterators). However, if the data does not need to be sorted, it may be better to use\nthe C++ STL unordered set (or Java HashSet) as it is a Hash Table that supports faster\nO(1) dynamic insertions and deletions.\nExercise 2.3.3.3*: For Subtask 1, we can run inorder traversal in O(n) and see if the values\nare sorted. Solutions to other subtasks are not shown.\nExercise 2.4.1.1: The graph is undirected.\nExercise 2.4.1.2*: Subtask 1: to count the number of vertices of a graph: AM/AL !\nreport the number of rows; EL ! count the number of distinct vertices in all edges. To\ncount the number of edges of a graph: AM ! sum the number of non-zero entries in every\nrow; AL ! sum the length of all the lists; EL ! simply report the number of rows. We can\nalso store and maintain the values of V and E as two more additional variables instead of\ncomputing them every time. Solutions to other subtasks are not shown.\nExercise 2.4.2.1: We can call unionSet(i, 0) 8i 2 [1..N-1]. This way, we make vertex 0\nto be the root with rank[0] = 1 and all other vertices are directly under vertex 0. This is\nthe shortest possible single tree (a star graph) in an UFDS of N > 1 elements.\nExercise 2.4.2.2: We need to group N vertices into N\n2 trees of height (rank) 1, then we\ngroup them into N\n4 trees of height (rank) 2, and so on until we have just 1 tree of height\nlog2(N). The di\ufb03culty of creating a very tall tree in UFDS data structure when the \u2018union\nby rank\u2019 heuristic is used show the importance of this heuristic.\nExercise 2.4.2.3: Without the \u2018union by rank\u2019 heuristic, the resulting tree can be as tall\nas N-1. However, we can \u2018\ufb02atten\u2019 the tree to a \u2018star graph\u2019 like in Exercise 2.4.2.1 again\nby calling find(i) 8i 2 [0..N-1] to compress the paths from all is directly to the root.\nExercise 2.4.2.4: We can use dummy value like -1 to do this, i.e., we test if p[i] == -1\nto identify whether item i is the representative item of the set.\nExercise 2.4.3.1: See the solution inside ch2/ourown/fenwicktree ds.cpp.\nExercise 2.4.4.1: RSQ(1, 7) = 167 and RSQ(3, 8) = 139.\n126\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.6\nChapter Notes\nThe basic data structures mentioned in Section 2.2-2.3 can be found in almost every data\nstructure and algorithm textbook.", "mimetype": "text/plain", "start_char_idx": 393844, "end_char_idx": 397144, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2fe778c2-016e-4e95-b2f8-b910574f4ff1": {"__data__": {"id_": "2fe778c2-016e-4e95-b2f8-b910574f4ff1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d2cd5c0d-e1fd-464a-b5fd-658275486540", "node_type": "1", "metadata": {}, "hash": "c8cba6efc1851b70588330b03545487fa69bba149f64d04545ad8e1a3171d154", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7984f61f-4dad-4704-988f-83feeed85ad9", "node_type": "1", "metadata": {}, "hash": "a3774aee52b0f5b34460af52e862ab7dfc5f7b0b2002bf88077763405efc5680", "class_name": "RelatedNodeInfo"}}, "text": "Exercise 2.4.2.4: We can use dummy value like -1 to do this, i.e., we test if p[i] == -1\nto identify whether item i is the representative item of the set.\nExercise 2.4.3.1: See the solution inside ch2/ourown/fenwicktree ds.cpp.\nExercise 2.4.4.1: RSQ(1, 7) = 167 and RSQ(3, 8) = 139.\n126\n\nCHAPTER 2. DATA STRUCTURES AND LIBRARIES\nc\u20ddSteven, Felix, Suhendry\n2.6\nChapter Notes\nThe basic data structures mentioned in Section 2.2-2.3 can be found in almost every data\nstructure and algorithm textbook. References to the C++/Java/Python/OCaml built-in li-\nbraries are available online at: http://en.cppreference.com/w/, https://docs.oracle.\ncom/en/java/javase/11/docs/api/index.html, https://docs.python.org/3/library/,\nand http://caml.inria.fr/pub/docs/manual-ocaml/. Note that although access to these\nreference websites are usually provided in programming contests, we suggest that you try to\nmaster the syntax of the most common library operations to minimize coding time!\nOne exception is the lightweight set of Boolean (a.k.a. bitmask). This unusual technique\nis not commonly taught in data structure and algorithm classes, but it is important for com-\npetitive programmers as it allows for signi\ufb01cant speedups if applied to certain problems. This\ndata structure appears in various places throughout this book, e.g., in some iterative brute\nforce and optimized backtracking (Section 3.2.2 and Book 2), DP TSP (Section 3.5.2), DP\nwith bitmask (Book 2). They use bitmasks instead of vector<boolean> or bitset<size>\ndue to its e\ufb03ciency. Interested readers are encouraged to read the book \u201cHacker\u2019s Delight\u201d\n[59] that discusses bit manipulation in further detail.\nExtra references for the data structures mentioned in Section 2.4 are as follows. For\nGraphs, see [51] and Chapters 22-26 of [5]. For Union-Find Disjoint Sets, see Chapter 21 of\n[5]. For the Fenwick Tree, see [27]. For Segment Trees and other geometric data structures,\nsee [7]. We remark that all our implementations of data structures discussed in Section 2.4\navoid the usage of pointers. We use either arrays or vectors.\nWith more experience and by reading the source code we have provided, you can master\nmore techniques in the application of these data structures. Please explore the source code\nprovided at https://github.com/stevenhalim/cpbook-code.\nThere are few more data structures (related techniques) discussed in this book\u2014string-\nspeci\ufb01c data structures (Trie/Su\ufb03x Trie/Tree/Array), Sliding Window, Sparse Ta-\nble, and Square Root/Heavy-Light Decompositions. Yet, there are still many other\ndata structures that we cannot cover in this book. If you want to do better in programming\ncontests, please research data structure techniques beyond what we have presented in this\nbook. For example, Red Black Trees, Splay Trees, or Treaps are useful for certain\nproblems that require you to implement and augment (add more data to) balanced BSTs\n(see Book 2). Interval Trees (which are similar to Segment Trees) and Quad Trees (for\npartitioning 2D space) are useful to know as their underlying concepts may help you to solve\ncertain contest problems.\nNotice that many of the e\ufb03cient data structures discussed in this book exhibit the \u2018Divide\nand Conquer\u2019 strategy (discussed in Section 3.3).\nStatistics of CP Editions\n1st\n2nd\n3rd\n4th\nNumber of Pages\n12\n18\n35\n75 (+114%)\nWritten Exercises\n5\n12\n41\n17+38*=55 (+34%)\nProgramming Exercises\n43\n124\n132\n410 (+211%)\nThe breakdown of the number of programming exercises from each section is shown below:\nSection\nTitle\nAppearance\n% in Chapter\n% in Book\n2.2\nLinear DS\n230\n\u21e156%\n\u21e16.7%\n2.3\nNon-Linear DS\n133\n\u21e132%\n\u21e13.9%\n2.4\nOur-own Libraries\n47\n\u21e111%\n\u21e11.4%\nTotal\n410\n\u21e111.9%\n127\n\n2.6.", "mimetype": "text/plain", "start_char_idx": 396649, "end_char_idx": 400331, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7984f61f-4dad-4704-988f-83feeed85ad9": {"__data__": {"id_": "7984f61f-4dad-4704-988f-83feeed85ad9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2fe778c2-016e-4e95-b2f8-b910574f4ff1", "node_type": "1", "metadata": {}, "hash": "fe0ce370382357637ce02353f32ba8e17771e5eb9dbdaf6d5b19bcc465c1ca15", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5cd45d32-1e0f-4f69-8824-260fff5f6ee8", "node_type": "1", "metadata": {}, "hash": "80753be47bcf89169edc31290033164cc73c08b27c4f9d99d14d275252c90c19", "class_name": "RelatedNodeInfo"}}, "text": "Statistics of CP Editions\n1st\n2nd\n3rd\n4th\nNumber of Pages\n12\n18\n35\n75 (+114%)\nWritten Exercises\n5\n12\n41\n17+38*=55 (+34%)\nProgramming Exercises\n43\n124\n132\n410 (+211%)\nThe breakdown of the number of programming exercises from each section is shown below:\nSection\nTitle\nAppearance\n% in Chapter\n% in Book\n2.2\nLinear DS\n230\n\u21e156%\n\u21e16.7%\n2.3\nNon-Linear DS\n133\n\u21e132%\n\u21e13.9%\n2.4\nOur-own Libraries\n47\n\u21e111%\n\u21e11.4%\nTotal\n410\n\u21e111.9%\n127\n\n2.6.\nCHAPTER NOTES\nc\u20ddSteven, Felix, Suhendry\nThis page is intentionally left blank to keep the number of pages per chapter even.\n128\n\nChapter 3\nProblem Solving Paradigms\nIf all you have is a hammer, everything looks like a nail\n\u2014 Abraham Maslow, 1962\n3.1\nOverview and Motivation\nIn this chapter, we discuss four problem solving paradigms commonly used to attack prob-\nlems in programming contests, namely Complete Search (a.k.a. Brute Force), Divide and\nConquer, the Greedy approach, and Dynamic Programming. All competitive programmers,\nincluding IOI and ICPC contestants, need to master these problem solving paradigms (and\nmore) in order to be able to attack a given problem with the appropriate \u2018tool\u2019. Hammering\nevery problem with Brute Force solutions will not enable anyone to perform well in contests.\nTo illustrate, we discuss four simple tasks below involving an array A containing n \uf8ff200K\npositive integers \uf8ff1M (e.g., A = {10, 7, 3, 5, 8, 2, 9}, n = 7) to give an overview of what\nhappens if we attempt every problem with Brute Force as our sole paradigm.\n1. Find the largest and the smallest element of A. (10 and 2 for the given example).\n2. Find the kth smallest element in A. (if k = 2, the answer is 3 for the given example).\n3. Find the largest gap g such that x, y 2 A and g = |x \u2212y|. (8 for the given example).\n4. Find the longest increasing subsequence of A. ({3, 5, 8, 9} for the given example).\nThe answer for the \ufb01rst task is simple: try each element of A and check if it is the current\nlargest (or smallest) element seen so far. This is an O(n) Complete Search solution.\nThe second task is a little harder. We can use the solution above to \ufb01nd the smallest\nvalue and replace it with a large value (e.g., 1M) to \u2018delete\u2019 it. We can then proceed to \ufb01nd\nthe smallest value again (the second smallest value in the original array) and replace it with\n1M. Repeating this process k times, we will \ufb01nd the kth smallest value. This works, but if\nk = n\n2 (the median), this Complete Search solution runs in O( n\n2 \u21e5n) = O(n2). Instead, we\ncan sort the array A in O(n log n), returning the answer simply as A[k-1]. However, there\nexists an expected O(n) solution (for a small number of queries) shown in Section 2.3.4. The\nO(n log n) and O(n) solutions above are Divide and Conquer (D&C) solutions.\nFor the third task, we can similarly consider all possible two integers x and y in A, checking\nif the gap between them is the largest for each pair. This Complete Search approach runs\nin O(n2). It works, but is slow and ine\ufb03cient. We can prove that g can be obtained by\n\ufb01nding the di\u21b5erence between the smallest and largest elements of A. These two integers can\nbe found with the solution of the \ufb01rst task in O(n). No other combination of two integers\nin A can produce a larger gap. This is a Greedy solution.\nFor the fourth task, trying all O(2n) possible subsequences to \ufb01nd the longest increasing\none is not feasible as n \uf8ff200K.", "mimetype": "text/plain", "start_char_idx": 399906, "end_char_idx": 403270, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5cd45d32-1e0f-4f69-8824-260fff5f6ee8": {"__data__": {"id_": "5cd45d32-1e0f-4f69-8824-260fff5f6ee8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7984f61f-4dad-4704-988f-83feeed85ad9", "node_type": "1", "metadata": {}, "hash": "a3774aee52b0f5b34460af52e862ab7dfc5f7b0b2002bf88077763405efc5680", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bd315507-f7d0-49e4-b4d5-45328d276e85", "node_type": "1", "metadata": {}, "hash": "2b0981a5aae5d11c3db4f53927eb5684f91db8f6757e3c701e4837be814e0502", "class_name": "RelatedNodeInfo"}}, "text": "The\nO(n log n) and O(n) solutions above are Divide and Conquer (D&C) solutions.\nFor the third task, we can similarly consider all possible two integers x and y in A, checking\nif the gap between them is the largest for each pair. This Complete Search approach runs\nin O(n2). It works, but is slow and ine\ufb03cient. We can prove that g can be obtained by\n\ufb01nding the di\u21b5erence between the smallest and largest elements of A. These two integers can\nbe found with the solution of the \ufb01rst task in O(n). No other combination of two integers\nin A can produce a larger gap. This is a Greedy solution.\nFor the fourth task, trying all O(2n) possible subsequences to \ufb01nd the longest increasing\none is not feasible as n \uf8ff200K. In Section 3.5.2, we discuss an O(n2) Dynamic Program-\nming solution and also the faster O(n log k) Greedy+D&C solution for this task.\n129\n\n3.2.\nCOMPLETE SEARCH\nc\u20ddSteven, Felix, Suhendry\n3.2\nComplete Search\nThe Complete Search technique, also known as brute force or (recursive) backtracking, is\na method for solving a problem by traversing the entire (or part of the) search space to\nobtain the required solution. During the search, we are allowed to prune (that is, choose\nnot to explore) parts of the search space if we have determined that these parts have no\npossibility of containing the required solution. This way, Complete Search must return the\nbest/optimal answer (if it exists) upon termination.\nIn programming contests, a contestant should develop a Complete Search solution when\nthere is clearly no other algorithm available (e.g., the task of enumerating all permutations\nof {0, 1, 2, . . . , N-1} clearly requires \u2326(N!), i.e., at least N! operations) or when better al-\ngorithms exist, but are overkill as the input size happens to be small (e.g., the problem of\nanswering Range Minimum Queries as in Section 2.4.4 but on static arrays with N \uf8ff100 is\nsolvable with an O(N) loop for each query).\nIn ICPC, Complete Search should be the \ufb01rst solution considered as it is usually easy to\ncome up with such a solution and to code/debug it. Remember the \u2018KISS\u2019 principle: Keep It\nShort and Simple. A bug-free Complete Search solution should never receive a Wrong Answer\n(WA) response in programming contests as it explores the entire search space that may\ncontain the answer. However, many programming problems do have better-than-Complete-\nSearch1 solutions as illustrated in Section 3.1. Thus a Complete Search solution may receive\na Time Limit Exceeded (TLE) verdict. With proper analysis, you can determine the likely\noutcome (TLE versus AC) before attempting to code anything (Table 1.4 in Section 1.3.3\nis a good starting point). If a Complete Search is easy to implement and likely to pass the\ntime limit, then go ahead and implement one. This will then give you more (contest) time\nto work on harder problems in which Complete Search will be too slow.\nIn IOI, you will usually need better problem solving techniques as Complete Search\nsolutions are usually only rewarded with very small fraction of the total score in the subtask\nscoring scheme. Nevertheless, Complete Search should be used when you cannot come up\nwith a better solution\u2014it will at least enable you to score some marks.\nSometimes, running Complete Search on small instances of a challenging problem can\nhelp us to understand its structure through patterns in the output (it is possible to visualize\nthe pattern for some problems) that can be exploited to design a faster algorithm. Some\ncombinatorics problems in Book 2 can be solved this way.\nThen, the Complete Search\nsolution can also act as a veri\ufb01er for small instances, providing an additional check for the\nfaster but non-trivial algorithm that you develop.\nAfter reading this section, you may have the impression that Complete Search only works\nfor \u2018easy problems\u2019 and it is usually not the intended solution for \u2018harder problems\u2019. This is\nnot entirely true. There exist hard problems that are only solvable with creative Complete\nSearch algorithms. Some of them are (the smaller instances of) NP-hard/complete problems.\nWe will discuss those problems later in Book 2.\nIn the next two subsections, we give several (easier) examples of this simple yet possibly\nchallenging paradigm.", "mimetype": "text/plain", "start_char_idx": 402559, "end_char_idx": 406795, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bd315507-f7d0-49e4-b4d5-45328d276e85": {"__data__": {"id_": "bd315507-f7d0-49e4-b4d5-45328d276e85", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5cd45d32-1e0f-4f69-8824-260fff5f6ee8", "node_type": "1", "metadata": {}, "hash": "80753be47bcf89169edc31290033164cc73c08b27c4f9d99d14d275252c90c19", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bc9679ce-bece-4931-bc92-1d48aa2e3ff3", "node_type": "1", "metadata": {}, "hash": "838df1ba65b5472f1889fd374a193ab9692f2ef834331ade23e0486c4f4111be", "class_name": "RelatedNodeInfo"}}, "text": "Some\ncombinatorics problems in Book 2 can be solved this way.\nThen, the Complete Search\nsolution can also act as a veri\ufb01er for small instances, providing an additional check for the\nfaster but non-trivial algorithm that you develop.\nAfter reading this section, you may have the impression that Complete Search only works\nfor \u2018easy problems\u2019 and it is usually not the intended solution for \u2018harder problems\u2019. This is\nnot entirely true. There exist hard problems that are only solvable with creative Complete\nSearch algorithms. Some of them are (the smaller instances of) NP-hard/complete problems.\nWe will discuss those problems later in Book 2.\nIn the next two subsections, we give several (easier) examples of this simple yet possibly\nchallenging paradigm. In Section 3.2.1, we give examples that are implemented iteratively.\nIn Section 3.2.2, we give examples of solutions that are implemented recursively (with back-\ntracking). Finally, in Section 3.2.3, we provide a few tips to give your solution, especially\nyour Complete Search solution, a better chance to pass the required Time Limit.\n1Rest assured that (a good) problem author will write a (heavily optimized) Complete Search solution\n(in a fast programming language like C++) and then set a large enough test case to ensure that such a\nComplete Search solution still gets the TLE verdict.\n130\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\n3.2.1\nIterative Complete Search\nIterative Complete Search (Two Nested Loops): UVa 00725 - Division\nAbridged problem statement: Find and display all pairs of 5-digit numbers that collectively\nuse the digits 0 through 9 once each, such that the \ufb01rst number divided by the second is\nequal to an integer N, where 2 \uf8ffN \uf8ff79. That is, abcde/fghij = N, where each letter\nrepresents a di\u21b5erent digit. The \ufb01rst digit of one of the numbers is allowed to be zero, e.g.,\nfor N = 62, we have 79546/01283 = 62; 94736/01528 = 62.\nQuick analysis shows that fghij can only range from 01234 to 98765 which is at most\n\u21e1100K possibilities. An even better bound for fghij is the range 01234 to 98765/N, which\nhas at most \u21e150K possibilities for N = 2 and becomes smaller with increasing N.\nFor each possible answer fghij2, we can get abcde from fghij\u21e5N and then check if\nall 10 digits are di\u21b5erent. This is a doubly-nested loop with a time complexity of at most\n\u21e150K \u21e510 = 500K operations per test case. This is small. Thus, an iterative Complete\nSearch is feasible. The main part of the code is shown below (we use a fancy bit manipulation\ntechnique shown in Section 2.2 to determine digit uniqueness):\nfor (int fghij = 1234; fghij <= 98765/N; ++fghij) {\nint abcde = fghij*N;\n// as discussed above\nint tmp, used = (fghij < 10000);\n// flag if f = 0\ntmp = abcde; while (tmp) { used |= 1<<(tmp%10); tmp /= 10; }\ntmp = fghij; while (tmp) { used |= 1<<(tmp%10); tmp /= 10; }\nif (used == (1<<10)-1)\n// all 10 digits are used\nprintf(\"%05d / %05d = %d\\n\", abcde, fghij, N);\n}\nSource code: ch3/cs/UVa00725.cpp|java|py|ml\nNote that another algorithm that permutes 10 digits abcdefghij and tests if the \ufb01rst \ufb01ve\ndigits abcde divided by the last \ufb01ve digites fghij equals to N will still get Accepted for this\nUVa 00725 as 10! \u21e13 million, just fractionally slower than the algorithm above.\nIterative Complete Search (Many Nested Loops): UVa 00441 - Lotto\nIn programming contests, problems that are solvable with a single loop are usually considered\neasy. Problems which require doubly-nested iterations like UVa 00725 - Division above are\nmore challenging but they are not necessarily considered di\ufb03cult.", "mimetype": "text/plain", "start_char_idx": 406038, "end_char_idx": 409625, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bc9679ce-bece-4931-bc92-1d48aa2e3ff3": {"__data__": {"id_": "bc9679ce-bece-4931-bc92-1d48aa2e3ff3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bd315507-f7d0-49e4-b4d5-45328d276e85", "node_type": "1", "metadata": {}, "hash": "2b0981a5aae5d11c3db4f53927eb5684f91db8f6757e3c701e4837be814e0502", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "02bbd247-cc7a-4e94-934d-8de0d27d31d1", "node_type": "1", "metadata": {}, "hash": "11a7f1d68623471d8a56e24b72b0083517d44824f12bee0c5611dd1ccb50000b", "class_name": "RelatedNodeInfo"}}, "text": "\u21e13 million, just fractionally slower than the algorithm above.\nIterative Complete Search (Many Nested Loops): UVa 00441 - Lotto\nIn programming contests, problems that are solvable with a single loop are usually considered\neasy. Problems which require doubly-nested iterations like UVa 00725 - Division above are\nmore challenging but they are not necessarily considered di\ufb03cult. Competitive programmers\nmust be comfortable writing code with more than two nested loops.\nLet\u2019s take a look at UVa 00441 - Lotto which can be summarized as follows: Given\n6 < k < 13 integers (which are already sorted), enumerate all possible subsets of size 6 of\nthese integers in sorted order.\nSince the size of the required subset is always 6 and the output has to be sorted lexico-\ngraphically, an easy solution is to use six nested loops. Even in the largest3 test case when\nk = 12, these six nested loops will only produce 12C6 = 924 lines of output. This is small.\nSource code: ch3/cs/UVa00441.cpp|java|py|ml\n2Notice that it is better to iterate through fghij and not through abcde in order to avoid the division\noperator so that we only work with precise integers. If we iterate through abcde instead, we may encounter\na non-integer result when we compute fghij = abcde/N.\n3Notice that problem authors like to exaggerate problem limit a bit by saying k < 13 instead of k \uf8ff12.\n131\n\n3.2.\nCOMPLETE SEARCH\nc\u20ddSteven, Felix, Suhendry\nfor (int i = 0; i < k; ++i) scanf(\"%d\", &S[i]);\n// input: k sorted ints\nfor (int a = 0\n; a < k-5; ++a)\n// six nested loops!\nfor (int b = a+1; b < k-4; ++b)\nfor (int c = b+1; c < k-3; ++c)\nfor (int d = c+1; d < k-2; ++d)\nfor (int e = d+1; e < k-1; ++e)\nfor (int f = e+1; f < k\n; ++f)\nprintf(\"%d %d %d %d %d %d\\n\",S[a],S[b],S[c],S[d],S[e],S[f]);\nIterative Complete Search (Loops+Pruning): UVa 11565 - Simple Equations\nAbridged problem statement: Given three integers A, B, and C (1 \uf8ffA, B, C \uf8ff10 000),\n\ufb01nd three other distinct integers x, y, and z such that x + y + z = A, x \u21e5y \u21e5z = B, and\nx2+y2+z2 = C. The third equation x2+y2+z2 = C is a good starting point. Assuming that\nC has the largest value of 10 000 and y and z are one and two (x, y, z have to be distinct),\nthen the possible range of values for x is [\u2212100..100]. We can use the same reasoning to get\na similar range for y and z. We can then write the triply-nested iterative solution below:\nbool sol = false; int x, y, z;\nfor (x = -100; x <= 100; ++x)\n// ~201^3 ~= 8M operations\nfor (y = -100; y <= 100; ++y)\nfor (z = -100; z <= 100; ++z)\nif ((y != x) && (z != x) && (z != y) &&\n// all 3 must be different\n(x+y+z == A) && (x*y*z == B) && (x*x + y*y + z*z == C)) {\nif (!sol) printf(\"%d %d %d\\n\", x, y, z);\nsol = true;\n}\nNotice the way a short circuit AND was used to speed up the solution by enforcing a\nlightweight check on whether x, y, and z are all di\u21b5erent before we check the three formulas.\nThe code shown above already passes the required time limit for this problem, but we can do\nbetter. We can also use the second equation x\u21e5y \u21e5z = B and assume that x is the smallest\nout of the three. We derive that x \uf8ffy and x \uf8ffz and x\u21e5x\u21e5x \uf8ffx\u21e5y \u21e5z = B or x <\n3p\nB.\nThe new range of x is [\u221222 .", "mimetype": "text/plain", "start_char_idx": 409248, "end_char_idx": 412408, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "02bbd247-cc7a-4e94-934d-8de0d27d31d1": {"__data__": {"id_": "02bbd247-cc7a-4e94-934d-8de0d27d31d1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bc9679ce-bece-4931-bc92-1d48aa2e3ff3", "node_type": "1", "metadata": {}, "hash": "838df1ba65b5472f1889fd374a193ab9692f2ef834331ade23e0486c4f4111be", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "88e619bc-7cc8-4174-af95-6704c3570f8b", "node_type": "1", "metadata": {}, "hash": "cd7495381f494b10564a998bdc76402d7364611cda904b91bbcd3c7e626b5548", "class_name": "RelatedNodeInfo"}}, "text": "The code shown above already passes the required time limit for this problem, but we can do\nbetter. We can also use the second equation x\u21e5y \u21e5z = B and assume that x is the smallest\nout of the three. We derive that x \uf8ffy and x \uf8ffz and x\u21e5x\u21e5x \uf8ffx\u21e5y \u21e5z = B or x <\n3p\nB.\nThe new range of x is [\u221222 . . . 22]. We then prune the search space by using if statements\nto execute only some of the (inner) loops, or use break/continue statements to stop/skip\nloops. The code shown below is now much faster than the code shown above (there are a\nfew other optimizations required to solve UVa 11571 - Simple Equations - Extreme!!):\nbool sol = false; int x, y, z;\nfor (x = -22; (x <= 22) && !sol; ++x) if (x*x <= C)\nfor (y = -100; (y <= 100) && !sol; ++y) if ((y != x) && (x*x + y*y <= C))\nfor (z = -100; (z <= 100) && !sol; ++z)\nif ((z != x) && (z != y) &&\n(x+y+z == A) && (x*y*z == B) && (x*x + y*y + z*z == C)) {\nprintf(\"%d %d %d\\n\", x, y, z);\nsol = true;\n}\nSource code: ch3/cs/UVa11565.cpp|java|py|ml\n132\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nIterative Complete Search (Permutations): UVa 11742 - Social Constraints\nAbridged problem statement: There are 0 < n \uf8ff8 movie goers. They will sit in the front\nrow in n consecutive open seats. There are 0 \uf8ffm \uf8ff20 seating constraints among them,\nwhere each constraint speci\ufb01es two movie goers a and b that must be at most (or at least)\nc seats apart. The question: How many possible seating arrangements are there?\nThe key part to solve this problem is in realizing that we have to explore all permutations\n(seating arrangements).\nOnce we realize this fact, we can derive this simple O(n! \u21e5m)\n\u2018\ufb01ltering\u2019 solution.\nWe set counter = 0 and then try all possible n! permutations.\nWe\nincrease the counter by 1 if the current permutation satis\ufb01es all m constraints. When all n!\npermutations have been examined, we output the \ufb01nal value of counter. As the maximum\nn is 8 and maximum m is 20, the largest test case will still only require 8! \u21e520 = 806 400\noperations\u2014a perfectly viable solution.\nIf you have never written an algorithm to generate all permutations of a set of num-\nbers, you may still be unsure about how to proceed. The simple C++ solution that uses\nnext permutation4 in the algorithm library is shown below.\n#include <bits/stdc++.h>\n// next_permutation is inside C++ STL <algorithm>\n// the main routine\nint i, n = 8, p[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n// the first permutation\ndo {\n// try all n! permutations\n// test each permutation \u2018p\u2019 in O(m)\n}\nwhile (next_permutation(p, p+n));\n// complexity = O(n! * m)\nSource code: ch3/cs/UVa11742.cpp|java|py|ml\nThere is a good news for Python users: We can use itertools. Here is an example of listing\nall permutations of 7 elements.\nimport itertools\np = list(itertools.permutations(range(7)))\n# iterate through p\nprint(len(p))\n# should be 7! = 5040\nSource code: ch3/cs/itertools1.py\nIterative Complete Search (Subsets): UVa 12455 - Bars\nAbridged problem statement5: Given a list l containing 1 \uf8ffn \uf8ff20 integers, is there a\nsubset of list l that sums to another given integer X?\nWe can try all 2n possible subsets of integers, sum the selected integers for each subset in\nO(n), and see if the sum of the selected integers equals to X. The overall time complexity\nis thus O(n \u21e52n).", "mimetype": "text/plain", "start_char_idx": 412117, "end_char_idx": 415398, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "88e619bc-7cc8-4174-af95-6704c3570f8b": {"__data__": {"id_": "88e619bc-7cc8-4174-af95-6704c3570f8b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "02bbd247-cc7a-4e94-934d-8de0d27d31d1", "node_type": "1", "metadata": {}, "hash": "11a7f1d68623471d8a56e24b72b0083517d44824f12bee0c5611dd1ccb50000b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6e23ec52-328a-4fa1-a402-ebed7090d1e9", "node_type": "1", "metadata": {}, "hash": "5fce6a9f723c9f875c2c0f7258738ee790c4990868fbcffacd414b5d95074003", "class_name": "RelatedNodeInfo"}}, "text": "Here is an example of listing\nall permutations of 7 elements.\nimport itertools\np = list(itertools.permutations(range(7)))\n# iterate through p\nprint(len(p))\n# should be 7! = 5040\nSource code: ch3/cs/itertools1.py\nIterative Complete Search (Subsets): UVa 12455 - Bars\nAbridged problem statement5: Given a list l containing 1 \uf8ffn \uf8ff20 integers, is there a\nsubset of list l that sums to another given integer X?\nWe can try all 2n possible subsets of integers, sum the selected integers for each subset in\nO(n), and see if the sum of the selected integers equals to X. The overall time complexity\nis thus O(n \u21e52n). For the largest test case when n = 20, this is just 20 \u21e5220 \u21e121M. This\nis \u2018large\u2019 but still viable (for the reason described below).\nIf you have never written an algorithm to generate all subsets of a set of numbers, you\nmay still be unsure how to proceed. An easy solution is to use the binary representation of\n4We can start from the \ufb01rst (sorted) permutation,\nand then use iterated calls of C++ STL\nnext permutation to generate the next (second) permutation, and so on until we reach the n!-th (reverse\nsorted) permutation. This way, we explore all n! possible permutations of n elements. Note that this is just\none of several possible ways to generate all n! permutations of n elements.\n5This is also known as the NP-hard Subset-Sum problem, see Section 3.5.3 and Book 2.\n133\n\n3.2.\nCOMPLETE SEARCH\nc\u20ddSteven, Felix, Suhendry\nintegers from 0 to 2n \u22121 to describe all possible subsets. If you are not familiar with bit\nmanipulation techniques, see Section 2.2. The solution can be written in simple C/C++\ncode shown below (also works in Java). Since bit manipulation operations are (very) fast,\nthe required 21M operations for the largest test case is still doable in under a second.\n// the main routine, variable \u2018i\u2019 (the bitmask) has been declared earlier\nfor (i = 0; i < (1<<n); ++i) {\n// for each subset, O(2^n)\nint sum = 0;\nfor (int j = 0; j < n; ++j)\n// check membership, O(n)\nif (i & (1<<j))\n// see if bit \u2019j\u2019 is on?\nsum += l[j];\n// if yes, process \u2019j\u2019\nif (sum == X) break;\n// the answer is found\n}\nNote: The implementation above can be speed up about a factor of two6 using LSOne(S)\nmethod (more details in Book 2).\n// the main routine, variable \u2018i\u2019 (the bitmask) has been declared earlier\nfor (i = 0; i < (1<<n); ++i) {\n// for each subset, O(2^n)\nint sum = 0;\nint mask = i;\n// this is now O(k)\nwhile (mask) {\n// k is the # of on bits\nint two_pow_j = LSOne(mask);\n// least significant bit\nint j = __builtin_ctz(two_pow_j);\n// 2^j = two_pow_j, get j\nsum += l[j];\nmask -= two_pow_j;\n}\nif (sum == X) break;\n// the answer is found\n}\nSource code: ch3/cs/UVa12455.cpp|java|py|ml\nThere is a good news for Python users: We can (also) use itertools. Here is an example\nof listing all 27 \u22121 possible subsets of 7 elements minus the empty subset.\nimport itertools\nN = 7\nitems = list(range(1, N+1))\nc = [list(itertools.combinations(items, i)) for i in range(1, N+1)]\nc = list(itertools.chain(*c))\n# combine lists\nprint(len(c))\n# should be 2^7-1 = 127\nSource code: ch3/cs/itertools2.py\n6There are 2n \u21e5n bits in 2n possible bitmasks of length n bits. Half of the bits are 1s, the others are\n0s. The LSOne(S) implementation shown here only processes the 2n\u21e5n\n2\n1s, hence about 2x faster than the\nstandard implementation that iterates through all 2n \u21e5n 1s and 0s bits.\n134\n\nCHAPTER 3.", "mimetype": "text/plain", "start_char_idx": 414791, "end_char_idx": 418176, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6e23ec52-328a-4fa1-a402-ebed7090d1e9": {"__data__": {"id_": "6e23ec52-328a-4fa1-a402-ebed7090d1e9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "88e619bc-7cc8-4174-af95-6704c3570f8b", "node_type": "1", "metadata": {}, "hash": "cd7495381f494b10564a998bdc76402d7364611cda904b91bbcd3c7e626b5548", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "503ae3a8-7cf8-48e7-87e7-26f381793dc0", "node_type": "1", "metadata": {}, "hash": "1db79d0220e789d83920a7c95adcbffb5cc4edfaafb6b36af9e8e51599338beb", "class_name": "RelatedNodeInfo"}}, "text": "import itertools\nN = 7\nitems = list(range(1, N+1))\nc = [list(itertools.combinations(items, i)) for i in range(1, N+1)]\nc = list(itertools.chain(*c))\n# combine lists\nprint(len(c))\n# should be 2^7-1 = 127\nSource code: ch3/cs/itertools2.py\n6There are 2n \u21e5n bits in 2n possible bitmasks of length n bits. Half of the bits are 1s, the others are\n0s. The LSOne(S) implementation shown here only processes the 2n\u21e5n\n2\n1s, hence about 2x faster than the\nstandard implementation that iterates through all 2n \u21e5n 1s and 0s bits.\n134\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nJosephus Problem\nThe Josephus problem is a classic problem where initially there are n person numbered from\n1, 2, . . . , n, standing in a circle. Starting from person no 1, every k-1 person are skipped and\nthe k-th person is going to be executed and then removed from the circle. This count-then-\nexecute process is repeated until there is only one person left and this person will be saved\n(history said that he was the person named Josephus). For example, n = 6 and k = 3, then\nthe order of execution is: 3, 6, 4, 2, and 5, leaving person 1 as the sole survivor (draw a\nsmall circular array of size n = 6 and simulate this process).\nThere are several variations of this Josephus problem, e.g., the one that doesn\u2019t start\nfrom person no 1, the one that wants the survivor to be a speci\ufb01c person x 2 [1..n], etc that\ncannot be named one by one in this book.\nThe smaller instances of Josephus problem are solvable with (iterative) Complete Search\nby simply simulating the process with help of a cyclic array (or a circular linked list).\nHowever, some of the larger instances of Josephus problem require better solutions. We\nshow two of them below:\nThere is an elegant way to determine the position of the last surviving person for k = 2\nusing binary representation of the number n. If n = 1b1b2b3..bn then the answer is b1b2b3..bn1,\ni.e., we move the most signi\ufb01cant bit of n to the back to make it the least signi\ufb01cant bit.\nThis way, the Josephus problem with k = 2 can be solved in O(1).\nFor other cases, let F(n, k) denotes the position of the survivor for a circle of size n and\nwith k skipping rule and we number the people from 0, 1, . . . , n-1 (we will later add +1 to\nthe \ufb01nal answer to match the format of the original problem description). After the k-th\nperson is killed, the circle shrinks by one to size n-1 and the position of the survivor is now\nF(n-1, k) + k (mod n). This is captured with equation F(n, k) = (F(n-1, k) + k)%n. The\nbase case is when n = 1 where we have F(1, k) = 0. This recurrence has a time complexity\nof O(n).\nExercise 3.2.1.1: Java does not have a built-in next permutation function yet. If you are\na Java user, write your own recursive backtracking routine to generate all permutations of\nup to n objects in (any) order!\nExercise 3.2.1.2: How to use C++ next permutation function to generate list of nCk\ncombinations of k out of n objects? You cannot use recursive backtracking.\n3.2.2\nRecursive Complete Search\nSimple Backtracking: UVa 00750 - 8-Queens Chess Problem\nAbridged problem statement: In standard chess (with an 8\u21e58 board), it is possible to place\n8-Queens on the board such that no two Queens attack each other. Determine all such\npossible arrangements given the position of one of the Queens (i.e., coordinate (a, b) must\ncontain a Queen). Output the possibilities in lexicographical (sorted) order.", "mimetype": "text/plain", "start_char_idx": 417644, "end_char_idx": 421079, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "503ae3a8-7cf8-48e7-87e7-26f381793dc0": {"__data__": {"id_": "503ae3a8-7cf8-48e7-87e7-26f381793dc0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6e23ec52-328a-4fa1-a402-ebed7090d1e9", "node_type": "1", "metadata": {}, "hash": "5fce6a9f723c9f875c2c0f7258738ee790c4990868fbcffacd414b5d95074003", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c318a363-0581-48cb-a76f-fc84d1d606f8", "node_type": "1", "metadata": {}, "hash": "88ed0fa03a3625ac499601e60674076e8ae91224b88597a107a6b166df8ad323", "class_name": "RelatedNodeInfo"}}, "text": "If you are\na Java user, write your own recursive backtracking routine to generate all permutations of\nup to n objects in (any) order!\nExercise 3.2.1.2: How to use C++ next permutation function to generate list of nCk\ncombinations of k out of n objects? You cannot use recursive backtracking.\n3.2.2\nRecursive Complete Search\nSimple Backtracking: UVa 00750 - 8-Queens Chess Problem\nAbridged problem statement: In standard chess (with an 8\u21e58 board), it is possible to place\n8-Queens on the board such that no two Queens attack each other. Determine all such\npossible arrangements given the position of one of the Queens (i.e., coordinate (a, b) must\ncontain a Queen). Output the possibilities in lexicographical (sorted) order.\nNa\u00a8\u0131ve 64C8 \u21e14B Idea\nThe most na\u00a8\u0131ve solution is to enumerate all combinations of 8 di\u21b5erent cells out of the\n8 \u21e58 = 64 possible cells in a chess board and see if the 8-Queens can be placed at these\npositions without con\ufb02icts. However, there are 64C8 \u21e14B such possibilities\u2014this idea is not\neven worth trying.\n135\n\n3.2.\nCOMPLETE SEARCH\nc\u20ddSteven, Felix, Suhendry\nStill Na\u00a8\u0131ve 88 \u21e117M Idea\nA better but still na\u00a8\u0131ve solution is to realize that each Queen can only occupy one column,\nso we can put exactly one Queen in each column. There are only 88 \u21e117M possibilities\nnow, down from 4B. This is just a \u2018borderline\u2019-passing solution for this problem. If we write\na Complete Search like this (without any ad hoc optimizations), we are likely to receive the\nTime Limit Exceeded (TLE) verdict. We can still apply the few easy optimizations described\nbelow to further reduce the search space.\nFaster 8! \u21e140K Idea\nFigure 3.1: 8-Queens\nWe know that no two Queens can share the same column or the\nsame row. Using this, we can further simplify the original prob-\nlem to the problem of \ufb01nding valid permutations among 8! row\npositions. The value of row[i] describes the row position of the\nQueen in column i, e.g., row = {1, 3, 5, 7, 2, 0, 6, 4} as\nin Figure 3.1 is one of the solutions for this problem; row[0] =\n1 implies that the Queen in column 0 is placed in row 1, and so\non (the index starts from 0 in this example). Modeled this way,\nthe search space goes down from 88 \u21e117M to 8! \u21e140K. This\nsolution is already fast enough, but we can still do (much) more.\nSub 8! \u21e140K Idea\nWe also know that no two Queens can share any of the two diagonal lines. Let Queen A be\nat (i, j) and Queen B be at (k, l). They attack each other diagonally if abs(i-k) ==\nabs(j-l). This formula means that the vertical and horizontal distances between these two\nQueens are equal, i.e., Queen A and B lie on one of each other\u2019s two diagonal lines.\nA recursive backtracking solution places the Queens one by one in columns 0 to 7, ob-\nserving all the constraints above. Finally, if a candidate solution is found, check if at least\none of the Queens satis\ufb01es the input constraints, i.e., row[b] == a. This sub (i.e., lower\nthan) O(n!) solution will obtain an AC verdict.\nWe provide our implementation below. If you have never written a recursive backtracking\nsolution before, please scrutinize it and perhaps re-code it in your own coding style.\nSome reader may also appreciate the connection between recursive backtracking and\nDepth First Search (DFS) graph traversal algorithm that is discussed in Section 4.2.2.", "mimetype": "text/plain", "start_char_idx": 420355, "end_char_idx": 423662, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c318a363-0581-48cb-a76f-fc84d1d606f8": {"__data__": {"id_": "c318a363-0581-48cb-a76f-fc84d1d606f8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "503ae3a8-7cf8-48e7-87e7-26f381793dc0", "node_type": "1", "metadata": {}, "hash": "1db79d0220e789d83920a7c95adcbffb5cc4edfaafb6b36af9e8e51599338beb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "da0abace-9b8c-4942-a950-38241689c0db", "node_type": "1", "metadata": {}, "hash": "892700b9dc7aac531269a0a8aaca9e6c570a549dd04105067c82ec4258f20d70", "class_name": "RelatedNodeInfo"}}, "text": "This formula means that the vertical and horizontal distances between these two\nQueens are equal, i.e., Queen A and B lie on one of each other\u2019s two diagonal lines.\nA recursive backtracking solution places the Queens one by one in columns 0 to 7, ob-\nserving all the constraints above. Finally, if a candidate solution is found, check if at least\none of the Queens satis\ufb01es the input constraints, i.e., row[b] == a. This sub (i.e., lower\nthan) O(n!) solution will obtain an AC verdict.\nWe provide our implementation below. If you have never written a recursive backtracking\nsolution before, please scrutinize it and perhaps re-code it in your own coding style.\nSome reader may also appreciate the connection between recursive backtracking and\nDepth First Search (DFS) graph traversal algorithm that is discussed in Section 4.2.2.\n#include <bits/stdc++.h>\nusing namespace std;\nint row[8], a, b, lineCounter;\n// global variables\nbool canPlace(int r, int c) {\nfor (int prev = 0; prev < c; ++prev)\n// check previous Queens\nif ((row[prev] == r) || (abs(row[prev]-r) == abs(prev-c)))\nreturn false;\n// infeasible\nreturn true;\n}\n136\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nvoid backtrack(int c) {\nif ((c == 8) && (row[b] == a)) {\n// a candidate solution\nprintf(\"%2d\n%d\", ++lineCounter, row[0]+1);\nfor (int j = 1; j < 8; ++j) printf(\" %d\", row[j]+1);\nprintf(\"\\n\");\nreturn;\n// optional statement\n}\nfor (int r = 0; r < 8; ++r) {\n// try all possible row\nif ((c == b) && (r != a)) continue;\n// early pruning\nif (canPlace(r, c))\n// can place a Queen here?\nrow[c] = r, backtrack(c+1);\n// put here and recurse\n}\n}\nint main() {\nint TC; scanf(\"%d\", &TC);\nwhile (TC--) {\nscanf(\"%d %d\", &a, &b); --a; --b;\n// to 0-based indexing\nmemset(row, 0, sizeof row); lineCounter = 0;\nprintf(\"SOLN\nCOLUMN\\n\");\nprintf(\" #\n1 2 3 4 5 6 7 8\\n\\n\");\nbacktrack(0);\n// sub 8! operations\nif (TC) printf(\"\\n\");\n}\nreturn 0;\n}\nSource code: ch3/cs/UVa00750.cpp|java|py|ml\nMore Challenging Backtracking: UVa 11195 - Another N-Queens Problem\nAbridged problem statement: Given an n \u21e5n chessboard (3 \uf8ffn \uf8ff15) where some of the\ncells are bad (Queens cannot be placed there), how many ways can you place N-Queens in\nthe chessboard so that no two Queens attack each other? Bad cells cannot be used to block\nQueens\u2019 attack.\nThe recursive backtracking code that we have presented above is not fast enough for\nn = 15 and no bad cells, the worst possible test case for this problem.\nThe sub O(n!)\nsolution presented earlier is still OK for n = 8 but not for n = 15. We have to do better.\nThe major issue with the previous N-Queens code is that it is quite slow when checking\nwhether the position of a new Queen is valid as we compare the new Queen\u2019s position with\nthe previous c-1 Queens\u2019 positions (see function bool canPlace(int r, int c)).\nIt is\nbetter to store the same information with three Boolean arrays (we use bitsets):\nbitset<30> rw, ld, rd;\n// for the largest n = 14, we have 27 diagonals\nInitially all n rows (rw), 2 \u21e5n \u22121 left diagonals (ld), and 2 \u21e5n \u22121 right diagonals (rd)\nare unused (these three bitsets are set to false). When a Queen is placed at cell (r, c),\nwe \ufb02ag rw[r] = true to disallow this row from being used again. Moreover, all (a, b)\nwhere abs(r-a) = abs(c-b) also cannot be used anymore. There are two possibilities after\nremoving the abs function: r-c = a-b and r+c = a+b. Note that r+c and r-c represent\nindices for the two diagonal axes.", "mimetype": "text/plain", "start_char_idx": 422833, "end_char_idx": 426273, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da0abace-9b8c-4942-a950-38241689c0db": {"__data__": {"id_": "da0abace-9b8c-4942-a950-38241689c0db", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c318a363-0581-48cb-a76f-fc84d1d606f8", "node_type": "1", "metadata": {}, "hash": "88ed0fa03a3625ac499601e60674076e8ae91224b88597a107a6b166df8ad323", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9f229035-8f40-4b06-9eca-a730b0f59151", "node_type": "1", "metadata": {}, "hash": "2e4225f61bf753ef6a7a8d92d47f8424b55d01a066b1a36b532418bae8c6d85a", "class_name": "RelatedNodeInfo"}}, "text": "It is\nbetter to store the same information with three Boolean arrays (we use bitsets):\nbitset<30> rw, ld, rd;\n// for the largest n = 14, we have 27 diagonals\nInitially all n rows (rw), 2 \u21e5n \u22121 left diagonals (ld), and 2 \u21e5n \u22121 right diagonals (rd)\nare unused (these three bitsets are set to false). When a Queen is placed at cell (r, c),\nwe \ufb02ag rw[r] = true to disallow this row from being used again. Moreover, all (a, b)\nwhere abs(r-a) = abs(c-b) also cannot be used anymore. There are two possibilities after\nremoving the abs function: r-c = a-b and r+c = a+b. Note that r+c and r-c represent\nindices for the two diagonal axes. As r-c can be negative, we add an o\u21b5set of n-1 to both\n137\n\n3.2.\nCOMPLETE SEARCH\nc\u20ddSteven, Felix, Suhendry\nsides of the equation so that r-c+n-1 = a-b+n-1. If a Queen is placed on cell (r, c), we\n\ufb02ag ld[r-c+n-1] = true and rd[r+c] = true to disallow these two diagonals from being\nused again. Now, with these extra data structures and the extra problem-speci\ufb01c constraint\nin UVa 11195 (board[r][c] cannot be a bad cell), we can extend our code to become:\nvoid backtrack(int c) {\nif (c == n) { ++ans; return; }\n// a solution\nfor (int r = 0; r < n; ++r)\n// try all possible row\nif ((board[r][c] != \u2019*\u2019) && !rw[r] && !ld[r-c+n-1] && !rd[r+c]) {\nrw[r] = ld[r-c+n-1] = rd[r+c] = true;\n// flag off\nbacktrack(c+1);\nrw[r] = ld[r-c+n-1] = rd[r+c] = false;\n// restore\n}\n}\nWe have added a tool for learning recursion in VisuAlgo. To explore the recursion tree\nof (many simpler) recursive backtracking routines, you can use VisuAlgo, Recursion visu-\nalization, that shows a visualization of the recursion tree of limited recursive backtracking\non small instances only. You can write a valid recursive function f(params) in JavaScript,\nspecify your own initial values of params, and execute it to view the recursion tree (VisuAlgo\nwill prevent its user from creating a gigantic recursion tree to avoid freezing the user\u2019s web\nbrowser). Figure 3.2 shows the recursion tree of TSP (see Section 3.5.2) with n = 5 cities\nthat tries all 4! = 24 permutations of 4 cities that starts from city 0. Note that there are 24\nleaves with several overlapping subproblems that can be speed up with DP.\nFigure 3.2: Recursion Tree of TSP with n = 5, also see Figure 4.42\nVisualization: https://visualgo.net/en/recursion\nExercise 3.2.2.1*: Unfortunately, the updated solution presented using bitsets: rw, ld,\nand rd will still obtain a TLE for UVa 11195 - Another N-Queens Problem. We need to\nfurther speed up the solution using bitmask techniques and another way of using the left\nand right diagonal constraints. This solution will be discussed in Book 2. For now, use the\nidea presented here to speed up the code for UVa 00750+00167+11085!\nExercise 3.2.2.2*: What if we are asked to print out just one (any) valid N-queens solution\ngiven N? What if 3 \uf8ffN \uf8ff15? What if 3 \uf8ffN \uf8ff1000? What if 3 \uf8ffN \uf8ff100 000?\n138\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\n3.2.3\nComplete Search Tips\nThe biggest gamble in writing a Complete Search solution is whether it will or will not be\nable to pass the time limit.", "mimetype": "text/plain", "start_char_idx": 425644, "end_char_idx": 428761, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9f229035-8f40-4b06-9eca-a730b0f59151": {"__data__": {"id_": "9f229035-8f40-4b06-9eca-a730b0f59151", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "da0abace-9b8c-4942-a950-38241689c0db", "node_type": "1", "metadata": {}, "hash": "892700b9dc7aac531269a0a8aaca9e6c570a549dd04105067c82ec4258f20d70", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "da83e738-5c56-4ad6-af6f-3f789fb909b0", "node_type": "1", "metadata": {}, "hash": "b50be45b9ce9e78969225b3ad5a75b60725d89a318f72c4d746cdd5612392d8c", "class_name": "RelatedNodeInfo"}}, "text": "This solution will be discussed in Book 2. For now, use the\nidea presented here to speed up the code for UVa 00750+00167+11085!\nExercise 3.2.2.2*: What if we are asked to print out just one (any) valid N-queens solution\ngiven N? What if 3 \uf8ffN \uf8ff15? What if 3 \uf8ffN \uf8ff1000? What if 3 \uf8ffN \uf8ff100 000?\n138\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\n3.2.3\nComplete Search Tips\nThe biggest gamble in writing a Complete Search solution is whether it will or will not be\nable to pass the time limit. If the time limit is 10 seconds (online judges do not usually\nuse large time limits for e\ufb03cient judging) and your program currently runs in \u21e110 seconds\non several (can be more than one) test cases with the largest input size as speci\ufb01ed in the\nproblem description, yet your code is still judged to be TLE, you may want to tweak the\n\u2018critical code\u20197 in your program instead of re-solving the problem with a faster algorithm\nwhich may not be easy to design or may be non-existent.\nHere are some tips that you may want to consider when designing your Complete Search\nsolution for a certain problem to give it a higher chance of passing the Time Limit. Writing\na good Complete Search solution is an art in itself.\nTip 1: Filtering versus Generating\nPrograms that examine lots of (if not all) candidate solutions and choose the ones that are\ncorrect (or remove the incorrect ones) are called \u2018\ufb01lters\u2019, e.g., the na\u00a8\u0131ve 8-Queens solver with\ntime complexity of 64C8 or 88, the iterative solution for UVa 00725 and UVa 11742, etc.\nUsually \u2018\ufb01lter\u2019 programs are written iteratively.\nPrograms that gradually build the solutions and immediately prune invalid partial solu-\ntions are called \u2018generators\u2019, e.g., the improved recursive 8-Queens solver with its sub O(n!)\ncomplexity plus diagonal checks. Usually, \u2018generator\u2019 programs are easier to implement when\nwritten recursively as it gives us greater \ufb02exibility for pruning the search space.\nGenerally, \ufb01lters are easier to code but run slower, given that it is usually far more\ndi\ufb03cult to prune more of the search space iteratively. Do the math (complexity analysis) to\nsee if a \ufb01lter is good enough or if you need to create a generator.\nTip 2: Prune Infeasible/Inferior Search Space Early\nWhen generating solutions using recursive backtracking (see tip above), we may encounter\na partial solution that will never lead to a full solution. We can prune the search there\nand explore other parts of the search space. Example: The diagonal check in the 8-Queens\nsolution above. Suppose we have placed a Queen at row[0] = 2. Placing the next Queen at\nrow[1] = 1 or 3 will cause a diagonal con\ufb02ict and placing the next Queen at row[1] = 2\nwill cause a row con\ufb02ict. Continuing from any of these infeasible partial solutions will never\nlead to a valid solution. Thus we can prune these partial solutions here and concentrate on\nthe other valid positions: row[1] = {0, 4, 5, 6, 7}, thus reducing the overall runtime.\nAs a rule of thumb, the earlier you can prune the search space, the better.\nIn other problems, we may be able to compute the \u2018potential worth\u2019 of a partial (and\nstill valid) solution. If the potential worth is inferior to the worth of the current best found\nvalid solution so far, we can prune the search there.\nTip 3: Utilize Symmetries\nSome problems have symmetries and we should try to exploit symmetries to reduce execu-\ntion time! In the 8-Queens problem, there are 92 solutions but there are only 12 unique (or\nfundamental/canonical) solutions as there are rotational and line symmetries in the prob-\nlem. You can utilize this fact by only generating the 12 unique solutions and, if needed,\ngenerate the whole 92 by rotating and re\ufb02ecting these 12 unique solutions.", "mimetype": "text/plain", "start_char_idx": 428257, "end_char_idx": 431982, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da83e738-5c56-4ad6-af6f-3f789fb909b0": {"__data__": {"id_": "da83e738-5c56-4ad6-af6f-3f789fb909b0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9f229035-8f40-4b06-9eca-a730b0f59151", "node_type": "1", "metadata": {}, "hash": "2e4225f61bf753ef6a7a8d92d47f8424b55d01a066b1a36b532418bae8c6d85a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "54bed8ff-4170-458d-945a-ae93ba18f467", "node_type": "1", "metadata": {}, "hash": "07d01f72d1fb8e65e1294052381e1b7d69d44a33d3a78d33a423e61db8125fb2", "class_name": "RelatedNodeInfo"}}, "text": "As a rule of thumb, the earlier you can prune the search space, the better.\nIn other problems, we may be able to compute the \u2018potential worth\u2019 of a partial (and\nstill valid) solution. If the potential worth is inferior to the worth of the current best found\nvalid solution so far, we can prune the search there.\nTip 3: Utilize Symmetries\nSome problems have symmetries and we should try to exploit symmetries to reduce execu-\ntion time! In the 8-Queens problem, there are 92 solutions but there are only 12 unique (or\nfundamental/canonical) solutions as there are rotational and line symmetries in the prob-\nlem. You can utilize this fact by only generating the 12 unique solutions and, if needed,\ngenerate the whole 92 by rotating and re\ufb02ecting these 12 unique solutions. Example: row =\n{7-1, 7-3, 7-5, 7-7, 7-2, 7-0, 7-6, 7-4} = {6, 4, 2, 0, 5, 7, 1, 3} is the hor-\nizontal re\ufb02ection of the con\ufb01guration in Figure 3.1.\n7It is said that every program spends most of its time in only about 10% of its code\u2014the critical code.\n139\n\n3.2.\nCOMPLETE SEARCH\nc\u20ddSteven, Felix, Suhendry\nHowever, we have to remark that it is true that sometimes considering symmetries can\nactually complicate the code. In competitive programming, this is usually not the best way\n(we want shorter code to minimize bugs). If the gain obtained by dealing with symmetry is\nnot signi\ufb01cant in solving the problem, just ignore this tip.\nTip 4: Pre-Computation a.k.a. Pre-Calculation\nSometimes it is helpful to generate tables or other data structures that accelerate the lookup\nof a result prior to the execution of the program itself. This is called Pre-Computation, in\nwhich one trades memory/space for time. However, this technique can rarely be used for\nrecent programming contest problems.\nFor example, since we know that there are only 92 solutions in the standard 8-Queens\nchess problem, we can create a 2D array int solution[92][8] and then \ufb01ll it with all\n92 valid permutations of the 8-Queens row positions! That is, we can create a generator\nprogram (which takes some time to run) to \ufb01ll this 2D array solution. Afterwards, we can\nwrite another program to simply and quickly print the correct permutations within the 92\npre-calculated con\ufb01gurations that satisfy the problem constraints.\nAlthough this tip cannot be used for most Complete Search problems, you can \ufb01nd a list\nof a few programming exercises where this tip can be used at the end of this section.\nTip 5: Try Solving the Problem Backwards\nSome contest problems look far easier when they are solved \u2018backwards\u2019 [47] (from a less\nobvious angle) than when they are solved using a frontal attack (from the more obvious angle\nas described in the problem description). Be prepared to attempt unconventional approaches\nto problems.\nThis tip is best illustrated using an example: UVa 10360 - Rat Attack: Imagine a 2D\narray (up to 1025 \u21e51025) containing rats. There are n \uf8ff20 000 rats spread across the\ncells. Determine which cell (x, y) should be gas-bombed so that the number of rats killed\nin a square box (x-d, y-d) to (x+d, y+d) is maximized. The value d is the power of the\ngas-bomb (d \uf8ff50), see Figure 3.3.\nAn immediate solution is to attack this problem in the most obvious fashion possible:\nbomb each of the 10252 cells and select the most e\u21b5ective location. For each bombed cell\n(x, y), we can perform an O(d2) scan to count the number of rats killed within the square-\nbombing radius. For the worst case, when the array has size 10252 and d = 50, this takes\n10252 \u21e5502 = 2626M operations. TLE8!\nFigure 3.3: UVa 10360 [44]\nAnother option is to attack this problem backwards. We\ncreate an array int killed[1025][1025].", "mimetype": "text/plain", "start_char_idx": 431211, "end_char_idx": 434868, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "54bed8ff-4170-458d-945a-ae93ba18f467": {"__data__": {"id_": "54bed8ff-4170-458d-945a-ae93ba18f467", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "da83e738-5c56-4ad6-af6f-3f789fb909b0", "node_type": "1", "metadata": {}, "hash": "b50be45b9ce9e78969225b3ad5a75b60725d89a318f72c4d746cdd5612392d8c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "507838c2-28ce-4e8e-9be5-c1d7668559af", "node_type": "1", "metadata": {}, "hash": "f89745caa60723a60248dbf1fd51a2157d8247b62bb4ba3ded7050177d0188c2", "class_name": "RelatedNodeInfo"}}, "text": "The value d is the power of the\ngas-bomb (d \uf8ff50), see Figure 3.3.\nAn immediate solution is to attack this problem in the most obvious fashion possible:\nbomb each of the 10252 cells and select the most e\u21b5ective location. For each bombed cell\n(x, y), we can perform an O(d2) scan to count the number of rats killed within the square-\nbombing radius. For the worst case, when the array has size 10252 and d = 50, this takes\n10252 \u21e5502 = 2626M operations. TLE8!\nFigure 3.3: UVa 10360 [44]\nAnother option is to attack this problem backwards. We\ncreate an array int killed[1025][1025]. For each rat pop-\nulation at coordinate (x, y), add it to killed[i][j], where\n|i \u2212x| \uf8ffd and |j \u2212y| \uf8ffd. This is because if a bomb was\nplaced at (i, j), the rats at coordinate (x, y) will be killed.\nThis pre-processing takes O(n \u21e5d2) operations. Then, to de-\ntermine the most optimal bombing position, we can simply\n\ufb01nd the coordinate of the highest entry in array killed, which\ncan be done in 10252 operations. This approach only requires\n20 000 \u21e5502 + 10252 = 51M operations for the worst test case\n(n = 20 000, d = 50), \u21e151 times faster than the frontal attack!\nThis is an AC solution.\n8Although year 2020 CPU can compute \u21e1100M operations in \u21e11 second, 2626M operations will still\ntake too long in a contest environment.\n140\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nTip 6: Data Compression\nThe input constraint in some creative problems where the problem author\u2019s expected solution\nis Complete Search may be \u2018disguised\u2019 to look too big for a normal Complete Search solution\nto work within time limit. But upon more careful inspection, some\u2013usually subtle\u2013remarks\nin the problem description actually reduce the search space (signi\ufb01cantly) which then makes\na Complete Search solution feasible, like the following exercise in Section 1.3.3:\nGiven a multiset S of M = 100K integers, we want to know how many di\u21b5erent integers\nthat we can form if we pick two (not necessarily distinct) integers from S and sum them.\nThe content of multiset S is prime numbers not more than 20K.\nIf we directly try all possible O(M 2) pairs of integers and insert their sums into a hash\ntable (O(1) per insertion), we will get Time Limit Exceeded as M = 100K integers.\nHowever, observe that multiset S contains only prime numbers under 20K. Later in Book\n2, we will \ufb01nd out that \u21e1(20 000) = 2262, i.e., there are only 2262 distinct prime numbers\nunder 20K despite the size of multiset S can be up to M = 100K. So, we do one O(M) data\ncompression pass to ensure that each integer only has at most two copies, i.e., N \uf8ff2\u21e52262.\nAfterwards, we perform O(N 2) complete search check as before.\nTip 7: Optimizing Your Source Code\nThere are many techniques that you can use to optimize9 your code. Understanding computer\nhardware and how it is organized, especially the I/O, memory, and cache behavior, can help\nyou design better code. Some examples (not exhaustive) are shown below:\n1. A biased opinion10: Use C++ instead of Java (slower than C++) or Python (slower\nthan Java). An algorithm implemented using C++ usually runs faster than the one\nimplemented in Java or Python in many online judges, including UVa [44] and Kattis\n[34]. Some, but not all, programming contests give Java/Python users extra time to\naccount for the di\u21b5erence in performance (but this is never 100% fair).\n2. Bit manipulation on the built-in integer data types (up to the 64-bit integer) is (much)\nmore e\ufb03cient than index manipulation in an array of booleans (see bitmask in Sec-\ntion 2.2).\nIf we need more than 64 bits, use the C++ STL bitset rather than\nvector<bool> (e.g., for Sieve of Eratosthenes in Book 2).", "mimetype": "text/plain", "start_char_idx": 434289, "end_char_idx": 437954, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "507838c2-28ce-4e8e-9be5-c1d7668559af": {"__data__": {"id_": "507838c2-28ce-4e8e-9be5-c1d7668559af", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "54bed8ff-4170-458d-945a-ae93ba18f467", "node_type": "1", "metadata": {}, "hash": "07d01f72d1fb8e65e1294052381e1b7d69d44a33d3a78d33a423e61db8125fb2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "54d91d97-f3da-4ef6-93ff-0c481f4155dc", "node_type": "1", "metadata": {}, "hash": "8d9869dc9b0965cb7ca129d9a1145ef8b992687c937ee5a837a865bf6286fd82", "class_name": "RelatedNodeInfo"}}, "text": "A biased opinion10: Use C++ instead of Java (slower than C++) or Python (slower\nthan Java). An algorithm implemented using C++ usually runs faster than the one\nimplemented in Java or Python in many online judges, including UVa [44] and Kattis\n[34]. Some, but not all, programming contests give Java/Python users extra time to\naccount for the di\u21b5erence in performance (but this is never 100% fair).\n2. Bit manipulation on the built-in integer data types (up to the 64-bit integer) is (much)\nmore e\ufb03cient than index manipulation in an array of booleans (see bitmask in Sec-\ntion 2.2).\nIf we need more than 64 bits, use the C++ STL bitset rather than\nvector<bool> (e.g., for Sieve of Eratosthenes in Book 2).\n3. For C/C++ users, use the faster C-style scanf/printf rather than cin/cout (or\nat least set ios::sync with stdio(false); cin.tie(NULL); albeit still slower than\nscanf/printf).\n4. For Java users, use the faster BufferedReader/BufferedWriter classes as follows:\nBufferedReader br = new BufferedReader(\n// speedup\nnew InputStreamReader(System.in));\n// Note: String splitting and/or input parsing is needed afterwards\nPrintWriter pw = new PrintWriter(new BufferedWriter(\n// speedup\nnew OutputStreamWriter(System.out)));\n// PrintWriter allows us to use the pw.printf() function\n// do not forget to call pw.close() before exiting your Java program\n9Most techniques mentioned in this tip are not good for general Software Engineering.\n10OCaml is not widely used in programming contest as of year 2020.\n141\n\n3.2.\nCOMPLETE SEARCH\nc\u20ddSteven, Felix, Suhendry\n5. For Python users, read all input \ufb01rst upfront before processing them in-memory and\nbu\u21b5er output \ufb01rst before writing them out in one go, especially if the I/O is big.\nimport sys\ninputs = sys.stdin.read().splitlines()\n# read all first\noutputs = []\n# buffer output first\nln = 0\n# assumption:\nwhile True:\n# input has >1 lines\nN = int(inputs[ln])\n# with 1 integer each\nif N == 0: break\noutputs.append(str(N))\n# sample output\nln += 1\nsys.stdout.write(\u2019\\n\u2019.join(outputs))\n# write in one go\n6. Use the expected O(n log n) but cache-friendly quicksort in C++ STL algorithm::sort\n(part of \u2018introsort\u2019) rather than the true O(n log n) but non cache-friendly heapsort (its\nroot-to-leaf/leaf-to-root operations span a wide range of indices\u2014lots of cache misses).\n7. Access a 2D array in a row-major fashion (row by row) rather than in a column-major\nfashion as multidimensional arrays are stored in a row-major order in memory. This\nwill increase the probability of cache hit.\n8. Use lower level data structures/types at all times if you do not need the extra func-\ntionality in the higher level (or larger) ones. For example, use an array with a slightly\nlarger size than the maximum size of input instead of using resizable vectors. Also,\nuse 32-bit ints instead of 64-bit long longs as the 32-bit int is faster in most 32-bit\nonline judge systems.\n9. For Java, use the faster ArrayList (and StringBuilder) rather than Vector (and\nStringBuffer). Java Vectors and StringBuffers are thread safe but this feature is\nnot needed in competitive programming.\n10. Declare most data structures (especially the bulky ones, e.g., large arrays) once by\nplacing them in global scope. Allocate enough memory to deal with the largest input\nof the problem. This way, we do not have to pass (or worse, copy) the data struc-\ntures around as function arguments. For problems with multiple test cases, simply\nclear/reset the contents of the data structure before dealing with each test case.\n11. When you have the option to write your code either iteratively or recursively, choose the\niterative version. Example: the iterative C++ STL next permutation and iterative\nsubset generation techniques using bitmask shown in Section 3.2.1 are (far) faster than\nif you write similar routines recursively and when early pruning is not possible.\n12. Array access in (nested) loops can be slow.", "mimetype": "text/plain", "start_char_idx": 437249, "end_char_idx": 441160, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "54d91d97-f3da-4ef6-93ff-0c481f4155dc": {"__data__": {"id_": "54d91d97-f3da-4ef6-93ff-0c481f4155dc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "507838c2-28ce-4e8e-9be5-c1d7668559af", "node_type": "1", "metadata": {}, "hash": "f89745caa60723a60248dbf1fd51a2157d8247b62bb4ba3ded7050177d0188c2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "daa2b039-82c1-44bd-8498-e3a34c17ab91", "node_type": "1", "metadata": {}, "hash": "baaadad2050a313bb86ef093cda46c60eeeb4a8e651848ecf4d44328a940e5b9", "class_name": "RelatedNodeInfo"}}, "text": "10. Declare most data structures (especially the bulky ones, e.g., large arrays) once by\nplacing them in global scope. Allocate enough memory to deal with the largest input\nof the problem. This way, we do not have to pass (or worse, copy) the data struc-\ntures around as function arguments. For problems with multiple test cases, simply\nclear/reset the contents of the data structure before dealing with each test case.\n11. When you have the option to write your code either iteratively or recursively, choose the\niterative version. Example: the iterative C++ STL next permutation and iterative\nsubset generation techniques using bitmask shown in Section 3.2.1 are (far) faster than\nif you write similar routines recursively and when early pruning is not possible.\n12. Array access in (nested) loops can be slow. If you have an array A and you frequently\naccess the value of A[i] (without changing it) in (nested) loops, it may be bene\ufb01cial\nto use a local variable temp = A[i] and work with temp instead.\n13. For C++ users: Using C-style character arrays will yield faster execution than when\nusing the C++ STL string. For Java/Python/OCaml users, please be careful with\nString manipulation as Java/Python/OCaml strings are immutable. It is better to\nuse Java StringBuilder or Python list (and join the list afterwards).\n142\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nBrowse the Internet or relevant books (e.g., [59]) to \ufb01nd (much) more information on how\nto speed up your code. Practice this \u2018code hacking skill\u2019 by choosing a harder problem in\nUVa or Kattis online judge where the runtime of the best solution is not 0.000s. Submit\nseveral variants of your Accepted solution and check the runtime di\u21b5erences. Adopt hacking\nmodi\ufb01cations that consistently give you faster runtime.\nFinally, Use Better Data Structures & Algorithms :)\nNo kidding. Using better data structures and algorithms \u2013 if such solutions exist \u2013 will\nalways outperform any micro optimizations11 mentioned in Tips 1-7 above. If you initially\nthought that the problem can be solved with Complete Search and you are also sure that\nyou have written your fastest Complete Search code, but it is still judged as TLE, maybe it\nis time to abandon Complete Search and think of another \u2013 non-Complete Search \u2013 solution.\nHowever, if this happens, it is a bad news for your contest performance.\n3.2.4\nComplete Search in Programming Contests\nThe starting source of the \u2018Complete Search\u2019 material in this chapter is the USACO training\ngateway [43]. We have adopted the name \u2018Complete Search\u2019 rather than \u2018Brute-Force\u2019 (with\nits negative connotations) as we believe that some Complete Search solutions can be clever\nand fast. We feel that the term \u2018clever Brute-Force\u2019 is also a little self-contradictory.\nIf a problem is solvable by Complete Search, it will also be clear when to use the iterative\nor recursive backtracking approaches. Iterative approaches are used when one can derive the\ndi\u21b5erent states easily with some formula relative to a certain counter and (almost) all states\nhave to be checked, e.g., scanning all the indices of an array, enumerating (almost) all possible\nsubsets of a small set, generating (almost) all permutations, etc. Recursive Backtracking is\nused when it is hard to derive the di\u21b5erent states with a simple index and/or one also wants\nto (heavily) prune the search space, e.g., the N-Queens chess problem. If the search space\nof a problem that is solvable with Complete Search is large, then recursive backtracking\napproaches that allow early pruning of infeasible sections of the search space are usually\nused. Pruning in iterative Complete Searches is not impossible but usually di\ufb03cult.\nThe best way to improve your Complete Search skills is to solve more Complete Search\nproblems so that your intuition of whether a problem is solvable with Complete Search gets\nbetter. We have provided a list of such problems, separated into several categories below.\nNote that we will discuss more advanced search techniques later in Book 2, e.g., using\nbit manipulation in recursive backtracking, harder state-space search, Meet in the Middle.\nThen, we will get ourselves more familiar with some of the NP-hard/complete problems with\nno special property that likely have no faster solutions than Complete Search.", "mimetype": "text/plain", "start_char_idx": 440348, "end_char_idx": 444664, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "daa2b039-82c1-44bd-8498-e3a34c17ab91": {"__data__": {"id_": "daa2b039-82c1-44bd-8498-e3a34c17ab91", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "54d91d97-f3da-4ef6-93ff-0c481f4155dc", "node_type": "1", "metadata": {}, "hash": "8d9869dc9b0965cb7ca129d9a1145ef8b992687c937ee5a837a865bf6286fd82", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a441f272-97bb-44b0-9b41-cdcfbe1271de", "node_type": "1", "metadata": {}, "hash": "fb8cbc6b74bc75f59171bc1a838224af5e4514819d11ae7b147fd5c99ae333ef", "class_name": "RelatedNodeInfo"}}, "text": "If the search space\nof a problem that is solvable with Complete Search is large, then recursive backtracking\napproaches that allow early pruning of infeasible sections of the search space are usually\nused. Pruning in iterative Complete Searches is not impossible but usually di\ufb03cult.\nThe best way to improve your Complete Search skills is to solve more Complete Search\nproblems so that your intuition of whether a problem is solvable with Complete Search gets\nbetter. We have provided a list of such problems, separated into several categories below.\nNote that we will discuss more advanced search techniques later in Book 2, e.g., using\nbit manipulation in recursive backtracking, harder state-space search, Meet in the Middle.\nThen, we will get ourselves more familiar with some of the NP-hard/complete problems with\nno special property that likely have no faster solutions than Complete Search. Lastly, we\nwill discuss a rarely used class of search heuristic algorithms: A* Search, Depth Limited\nSearch (DLS), and Iterative Deepening Search/A* (IDS/IDA*).\nFinally, a few rule of thumbs below can be used to help identify problems that are solvable\nwith Complete Search. A problem is possibly a Complete Search problem if the problem:\n\u2022 Asks to print all answers and the solution space can be as big as the search space,\n\u2022 Has small search space (the total operations in the worst case is < 100M),\n\u2022 Has suspiciously large time limit constraint and has lots of (early) pruning potentials,\n\u2022 Can be pre-calculated,\n\u2022 Is a known NP-hard/complete problem without any special property (see Book 2).\n11Premature optimization is discouraged in Software Engineering.\n143\n\n3.2.\nCOMPLETE SEARCH\nc\u20ddSteven, Felix, Suhendry\nProgramming exercises solvable using Complete Search:\na. Pre-calculate-able\n1. Entry Level: UVa 00750 - 8 Queens Chess ... * (classic backtracking\nproblem; only 92 possible 8-queens positions)\n2. UVa 00165 - Stamps * (requires some DP too; can be pre-calculated as\nh and k are small)\n3. UVa 10128 - Queue * (backtracking with pruning; try all N! permutations\nthat satisfy the requirement; 13! will TLE; pre-calculate the results)\n4. UVa 10276 - Hanoi Tower ... * (insert a number one by one; 1 \uf8ffN \uf8ff50)\n5. Kattis - cardtrick2 * (n \uf8ff13, we can simulate the process using queue and\nprecalculate all 13 possible answers)\n6. Kattis - foolingaround * (there are only 379 di\u21b5erent values of N where Bob\nwins; pre-calculateable)\n7. Kattis - sgcoin * (we can either brute force short string message; precompute\nall possible hash values; or come up with O(1) solution)\nExtra UVa: 00167, 00256, 00347, 00861, 10177, 11085.\nExtra Kattis: 4thought, chocolates, lastfactorialdigit, luckynumber, mancala,\nprimematrix.\nb. Iterative (Two Nested Loops)\n1. Entry Level: Kattis - pet * (very simple 2D nested loops problem)\n2. UVa 00592 - Island of Logic * (key idea: there are only 35 \u21e42 possible\nstates: the status of each person and whether it is day or night)\n3. UVa 01588 - Kickdown * (LA 3712 - NorthEasternEurope06; good iter-\native brute force problem; beware of corner cases)\n4. UVa 12488 - Start Grid * (2 nested loops; simulate overtaking process)\n5. Kattis - blackfriday * (2D nested loops; frequency counting)\n6. Kattis - closestsums * (sort and then do O(n2) pairings; also available at\nUVa 10487 - Closest Sums)\n7. Kattis - golombrulers * (2D nested loops; additional 1D loops for checking)\nExtra UVa: 00105, 00617, 01260, 10041, 10570, 12583, 13018.\nExtra Kattis: 8queens, antiarithmetic, bestrelayteam, bikegears, kafkaesque,\nliga, peg, putovanje, reduction, register, summertrip, telephones, tourdefrance.\nc. Iterative (Three or More Nested Loops, Easier)\n1.", "mimetype": "text/plain", "start_char_idx": 443767, "end_char_idx": 447437, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a441f272-97bb-44b0-9b41-cdcfbe1271de": {"__data__": {"id_": "a441f272-97bb-44b0-9b41-cdcfbe1271de", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "daa2b039-82c1-44bd-8498-e3a34c17ab91", "node_type": "1", "metadata": {}, "hash": "baaadad2050a313bb86ef093cda46c60eeeb4a8e651848ecf4d44328a940e5b9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f706fc4f-014f-4c4a-a424-37d4f575b6e1", "node_type": "1", "metadata": {}, "hash": "e8585f3348f09230760e2253d844c9b5bb2aa48e76cd602e9761c0683560d9e6", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - blackfriday * (2D nested loops; frequency counting)\n6. Kattis - closestsums * (sort and then do O(n2) pairings; also available at\nUVa 10487 - Closest Sums)\n7. Kattis - golombrulers * (2D nested loops; additional 1D loops for checking)\nExtra UVa: 00105, 00617, 01260, 10041, 10570, 12583, 13018.\nExtra Kattis: 8queens, antiarithmetic, bestrelayteam, bikegears, kafkaesque,\nliga, peg, putovanje, reduction, register, summertrip, telephones, tourdefrance.\nc. Iterative (Three or More Nested Loops, Easier)\n1. Entry Level: UVa 00441 - Lotto * (6 nested loops; easy)\n2. UVa 00735 - Dart-a-Mania * (3 nested loops; then count)\n3. UVa 12515 - Movie Police * (3 nested loops)\n4. UVa 12844 - Outwitting the ... * (5 nested loops; scaled down version\nof UVa 10202; do observations \ufb01rst)\n5. Kattis - cudoviste * (4 nested loops; the inner loops is just 2x2; 5 possibilities\nof crushed cars; skip 2x2 area that contains building)\n6. Kattis - npuzzle * (4 nested loops; easy)\n7. Kattis - set * (4 nested loops; easy)\nExtra UVa: 00154, 00626, 00703, 10102, 10662, 11059, 12498, 12801.\nExtra Kattis: mathhomework, patuljci, safehouses.\n144\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nd. Iterative (Three or More Nested Loops, Harder)\n1. Entry Level: UVa 00386 - Perfect Cubes * (4 nested loops with pruning)\n2. UVa 10660 - Citizen attention ... * (7 nested loops; Manhattan distance)\n3. UVa 11236 - Grocery Store * (3 nested loops for a, b, c; derive d from\na, b, c; check if you have 949 lines of output)\n4. UVa 11804 - Argentina * (5 nested loops)\n5. Kattis - calculatingdartscores * (6 nested loops; is a*i +b*j + c*k == n)\n6. Kattis - lektira * (2 nested loops to try all 2 cutting points plus 1 more loop\nto actually do the reversing of sub words)\n7. Kattis - tautology * (try all 25 = 32 values with pruning; also available at\nUVa 11108 - Tautology)\nExtra UVa: 00253, 00296, 10360, 10365, 10483, 10502, 10973, 11342, 11548,\n11565, 11959, 11975, 12337.\nExtra Kattis: goblingardenguards, misa, medals.\ne. Iterative (Permutation)\n1. Entry Level: UVa 11742 - Social Constraints * (try all permutations)\n2. UVa 00234 - Switching Channels * (LA 5173 - WorldFinals Phoenix94;\nuse next permutation; simulation)\n3. UVa 01064 - Network * (LA 3808 - WorldFinals Tokyo07; permutation\nof up to 5 messages; simulation; mind the word \u2018consecutive\u2019)\n4. UVa 12249 - Overlapping Scenes * (LA 4994 - KualaLumpur10; try all\npermutations; a bit of string matching)\n5. Kattis - dancerecital * (try all R! permutations; compare adjacent routines)\n6. Kattis - dreamer * (try all 8! permutations of digits; check if the date is\nvalid; output earliest valid date)\n7. Kattis - veci * (try all permutations; get the one that is larger than X)\nExtra UVa: 00140, 00146, 00418, 01209, 11412.\nExtra Kattis: classpicture, towering, victorythroughsynergy.\nf. Iterative (Combination)\n1.", "mimetype": "text/plain", "start_char_idx": 446923, "end_char_idx": 449794, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f706fc4f-014f-4c4a-a424-37d4f575b6e1": {"__data__": {"id_": "f706fc4f-014f-4c4a-a424-37d4f575b6e1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a441f272-97bb-44b0-9b41-cdcfbe1271de", "node_type": "1", "metadata": {}, "hash": "fb8cbc6b74bc75f59171bc1a838224af5e4514819d11ae7b147fd5c99ae333ef", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c510323f-9234-4cc9-9177-972882dc4c92", "node_type": "1", "metadata": {}, "hash": "73da85008784036ed545e46fa325fb0142a3e1527918a03e3e4b914adc64cc39", "class_name": "RelatedNodeInfo"}}, "text": "UVa 12249 - Overlapping Scenes * (LA 4994 - KualaLumpur10; try all\npermutations; a bit of string matching)\n5. Kattis - dancerecital * (try all R! permutations; compare adjacent routines)\n6. Kattis - dreamer * (try all 8! permutations of digits; check if the date is\nvalid; output earliest valid date)\n7. Kattis - veci * (try all permutations; get the one that is larger than X)\nExtra UVa: 00140, 00146, 00418, 01209, 11412.\nExtra Kattis: classpicture, towering, victorythroughsynergy.\nf. Iterative (Combination)\n1. Entry Level: UVa 00639 - Don\u2019t Get Rooked * (generate 24\u21e54 = 216\ncombinations and prune)\n2. UVa 01047 - Zones * (LA 3278 - WorldFinals Shanghai05; try all 2n\nsubsets of towers to be taken; use inclusion-exclusion principle)\n3. UVa 11659 - Informants * (try all 220 bitmask and check)\n4. UVa 12694 - Meeting Room ... * (LA 6606 - Phuket13; it is safest to\njust brute force all 220 possibilities; greedy solution should be possible too)\n5. Kattis - geppetto * (try all 2N subsets of ingredients)\n6. Kattis - squaredeal * (try all 3! permutations of rectangles and try all 23\ncombinations of rectangle orientations; test \ufb01gure 1.a and 1.b conditions)\n7. Kattis - zagrade * (try all subsets of bracket pairs to be removed)\nExtra UVa: 00435, 00517, 11205, 12346, 12348, 12406, 13103.\nExtra Kattis: buildingboundaries, doubleplusgood, perket.\n145\n\n3.2.\nCOMPLETE SEARCH\nc\u20ddSteven, Felix, Suhendry\ng. Try All Possible Answer(s)\n1. Entry Level: Kattis - \ufb02exible * (try all possible answers)\n2. UVa 00188 - Perfect Hash * (3 nested loops; try until an answer is found)\n3. UVa 00725 - Division * (try all possible answers)\n4. UVa 10908 - Largest Square * (4 nested loops; try all odd square lengths)\n5. Kattis - communication * (try all possible bytes; apply the bitmask formula)\n6. Kattis - islands * (try all possible subsets; prune the non-contiguous ones\n(only 55 valid bitmasks between [0..1023]); check the \u2018island\u2019 property)\n7. Kattis - walls * (try whether the answer is 1/2/3/4; or Impossible; use up to\n4 nested loops)\nExtra UVa: 00102, 00471.\nExtra Kattis: cookingwater, gradecurving, heirsdilemma, owlandfox, park-\ning2, prinova, savingforretirement.\nh. Mathematical Simulation (Complete Search), Easier\n1. Entry Level: Kattis - easiest * (complete search; sum of digits)\n2. UVa 00382 - Perfection * (do trial division)\n3. UVa 01225 - Digit Counting * (LA 3996 - Danang07; N is small)\n4. UVa 10346 - Peter\u2019s Smoke * (interesting simulation problem)\n5. Kattis - growlinggears * (physics of parabola; derivation; try all gears)\n6. Kattis - trollhunt * (brute force; simple)\n7. Kattis - videospeedup * (brute force; simple for loop; do as asked)\nExtra UVa: 00100 12, 00371, 00654, 00906, 01583, 10783, 10879, 11001,\n11150, 11247, 11313, 11877, 11934, 12527, 12938, 13059, 13131.\nExtra Kattis:\naboveaverage, dicecup, harshadnumbers, socialrunning, so-\ndaslurper, somesum, sumoftheothers, tri, zamka.\ni. Mathematical Simulation (Complete Search), Harder\n1. Entry Level: UVa 00616 - Coconuts, Revisited * (brute force up to pn)\n2.", "mimetype": "text/plain", "start_char_idx": 449280, "end_char_idx": 452319, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c510323f-9234-4cc9-9177-972882dc4c92": {"__data__": {"id_": "c510323f-9234-4cc9-9177-972882dc4c92", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f706fc4f-014f-4c4a-a424-37d4f575b6e1", "node_type": "1", "metadata": {}, "hash": "e8585f3348f09230760e2253d844c9b5bb2aa48e76cd602e9761c0683560d9e6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c4464ade-f4b5-45fb-954a-bf08970554a4", "node_type": "1", "metadata": {}, "hash": "0362e2fa0d7def90f76568223baa7e9265ba2ab8ebc59a29a63ade4ed21a3b85", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - trollhunt * (brute force; simple)\n7. Kattis - videospeedup * (brute force; simple for loop; do as asked)\nExtra UVa: 00100 12, 00371, 00654, 00906, 01583, 10783, 10879, 11001,\n11150, 11247, 11313, 11877, 11934, 12527, 12938, 13059, 13131.\nExtra Kattis:\naboveaverage, dicecup, harshadnumbers, socialrunning, so-\ndaslurper, somesum, sumoftheothers, tri, zamka.\ni. Mathematical Simulation (Complete Search), Harder\n1. Entry Level: UVa 00616 - Coconuts, Revisited * (brute force up to pn)\n2. UVa 11130 - Billiard bounces * (mirror the billiard table to the right\n(and/or top); deal with one straight line instead of bouncing lines)\n3. UVa 11254 - Consecutive Integers * (use sum of arithmetic progression;\nbrute force all values of r from\np\n2n down to 1; stop at the \ufb01rst valid a)\n4. UVa 11490 - Just Another Problem * (let missing people = 2 \u21e4a2,\nthickness of soldiers = b, derive a formula involving a, b, and the given S)\n5. Kattis - crackingrsa * (a bit number theory; solvable with complete search)\n6. Kattis - falling * (rework the formula; complete search up to\np\nD)\n7. Kattis - thanosthehero * (for-loop from backwards)\nExtra UVa: 00493, 00550, 00697, 00846, 10025, 10035, 11968, 12290, 12665,\n12792, 12895.\nExtra Kattis: disgruntledjudge, houselawn, lipschitzconstant, milestones, re-\npeatingdecimal, robotopia, stopcounting, trick.\n12The very \ufb01rst problem in the UVa online judge is about (Lothar) Collatz\u2019s conjecture.\n146\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nj. Josephus Problem\n1. Entry Level: UVa 00151 - Power Crisis * (the original Josephus problem)\n2. UVa 01176 - A Benevolent Josephus * (LA 2346 - Dhaka01; special\ncase when k = 2; use Josephus recurrence; simulation)\n3. UVa 10774 - Repeated Josephus * (repeated special case of Josephus\nwhen k = 2)\n4. UVa 11351 - Last Man Standing * (use general case Josephus recurrence)\n5. Kattis - eenymeeny * (Josephus problem; small n; just simulate)\n6. Kattis - musicalchairs * (Josephus variant; brute force)\n7. Kattis - toys * (use general case Josephus recurrence)\nExtra UVa: 00130, 00133, 00305, 00402, 00440, 10015, 10771.\nExtra Kattis: coconut.\nk. Recursive Backtracking (Easier)\n1. Entry Level: UVa 10344 - 23 Out of 5 * (5 operands + 3 operators)\n2. UVa 00729 - The Hamming ... * (generate all bit strings)\n3. UVa 10576 - Y2K Accounting Bug * (generate all; prune; take max)\n4. UVa 12840 - The Archery Puzzle * (simple backtracking)\n5. Kattis - goodmorning * (we can use backtracking to generate all possible\n(small) numbers that can be pressed according to the constraints)\n6. Kattis - natjecanje * (4 options for each team with kayak: do nothing, pass\nto left (if damaged), keep to self (if damaged), pass to right (if damaged))\n7. Kattis - paintings * (try all possible paintings based on Catherine\u2019s prefer-\nence; skip hideous color pairs)\nExtra UVa: 00380, 00487, 00524, 00529, 00571, 00598, 00628, 00677, 00868,\n10452, 10503, 10624, 10776, 10950, 11201, 11961.\nExtra Kattis: draughts.", "mimetype": "text/plain", "start_char_idx": 451824, "end_char_idx": 454813, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c4464ade-f4b5-45fb-954a-bf08970554a4": {"__data__": {"id_": "c4464ade-f4b5-45fb-954a-bf08970554a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c510323f-9234-4cc9-9177-972882dc4c92", "node_type": "1", "metadata": {}, "hash": "73da85008784036ed545e46fa325fb0142a3e1527918a03e3e4b914adc64cc39", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "41c7ce11-0858-4f4c-a529-c975f25fcce1", "node_type": "1", "metadata": {}, "hash": "7769bf64eb6e35e9b95846a34011053c6381d30d19592e5b79778af3db54d940", "class_name": "RelatedNodeInfo"}}, "text": "UVa 12840 - The Archery Puzzle * (simple backtracking)\n5. Kattis - goodmorning * (we can use backtracking to generate all possible\n(small) numbers that can be pressed according to the constraints)\n6. Kattis - natjecanje * (4 options for each team with kayak: do nothing, pass\nto left (if damaged), keep to self (if damaged), pass to right (if damaged))\n7. Kattis - paintings * (try all possible paintings based on Catherine\u2019s prefer-\nence; skip hideous color pairs)\nExtra UVa: 00380, 00487, 00524, 00529, 00571, 00598, 00628, 00677, 00868,\n10452, 10503, 10624, 10776, 10950, 11201, 11961.\nExtra Kattis: draughts.\nl. Recursive Backtracking (Harder)\n1. Entry Level: UVa 00208 - Firetruck * (LA 5147 - WorldFinals SanAnto-\nnio91; backtracking with some pruning)\n2. UVa 00222 - Budget Travel * (LA 5161 - WorldFinals Indianapolis93;\ncannot use DP \u2018tank\u2019 is \ufb02oating-point; use backtracking)\n3. UVa 00307 - Sticks * (sort the sticks in descending length; group similar\nlengths; brute force the number of sticks; backtracking to check feasibility)\n4. UVa 01262 - Password * (LA 4845 - Daejeon10; sort grid columns; process\ncommon passwords in lexicographic order; skip two similar passwords)\n5. Kattis - dobra * (try all possible 3n changes of \u2018 \u2019 (to a vowel, an \u2018L\u2019, or other\nconsonant not \u2018L\u2019); prune invalid states; count valid states)\n6. Kattis - fruitbaskets * (interesting backtracking problem; compute the small\nnumbers < 200; output all minus this value computed via backtracking)\n7. Kattis - pagelayout * (a bit of geometry; O(2n \u21e5n2) iterative bitmask will\nTLE; need to use recursive backtracking with pruning)\nExtra UVa: 00129, 00301, 00331, 00416, 00433, 00565, 10001, 10063, 10094,\n10460, 10475, 10582, 11052, 11753.\nExtra Kattis: carvet, primes, solitaire.\n147\n\n3.3.\nDIVIDE AND CONQUER\nc\u20ddSteven, Felix, Suhendry\n3.3\nDivide and Conquer\nDivide and Conquer (D&C) is a problem-solving paradigm in which a problem is made\nsimpler by \u2018dividing\u2019 it into smaller parts and then conquering each part. The steps:\n1. Divide the original problem into sub-problems\u2014usually by half or nearly half,\n2. Find (sub)-solutions for each of these sub-problems\u2014which are now easier,\n3. If needed, combine the sub-solutions to get a complete solution for the main problem.\nWe have seen examples of the D&C paradigm in the previous sections of this book: Various\nO(n log n) sorting algorithms (e.g., Merge Sort, Quick Sort, Heap Sort, Balanced BST Sort\na.k.a. Tree Sort) and Binary Search in Section 2.2 utilize this paradigm. The way data is\norganized in Binary Heap, Binary Search Tree, Fenwick Tree, and Segment Tree in Section\n2.3, 2.4.3, and 2.4.4 also relies upon the D&C paradigm.\n3.3.1\nInteresting Usages of Binary Search\nIn this subsection, we discuss the D&C paradigm in the well-known Binary Search algorithm.\nWe classify Binary Search as a \u2018Divide\u2019 and Conquer algorithm although one reference [38]\nsuggests that it should be actually classi\ufb01ed as \u2018Decrease (by-half)\u2019 and Conquer as it does\nnot actually \u2018combine\u2019 the result. We highlight this algorithm because many contestants\nknow it, but not many are aware that it can be used in many other non-obvious ways.\nBinary Search: The Ordinary Usage\nRecall that the canonical usage of Binary Search is searching for an item in a static sorted\narray. We check the middle of the sorted array to determine if it contains what we are\nlooking for. If it is or there are no more items to consider, stop.", "mimetype": "text/plain", "start_char_idx": 454201, "end_char_idx": 457642, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "41c7ce11-0858-4f4c-a529-c975f25fcce1": {"__data__": {"id_": "41c7ce11-0858-4f4c-a529-c975f25fcce1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c4464ade-f4b5-45fb-954a-bf08970554a4", "node_type": "1", "metadata": {}, "hash": "0362e2fa0d7def90f76568223baa7e9265ba2ab8ebc59a29a63ade4ed21a3b85", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5a7ece0e-17c3-4104-a056-a89ea1159c7d", "node_type": "1", "metadata": {}, "hash": "7444c3b0087ebce3a2a8037b68fa82a2a19e008a42a5bc39109c7480aa310c9c", "class_name": "RelatedNodeInfo"}}, "text": "3.3.1\nInteresting Usages of Binary Search\nIn this subsection, we discuss the D&C paradigm in the well-known Binary Search algorithm.\nWe classify Binary Search as a \u2018Divide\u2019 and Conquer algorithm although one reference [38]\nsuggests that it should be actually classi\ufb01ed as \u2018Decrease (by-half)\u2019 and Conquer as it does\nnot actually \u2018combine\u2019 the result. We highlight this algorithm because many contestants\nknow it, but not many are aware that it can be used in many other non-obvious ways.\nBinary Search: The Ordinary Usage\nRecall that the canonical usage of Binary Search is searching for an item in a static sorted\narray. We check the middle of the sorted array to determine if it contains what we are\nlooking for. If it is or there are no more items to consider, stop. Otherwise, we can decide\nwhether the answer is to the left or right of the middle element and continue searching. As\nthe size of search space is halved (in binary fashion) after each check, the complexity of this\nalgorithm is O(log n). In Section 2.2, we have seen that there are built-in library routines\nfor this algorithm, e.g., the C++ STL lower bound, Java Collections.binarySearch, or\nPython bisect.\nThis is not the only way to use binary search. The prerequisite for performing a binary\nsearch\u2014a static sorted sequence (array or vector)\u2014can also be found in other uncommon\ndata structures such as in the root-to-leaf path of a tree (not necessarily binary nor complete)\nthat satis\ufb01es the min heap property. This variant is discussed below.\nBinary Search on Uncommon Data Structures\nThis original problem is titled \u2018My Ancestor\u2019 and was used in the Thailand ICPC National\nContest 2009. Abridged problem description: Given a weighted (family) tree of up to N \uf8ff\n80K vertices with a special trait: vertex values are increasing from root to leaves13, \ufb01nd\nthe ancestor vertex closest to the root from a starting vertex v that has weight at least P.\nThere are up to Q \uf8ff20K such o\u270fine queries. Examine Figure 3.4\u2014left. If P = 4, then\nthe answer is the vertex labeled with \u2018B\u2019 with value 5 as it is the ancestor of vertex v that\nis closest to root \u2018A\u2019 and has a value of \u22654. If P = 7, then the answer is \u2018C\u2019, with value 7.\nIf P \u22659, there is no answer as there is no ancestor of v with a weight \u22659.\nThe na\u00a8\u0131ve solution is to perform a linear O(N) scan per query: starting from the given\nvertex v, we move up the (family) tree until we reach the \ufb01rst vertex whose direct parent\n13This is actually a (Min) Heap property albeit not on Binary Tree, see Section 2.3.1.\n148\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nFigure 3.4: My Ancestor (all 5 root-to-leaf paths are sorted)\nhas value < P or until we reach the root. If this vertex has value \u2265P and it is not vertex\nv itself, we have found the solution. As there are Q queries, this approach runs in O(QN)\n(the input tree can be a sorted linked list of length N) and will get a TLE as N \uf8ff80K and\nQ \uf8ff20K.\nA better solution is to store all the 20K queries (we do not have to answer them im-\nmediately). Traverse the tree just once starting from the root using the O(N) preorder\ntree traversal algorithm (Section 4.6.2). This preorder tree traversal is slightly modi\ufb01ed to\nremember the partial root-to-current-vertex sequence as it executes. The array is always\nsorted because the vertices along the root-to-current-vertex path have increasing weights,\nsee Figure 3.4 (right).", "mimetype": "text/plain", "start_char_idx": 456873, "end_char_idx": 460282, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5a7ece0e-17c3-4104-a056-a89ea1159c7d": {"__data__": {"id_": "5a7ece0e-17c3-4104-a056-a89ea1159c7d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "41c7ce11-0858-4f4c-a529-c975f25fcce1", "node_type": "1", "metadata": {}, "hash": "7769bf64eb6e35e9b95846a34011053c6381d30d19592e5b79778af3db54d940", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3d07c2c0-5fa3-45b9-896a-b00b8b9376db", "node_type": "1", "metadata": {}, "hash": "51813bf4c7c2a4bcdca5c275c253f654379cb4b966dc1170cab540c96fcc5fb7", "class_name": "RelatedNodeInfo"}}, "text": "If this vertex has value \u2265P and it is not vertex\nv itself, we have found the solution. As there are Q queries, this approach runs in O(QN)\n(the input tree can be a sorted linked list of length N) and will get a TLE as N \uf8ff80K and\nQ \uf8ff20K.\nA better solution is to store all the 20K queries (we do not have to answer them im-\nmediately). Traverse the tree just once starting from the root using the O(N) preorder\ntree traversal algorithm (Section 4.6.2). This preorder tree traversal is slightly modi\ufb01ed to\nremember the partial root-to-current-vertex sequence as it executes. The array is always\nsorted because the vertices along the root-to-current-vertex path have increasing weights,\nsee Figure 3.4 (right). The preorder tree traversal on the tree shown in Figure 3.4 (left)\nproduces the following partial root-to-current-vertex sorted array: {{3}, {3, 5}, {3, 5, 7},\n{3, 5, 7, 8}, backtrack, {3, 5, 7, 9}, backtrack, backtrack, backtrack, {3, 8}, backtrack,\n{3, 6}, {3, 6, 20}, backtrack, {3, 6, 10}, and \ufb01nally {3, 6, 10, 20}, backtrack, backtrack,\nbacktrack (done)}.\nDuring the O(N) preorder traversal, when we land on a queried vertex, we can perform a\nO(log N) binary search (to be precise: lower bound) on the partial root-to-current-vertex\nweight array to obtain the ancestor closest to the root with a value of at least P, recording\nthese solutions. Finally, we can perform a simple O(Q) iteration to output the results. The\noverall time complexity of this approach is O(N + Q log N), which is now manageable.\nBisection Method\nWe have discussed the applications of Binary Searches in \ufb01nding items in static sorted\nsequences. However, the binary search principle14 can also be used to \ufb01nd the root of a\nfunction (not necessarily a square root) that may be di\ufb03cult to compute directly.\nFor example, you buy a car with loan and now want to pay the loan in monthly install-\nments of d dollars for m months. Suppose the value of the car is originally v dollars and the\nbank charges an interest rate of i% for any unpaid loan at the end of each month. What\nis the amount of monthly installment d that you must pay (to 2 digits after the decimal\npoint)? Note that you pay this installment d at the end of the month after the interest of\nthat month has been calculated.\nSuppose d = 576.19, m = 2, v = 1000, and i = 10%. After one month, your debt becomes\n1000\u21e5(1.1)\u2212576.19 = 523.81. After two months, your debt becomes 523.81\u21e5(1.1)\u2212576.19 \u21e1\n0. If we are only given m = 2, v = 1000, and i = 10%, how would we determine that\nd = 576.19? In other words, \ufb01nd the root d such that the debt payment function f(d) given\nm, v, i gives \u21e10.\n14We use the term \u2018binary search principle\u2019 to refer to the D&C approach of halving the range of possible\nanswers. The \u2018binary search algorithm\u2019 (\ufb01nding index of an item in a sorted array), the \u2018bisection method\u2019\n(\ufb01nding the root of a function), and \u2018binary search the answer\u2019 (discussed in the next subsection) are all\ninstances of this principle.\n149\n\n3.3.\nDIVIDE AND CONQUER\nc\u20ddSteven, Felix, Suhendry\nAn easy way to solve this root \ufb01nding problem is to use the bisection method. We pick\na reasonable range as a starting point. We want to \ufb01nd d within the range [a..b] where\na = 0.01 as we have to pay at least one cent and b = (1 + i%) \u21e5v as the earliest we can\ncomplete the payment is m = 1 if we pay exactly (1 + i%) \u21e5v dollars after one month. In\nthis example, b = (1 + 0.1) \u21e51000 = 1100.00 dollars.", "mimetype": "text/plain", "start_char_idx": 459576, "end_char_idx": 463011, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3d07c2c0-5fa3-45b9-896a-b00b8b9376db": {"__data__": {"id_": "3d07c2c0-5fa3-45b9-896a-b00b8b9376db", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5a7ece0e-17c3-4104-a056-a89ea1159c7d", "node_type": "1", "metadata": {}, "hash": "7444c3b0087ebce3a2a8037b68fa82a2a19e008a42a5bc39109c7480aa310c9c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3fa16795-8749-49ca-b368-e0aee1c9bb8b", "node_type": "1", "metadata": {}, "hash": "abedf719b8dd3c943d97ca8a80f52a4865da445a6de52814589b5103cf9ce81b", "class_name": "RelatedNodeInfo"}}, "text": "149\n\n3.3.\nDIVIDE AND CONQUER\nc\u20ddSteven, Felix, Suhendry\nAn easy way to solve this root \ufb01nding problem is to use the bisection method. We pick\na reasonable range as a starting point. We want to \ufb01nd d within the range [a..b] where\na = 0.01 as we have to pay at least one cent and b = (1 + i%) \u21e5v as the earliest we can\ncomplete the payment is m = 1 if we pay exactly (1 + i%) \u21e5v dollars after one month. In\nthis example, b = (1 + 0.1) \u21e51000 = 1100.00 dollars. For the bisection method to work15,\nwe must ensure that the function values of the two extreme points in the initial real range\n[a..b], i.e., f(a) and f(b) have opposite signs (this is true for the computed a and b above,\nf(a) is positive\u2013installment d = a is too small and f(b) is negative\u2013installment d = b is too\nbig) and function f(d) is a monotone16 function (this is true for function f(d) above).\na\nb\nd = a+b\n2\nstatus: f(d, m, v, i)\naction\n0.01\n1100.00\n550.005\nundershoot by 54.9895\nincrease d to a+b\n2\n550.005\n1100.00\n825.0025\novershoot by 522.50525\ndecrease d to a+b\n2\n550.005\n825.0025\n687.50375\novershoot by 233.757875\ndecrease d\n550.005\n687.50375\n618.754375\novershoot by 89.384187\ndecrease d\n550.005\n618.754375\n584.379688\novershoot by 17.197344\ndecrease d\n550.005\n584.379688\n567.192344\nundershoot by 18.896078\nincrease d\n567.192344\n584.379688\n575.786016\nundershoot by 0.849366\nincrease d\n. . .\n. . .\n. . .\na few iterations later . . .\n. . .\n. . .\n. . .\n576.190476\nstop; error is now less than \u270f\nanswer = 576.19\nTable 3.1: Running Bisection Method on the Example Function\nNotice that bisection method only requires O(log2((b \u2212a)/\u270f)) iterations to get an answer\nthat is good enough (the error is smaller than the threshold error \u270fthat we can tolerate). In\nthis example, bisection method only takes log2 1099.99/\u270ftries. Using a small \u270f= 1e-9, this\nyields only \u21e140 iterations. Even if we use a smaller \u270f= 1e-15, we will still only need \u21e160\ntries. Notice that the number of tries is small. The bisection method is much more e\ufb03cient\ncompared to exhaustively evaluating each possible value of d =[0.01..1100.00]/\u270ffor this\nexample function. Note that the bisection method can be written with a loop that tries the\nvalues of d \u21e140 to 60 times (see our implementation below).\nBinary Search the Answer (BSTA)\nThe abridged version of UVa 11935 - Through the Desert is as follows: Imagine that you are\nan explorer trying to cross a desert. You use a jeep with a \u2018large enough\u2019 fuel tank \u2013 initially\nfull. You encounter a series of events throughout your journey such as \u2018drive (that consumes\nfuel)\u2019, \u2018experience gas leak (further reduces the amount of fuel left)\u2019, \u2018encounter gas station\n(allowing you to refuel to the original capacity of your jeep\u2019s fuel tank)\u2019, \u2018encounter mechanic\n(\ufb01xes all leaks)\u2019, or \u2018reach goal (done)\u2019. You need to determine the smallest possible fuel\ntank capacity for your jeep to be able to reach the goal. The answer must be precise to three\ndigits after decimal point.\nIf we know the jeep\u2019s fuel tank capacity, then this problem is just a simulation problem.\nFrom the start, we can simulate each event in order and determine if the goal can be reached\nwithout running out of fuel.\nThe problem is that we do not know the jeep\u2019s fuel tank\ncapacity\u2014this is the value that we are looking for.", "mimetype": "text/plain", "start_char_idx": 462555, "end_char_idx": 465828, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3fa16795-8749-49ca-b368-e0aee1c9bb8b": {"__data__": {"id_": "3fa16795-8749-49ca-b368-e0aee1c9bb8b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3d07c2c0-5fa3-45b9-896a-b00b8b9376db", "node_type": "1", "metadata": {}, "hash": "51813bf4c7c2a4bcdca5c275c253f654379cb4b966dc1170cab540c96fcc5fb7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "305b3fad-ab0d-4347-a4a8-f692396fe162", "node_type": "1", "metadata": {}, "hash": "a37832e252206f1dfd37d3045baa2aa36d79078b86e47a0fde2879b36869f061", "class_name": "RelatedNodeInfo"}}, "text": "You encounter a series of events throughout your journey such as \u2018drive (that consumes\nfuel)\u2019, \u2018experience gas leak (further reduces the amount of fuel left)\u2019, \u2018encounter gas station\n(allowing you to refuel to the original capacity of your jeep\u2019s fuel tank)\u2019, \u2018encounter mechanic\n(\ufb01xes all leaks)\u2019, or \u2018reach goal (done)\u2019. You need to determine the smallest possible fuel\ntank capacity for your jeep to be able to reach the goal. The answer must be precise to three\ndigits after decimal point.\nIf we know the jeep\u2019s fuel tank capacity, then this problem is just a simulation problem.\nFrom the start, we can simulate each event in order and determine if the goal can be reached\nwithout running out of fuel.\nThe problem is that we do not know the jeep\u2019s fuel tank\ncapacity\u2014this is the value that we are looking for.\n15Note that the requirements for the bisection method (which uses the binary search principle) are slightly\ndi\u21b5erent from the binary search algorithm which needs a sorted array.\n16In Mathematics, a function f is called a monotone function if and only if it is either entirely non-\nincreasing or entirely non-decreasing, e.g., see Figure 3.5\u2014left.\n150\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nFrom the problem description, we can compute that the range of possible answers is\nbetween [0.000..10000.000], with 3 digits of precision. However, there are 10M such\npossibilities. Trying each value sequentially will get us a TLE verdict.\nFortunately, this problem has a property that we can exploit. Suppose that the correct\nanswer is x. Setting your jeep\u2019s fuel tank capacity to any value between [0.000..x-0.001]\nwill not bring your jeep safely to the goal event. On the other hand, setting your jeep fuel\ntank volume to any value between [x..10000.000] will bring your jeep safely to the goal\nevent, usually with some fuel left. This monotone property allows us to perform Binary\nSearch the Answer x (abbreviated as BSTA)! Notice that BSTA (on Boolean monotone\nfunction can(x), see Figure 3.5\u2014right) is very similar to Bisection method (on more general\nmonotone function f(x), see Figure 3.5\u2014left).\nFigure 3.5: Monotone Function; Left: Bisection; Right: BSTA\nWe can use the following code to obtain the solution for this problem.\nconst double EPS = 1e-9;\n// this EPS is adjustable\nbool can(double x) {\n// details omitted\n// return true if the jeep can reach goal with fuel tank capacity of x\n// return false otherwise\n}\n// inside int main()\n// Binary Search the Answer (BSTA), then simulate\ndouble lo = 0.0, hi = 10000.0;\nwhile (fabs(hi-lo) > EPS) {\n// answer is not found yet\ndouble mid = (lo+hi) / 2.0;\n// try the middle value\ncan(mid) ? hi = mid : lo = mid;\n// then continue\n}\nprintf(\"%.3lf\\n\", hi);\n// we have the answer\nNote that some programmers choose to use a constant number of re\ufb01nement iterations instead\nof allowing the number of iterations to vary dynamically to avoid precision errors when testing\nfabs(hi-lo) > EPS and thus being trapped in an accidental in\ufb01nite loop. The only changes\nrequired to implement this approach are shown below. The rest are the same as above.\ndouble lo = 0.0, hi = 10000.0;\nfor (int i = 0; i < 50; ++i) {\n// log_2(10000/1e-9) ~= 43\ndouble mid = (lo+hi) / 2.0;\n// looping 50x is enough\ncan(mid) ? hi = mid : lo = mid;\n// ternary operator\n}\nSource code: ch3/dnc/UVa11935.cpp|java|py|ml\n151\n\n3.3.\nDIVIDE AND CONQUER\nc\u20ddSteven, Felix, Suhendry\nExercise 3.3.1.1: There is an alternative solution for UVa 11935 that does not use \u2018binary\nsearch the answer\u2019 technique. Can you spot it?\nExercise 3.3.1.2: The example shown here involves binary-searching the answer where the\nanswer is a \ufb02oating point number.", "mimetype": "text/plain", "start_char_idx": 465015, "end_char_idx": 468690, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "305b3fad-ab0d-4347-a4a8-f692396fe162": {"__data__": {"id_": "305b3fad-ab0d-4347-a4a8-f692396fe162", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3fa16795-8749-49ca-b368-e0aee1c9bb8b", "node_type": "1", "metadata": {}, "hash": "abedf719b8dd3c943d97ca8a80f52a4865da445a6de52814589b5103cf9ce81b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e3d50b49-642b-49ce-b5a1-6a6957ea1bff", "node_type": "1", "metadata": {}, "hash": "81baed481823f3669dfccb6af5f95fcd9d02fac17bffdaf819ee9e68ed71f679", "class_name": "RelatedNodeInfo"}}, "text": "hi = mid : lo = mid;\n// ternary operator\n}\nSource code: ch3/dnc/UVa11935.cpp|java|py|ml\n151\n\n3.3.\nDIVIDE AND CONQUER\nc\u20ddSteven, Felix, Suhendry\nExercise 3.3.1.1: There is an alternative solution for UVa 11935 that does not use \u2018binary\nsearch the answer\u2019 technique. Can you spot it?\nExercise 3.3.1.2: The example shown here involves binary-searching the answer where the\nanswer is a \ufb02oating point number. Modify the code to solve Binary Search the Answer\n(BSTA) problems where the answer lies in an integer range!\n3.3.2\nTernary Search\nGiven a unimodal function f(x) and a range [L..R], \ufb01nd x such that f(x) is minimum17.\nThis unimodal function f(x) in a range [L..R] is formally de\ufb01ned as follows: 8a, b with\nL \uf8ffa < b \uf8ffx, we have f(a) > f(b), and 8a, b with x \uf8ffa < b \uf8ffR, we have f(a) < f(b)\n(that is, f(x) is strictly decreasing and then strictly increasing), see Figure 3.6.\nFigure 3.6: Ternary Search on a Unimodal Function\nThe classic binary search that we have discussed in Section 3.3.1 cannot be applied on such\na problem. We need another \u2018variant\u2019 of binary search called the ternary search18.\nThe basic idea is as follows. While binary search divides the range into two and decides\nwhich half to explore, ternary search divides the range into three and decide which two-\nthirds to explore. Let a unimodal function f(x) on a range [lo..hi]. Let\u2019s take any two\npoints m1 and m2 inside this range such that lo < m1 < m2 < hi. However, for simplicity\nand performance, we set delta = (hi \u2212lo)/3.0, m1 = lo + delta and m2 = hi \u2212delta so that\nm1 is approximately 1\n3 from lo and m2 is approximately 1\n3 from hi (or 2\n3 from lo). Then,\nthere are three possibilities:\n1. If f(m1) > f(m2), then the minimum cannot be in the left subrange [lo..m1] and we\nshould continue exploring subrange [m1..hi].\n2. If f(m1) < f(m2), then it is the opposite of the \ufb01rst possibility. In this case, the\nminimum cannot be on the right subrange [m2..hi] and we should continue exploring\nsubrange [lo..m2]. This scenario is shown in Figure 3.6.\n3. If f(m1) = f(m2), a rare case, then the ternary search should be conducted in\n[m1..m2]. However, in order to simplify the code, we will just assume that f(m1) \uf8ff\nf(m2) and apply the second possibility above.\nAfter O(log(hi \u2212lo)) steps, the range will be small enough than \u270fand we can stop. This is\ne\ufb03cient. The key part of Kattis - tricktreat code that uses ternary search is shown below.\n17We can reverse the problem to \ufb01nd x such that f(x) is maximum by reversing the signs of the constraints.\n18Unimodal functions are rarely found in programming contests, therefore ternary search is also rarely\nused in programming contests.\n152\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nfor (int i = 0; i < 50; ++i) {\n// similar as BSTA\ndouble delta = (hi-lo)/3.0;\n// 1/3rd of the range\ndouble m1 = lo+delta;\n// 1/3rd away from lo\ndouble m2 = hi-delta;\n// 1/3rd away from hi\n(f(m1) > f(m2)) ?", "mimetype": "text/plain", "start_char_idx": 468288, "end_char_idx": 471214, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e3d50b49-642b-49ce-b5a1-6a6957ea1bff": {"__data__": {"id_": "e3d50b49-642b-49ce-b5a1-6a6957ea1bff", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "305b3fad-ab0d-4347-a4a8-f692396fe162", "node_type": "1", "metadata": {}, "hash": "a37832e252206f1dfd37d3045baa2aa36d79078b86e47a0fde2879b36869f061", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b63d9d27-8c18-4865-9312-d9295047e3a2", "node_type": "1", "metadata": {}, "hash": "c4d0c05bd54f08e3fe99f18bbd1f72b59ab045d85abcb96db76a076d93663d17", "class_name": "RelatedNodeInfo"}}, "text": "The key part of Kattis - tricktreat code that uses ternary search is shown below.\n17We can reverse the problem to \ufb01nd x such that f(x) is maximum by reversing the signs of the constraints.\n18Unimodal functions are rarely found in programming contests, therefore ternary search is also rarely\nused in programming contests.\n152\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nfor (int i = 0; i < 50; ++i) {\n// similar as BSTA\ndouble delta = (hi-lo)/3.0;\n// 1/3rd of the range\ndouble m1 = lo+delta;\n// 1/3rd away from lo\ndouble m2 = hi-delta;\n// 1/3rd away from hi\n(f(m1) > f(m2)) ? lo = m1 : hi = m2;\n// f is unimodal\n}\nSource code: ch3/dnc/tricktreat.cpp|java|py|ml\n3.3.3\nDivide and Conquer in Programming Contests\nThe Divide and Conquer (D&C) paradigm is usually utilized through popular algorithms:\nBinary Search and its variants, Ternary Search, Merge/Quick/Heap/Balanced BST (Tree)\nSort, Inversion Index (modi\ufb01ed Merge Sort), and data structures: Binary Heap, (Balanced)\nBinary Search Tree, Order Statistics Tree, Fenwick Tree, Segment Tree, etc. However\u2014based\non our experience, we reckon that the most commonly used form of the D&C paradigm in\nprogramming contests is the Binary Search principle. If you want to do well in programming\ncontests, please spend time practicing the various ways to apply it.\nOnce you are more familiar with the \u2018Binary Search the Answer\u2019 (abbreviated as BSTA)\ntechnique discussed in this section, please explore Book 2 for a few more programming\nexercises that use this technique with other algorithms that we will discuss in the later parts\nof this book.\nWe notice that there are not that many D&C problems outside of our binary search\ncategorization. Most D&C solutions are \u2018geometry-related\u2019 or \u2018problem speci\ufb01c\u2019, and thus\ncannot be discussed in detail in this book. However, we will encounter some of them later,\ne.g.,: Matrix Power, BSTA plus other algorithms, Square Root/Heavy-Light Decomposition,\nand Closest Pair Problem.\nProgramming exercises solvable using Divide and Conquer:\na. Binary Search\n1. Entry Level: UVa 11057 - Exact Sum * (sort; target pair problem)\n2. UVa 11621 - Small Factors * (generate; sort; upper bound)\n3. UVa 12192 - Grapevine * (input array is specially sorted; lower bound)\n4. UVa 12965 - Angry Birds * (sort producer/consumer prices; the answer\nis one of the prices mentioned; use binary searches to count the answer)\n5. Kattis - \ufb01re\ufb02y * (sort stalactites vs stalagmites separately; brute force height;\nbinary search the obstacles hit)\n6. Kattis - outofsorts * (do O(log n) binary searches on unsorted array n times)\n7. Kattis - roompainting * (sort the cans at shop (can be used more than once);\nuse lower bound for what Joe needs at shop)\nExtra UVa: 00679, 00957, 10057, 10077, 10474, 10567, 10611, 10706, 10742,\n11876.\nExtra Kattis: synchronizinglists.\nOthers: Thailand ICPC National Contest 2009 - My Ancestor.\n153\n\n3.3.\nDIVIDE AND CONQUER\nc\u20ddSteven, Felix, Suhendry\nb. Bisection Method and BSTA (Easier)\n1. Entry Level: Kattis - carefulascent * (BSTA + Physics simulation)\n2. UVa 12032 - The Monkey ... * (BSTA + simulation)\n3. UVa 12190 - Electric Bill * (BSTA + algebra)\n4. UVa 13142 - Destroy the Moon ... * (BSTA + Physics simulation)\n5. Kattis - freeweights * (BSTA + simulation; Mathematical observation)\n6. Kattis - monk * (BSTA + simulation; cool)\n7. Kattis - suspensionbridges * (BSTA + Maths; be careful of precision error)\nExtra UVa: 10341, 11413, 11881, 11935, 12791.", "mimetype": "text/plain", "start_char_idx": 470619, "end_char_idx": 474087, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b63d9d27-8c18-4865-9312-d9295047e3a2": {"__data__": {"id_": "b63d9d27-8c18-4865-9312-d9295047e3a2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e3d50b49-642b-49ce-b5a1-6a6957ea1bff", "node_type": "1", "metadata": {}, "hash": "81baed481823f3669dfccb6af5f95fcd9d02fac17bffdaf819ee9e68ed71f679", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a2dd392f-caf8-4f63-b39a-89af7d5e45b9", "node_type": "1", "metadata": {}, "hash": "3fa1dfe4cde3d3ef6f7e1cd6cebf832db3232004ee6bc9f3f2c00fb656be6ed6", "class_name": "RelatedNodeInfo"}}, "text": "DIVIDE AND CONQUER\nc\u20ddSteven, Felix, Suhendry\nb. Bisection Method and BSTA (Easier)\n1. Entry Level: Kattis - carefulascent * (BSTA + Physics simulation)\n2. UVa 12032 - The Monkey ... * (BSTA + simulation)\n3. UVa 12190 - Electric Bill * (BSTA + algebra)\n4. UVa 13142 - Destroy the Moon ... * (BSTA + Physics simulation)\n5. Kattis - freeweights * (BSTA + simulation; Mathematical observation)\n6. Kattis - monk * (BSTA + simulation; cool)\n7. Kattis - suspensionbridges * (BSTA + Maths; be careful of precision error)\nExtra UVa: 10341, 11413, 11881, 11935, 12791.\nExtra Kattis: expeditiouscubing, \ufb01nancialplanning, hindex, htoo, rainfall2,\nslalom2, smallschedule, speed, svada, taxing.\nOthers: IOI 2010 - Quality of Living (BSTA).\nc. Ternary Search and Others\n1. Entry Level: UVa 00183 - Bit Maps * (simple exercise of DnC)\n2. UVa 10385 - Duathlon * (the function is unimodal; ternary search)\n3. UVa 11147 - KuPellaKeS BST * (implement the given recursive DnC)\n4. UVa 12893 - Count It * (convert the given code into recursive DnC)\n5. Kattis - a1paper * (division of A1 paper is a kind of DnC principle)\n6. Kattis - ceiling * (LA 7578 - WorldFinals Phuket16; BST insertion+tree\nequality check; also available at UVa 01738 - Ceiling Function)\n7. Kattis - goingtoseed * (divide to search into four regions; extension of bi-\nnary/ternary search concept)\nExtra UVa: 00608.\nExtra Kattis: cantor, euclideantsp, jewelrybox, qanat, reconnaissance, sretan,\nsylvester, tricktreat, zipline.\nOthers: IOI 2011 - Race (DnC), IOI 2011 - Valley (ternary search)\n154\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\n3.4\nGreedy\nAn algorithm is said to be greedy if it makes the locally optimal choice at each step with the\nhope of eventually reaching the globally optimal solution. In some cases, greedy works\u2014the\nsolution is short and runs e\ufb03ciently. For many others, however, it does not. As discussed\nin other typical Computer Science textbooks, e.g., [5, 35], a problem must exhibit these two\nproperties in order for a greedy algorithm to work:\n1. It has optimal sub-structures.\nOptimal solution to the problem contains optimal solutions to the sub-problems.\n2. It has the greedy property (di\ufb03cult or not cost-e\u21b5ective19 to prove during contest).\nIf we make a choice that seems like the best at the moment and proceed to solve the\nremaining sub-problem, we reach the optimal solution. We will never have to reconsider\nour previous choices.\n3.4.1\nExamples\nCoin Change - The Greedy Version\nProblem description: Given a target amount V cents and a list of denominations of n coins,\ni.e., we have coinValue[i] (in cents) for coin types i 2 [0..n-1], what is the minimum\nnumber of coins that we must use to represent amount V ? Assume that we have an unlimited\nsupply of coins of any type. Example: If n = 4, coinValue = {25, 10, 5, 1} cents20, and\nwe want to represent V = 42 cents, we can use this Greedy algorithm: Select the largest coin\ndenomination which is not greater than the remaining amount, i.e., 42-25 = 17 ! 17-10 =\n7 ! 7-5 = 2 ! 2-1 = 1 ! 1-1 = 0, a total of 5 coins. This is optimal.\nThe problem above has the two ingredients required for a successful greedy algorithm:\n1. It has optimal sub-structures.\nWe have seen that in our quest to represent 42 cents, we use 25+10+5+1+1.", "mimetype": "text/plain", "start_char_idx": 473529, "end_char_idx": 476812, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a2dd392f-caf8-4f63-b39a-89af7d5e45b9": {"__data__": {"id_": "a2dd392f-caf8-4f63-b39a-89af7d5e45b9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b63d9d27-8c18-4865-9312-d9295047e3a2", "node_type": "1", "metadata": {}, "hash": "c4d0c05bd54f08e3fe99f18bbd1f72b59ab045d85abcb96db76a076d93663d17", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4590ec06-6d10-4146-b6ad-f95e18cc7981", "node_type": "1", "metadata": {}, "hash": "e595f5c9fadeef08628b3c2960cef475f4c904c6d01e9d46333bc464155b8b96", "class_name": "RelatedNodeInfo"}}, "text": "Assume that we have an unlimited\nsupply of coins of any type. Example: If n = 4, coinValue = {25, 10, 5, 1} cents20, and\nwe want to represent V = 42 cents, we can use this Greedy algorithm: Select the largest coin\ndenomination which is not greater than the remaining amount, i.e., 42-25 = 17 ! 17-10 =\n7 ! 7-5 = 2 ! 2-1 = 1 ! 1-1 = 0, a total of 5 coins. This is optimal.\nThe problem above has the two ingredients required for a successful greedy algorithm:\n1. It has optimal sub-structures.\nWe have seen that in our quest to represent 42 cents, we use 25+10+5+1+1.\nThis is an optimal 5-coin solution to the original problem!\nOptimal solutions to sub-problem are contained within the 5-coin solution, i.e.,\na. To represent 17 cents, we use 10+5+1+1 (part of the solution for 42 cents),\nb. To represent 7 cents, we use 5+1+1 (also part of the solution for 42 cents), etc.\n2. It has the greedy property: given every amount V , we can greedily subtract V with the\nlargest coin denomination which is not greater than this amount V . It can be proven\n(not shown here for brevity) that using any other strategies will not lead to an optimal\nsolution, at least for this set of coin denominations.\nHowever, this greedy algorithm does not work for all sets of coin denominations. Take for\nexample {4, 3, 1} cents. To make 6 cents with that set, a greedy algorithm would choose 3\ncoins {4, 1, 1} instead of the optimal solution that uses 2 coins {3, 3}. The general version\nof this problem is revisited later in Section 3.5.2 (Dynamic Programming) and in Section on\nNP-hard/complete problems in Book 2.\n19It may be easier/faster to just code the usually simple Greedy algorithm implementation and submit\nthe code to see if it is already Accepted or not.\n20The presence of the unlimited 1-cent coin ensures that we can always make every value.\n155\n\n3.4.\nGREEDY\nc\u20ddSteven, Felix, Suhendry\nLoad Balancing - The Greedy Version: UVa 00410 - Station Balance\nGiven 1 \uf8ffC \uf8ff5 chambers which can store 0, 1, or 2 specimens, 1 \uf8ffS \uf8ff2C specimens\nand a list M of the masses of the S specimens, determine which chamber should store each\nspecimen in order to minimize \u2018imbalance\u2019. See Figure 3.7 for a visual explanation21.\nLet A = (PS\nj=1 Mj)/C, i.e., A is the average of the total mass in each of the C chambers.\nLet Imbalance = PC\ni=1 |Xi \u2212A|, i.e., the sum of di\u21b5erences between the total mass in each\nchamber w.r.t. A where Xi is the total mass of specimens in chamber i.\nFigure 3.7: Visualization of UVa 00410 - Station Balance\nThis version of Load Balancing problem can be solved using a greedy algorithm, but to arrive\nat that solution, we have to make several observations.\nFigure 3.8: UVa 00410 - Observations\nObservation 1: If there exists an empty chamber, it is usually bene\ufb01cial and never worse to\nmove one specimen from a chamber with two specimens to the empty chamber! Otherwise,\nthe empty chamber contributes more to the imbalance as shown in Figure 3.8, top.\nObservation 2: If S > C, then S \u2212C specimens must be paired with a chamber already\ncontaining other specimens\u2014the Pigeonhole principle! See Figure 3.8, bottom.\nThe key insight is that the solution to this problem can be simpli\ufb01ed with sorting:\nif S < 2C, add 2C \u2212S dummy specimens with mass 0.\nFor example, C = 3, S = 4,\nM = {5, 1, 2, 7} ! C = 3, S = 6, M = {5, 1, 2, 7, 0, 0}. Then, sort the specimens on their\nmass such that M1 \uf8ffM2 \uf8ff. . .", "mimetype": "text/plain", "start_char_idx": 476247, "end_char_idx": 479637, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4590ec06-6d10-4146-b6ad-f95e18cc7981": {"__data__": {"id_": "4590ec06-6d10-4146-b6ad-f95e18cc7981", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a2dd392f-caf8-4f63-b39a-89af7d5e45b9", "node_type": "1", "metadata": {}, "hash": "3fa1dfe4cde3d3ef6f7e1cd6cebf832db3232004ee6bc9f3f2c00fb656be6ed6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9f6f7fca-ffc5-43e3-934c-ffd8477c0b68", "node_type": "1", "metadata": {}, "hash": "a5670dfefc400e6ab7c82d03404b5115cc74de6b87c564f5175d6ef845251a97", "class_name": "RelatedNodeInfo"}}, "text": "Otherwise,\nthe empty chamber contributes more to the imbalance as shown in Figure 3.8, top.\nObservation 2: If S > C, then S \u2212C specimens must be paired with a chamber already\ncontaining other specimens\u2014the Pigeonhole principle! See Figure 3.8, bottom.\nThe key insight is that the solution to this problem can be simpli\ufb01ed with sorting:\nif S < 2C, add 2C \u2212S dummy specimens with mass 0.\nFor example, C = 3, S = 4,\nM = {5, 1, 2, 7} ! C = 3, S = 6, M = {5, 1, 2, 7, 0, 0}. Then, sort the specimens on their\nmass such that M1 \uf8ffM2 \uf8ff. . . \uf8ffM2C\u22121 \uf8ffM2C. In this example, M = {5, 1, 2, 7, 0, 0} !\n{0, 0, 1, 2, 5, 7}.\nBy adding dummy specimens and then sorting them, a greedy strategy\nbecomes \u2018apparent\u2019:\n\u2022 Pair the specimens with masses M1&M2C and put them in chamber 1, then\n\u2022 Pair the specimens with masses M2&M2C\u22121 and put them in chamber 2, and so on . . .\n21Since C \uf8ff5 and S \uf8ff10, we can actually use a Complete Search solution for this problem. However,\nthis problem is simpler to solve using the Greedy algorithm.\n156\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nThis greedy algorithm\u2014known as load balancing\u2014works for this version (pairing) of Load\nBalancing problem22! See Figure 3.9.\nFigure 3.9: UVa 00410 - Greedy Solution\nIt is hard to impart the techniques used in deriving this greedy solution. Finding greedy\nsolutions is an art, just as \ufb01nding fast enough pruning strategies in Complete Search solutions\nrequires creativity. A tip that arises from this example: if there is no obvious greedy strategy,\ntry sorting the data or introducing some tweak and see if a greedy strategy emerges.\nInterval Covering: Kattis - grass/UVa 10382 - Watering Grass\nAbridged problem description: n sprinklers are installed in a horizontal strip of grass L\nmeters long and W meters wide. Each sprinkler is centered vertically in the strip. For each\nsprinkler, we are given its position as the distance from the left end of the center line and\nits radius of operation. What is the minimum number of sprinklers that should be turned\non in order to water the entire strip of grass? Constraint: n \uf8ff10 000. For an illustration of\nthe problem, see Figure 3.10\u2014left side. The answer for this test case is 6 sprinklers (those\nlabeled with {A, B, D, E, F, H}). There are 2 unused sprinklers: {C, G}.\nFigure 3.10: Kattis - grass/UVa 10382 - Watering Grass\nWe cannot solve this problem with a brute force strategy that tries all possible subsets of\nsprinklers to be turned on since the number of sprinklers can go up to 10 000. It is de\ufb01nitely\ninfeasible to try all 210 000 possible subsets of sprinklers.\nThis problem is actually a variant of the well-known greedy problem called the interval\ncovering problem.\nHowever, it includes a simple geometric twist.\nThe original interval\ncovering problem deals with intervals. This problem deals with sprinklers that have circles of\nin\ufb02uence in a horizontal area rather than simple intervals. We \ufb01rst have to transform/reduce\nthe problem to resemble the standard interval covering problem.\n22The general case of this Load-Balancing problem is actually NP-complete.\n157\n\n3.4.\nGREEDY\nc\u20ddSteven, Felix, Suhendry\nSee Figure 3.10\u2014right side.\nWe can convert these circles and horizontal strips into\nintervals. We can compute dx = sqrt(R2 - (W/2)2). Suppose a circle is centered at (x,\ny). The interval represented by this circle is [x-dx..x+dx]. To see why this works, notice\nthat the additional circle segment beyond dx away from x does not completely cover the\nstrip in the horizontal region it spans.", "mimetype": "text/plain", "start_char_idx": 479105, "end_char_idx": 482639, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9f6f7fca-ffc5-43e3-934c-ffd8477c0b68": {"__data__": {"id_": "9f6f7fca-ffc5-43e3-934c-ffd8477c0b68", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4590ec06-6d10-4146-b6ad-f95e18cc7981", "node_type": "1", "metadata": {}, "hash": "e595f5c9fadeef08628b3c2960cef475f4c904c6d01e9d46333bc464155b8b96", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5e800259-51fc-4253-8153-6610aab6703c", "node_type": "1", "metadata": {}, "hash": "420ac33f25a4f59c719c0154bf4fe5211251c6f2da8283476a5e26c6e3b95fd4", "class_name": "RelatedNodeInfo"}}, "text": "The original interval\ncovering problem deals with intervals. This problem deals with sprinklers that have circles of\nin\ufb02uence in a horizontal area rather than simple intervals. We \ufb01rst have to transform/reduce\nthe problem to resemble the standard interval covering problem.\n22The general case of this Load-Balancing problem is actually NP-complete.\n157\n\n3.4.\nGREEDY\nc\u20ddSteven, Felix, Suhendry\nSee Figure 3.10\u2014right side.\nWe can convert these circles and horizontal strips into\nintervals. We can compute dx = sqrt(R2 - (W/2)2). Suppose a circle is centered at (x,\ny). The interval represented by this circle is [x-dx..x+dx]. To see why this works, notice\nthat the additional circle segment beyond dx away from x does not completely cover the\nstrip in the horizontal region it spans. If you have issues with this geometric transformation,\nsee geometry topics in Book 2 which discusses basic operations involving a right triangle.\nNow that we have transformed the original problem into the interval covering problem,\nwe can use the following Greedy algorithm. First, the Greedy algorithm sorts the intervals\nby increasing left endpoint and by decreasing right endpoint if ties arise. Then, the Greedy\nalgorithm processes the intervals one at a time. It takes the interval that covers \u2018as far\nright as possible\u2019 and yet still produces uninterrupted coverage from the leftmost side to the\nrightmost side of the horizontal strip of grass. It ignores intervals that are already completely\ncovered by other (previous) intervals. This is also called as Sweep Line algorithm.\nFor the test case shown in Figure 3.10\u2014left side, this Greedy algorithm \ufb01rst sorts the\nintervals to obtain the sequence {A, B, C, D, E, F, G, H}. Then it processes them one by\none. First, it takes \u2018A\u2019 (it has to), takes \u2018B\u2019 (connected to interval \u2018A\u2019), ignores \u2018C\u2019 (as it is\nembedded inside interval \u2018B\u2019), takes \u2018D\u2019 (it has to, as intervals \u2018B\u2019 and \u2018E\u2019 are not connected\nif \u2018D\u2019 is not used), takes \u2018E\u2019, takes \u2018F\u2019, ignores \u2018G\u2019 (as taking \u2018G\u2019 is not \u2018as far right as\npossible\u2019 and does not reach the rightmost side of the grass strip), takes \u2018H\u2019 (as it connects\nwith interval \u2018F\u2019 and covers more to the right than interval of \u2018G\u2019 does, going beyond the\nrightmost end of the grass strip). In total, we select 6 sprinklers: {A, B, D, E, F, H}. This\nis the minimum possible number of sprinklers for this test case.\nsort(sprinkler, sprinkler+n, cmp);\n// sort the sprinklers\nbool possible = true;\ndouble covered = 0.0;\nint ans = 0;\nfor (int i = 0; (i < n) && possible; ++i) {\nif (covered > l) break;\n// done\nif (sprinkler[i].x_r < covered+EPS) continue; // inside prev interval\nif (sprinkler[i].x_l < covered+EPS) {\n// can cover\ndouble max_r = -1.0;\nint max_id;\nfor (int j = i; (j < n) && (sprinkler[j].x_l < covered+EPS); ++j)\nif (sprinkler[j].x_r > max_r) {\n// go to right to find\nmax_r = sprinkler[j].x_r;\n// interval with\nmax_id = j;\n// the largest coverage\n}\n++ans;\ncovered = max_r;\n// jump here\ni = max_id;\n}\nelse\npossible = false;\n}\nif (!possible || (covered < l)) printf(\"-1\\n\");\nelse\nprintf(\"%d\\n\", ans);\nSource code: ch3/greedy/grass UVa10382.cpp|java|py\n158\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nGreedy (Bipartite) Matching: Kattis - loowater/UVa 11292 - The Dragon of ...\nAbridged problem description: There are n dragon heads and m knights (1 \uf8ffn, m \uf8ff20 000).\nEach dragon head has a diameter and each knight has a height. A dragon head with diameter\nD can be chopped o\u21b5by a knight with height H if D \uf8ffH. A knight can only chop o\u21b5one\ndragon head.", "mimetype": "text/plain", "start_char_idx": 481859, "end_char_idx": 485400, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5e800259-51fc-4253-8153-6610aab6703c": {"__data__": {"id_": "5e800259-51fc-4253-8153-6610aab6703c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9f6f7fca-ffc5-43e3-934c-ffd8477c0b68", "node_type": "1", "metadata": {}, "hash": "a5670dfefc400e6ab7c82d03404b5115cc74de6b87c564f5175d6ef845251a97", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f46dcf2d-6e3b-47d4-9ad0-f9e6b19eed13", "node_type": "1", "metadata": {}, "hash": "e460b48d3ada6f4e62c5e6aea574295c4f9759a131b76cb935492b9d29f4d388", "class_name": "RelatedNodeInfo"}}, "text": "PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nGreedy (Bipartite) Matching: Kattis - loowater/UVa 11292 - The Dragon of ...\nAbridged problem description: There are n dragon heads and m knights (1 \uf8ffn, m \uf8ff20 000).\nEach dragon head has a diameter and each knight has a height. A dragon head with diameter\nD can be chopped o\u21b5by a knight with height H if D \uf8ffH. A knight can only chop o\u21b5one\ndragon head. Given a list of diameters of the dragon heads and a list of heights of the\nknights, is it possible to chop o\u21b5all the dragon heads? If yes, what is the minimum total\nheight of the knights used to chop o\u21b5the dragons\u2019 heads?\nThere are several ways to solve this problem, but we will illustrate one of the easiest.\nThis problem is a bipartite matching problem (this will be discussed in more detail in Section\n4.6.3 and in Book 2), in the sense that we are required to match (pair) knights to dragons in\na minimal cost way (see Figure 3.11\u2014left side, before sorting). However, this problem can\nbe solved greedily: a dragon head with a certain diameter D should be chopped by a knight\nwith the shortest height H such that D \uf8ffH (see Figure 3.11\u2014right side, after sorting).\nFigure 3.11: Kattis - loowater/UVa 11292 - The Dragon of ...\nHowever, the input is given in an arbitrary order. This is frequently done by the problem\nauthors to mask the greedy strategy. If we sort both the array of dragon head diameters head\nand knight heights height in O(n log n + m log m), we can use the following O(max(n, m))\nscan to determine the answer. This is yet another example where sorting the input can help\nproduce the required greedy strategy.\nsort(D.begin(), D.end());\n// sorting is an important\nsort(H.begin(), H.end());\n// pre-processing step\nint gold = 0, d = 0, k = 0;\n// both arrays are sorted\nwhile ((d < n) && (k < m)) {\n// while not done yet\nwhile ((k < m) && (D[d] > H[k])) ++k;\n// find required knight k\nif (k == m) break;\n// loowater is doomed :S\ngold += H[k];\n// pay this amount of gold\n++d; ++k;\n// next dragon & knight\n}\nif (d == n) printf(\"%d\\n\", gold);\n// all dragons are chopped\nelse\nprintf(\"Loowater is doomed!\\n\");\nSource code: ch3/greedy/loowater UVa11292.cpp|java|py|ml\nInvolving Priority Queue: Kattis - ballotboxes/UVa 12390 - Distributing ...\nProblem description: Given N (1 \uf8ffN \uf8ff500K) cities\u2014each city must be assigned at least\none box, the population size ai of each city i (1 \uf8ffai \uf8ff5M)\u2014each person can only vote\nin his/her assigned box in his/her own city, and B ballot boxes (N \uf8ffB \uf8ff2M), distribute\nthese B boxes to N cities so that the maximum number of people assigned to vote in one\nbox is minimized.\nFor example, if we have N = 4 cities with sizes {120, 2680, 3400, 200} and B = 6 ballot\nboxes, we should give {1, 2, 2, 1} boxes to them. This way, the two largest cities can use\n159\n\n3.4.\nGREEDY\nc\u20ddSteven, Felix, Suhendry\ntheir extra boxes to reduce the number of people assigned to vote in one box as follows: {120,\n1340+1340, 1700+1700, 200}. We output 1700 as maximum number of people assigned to\none box in the most e\ufb03cient assignment.\nIt should be clear that we should sort the cities by non-increasing population sizes \ufb01rst.\nThe \ufb01rst extra ballot box should be given to the largest city with population a0 to reduce\nits workload from a0 to a0\n2 . However, how should we give the second extra box?", "mimetype": "text/plain", "start_char_idx": 484998, "end_char_idx": 488318, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f46dcf2d-6e3b-47d4-9ad0-f9e6b19eed13": {"__data__": {"id_": "f46dcf2d-6e3b-47d4-9ad0-f9e6b19eed13", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5e800259-51fc-4253-8153-6610aab6703c", "node_type": "1", "metadata": {}, "hash": "420ac33f25a4f59c719c0154bf4fe5211251c6f2da8283476a5e26c6e3b95fd4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3c75a03b-7b40-4cac-aafd-9404b1e6f6a4", "node_type": "1", "metadata": {}, "hash": "8769a7ea7d195aa64d1ab10cd5e909b183233828d7a3a6c780439f5415caf295", "class_name": "RelatedNodeInfo"}}, "text": "This way, the two largest cities can use\n159\n\n3.4.\nGREEDY\nc\u20ddSteven, Felix, Suhendry\ntheir extra boxes to reduce the number of people assigned to vote in one box as follows: {120,\n1340+1340, 1700+1700, 200}. We output 1700 as maximum number of people assigned to\none box in the most e\ufb03cient assignment.\nIt should be clear that we should sort the cities by non-increasing population sizes \ufb01rst.\nThe \ufb01rst extra ballot box should be given to the largest city with population a0 to reduce\nits workload from a0 to a0\n2 . However, how should we give the second extra box? If the \ufb01rst\ncity has a0 has more than twice size than a1, we should actually give another ballot box to\nthe \ufb01rst city to further reduce its workload from a0\n2 to a0\n3 . But what if a0 > 3 \u21e5a1?\nBy now we should realize that this greedy process has to actually be simulated as the\nbox ratio information in a certain city i keeps changing as we give more box(es) to city\ni. If we keep re-sorting these ratios of the N cities, we will get TLE as N is up to 500K.\nHowever, there is a data structure that allows us to maintain dynamic ordering of the N\ncities: Priority Queue (see Section 2.3.1 or Section 2.3.3). The simple greedy-based Priority\nQueue simulation is as follows:\ntypedef tuple<double, int, int> dii;\n// (ratio r, num, den)\n// inside int main()\npriority_queue<dii> pq;\n// max pq\nfor (int i = 0; i < N; ++i) {\nint a; scanf(\"%d\", &a);\npq.push({(double)a/1.0, a, 1});\n// initially, 1 box/city\n}\nB -= N;\n// remaining boxes\nwhile (B--) {\n// extra box->largest city\nauto [r, num, den] = pq.top(); pq.pop();\n// current largest city\npq.push({num/(den+1.0), num, den+1});\n// reduce its workload\n}\nprintf(\"%d\\n\", (int)ceil(get<0>(pq.top())));\n// the final answer\n} // all other cities in the max pq will have equal or lesser ratio\nNotice that Prim\u2019s (in Section 4.3) and Dijkstra\u2019s (in Section 4.4) algorithms are essentially\ngreedy algorithms using Priority Queue too.\nSource code: ch3/greedy/ballotboxes UVa12390.cpp|py (BSTA)\nExercise 3.4.1.1*: Which of the following sets of coins (all in cents) are solvable using the\ngreedy \u2018coin change\u2019 algorithm discussed in this section? If the greedy algorithm fails on a\ncertain set of coin denominations, determine the smallest counter example V cents on which\nit fails to be optimal. See [46] for more details about \ufb01nding such counter examples.\n1. S1 = {10, 7, 5, 4, 1}\n2. S2 = {64, 32, 16, 8, 4, 2, 1}\n3. S3 = {13, 11, 7, 5, 3, 2, 1}\n4. S4 = {7, 6, 5, 4, 3, 2, 1}\n5. S5 = {21, 17, 11, 10, 1}\n160\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nExercise 3.4.1.2*: There is an alternative (faster) solution for Kattis - ballotboxes/UVa\n12390 - Distributing Ballot Boxes using Binary Search the Answer (BSTA) discussed in Sec-\ntion 3.3.1. Study ch3/greedy/ballotboxes UVa12390 bsta.py for this alternative solution!\nExercise 3.4.1.3*: Another classic Greedy algorithm that uses Priority Queue in its im-\nplementation is the Hu\u21b5man Code [5, 35] construction algorithm. Study this algorithm and\ntry to solve Kattis - weather (it is Hu\u21b5man Code plus some Mathematics techniques)!", "mimetype": "text/plain", "start_char_idx": 487754, "end_char_idx": 490856, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3c75a03b-7b40-4cac-aafd-9404b1e6f6a4": {"__data__": {"id_": "3c75a03b-7b40-4cac-aafd-9404b1e6f6a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f46dcf2d-6e3b-47d4-9ad0-f9e6b19eed13", "node_type": "1", "metadata": {}, "hash": "e460b48d3ada6f4e62c5e6aea574295c4f9759a131b76cb935492b9d29f4d388", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "50e0a2be-b209-4d61-9e8e-c0265ccf1eb8", "node_type": "1", "metadata": {}, "hash": "e47f4363b9faf32362c59a081b39c2e79ecbf75613ae31358a9f805eb7b2a74b", "class_name": "RelatedNodeInfo"}}, "text": "S5 = {21, 17, 11, 10, 1}\n160\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nExercise 3.4.1.2*: There is an alternative (faster) solution for Kattis - ballotboxes/UVa\n12390 - Distributing Ballot Boxes using Binary Search the Answer (BSTA) discussed in Sec-\ntion 3.3.1. Study ch3/greedy/ballotboxes UVa12390 bsta.py for this alternative solution!\nExercise 3.4.1.3*: Another classic Greedy algorithm that uses Priority Queue in its im-\nplementation is the Hu\u21b5man Code [5, 35] construction algorithm. Study this algorithm and\ntry to solve Kattis - weather (it is Hu\u21b5man Code plus some Mathematics techniques)!\n3.4.2\nGreedy Algorithm in Programming Contests\nIn this section, we have discussed a few classical problems solvable with Greedy algorithms:\nCoin Change (the special case), Load Balancing (the special case shown in this section),\nInterval Covering, Greedy Bipartite Matching, and Greedy Algorithm involving Priority\nQueue. For these classical problems, it is helpful to memorize their solutions (for this case,\nignore that we have said earlier in the chapter about not relying too much on memorization).\nWe have also discussed an important problem solving strategy usually applicable to greedy\nproblems: sorting the (static) input data or using Priority Queue to maintain the ordering\nof (dynamic) input data to elucidate hidden greedy strategies.\nThere are two other classical examples of Greedy algorithms in this book, e.g., Kruskal\u2019s\n(sorting static list of edges) plus Prim\u2019s (dynamic ordering of edges using Priority Queue)\nalgorithms for the Minimum Spanning Tree (MST) problem (see Section 4.3) and Dijkstra\u2019s\n(dynamic ordering of vertices based on increasing shortest path values using Priority Queue)\nalgorithm for the Single-Source Shortest Paths (SSSP) problem (see Section 4.4.3). There\nare many more known Greedy algorithms that we do not discuss in this book as they are too\n\u2018problem speci\ufb01c\u2019 and rarely appear in programming contests, e.g., Hu\u21b5man Code [5, 35],\nFractional Knapsack [5, 35], some Job Scheduling problems, etc.\nHowever, today\u2019s programming contests (both IOI and ICPC) rarely involve the purely\ncanonical versions of these classical problems. Using Greedy algorithms to attack a \u2018non\nclassical\u2019 problem is usually risky. A Greedy algorithm will normally not encounter the TLE\nresponse as it is often lightweight, but instead tends to obtain WA verdicts23. Proving that a\ncertain \u2018non classical\u2019 problem has optimal sub-structure and greedy property during contest\ntime may be di\ufb03cult or time consuming, so a competitive programmer should usually use\nthis rule of thumb:\nIf the input size is \u2018small enough\u2019 to accommodate the time complexity of either Complete\nSearch or Dynamic Programming approaches (see Section 3.5), then use these approaches\nas both will ensure a correct answer. Only use a Greedy algorithm if the input size given in\nthe problem statement are too large even for the best Complete Search or DP algorithm.\nHaving said that, it is increasingly true that problem authors try to set the input bounds\nof problems that allow for Greedy strategies to be in an ambiguous range so that contestants\ncannot use the input size to quickly determine the required algorithm!\nWe have to remark that it is quite challenging to come up with new \u2018non classical\u2019\nGreedy problems. Therefore, the number of such novel Greedy problems used in competitive\nprogramming is lower than that of Complete Search or Dynamic Programming problems.\nThis strengthen our tips above on memorizing the solutions for some of the classical problems\nsolvable with Greedy algorithms.\n23Note that there is no wrong answer submission penalty in the IOI. If the greedy idea does not take too\nlong to code, it may be bene\ufb01cial to just test the greedy idea by simply coding and then submitting your\nimplementation to the judging system.\n161\n\n3.4.\nGREEDY\nc\u20ddSteven, Felix, Suhendry\nStarred programming exercises solvable using Greedy algorithm24:\n\u2022 Classical\n1. Entry Level: UVa 10020 - Minimal Coverage * (interval covering)\n2. UVa 01193 - Radar Install... * (LA 2519 - Beijing02; interval covering)\n3. UVa 11264 - Coin Collector * (coin change variant)\n4. UVa 12321 - Gas Station * (interval covering)\n5.", "mimetype": "text/plain", "start_char_idx": 490234, "end_char_idx": 494465, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "50e0a2be-b209-4d61-9e8e-c0265ccf1eb8": {"__data__": {"id_": "50e0a2be-b209-4d61-9e8e-c0265ccf1eb8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3c75a03b-7b40-4cac-aafd-9404b1e6f6a4", "node_type": "1", "metadata": {}, "hash": "8769a7ea7d195aa64d1ab10cd5e909b183233828d7a3a6c780439f5415caf295", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "df1cae18-e5c4-4c8c-a057-f3acfed248d5", "node_type": "1", "metadata": {}, "hash": "4984dc1ab63fe52e4d5b5c48a605350d8ac5be9b0f42ad6115123a0f4507d578", "class_name": "RelatedNodeInfo"}}, "text": "This strengthen our tips above on memorizing the solutions for some of the classical problems\nsolvable with Greedy algorithms.\n23Note that there is no wrong answer submission penalty in the IOI. If the greedy idea does not take too\nlong to code, it may be bene\ufb01cial to just test the greedy idea by simply coding and then submitting your\nimplementation to the judging system.\n161\n\n3.4.\nGREEDY\nc\u20ddSteven, Felix, Suhendry\nStarred programming exercises solvable using Greedy algorithm24:\n\u2022 Classical\n1. Entry Level: UVa 10020 - Minimal Coverage * (interval covering)\n2. UVa 01193 - Radar Install... * (LA 2519 - Beijing02; interval covering)\n3. UVa 11264 - Coin Collector * (coin change variant)\n4. UVa 12321 - Gas Station * (interval covering)\n5. Kattis - classrooms * (variant of interval covering; multiple rooms)\n6. Kattis - froshweek2 * (sort; similar to UVa 11292; greedy bipartite matching)\n7. Kattis - squarepegs * (convert square to circular; sort; greedy matching)\nExtra UVa: 00410, 10249, 11389, 12210, 12405.\nExtra Kattis: avoidland, color, \ufb01shmongers, grass, in\ufb02ation, intervalcover,\nloowater, messages.\nExtra: IOI 2011 - Elephants (greedy solution up to subtask 3).\n\u2022 Involving Sorting (Or The Input Is Already Sorted), Easier\n1. Entry Level: UVa 11369 - Shopaholic *\n2. UVa 11729 - Commando War *\n3. UVa 11900 - Boiled Eggs *\n4. UVa 13109 - Elephants *\n5. Kattis - icpcteamselection *\n6. Kattis - minimumscalar *\n7. Kattis - shopaholic *\nExtra UVa: 10763, 10785, 11269, 12485, 13031.\nExtra Kattis: acm2 aprizenoonecanwin, akcija, fallingapart, fridge, gettowork,\npikemaneasy, planetaris, plantingtrees, redistribution, standings, textmessag-\ning, woodcutting.\n\u2022 Involving Sorting (Or The Input Is Already Sorted), Harder\n1. Entry Level: UVa 12673 - Football * (LA 6530 - LatinAmerica13)\n2. UVa 10026 - Shoemaker\u2019s Problem *\n3. UVa 12834 - Extreme Terror *\n4. UVa 13054 - Hippo Circus *\n5. Kattis - airconditioned *\n6. Kattis - birds *\n7. Kattis - delivery *\nExtra UVa: 10037.\nExtra Kattis: andrewant, ceremony, dasort, fairdivision, help, intergalac-\nticbidding, trip2007, w\u21b5nproof.\n24Hints other than the classical ones are omitted to keep the problems interesting as many greedy problems\nbecame just an implementation exercises after their greedy strategies are revealed.\n162\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\n\u2022 Involving Priority Queue\n1. Entry Level: Kattis - ballotboxes * (also available at UVa 12390 - Distributing\nBallot Boxes)\n2. UVa 01153 - Keep the Customer ... *\n3. UVa 10954 - Add All *\n4. UVa 13177 - Orchestral scores *\n5. Kattis - canvas *\n6. Kattis - vegetables *\n7. Kattis - workstations *\nExtra Kattis: convoy, entertainmentbox, simpli\ufb01cation.\n\u2022 Non Classical, Easier\n1. Entry Level: UVa 10656 - Maximum Sum (II) *\n2. UVa 10340 - All in All *\n3. UVa 11520 - Fill the Square *\n4. UVa 12482 - Short Story Competition *\n5. Kattis - ants * (also available at UVa 10714 - Ants)\n6. Kattis - bank *\n7. Kattis - marblestree * (also available at UVa 10672 - Marbles on a tree)\nExtra UVa: 10152, 10440, 10602, 10700, 11054, 11532.", "mimetype": "text/plain", "start_char_idx": 493723, "end_char_idx": 496802, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "df1cae18-e5c4-4c8c-a057-f3acfed248d5": {"__data__": {"id_": "df1cae18-e5c4-4c8c-a057-f3acfed248d5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "50e0a2be-b209-4d61-9e8e-c0265ccf1eb8", "node_type": "1", "metadata": {}, "hash": "e47f4363b9faf32362c59a081b39c2e79ecbf75613ae31358a9f805eb7b2a74b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1592a926-e773-47a5-b542-8e4892271326", "node_type": "1", "metadata": {}, "hash": "ed5acb25cd4d1777ce23a69e47a4ddfd0362e6f31f29d297d457204cc222731f", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - canvas *\n6. Kattis - vegetables *\n7. Kattis - workstations *\nExtra Kattis: convoy, entertainmentbox, simpli\ufb01cation.\n\u2022 Non Classical, Easier\n1. Entry Level: UVa 10656 - Maximum Sum (II) *\n2. UVa 10340 - All in All *\n3. UVa 11520 - Fill the Square *\n4. UVa 12482 - Short Story Competition *\n5. Kattis - ants * (also available at UVa 10714 - Ants)\n6. Kattis - bank *\n7. Kattis - marblestree * (also available at UVa 10672 - Marbles on a tree)\nExtra UVa: 10152, 10440, 10602, 10700, 11054, 11532.\nExtra Kattis: applesack, driver, haybales, horror\ufb01lmnight, pripreme, simplic-\nity, skocimis, teacherevaluation.\n\u2022 Non Classical, Harder\n1. Entry Level: UVa 11491 - Erasing and Winning *\n2. UVa 10821 - Constructing BST *\n3. UVa 11583 - Alien DNA *\n4. UVa 11890 - Calculus Simpli\ufb01ed *\n5. Kattis - dvds *\n6. Kattis - stockbroker *\n7. Kattis - virus *\nExtra UVa: 00311, 00668, 10718, 10982, 11157, 11230, 11240, 11330, 11335,\n11567, 12124, 12516, 13082.\nExtra Kattis: cardtrading, logland, playground. wordspin.\nAlso see some greedy Prim\u2019s/Kruskal\u2019s algorithm to solve the Minimum\nSpanning Tree problem (Section 4.3.2 and 4.3.3), and greedy Dijkstra\u2019s al-\ngorithm to solve the Single-Source Shortest Paths problem (Section 4.4.3).\n163\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\n3.5\nDynamic Programming\nDynamic Programming (from now on abbreviated as DP) is perhaps the most challenging\nproblem-solving technique among the four paradigms discussed in this chapter. Thus, make\nsure that you have mastered the material mentioned in the previous chapters/sections before\nreading this section. Also, prepare to see lots of recursions and recurrence relations!\nThe key skills that you have to develop in order to master DP are the abilities to determine\nthe problem states and to determine the relationships or transitions between the current\nproblem and its sub-problems. We have used these skills earlier in recursive backtracking\n(see Section 3.2.2). In fact, DP problems with small input size constraints may already be\nsolvable with recursive backtracking25.\nIf you are new to the DP technique, you can start by assuming that (the \u2018top-down\u2019) DP\nis a kind of \u2018intelligent\u2019 or \u2018faster\u2019 recursive backtracking. In this section, we will explain the\nreasons why DP is often faster than recursive backtracking for problems amenable to it.\nDP is primarily26 used to solve optimization problems and counting problems. If you\nencounter a problem that says \u201cminimize this\u201d or \u201cmaximize that\u201d or \u201ccount the ways to\ndo that\u201d, then there is a (high) chance that it is a DP problem. Most DP problems in\nprogramming contests only ask for the optimal/total value and not the optimal solution\nitself, which often makes the problem easier to solve by removing the need to backtrack and\nproduce the solution. However, some harder DP problems also require the optimal solution\nto be returned in some fashion. We will continually re\ufb01ne our understanding of DP in this\nsection. Later in Book 2, we will learn a bit more about some of these DP solutions in the\ncontext of NP-hard/complete problems.\n3.5.1\nDP Illustration\nWe will illustrate the concept of Dynamic Programming with an example problem: UVa\n11450 - Wedding Shopping. Abridged problem statement: Given di\u21b5erent options for each\ngarment (e.g., 3 shirt models, 2 belt models, 4 shoe models, . . . )\nand a certain limited\nbudget, our task is to buy one model of each garment. We cannot spend more money than\nthe given budget, but we want to spend the maximum possible amount.", "mimetype": "text/plain", "start_char_idx": 496301, "end_char_idx": 499819, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1592a926-e773-47a5-b542-8e4892271326": {"__data__": {"id_": "1592a926-e773-47a5-b542-8e4892271326", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "df1cae18-e5c4-4c8c-a057-f3acfed248d5", "node_type": "1", "metadata": {}, "hash": "4984dc1ab63fe52e4d5b5c48a605350d8ac5be9b0f42ad6115123a0f4507d578", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e3805032-ebeb-4017-841f-772afe7d80da", "node_type": "1", "metadata": {}, "hash": "cc91cd9cdb8201bceb220c1b64117d757b28b32f03402e2e846a03f408ec7d8e", "class_name": "RelatedNodeInfo"}}, "text": "However, some harder DP problems also require the optimal solution\nto be returned in some fashion. We will continually re\ufb01ne our understanding of DP in this\nsection. Later in Book 2, we will learn a bit more about some of these DP solutions in the\ncontext of NP-hard/complete problems.\n3.5.1\nDP Illustration\nWe will illustrate the concept of Dynamic Programming with an example problem: UVa\n11450 - Wedding Shopping. Abridged problem statement: Given di\u21b5erent options for each\ngarment (e.g., 3 shirt models, 2 belt models, 4 shoe models, . . . )\nand a certain limited\nbudget, our task is to buy one model of each garment. We cannot spend more money than\nthe given budget, but we want to spend the maximum possible amount.\nThe input consists of two integers 1 \uf8ffM \uf8ff200 and 1 \uf8ffC \uf8ff20, where M is the budget\nand C is the number of garments that you have to buy, followed by some information about\nthe C garments. For the garment g 2 [0..C-1], we will receive an integer 1 \uf8ffK \uf8ff20\nwhich indicates the number of di\u21b5erent models there are for that garment g, followed by K\nintegers indicating the price of each model 2 [1..K] of that garment g.\nThe output is one integer that indicates the maximum amount of money we can spend\npurchasing one of each garment without exceeding the budget. If there is no solution due to\nthe small budget given to us, then simply print \u201cno solution\u201d.\nSuppose we have the following test case A with M = 20, C = 3:\nPrice of the 3 models of garment g = 0 ! 6 4 8 // the prices are not sorted in the input\nPrice of the 2 models of garment g = 1 ! 5 10\nPrice of the 4 models of garment g = 2 ! 1 5 3 5\nFor this test case, the answer is 19, which may result from buying the underlined items\n(8+10+1). This is not unique, as solutions (6+10+3) and (4+10+5) are also optimal.\n25If the intended solution is DP, (a good) problem author will usually set large enough constraints so that\na (heavily optimized) recursive backtracking solution (in a fast programming language like C++) still gets\nthe TLE verdict.\n26But DP can also be the solution for a yes/no decision problem too.\n164\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nHowever, suppose we have this test case B with M = 9 (limited budget), C = 3:\nPrice of the 3 models of garment g = 0 ! 6 4 8\nPrice of the 2 models of garment g = 1 ! 5 10\nPrice of the 4 models of garment g = 2 ! 1 5 3 5\nThe answer is then \u201cno solution\u201d because even if we buy all the cheapest models for each\ngarment, the total price (4+5+1) = 10 still exceeds our given budget M = 9.\nIn order for us to appreciate the usefulness of Dynamic Programming in solving the\nabove-mentioned problem, let\u2019s explore how far the other approaches discussed earlier will\nget us in this particular problem.\nApproach 1: Greedy (Wrong Answer)\nSince we want to maximize the budget spent (budget b = M initially), one greedy idea (there\nare other greedy approaches\u2014which are also WA) is to take the most expensive model for\neach garment g which still \ufb01ts our budget. For example in test case A above, we can choose\nthe most expensive model 3 of garment g = 0 with price 8 (b is now 20-8 = 12), then choose\nthe most expensive model 2 of garment g = 1 with price 10 (b = 12-10 = 2), and \ufb01nally\nfor the last garment g = 2, we can only choose model 1 with price 1 as the budget b we\nhave left does not allow us to buy the other models with price 3 or 5. This greedy strategy\n\u2018works\u2019 for test cases A and B above and produces the same optimal solution (8+10+1) =\n19 and \u201cno solution\u201d, respectively. It also runs very fast27: 20 + 20 + . . .", "mimetype": "text/plain", "start_char_idx": 499098, "end_char_idx": 502675, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e3805032-ebeb-4017-841f-772afe7d80da": {"__data__": {"id_": "e3805032-ebeb-4017-841f-772afe7d80da", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1592a926-e773-47a5-b542-8e4892271326", "node_type": "1", "metadata": {}, "hash": "ed5acb25cd4d1777ce23a69e47a4ddfd0362e6f31f29d297d457204cc222731f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5320215f-7cb1-479e-8f0a-98d19b52685e", "node_type": "1", "metadata": {}, "hash": "78a0e2c24f8b15e02a40cd49eaef5488d615ad652aa6a48db591ed77a3af533a", "class_name": "RelatedNodeInfo"}}, "text": "For example in test case A above, we can choose\nthe most expensive model 3 of garment g = 0 with price 8 (b is now 20-8 = 12), then choose\nthe most expensive model 2 of garment g = 1 with price 10 (b = 12-10 = 2), and \ufb01nally\nfor the last garment g = 2, we can only choose model 1 with price 1 as the budget b we\nhave left does not allow us to buy the other models with price 3 or 5. This greedy strategy\n\u2018works\u2019 for test cases A and B above and produces the same optimal solution (8+10+1) =\n19 and \u201cno solution\u201d, respectively. It also runs very fast27: 20 + 20 + . . . + 20 operations\nin the worst case, i.e., 20 \u21e520 = 400, a small number. However, this greedy strategy does\nnot work for many other test cases, such as this counter-example28 below (test case C):\nTest case C with M = 12, C = 3:\n3 models of garment g = 0 ! 6 4 8\n2 models of garment g = 1 ! 5 10\n4 models of garment g = 2 ! 1 5 3 5\nThe Greedy strategy selects model 3 of garment g = 0 with price 8 (b = 12-8 = 4), causing\nus to not have enough budget to buy any model in garment g = 1, thus incorrectly reporting\n\u201cno solution\u201d. One optimal solution is 4+5+3 = 12, which uses up all of our budget. The\noptimal solution is not unique as 6+5+1 = 12 also depletes the budget.\nApproach 2: Divide and Conquer (Wrong Answer)\nThis problem is not solvable using the Divide and Conquer paradigm. This is because the\nsub-problems (explained in the Complete Search sub-section below) are not independent.\nTherefore, we cannot solve them separately with the Divide and Conquer approach.\nApproach 3: Complete Search (Time Limit Exceeded)\nNext, let\u2019s see if Complete Search (recursive backtracking) can solve this problem. One\nway to use recursive backtracking in this problem is to write a function dp(g, b) with two\nparameters: the current garment g that we are dealing with and the current (remaining)\nbudget b that we have. This function returns the required answer. The pair (g, b) is the\nstate of this problem. Note that the order of parameters does not matter, e.g., (b, g) is\nalso a perfectly valid state. Later in Section 3.5.3, we will see more discussion on how to\nselect appropriate states for a problem.\n27We do not need to sort the prices just to \ufb01nd the model with the maximum price as there are only up\nto K \uf8ff20 models. An O(K) scan is enough. However, if the constraints are bigger, it may be bene\ufb01cial to\nsort the prices in descending order to give us early pruning possibilities.\n28To prove that a Greedy algorithm is incorrect, we just need to \ufb01nd one counter-example.\n165\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nWe start with garment g = 0 (\ufb01rst garment) and b = M (the initial budget). Then, we\ntry all possible models in garment g = 0 (a maximum of 20 models). If model i is chosen, we\nsubtract model i\u2019s price from b, then repeat the process in a recursive fashion with garment\ng = 1 (which can also have up to 20 models), etc. We stop when the model for the last\ngarment g = C-1 has been chosen. If remaining budget b < 0 before we choose a model\nfrom garment g = C-1, we can prune the infeasible solution. Among all valid combinations,\nwe can then pick the one that results in the smallest non-negative b. This maximizes the\nbudget spent, which is (M-b).\nWe can formally de\ufb01ne these Complete Search recurrences (transitions) as follows:\n1. If b < 0 (i.e., the remaining budget goes negative),\ndp(g, b) = \u22121 (in practice, we can just return a large negative value)\n2. If a model from the last garment has been bought, that is, g = C,\ndp(g, b) = M-b (this is the actual budget that we spent)\n3.", "mimetype": "text/plain", "start_char_idx": 502107, "end_char_idx": 505688, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5320215f-7cb1-479e-8f0a-98d19b52685e": {"__data__": {"id_": "5320215f-7cb1-479e-8f0a-98d19b52685e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e3805032-ebeb-4017-841f-772afe7d80da", "node_type": "1", "metadata": {}, "hash": "cc91cd9cdb8201bceb220c1b64117d757b28b32f03402e2e846a03f408ec7d8e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a5957a05-1510-4b01-a59b-1e7b2ff465f8", "node_type": "1", "metadata": {}, "hash": "b07325a1864d7d132fcbf473c7520f9d1b5761774c704243ffd012976d22da61", "class_name": "RelatedNodeInfo"}}, "text": "We stop when the model for the last\ngarment g = C-1 has been chosen. If remaining budget b < 0 before we choose a model\nfrom garment g = C-1, we can prune the infeasible solution. Among all valid combinations,\nwe can then pick the one that results in the smallest non-negative b. This maximizes the\nbudget spent, which is (M-b).\nWe can formally de\ufb01ne these Complete Search recurrences (transitions) as follows:\n1. If b < 0 (i.e., the remaining budget goes negative),\ndp(g, b) = \u22121 (in practice, we can just return a large negative value)\n2. If a model from the last garment has been bought, that is, g = C,\ndp(g, b) = M-b (this is the actual budget that we spent)\n3. In general case, 8 model 2 [1..k] of current garment g,\ndp(g, b) = max(dp(g+1, b-price[g][model]))\nWe want to maximize this value (Recall that the invalid ones have large negative value)\nThis solution works correctly, but it is very slow! Let\u2019s analyze the worst case time com-\nplexity. In the largest test case, garment g = 0 has up to 20 models; garment g = 1 also\nhas up to 20 models and all garments including the last garment g = 19 also have up to 20\nmodels. Therefore, this Complete Search runs in 20 \u21e520 \u21e5. . . \u21e520 operations in the worst\ncase, i.e., 2020 \u21e11026, a very large number. If we can only come up with this Complete\nSearch solution, we cannot solve this problem.\nApproach 4: Top-Down DP (Accepted)\nTo solve this problem, we have to use the DP concept as this problem satis\ufb01es the two\nprerequisites for DP to be applicable:\n1. This problem has optimal sub-structures29.\nThis is illustrated in the third Complete Search recurrence above: the solution for the\nsub-problem is part of the solution of the original problem. In other words, if we select\nmodel i for garment g = 0, for our \ufb01nal selection to be optimal, our choice for garments\ng = 1 and above must also be the optimal choice for a reduced budget of M-price,\nwhere price refers to the price of model i.\n2. This problem has overlapping sub-problems.\nThis is the key characteristic of DP! The search space of this problem is not as big as\nthe rough 2020 bound obtained earlier because many sub-problems are overlapping!\nLet\u2019s verify if this problem indeed has overlapping sub-problems. Suppose that there are 2\nmodels in a certain garment g with the same price p. Then, a Complete Search will move\nto the same sub-problem dp(g+1, b-p) after picking either model! This situation will also\noccur if some combination of b and chosen model\u2019s price causes b1-p1 = b2-p2 at the same\ngarment g. This will\u2014in a Complete Search solution\u2014cause the same sub-problem to be\ncomputed more than once, an ine\ufb03cient state of a\u21b5airs!\nSo, how many distinct sub-problems (a.k.a. states in DP terminology) are there in this\nproblem? There are only 20 possible values for the garment g (0 to 19 inclusive) and 201\n29Optimal sub-structures are also required for Greedy algorithms to work, but this problem lacks the\n\u2018greedy property\u2019, making it unsolvable with the Greedy algorithm.\n166\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\npossible values for b (0 to 200 inclusive). Thus there are only 201 \u21e520 = 4020 distinct\nsub-problems. Each sub-problem just needs to be computed once. If we can ensure this, we\ncan solve this problem much faster.\nThe implementation of this DP solution is surprisingly simple. If we already have the re-\ncursive backtracking solution (see the recurrences\u2014a.k.a. transitions in DP terminology\u2014\nshown in the Complete Search approach above), we can implement the top-down DP by\nadding these two additional steps:\n1. We add an e\ufb03cient data structure to map states to values. For most DP problems,\nsuch data structure is a (multi-dimensional) array that have dimensions corresponding\nto the problem states, called the DP memo table.", "mimetype": "text/plain", "start_char_idx": 505022, "end_char_idx": 508817, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a5957a05-1510-4b01-a59b-1e7b2ff465f8": {"__data__": {"id_": "a5957a05-1510-4b01-a59b-1e7b2ff465f8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5320215f-7cb1-479e-8f0a-98d19b52685e", "node_type": "1", "metadata": {}, "hash": "78a0e2c24f8b15e02a40cd49eaef5488d615ad652aa6a48db591ed77a3af533a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6536fe42-1b76-4d6f-9030-34c29459e4ae", "node_type": "1", "metadata": {}, "hash": "a89fddd5d349ad087e66249e3a5161c6610cc31b24cedfb676f09efddd2cb2a8", "class_name": "RelatedNodeInfo"}}, "text": "PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\npossible values for b (0 to 200 inclusive). Thus there are only 201 \u21e520 = 4020 distinct\nsub-problems. Each sub-problem just needs to be computed once. If we can ensure this, we\ncan solve this problem much faster.\nThe implementation of this DP solution is surprisingly simple. If we already have the re-\ncursive backtracking solution (see the recurrences\u2014a.k.a. transitions in DP terminology\u2014\nshown in the Complete Search approach above), we can implement the top-down DP by\nadding these two additional steps:\n1. We add an e\ufb03cient data structure to map states to values. For most DP problems,\nsuch data structure is a (multi-dimensional) array that have dimensions corresponding\nto the problem states, called the DP memo table. This way, we can use fast O(1) array\nindexing to quickly30 map a state to a corresponding cell in the array. We initialize\nthis memo table with dummy values that are not used in the problem, e.g., -131.\n2. At the start of the recursive function, check if this state has been computed before.\n(a) If it has, we simply return the value from the DP memo table, O(1) using fast\narray indexing. This is the origin of the term \u2018memoization\u2019.\n(b) If it has not been computed before, perform the computation as per normal (only\nonce) and then store the computed value in the DP memo table (also in O(1) using\nfast array indexing) so that further calls to this sub-problem (state) can return\nwith the (same) answer immediately.\nAnalyzing a basic32 DP solution is easy. If it has M distinct states, then it requires O(M)\nmemory space. If computing one state (the complexity of the DP transition) requires O(k)\nsteps, then the overall time complexity is O(Mk) as DP guarantees that each state is com-\nputed just once. This UVa 11450 problem has M = 20\u21e5201 = 4020 and k = 20 (as we have\nto iterate through at most 20 models for each garment g). Thus, the time complexity is at\nmost 4020 \u21e520 = 80 400 operations per test case, a very manageable calculation33.\nWe display our code below for illustration, especially for those who have never coded a\ntop-down DP algorithm before. Scrutinize this code and verify that it is indeed very similar\nto the recursive backtracking code that you have seen in Section 3.2.\n// UVa 11450 - Wedding Shopping - Top Down\n// this code is similar to recursive backtracking code\n// parts of the code specific to top-down DP are commented with: \u2018TOP-DOWN\u2019\n// if these lines are commented, this top-down DP will become backtracking!\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_gm = 30; // up to 20 garments at most and 20 models/garment\nconst int MAX_M = 210; // maximum budget is 200\n30Also see Book 2 for alternative data structures that can be used for this purpose.\n31For C/C++ users, we can use memset(memo, -1, sizeof memo); in <cstring> to initialize the con-\ntent of array memo to all -1, regardless of its dimensions. Note that to avoid unnecessary bug, please use\nmemset only with special initialization values, like -1 (for typical DP memo table) or 0 (to clear all values).\nRead the documentation of memset to learn what this function actually does. For C++ users, note that\nwe can use vector construction method like vector<int> memo(n, -1); but it is harder to do so for\nmultidimensional vector.\n32Basic means \u201cwithout fancy optimizations that we will see later in this section and in Book 2\u201d.\n33This UVa 11450 is a rather old problem. In modern programming competitions, usually DP problems\nwill have Mk close to 100M.\n167\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nint M, C, price[MAX_gm][MAX_gm];\n// g < 20 and k <= 20\nint memo[MAX_gm][MAX_M];\n// g < 20 and b <= 200\nint dp(int g, int b) {\nif (b < 0) return -1e9;\n// fail, return -ve number\nif (g == C) return M-b;\n// we are done\n// if the line below is commented, top-down DP will become backtracking!!", "mimetype": "text/plain", "start_char_idx": 508039, "end_char_idx": 511928, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6536fe42-1b76-4d6f-9030-34c29459e4ae": {"__data__": {"id_": "6536fe42-1b76-4d6f-9030-34c29459e4ae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a5957a05-1510-4b01-a59b-1e7b2ff465f8", "node_type": "1", "metadata": {}, "hash": "b07325a1864d7d132fcbf473c7520f9d1b5761774c704243ffd012976d22da61", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f4c68d10-8304-4201-9740-ed93244612aa", "node_type": "1", "metadata": {}, "hash": "c04dc0d127a602dfbfa45c45cd5c8232b412643a4fdd6b7030bef217c12bcef6", "class_name": "RelatedNodeInfo"}}, "text": "32Basic means \u201cwithout fancy optimizations that we will see later in this section and in Book 2\u201d.\n33This UVa 11450 is a rather old problem. In modern programming competitions, usually DP problems\nwill have Mk close to 100M.\n167\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nint M, C, price[MAX_gm][MAX_gm];\n// g < 20 and k <= 20\nint memo[MAX_gm][MAX_M];\n// g < 20 and b <= 200\nint dp(int g, int b) {\nif (b < 0) return -1e9;\n// fail, return -ve number\nif (g == C) return M-b;\n// we are done\n// if the line below is commented, top-down DP will become backtracking!!\nif (memo[g][b] != -1) return memo[g][b];\n// TOP-DOWN: memoization\nint ans = -1;\n// start with a -ve number\nfor (int k = 1; k <= price[g][0]; ++k)\n// try each model k\nans = max(ans, dp(g+1, b-price[g][k]));\nreturn memo[g][b] = ans;\n// TOP-DOWN: memoize ans\n}\nint main() {\n// easy to code\nint TC; scanf(\"%d\", &TC);\nwhile (TC--) {\nscanf(\"%d %d\", &M, &C);\nfor (int g = 0; g < C; ++g) {\nscanf(\"%d\", &price[g][0]);\n// store k in price[g][0]\nfor (int k = 1; k <= price[g][0]; ++k)\nscanf(\"%d\", &price[g][k]);\n}\nmemset(memo, -1, sizeof memo);\n// TOP-DOWN: init memo\nif (dp(0, M) < 0) printf(\"no solution\\n\");\n// start the top-down DP\nelse\nprintf(\"%d\\n\", dp(0, M));\n}\nreturn 0;\n}\nWe want to take this opportunity to illustrate another style used in implementing DP solu-\ntions (only applicable for C/C++ users). Instead of frequently addressing a certain cell in\nthe memo table, we can use a local reference (or alias) variable to store the memory address\nof the required cell in the memo table as shown below. The two coding styles are not very\ndi\u21b5erent, and it is up to you to decide which style you prefer.\nint dp(int g, b) {\nif (b < 0) return -1e9;\n// must check this first\nif (g == C) return M-b;\n// budget can\u2019t be < 0\nint &ans = memo[g][b];\n// remember memory address\nif (ans != -1) return ans;\nfor (int k = 1; k <= price[g][0]; ++k)\n// try each model k\nans = max(ans, dp(g+1, b-price[g][k]));\nreturn ans;\n// ans == memo[g][b]\n}\nSource code: ch3/dp/UVa11450 td.cpp|java|py|ml\n168\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nApproach 5: Bottom-Up DP (Accepted)\nThere is another way to implement a DP solution often referred to as the bottom-up DP.\nThis is actually the \u2018true form\u2019 of DP as DP was originally known as the \u2018tabular method\u2019\n(computation technique involving a table). The basic steps to build a bottom-up DP solution\nare as follows:\n1. Determine the required set of parameters that uniquely describe the problem (the\nstate). This step is similar to what we have discussed in recursive backtracking and\ntop-down DP earlier.\n2. If there are N parameters required to represent the states, prepare an N dimensional\narray (DP table), with one entry per state. This is equivalent to the memo table in top-\ndown DP. However, there are di\u21b5erences. In bottom-up DP, we only need to initialize\nsome cells of the DP table with known initial values (the base cases). Recall that in\ntop-down DP, we initialize the memo table completely with dummy values (usually -1)\nto indicate that we have not yet computed the values.\n3. Now, with the base-case cells/states in the DP table already \ufb01lled, determine the\ncells/states that can be \ufb01lled next (the transitions). Repeat this process until the DP\ntable is complete. For the bottom-up DP, this part is usually accomplished through\niterations, using loops (more details about this later).", "mimetype": "text/plain", "start_char_idx": 511359, "end_char_idx": 514778, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f4c68d10-8304-4201-9740-ed93244612aa": {"__data__": {"id_": "f4c68d10-8304-4201-9740-ed93244612aa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6536fe42-1b76-4d6f-9030-34c29459e4ae", "node_type": "1", "metadata": {}, "hash": "a89fddd5d349ad087e66249e3a5161c6610cc31b24cedfb676f09efddd2cb2a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "97ee77f4-e793-406e-a5f7-86aa16ca3c50", "node_type": "1", "metadata": {}, "hash": "896fae241a74a95d7e36ad6a6b12757e91175a90f9d93de4108e92c2c308d02c", "class_name": "RelatedNodeInfo"}}, "text": "2. If there are N parameters required to represent the states, prepare an N dimensional\narray (DP table), with one entry per state. This is equivalent to the memo table in top-\ndown DP. However, there are di\u21b5erences. In bottom-up DP, we only need to initialize\nsome cells of the DP table with known initial values (the base cases). Recall that in\ntop-down DP, we initialize the memo table completely with dummy values (usually -1)\nto indicate that we have not yet computed the values.\n3. Now, with the base-case cells/states in the DP table already \ufb01lled, determine the\ncells/states that can be \ufb01lled next (the transitions). Repeat this process until the DP\ntable is complete. For the bottom-up DP, this part is usually accomplished through\niterations, using loops (more details about this later).\nFor UVa 11450, we can write the bottom-up DP as follows: We describe the state of a sub-\nproblem with two parameters: the current garment g and the current budget left b. This\nstate formulation is the same as the top-down DP above. The values of g are the row indices\nof the DP table so that we can take advantage of the cache-friendly row-major traversal in\na 2D array, see the speed-up tips in Section 3.2.3. Then, we initialize a 2D table (Boolean\nmatrix) reachable[g][b] of size 20 \u21e5201. Initially, only cells/states reachable by buying\nany of the models of the \ufb01rst garment g = 0 are set to true (in the \ufb01rst row). Let\u2019s use\ntest case A above as an example. In Figure 3.12\u2014top, the only columns in row 0 that are\ninitially set to true are column 12 (from 20-8), 14 (from 20-6), and 16 (from 20-4).\nFigure 3.12: Bottom-Up DP (columns 21 to 200 are not shown for brevity)\nNow, we loop from the second garment g = 1 (second row) to the last garment g = C-1 =\n3-1 = 2 (third and last row) in row-major order (row by row). If reachable[g-1][b] is\ntrue, then the next state reachable[g][b-p] where p is the price of a model of current gar-\nment g is also reachable as long as the second parameter (i.e., the value of b-p) is not negative.\nSee Figure 3.12\u2014middle, where reachable[0][16] propagates to reachable[1][16-5] and\n169\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nreachable[1][16-10] when the model with price 5 and 10 in garment g = 1 is bought, re-\nspectively; reachable[0][12] propagates to reachable[1][12-10] when the model with\nprice 10 in garment g = 1 is bought, etc. We repeat this table \ufb01lling process row by row\nuntil we are done with the last row.\nFinally, the answer can be found in the last row when g = C-1.\nFind the state in\nthat row that is both nearest to index 0 and reachable. In Figure 3.12\u2014bottom, the cell\nreachable[2][1] provides the answer. This means that we can reach state (b = 1) by\nbuying some combination of the various garment models.\nThe required \ufb01nal answer is\nactually M-b, or in this case, 20-1 = 19. The answer is \u201cno solution\u201d if there is no state\nin the last row that is reachable (where reachable[C-1][b] is set to true). We provide our\nimplementation below for comparison with the top-down version.", "mimetype": "text/plain", "start_char_idx": 513981, "end_char_idx": 517032, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97ee77f4-e793-406e-a5f7-86aa16ca3c50": {"__data__": {"id_": "97ee77f4-e793-406e-a5f7-86aa16ca3c50", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f4c68d10-8304-4201-9740-ed93244612aa", "node_type": "1", "metadata": {}, "hash": "c04dc0d127a602dfbfa45c45cd5c8232b412643a4fdd6b7030bef217c12bcef6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "24ca5357-fc2e-437f-9809-532a330299ba", "node_type": "1", "metadata": {}, "hash": "2839136bdd77ac69dcb1fcb044d1a232b697b3d68ed26c563fb54458dd0621ab", "class_name": "RelatedNodeInfo"}}, "text": "We repeat this table \ufb01lling process row by row\nuntil we are done with the last row.\nFinally, the answer can be found in the last row when g = C-1.\nFind the state in\nthat row that is both nearest to index 0 and reachable. In Figure 3.12\u2014bottom, the cell\nreachable[2][1] provides the answer. This means that we can reach state (b = 1) by\nbuying some combination of the various garment models.\nThe required \ufb01nal answer is\nactually M-b, or in this case, 20-1 = 19. The answer is \u201cno solution\u201d if there is no state\nin the last row that is reachable (where reachable[C-1][b] is set to true). We provide our\nimplementation below for comparison with the top-down version.\n// UVa 11450 - Wedding Shopping - Bottom Up (faster than Top Down)\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_gm = 30;\n// <= 20 garments&models\nconst int MAX_M = 210;\n// maximum budget is 200\nint price[MAX_gm][MAX_gm];\n// g < 20 and k <= 20\nbool reachable[MAX_gm][MAX_M];\n// g < 20 and b <= 200\nint main() {\nint TC; scanf(\"%d\", &TC);\nwhile (TC--) {\nint M, C; scanf(\"%d %d\", &M, &C);\nfor (int g = 0; g < C; ++g) {\nscanf(\"%d\", &price[g][0]);\n// store k in price[g][0]\nfor (int k = 1; k <= price[g][0]; ++k)\nscanf(\"%d\", &price[g][k]);\n}\nmemset(reachable, false, sizeof reachable);\n// clear everything\n// initial values (base cases), using first garment g = 0\nfor (int k = 1; k <= price[0][0]; ++k)\nif (M-price[0][k] >= 0)\nreachable[0][M-price[0][k]] = true;\nint b;\nfor (int g = 1; g < C; ++g)\n// for each garment\nfor (b = 0; b < M; ++b) if (reachable[g-1][b])\nfor (int k = 1; k <= price[g][0]; ++k) if (b-price[g][k] >= 0)\nreachable[g][b-price[g][k]] = true;\n// also reachable now\nfor (b = 0; b <= M && !reachable[C-1][b]; ++b);\nif (b == M+1) printf(\"no solution\\n\");\n// last row has no on bit\nelse\nprintf(\"%d\\n\", M-b);\n}\nreturn 0;\n}\n170\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nThere is an advantage for writing DP solutions in the bottom-up fashion. For problems\nwhere we only need the last row of the DP table (or, more generally, the last updated slice\nof all the states) to determine the solution\u2014including this problem, we can optimize the\nmemory usage of our DP solution by sacri\ufb01cing one dimension in our DP table. For harder\nDP problems34 with tight memory requirements, this \u2018space saving technique\u2019 may prove to\nbe useful, though the overall time complexity does not change.\nLet\u2019s take a look again at Figure 3.12. We only need to store two rows, the current row we\nare processing and the previous row we have processed. To compute row 1, we only need to\nknow the columns in row 0 that are set to true in reachable. To compute row 2, we similarly\nonly need to know the columns in row 1 that are set to true in reachable. In general, to\ncompute row g, we only need values from the previous row g \u22121. So, instead of storing a\nboolean matrix reachable[g][b] of size 20\u21e5201, we can simply store reachable[2][b] of\nsize 2 \u21e5201. We can use this programming technique to reference one row as the \u2018previous\u2019\nrow and another row as the \u2018current\u2019 row (e.g., prev = 0, cur = 1) and then swap them\n(e.g., now prev = 1, cur = 0) as we compute the bottom-up DP row by row. Note that for\nthis problem, the memory savings are not signi\ufb01cant.", "mimetype": "text/plain", "start_char_idx": 516369, "end_char_idx": 519606, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24ca5357-fc2e-437f-9809-532a330299ba": {"__data__": {"id_": "24ca5357-fc2e-437f-9809-532a330299ba", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "97ee77f4-e793-406e-a5f7-86aa16ca3c50", "node_type": "1", "metadata": {}, "hash": "896fae241a74a95d7e36ad6a6b12757e91175a90f9d93de4108e92c2c308d02c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3119c97f-6fd0-458b-a756-00c02f2f8bde", "node_type": "1", "metadata": {}, "hash": "da6d24ab0546650093014728903107d0c643f7d1eb718b7ac5d3f50c7128f8bd", "class_name": "RelatedNodeInfo"}}, "text": "To compute row 2, we similarly\nonly need to know the columns in row 1 that are set to true in reachable. In general, to\ncompute row g, we only need values from the previous row g \u22121. So, instead of storing a\nboolean matrix reachable[g][b] of size 20\u21e5201, we can simply store reachable[2][b] of\nsize 2 \u21e5201. We can use this programming technique to reference one row as the \u2018previous\u2019\nrow and another row as the \u2018current\u2019 row (e.g., prev = 0, cur = 1) and then swap them\n(e.g., now prev = 1, cur = 0) as we compute the bottom-up DP row by row. Note that for\nthis problem, the memory savings are not signi\ufb01cant. For harder DP problems, for example\nwhere there might be thousands of garment models instead of 20, this space saving technique\ncan be important.\n// all else the same as the previous code\nbool reachable[2][MAX_M];\n// ONLY TWO ROWS\n// inside int main()\n// then we modify the main loop in int main a bit\nint cur = 1;\n// we start with this row\nfor (int g = 1; g < C; ++g) {\n// for each garment\nmemset(reachable[cur], false, sizeof reachable[cur]); // reset row\nfor (b = 0; b < M; ++b) if (reachable[!cur][b])\nfor (int k = 1; k <= price[g][0]; ++k) if (b-price[g][k] >= 0)\nreachable[cur][b-price[g][k]] = true;\ncur = 1-cur;\n// flip the two rows\n}\nfor (b = 0; b <= M && !reachable[!cur][b]; ++b);\nSource code: ch3/dp/UVa11450 bu.cpp|java|py|ml\nTop-Down versus Bottom-Up DP\nAlthough both styles use \u2018tables\u2019, the way the bottom-up DP table is \ufb01lled is di\u21b5erent from\nthat of the top-down DP memo table. In the top-down DP, the memo table entries are\n\ufb01lled \u2018as needed\u2019 through the recursion itself. In the bottom-up DP, we use a correct \u2018DP\ntable \ufb01lling order\u2019 to compute the values such that the previous values needed to process\nthe current cell have already been obtained. This table \ufb01lling order is the topological order\nof the implicit DAG (this will be explained in more detail in Section 4.6.1) in the recurrence\nstructure. For most DP problems, a topological order can be achieved simply with the proper\nsequencing of some (nested) loops.\nFor most DP problems, these two styles are equally good and the decision to use a\nparticular DP style is a matter of preference. However, for harder DP problems, one of the\n34Not this introductory UVa 11450 DP problem.\n171\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nstyles can be better than the other. To help you understand which style that you should\nuse when presented with a DP problem, please study the trade-o\u21b5s between top-down and\nbottom-up DPs listed in Table 3.2.\nTop-Down\nBottom-Up\nPros:\nPros:\n1. It is a natural transformation from the\nnormal Complete Search recursion\n1. Faster if many sub-problems are revisited\nas there is no overhead from recursive calls\n2. Computes the sub-problems only when\nnecessary (sometimes this is faster)\n2. Can save memory space with the \u2018space\nsaving\u2019 technique\nCons:\nCons:\n1. Slower if many sub-problems are revis-\nited due to function call overhead (this is not\nusually penalized in programming contests)\n1. For programmers who are inclined to re-\ncursion, this style may not be intuitive\n2. If there are M states, an O(M) table size\nis required, which can lead to MLE for some\nharder problems (except if we use alternative\ndata structures shown in Book 2)\n2.\nIf there are M states, bottom-up DP\nvisits and \ufb01lls the value of all these M states\neven if many of the states are not necessary\nTable 3.2: DP Decision Table\nDisplaying the Optimal Solution\nMany DP problems request only for the value of the optimal solution (like the UVa 11450\nabove). However, many contestants are caught o\u21b5-guard when they are also required to print\nthe optimal solution.", "mimetype": "text/plain", "start_char_idx": 518997, "end_char_idx": 522652, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3119c97f-6fd0-458b-a756-00c02f2f8bde": {"__data__": {"id_": "3119c97f-6fd0-458b-a756-00c02f2f8bde", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "24ca5357-fc2e-437f-9809-532a330299ba", "node_type": "1", "metadata": {}, "hash": "2839136bdd77ac69dcb1fcb044d1a232b697b3d68ed26c563fb54458dd0621ab", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "08e6b320-9bbf-4928-b482-7a9a4cc3ec48", "node_type": "1", "metadata": {}, "hash": "720c3a9919e455a60a15fe76f4658873b53e125b85a6dac9019e9169a82dfce9", "class_name": "RelatedNodeInfo"}}, "text": "Slower if many sub-problems are revis-\nited due to function call overhead (this is not\nusually penalized in programming contests)\n1. For programmers who are inclined to re-\ncursion, this style may not be intuitive\n2. If there are M states, an O(M) table size\nis required, which can lead to MLE for some\nharder problems (except if we use alternative\ndata structures shown in Book 2)\n2.\nIf there are M states, bottom-up DP\nvisits and \ufb01lls the value of all these M states\neven if many of the states are not necessary\nTable 3.2: DP Decision Table\nDisplaying the Optimal Solution\nMany DP problems request only for the value of the optimal solution (like the UVa 11450\nabove). However, many contestants are caught o\u21b5-guard when they are also required to print\nthe optimal solution. We are aware of two ways to do this.\nThe \ufb01rst way is mainly used in the bottom-up DP approach (which is still applicable to\ntop-down DPs) where we store the predecessor information at each state. If there is more\nthan one optimal predecessor and we have to output all optimal solutions, we can store those\npredecessors in a list. Once we have the optimal \ufb01nal state, we can do backtracking from\nthe optimal \ufb01nal state and follow the optimal transition(s) recorded at each state until we\nreach one of the base cases. If the problem asks for all optimal solutions, this backtracking\nroutine will print them all. However, most problem authors usually set additional output\ncriteria so that the selected optimal solution is unique (for easier judging).\nExample: See Figure 3.12\u2014bottom. The optimal \ufb01nal state is reachable[2][1]. The\npredecessor of this optimal \ufb01nal state is state reachable[1][2].\nWe now backtrack to\nreachable[1][2]. Next, see Figure 3.12\u2014middle. The predecessor of state reachable[1][2]\nis state reachable[0][12]. We then backtrack to reachable[0][12]. As this is already\none of the initial base states (at the \ufb01rst row), we know that an optimal solution is: (20!12)\n= price 8, then (12!2) = price 10, then (2!1) = price 1. However, as mentioned earlier\nin the problem description, this problem may have several other optimal solutions, e.g., We\ncan also follow the path: reachable[2][1] ! reachable[1][6] ! reachable[0][16]\nwhich represents another optimal solution: (20!16) = price 4, then (16!6) = price 10,\nthen (6!1) = price 5.\nThe second way is applicable mainly to the top-down DP approach where we utilize the\nstrength of recursion and memoization to do the same job. Using the top-down DP code\nshown in Approach 4 above, we will add another function void print dp(int g, int b)\nthat has the same structure as int dp(int g, int b) except that it uses the values stored\nin the memo table to reconstruct the solution. A sample implementation (that only prints\nout one optimal solution) is as follows:\n172\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nvoid print_dp(int g, b) {\n// void function\nif ((g == C) || (b < 0)) return;\n// similar base cases\nfor (int k = 1; k <= price[g][0]; ++k)\n// which model k is opt?\nif (dp(g+1, b-price[g][k]) == memo[g][b]) {\n// this one\nprintf(\"%d - \", price[g][k]);\nprint_dp(g+1, b-price[g][k]);\n// recurse to this only\nbreak;\n}\n}\nExercise 3.5.1.1: To verify your understanding of UVa 11450 problem discussed in this\nsection, determine what is the output for test case D below?\nTest case D with M = 25, C = 3:\nPrice of the 3 models of garment g = 0 ! 6 4 8\nPrice of the 2 models of garment g = 1 ! 10 6\nPrice of the 4 models of garment g = 2 ! 7 3 1 5\nExercise 3.5.1.2: Is the following state formulation dp(g, model), where g is the current\ngarment and model is the current model, appropriate and exhaustive for UVa 11450 problem?", "mimetype": "text/plain", "start_char_idx": 521877, "end_char_idx": 525556, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08e6b320-9bbf-4928-b482-7a9a4cc3ec48": {"__data__": {"id_": "08e6b320-9bbf-4928-b482-7a9a4cc3ec48", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3119c97f-6fd0-458b-a756-00c02f2f8bde", "node_type": "1", "metadata": {}, "hash": "da6d24ab0546650093014728903107d0c643f7d1eb718b7ac5d3f50c7128f8bd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b30f64a4-fd94-4eb3-aa15-f5d024b11799", "node_type": "1", "metadata": {}, "hash": "93b48f6b1e2ad4cd99bd4c91ae44c2d00c37e698614a093788adca720217df19", "class_name": "RelatedNodeInfo"}}, "text": "Test case D with M = 25, C = 3:\nPrice of the 3 models of garment g = 0 ! 6 4 8\nPrice of the 2 models of garment g = 1 ! 10 6\nPrice of the 4 models of garment g = 2 ! 7 3 1 5\nExercise 3.5.1.2: Is the following state formulation dp(g, model), where g is the current\ngarment and model is the current model, appropriate and exhaustive for UVa 11450 problem?\nExercise 3.5.1.3: Python users have another tool in their disposal for Top-Down DP\nimplementation. Study @lru cache function from functools!\nExercise 3.5.1.4*: Modify the given print dp code so that it prints all optimal solutions\nof this UVa 11450!\n3.5.2\nClassical Examples\nThe problem UVa 11450 - Wedding Shopping above is a (relatively easy) non classical DP\nproblem, where we had to come up with the correct DP states and transitions by ourself.\nHowever, there are many other classical problems with e\ufb03cient DP solutions, i.e., their\nDP states and transitions are well-known. Therefore, such classical DP problems and their\nsolutions should be mastered by every contestant who wishes to do well in IOI or ICPC! In\nthis section, we list down six classical DP problems and their solutions. Note: Once you\nunderstand the basic form of these DP solutions, try solving the programming exercises that\nenumerate their variants.\na1. Max 1D Range Sum\nAbridged problem statement of UVa 00507 - Jill Rides Again: Given an integer array A\ncontaining n \uf8ff20K non-zero integers, determine the maximum (1D) range sum of A. In\nother words, \ufb01nd the maximum Range Sum Query (RSQ) between two indices i and j in\n[0..n-1], that is: A[i] + A[i+1] + +...+ A[j] (also see Section 2.4.3 and 2.4.4).\nO(n3) Algorithm\nA Complete Search algorithm that tries all possible O(n2) pairs of i and j, computes the\nrequired RSQ(i, j) in O(n), and \ufb01nally picks the maximum one runs in an overall time\ncomplexity of O(n3). With n up to 20K, this is a TLE algorithm.\n173\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nO(n2) Algorithm\nIn Section 2.4.3, we have discussed the following DP strategy: pre-process array A by comput-\ning pre\ufb01x sums A[i] += A[i-1] 8i 2 [1..n-1] so that A[i] contains the sum of integers\nin subarray A[0..i]. We can now compute RSQ(i, j) in O(1): RSQ(0, j) = A[j] and\nRSQ(i, j) = A[j] - A[i-1] 8i > 0 using inclusion-exclusion principle. With this35, the\nComplete Search algorithm above can be made to run in O(n2). For n up to 20K, this is\nstill a TLE algorithm.\nO(n) Algorithm\nThere is an even better algorithm for this problem. The main part of Jay Kadane\u2019s O(n)\n(can be viewed as a greedy or DP) algorithm to solve this problem is shown below.\n// inside int main()\nint n = 9, A[] = { 4,-5, 4,-3, 4, 4,-4, 4,-5 };// a sample array A\nint sum = 0, ans = 0;\nfor (int i = 0; i < n; ++i) {\n// linear scan, O(n)\nsum += A[i];\n// greedily extend this\nans = max(ans, sum);\n// keep the cur max RSQ\nif (sum < 0) sum = 0;\n// reset the running sum\n}\n// if it ever dips below 0\nprintf(\"Max 1D Range Sum = %d\\n\", ans);\n// should be 9\nSource code: ch3/dp/Max1DRangeSum.cpp|java|py|ml\nThe key idea of Kadane\u2019s algorithm is to keep a running sum of the integers seen so far and\ngreedily reset that to 0 if the running sum dips below 0. This is because re-starting from\n0 is always better than continuing from a negative running sum.", "mimetype": "text/plain", "start_char_idx": 525203, "end_char_idx": 528470, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b30f64a4-fd94-4eb3-aa15-f5d024b11799": {"__data__": {"id_": "b30f64a4-fd94-4eb3-aa15-f5d024b11799", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "08e6b320-9bbf-4928-b482-7a9a4cc3ec48", "node_type": "1", "metadata": {}, "hash": "720c3a9919e455a60a15fe76f4658873b53e125b85a6dac9019e9169a82dfce9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "50f949a3-5060-4181-971a-6f6ecb238efa", "node_type": "1", "metadata": {}, "hash": "9a268229739322060589794b414e22257b4e71e2c29c10704d85bdc3523cb6c1", "class_name": "RelatedNodeInfo"}}, "text": "This is because re-starting from\n0 is always better than continuing from a negative running sum. Kadane\u2019s algorithm is the\nrequired algorithm to solve this UVa 00507 problem as n \uf8ff20K.\nNote that we can also view this Kadane\u2019s algorithm as a DP solution. At each step,\nwe have two choices: we can either leverage the previously accumulated maximum sum, or\nbegin a new range. The DP variable dp(i) thus represents the maximum sum of a range of\nintegers that ends with element A[i]. Thus, the \ufb01nal answer is the maximum over all the\nvalues of dp(i) where i 2 [0..n-1]. If zero-length ranges are allowed, then 0 must also be\nconsidered as a possible answer. The implementation above is essentially an e\ufb03cient version\nthat utilizes the space saving technique discussed earlier.\na2. Max 2D Range Sum\nAbridged problem statement of UVa 00108 - Maximum Sum: Given an n \u21e5n (1 \uf8ffn \uf8ff100)\nsquare matrix of integers A where each integer ranges from [-127..127], \ufb01nd a sub-matrix\nof A with the maximum sum. For example: The 4 \u21e54 matrix (n = 4) in Table 3.3.A below\nhas a 3 \u21e52 sub-matrix on the lower-left with sum of 9 + 2 - 4 + 1 - 1 + 8 = 15 and this is\nthe maximum possible sum.\nO(n6) Algorithm\nAttacking this problem na\u00a8\u0131vely using a Complete Search as shown below does not work as\nit runs in O(n6). For the largest test case with n = 100, an O(n6) algorithm is too slow.\n35However, if we use data structure for dynamic RSQ like Fenwick Tree or Segment Tree discussed in\nSection 2.4, we will end up with O(n2 log n) time complexity.\n174\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nTable 3.3: UVa 00108 - Maximum Sum\nint maxSubRect = -127*100*100;\n// the lowest possible val\nfor (int i = 0; i < n; ++i)\nfor (int j = 0; j < n; ++j)\n// start coordinate\nfor (int k = i; k < n; ++k)\nfor (int l = j; l < n; ++l) {\n// end coord\nint subRect = 0;\n// sum this sub-rectangle\nfor (int a = i; a <= k; ++a)\nfor (int b = j; b <= l; ++b)\nsubRect += A[a][b];\nmaxSubRect = max(maxSubRect, subRect); // the answer is here\n}\nO(n4) Algorithm\nThe solution for the Max 1D Range Sum in the previous subsection can be extended to two\n(or more) dimensions as long as the inclusion-exclusion principle is properly applied. The\nonly di\u21b5erence is that while we dealt with overlapping sub-ranges in Max 1D Range Sum,\nwe will deal with overlapping sub-matrices in Max 2D Range Sum. We can turn the n \u21e5n\ninput matrix into an n \u21e5n cumulative sum matrix where A[i][j] no longer contains its\nown value, but the sum of all items within sub-matrix (0, 0) to (i, j). This can be done\nsimultaneously while reading the input and still runs in O(n2). The code shown below turns\nthe input square matrix (Table 3.3\u2014A) into a cumulative sum matrix (Table 3.3\u2014B).", "mimetype": "text/plain", "start_char_idx": 528374, "end_char_idx": 531100, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "50f949a3-5060-4181-971a-6f6ecb238efa": {"__data__": {"id_": "50f949a3-5060-4181-971a-6f6ecb238efa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b30f64a4-fd94-4eb3-aa15-f5d024b11799", "node_type": "1", "metadata": {}, "hash": "93b48f6b1e2ad4cd99bd4c91ae44c2d00c37e698614a093788adca720217df19", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "430e339a-2652-48a2-96dd-99bf1ca848c2", "node_type": "1", "metadata": {}, "hash": "cea0e343d24d1cbcd122357e9d25685cddec95cb435be279bb0f6f39d9b3cbf1", "class_name": "RelatedNodeInfo"}}, "text": "The\nonly di\u21b5erence is that while we dealt with overlapping sub-ranges in Max 1D Range Sum,\nwe will deal with overlapping sub-matrices in Max 2D Range Sum. We can turn the n \u21e5n\ninput matrix into an n \u21e5n cumulative sum matrix where A[i][j] no longer contains its\nown value, but the sum of all items within sub-matrix (0, 0) to (i, j). This can be done\nsimultaneously while reading the input and still runs in O(n2). The code shown below turns\nthe input square matrix (Table 3.3\u2014A) into a cumulative sum matrix (Table 3.3\u2014B).\nint n; scanf(\"%d\", &n);\n// square matrix size\nfor (int i = 0; i < n; ++i)\nfor (int j = 0; j < n; ++j) {\nscanf(\"%d\", &A[i][j]);\nif (i > 0) A[i][j] += A[i-1][j];\n// add from top\nif (j > 0) A[i][j] += A[i][j-1];\n// add from left\nif (i > 0 && j > 0) A[i][j] -= A[i-1][j-1];// avoid double count\n}\n// inclusion-exclusion\nint maxSubRect = -127*100*100;\n// the lowest possible val\nfor (int i = 0; i < n; ++i)\nfor (int j = 0; j < n; ++j)\n// start coordinate\nfor (int k = i; k < n; ++k)\nfor (int l = j; l < n; ++l) {\n// end coord\nint subRect = A[k][l];\n// from (0, 0) to (k, l)\nif (i > 0) subRect -= A[i-1][l];\n// O(1)\nif (j > 0) subRect -= A[k][j-1];\n// O(1)\nif (i > 0 && j > 0) subRect += A[i-1][j-1]; // O(1)\nmaxSubRect = max(maxSubRect, subRect); // the answer is here\n}\n175\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nFor example, let\u2019s compute the sum of (1, 2) to (3, 3). We split the sum into 4 parts and\ncompute A[3][3] - A[0][3] - A[3][1] + A[0][1] = -3 - 13 - (-9) + (-2) = -9 as\nhighlighted in Table 3.3\u2014C. With this O(1) DP formulation, the Max 2D Range Sum prob-\nlem can be solved in O(n4). For the largest test case of UVa 00108 with n = 100, this is\nAC.\nO(n3) Algorithm\nThere exists an O(n3) solution that combines the DP solution for the Max Range 1D Sum\nproblem on one dimension and uses the same idea as proposed by Kadane on the other\ndimension to solve cases up to n \uf8ff450.", "mimetype": "text/plain", "start_char_idx": 530578, "end_char_idx": 532493, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "430e339a-2652-48a2-96dd-99bf1ca848c2": {"__data__": {"id_": "430e339a-2652-48a2-96dd-99bf1ca848c2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "50f949a3-5060-4181-971a-6f6ecb238efa", "node_type": "1", "metadata": {}, "hash": "9a268229739322060589794b414e22257b4e71e2c29c10704d85bdc3523cb6c1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "02512f5c-1172-4850-9c8e-40a38cf8919a", "node_type": "1", "metadata": {}, "hash": "45c1c2701ed7a3b269f8f8ea15d6ea2cfe8368569057d0af612c9df5b52af3d8", "class_name": "RelatedNodeInfo"}}, "text": "We split the sum into 4 parts and\ncompute A[3][3] - A[0][3] - A[3][1] + A[0][1] = -3 - 13 - (-9) + (-2) = -9 as\nhighlighted in Table 3.3\u2014C. With this O(1) DP formulation, the Max 2D Range Sum prob-\nlem can be solved in O(n4). For the largest test case of UVa 00108 with n = 100, this is\nAC.\nO(n3) Algorithm\nThere exists an O(n3) solution that combines the DP solution for the Max Range 1D Sum\nproblem on one dimension and uses the same idea as proposed by Kadane on the other\ndimension to solve cases up to n \uf8ff450. The implementation is shown below:\n// inside int main()\nint n; scanf(\"%d\", &n);\n// square matrix size\nfor (int i = 0; i < n; ++i)\nfor (int j = 0; j < n; ++j) {\nscanf(\"%d\", &A[i][j]);\nif (j > 0) A[i][j] += A[i][j-1];\n// pre-processing\n}\nint maxSubRect = -127*100*100;\n// lowest possible val\nfor (int l = 0; l < n; ++l)\nfor (int r = l; r < n; ++r) {\nint subRect = 0;\nfor (int row = 0; row < n; ++row) {\n// Max 1D Range Sum on columns of this row\nif (l > 0) subRect += A[row][r] - A[row][l-1];\nelse\nsubRect += A[row][r];\n// Kadane\u2019s algorithm on rows\nif (subRect < 0) subRect = 0;\n// restart if negative\nmaxSubRect = max(maxSubRect, subRect);\n}\n}\nSource code: ch3/dp/UVa00108.cpp|java|py|ml\nFrom these two examples\u2014the Max 1D/2D Range Sum Problems\u2014we can see that not\nevery range problem requires a Fenwick/Segment Tree as discussed in Section 2.4.3/2.4.4,\nrespectively. Static-input range-related problems are often solvable with DP techniques. It\nis also worth mentioning that the solution for a range problem is very natural to produce\nwith bottom-up DP techniques as the operand is already a 1D or a 2D array. We can still\nwrite the recursive top-down solution for a range problem, but that is not as natural.\nb. Longest Increasing Subsequence (LIS)\nProblem: Given a sequence {A[0], A[1],..., A[n-1]}, determine its Longest Increasing\nSubsequence (LIS)36. Note that these \u2018subsequences\u2019 are not necessarily contiguous. Exam-\nple: n = 8, A = {\u22127, 10, 9, 2, 3, 8a, 8b, 1}. The length-4 LIS is {-7, 2, 3, 8a} (it can also end\nwith the second copy of 8, i.e., 8b).\n36There are other variants of this problem, e.g., the Longest Decreasing Subsequence and Longest Non\nIncreasing/Decreasing Subsequence. The increasing subsequences can be modeled as a Directed Acyclic\nGraph (DAG) and \ufb01nding the LIS is equivalent to \ufb01nding the Longest Paths in the DAG (see Section 4.6.1).\n176\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nFigure 3.13: Longest Increasing Subsequence\nO(2n) Complete Search Algorithm\nIf you re-read the overview and motivation of this chapter (see Section 3.1), you will \ufb01nd a\nna\u00a8\u0131ve Complete Search that simply enumerates all possible subsequences of a sequence with\nn items in order to \ufb01nd the longest increasing one. This is clearly too slow as there are O(2n)\npossible subsequences.\nO(n2) DP Algorithm\nInstead of trying all possible subsequences, we can consider the problem with a di\u21b5erent\napproach. We can write the state of this problem with just one parameter: i. Let LIS(i)\nbe the LIS ending at index i. We know that LIS(0) = 1 as the \ufb01rst number in A is itself a\nsubsequence. For i \u22651, LIS(i) is slightly more complex.", "mimetype": "text/plain", "start_char_idx": 531979, "end_char_idx": 535150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "02512f5c-1172-4850-9c8e-40a38cf8919a": {"__data__": {"id_": "02512f5c-1172-4850-9c8e-40a38cf8919a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "430e339a-2652-48a2-96dd-99bf1ca848c2", "node_type": "1", "metadata": {}, "hash": "cea0e343d24d1cbcd122357e9d25685cddec95cb435be279bb0f6f39d9b3cbf1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "69d36dc7-323b-443e-816b-ea8566566973", "node_type": "1", "metadata": {}, "hash": "e4014a91e0da4d477ae28e9dde435edf89ee0b8bac3bd11447574099aea7baee", "class_name": "RelatedNodeInfo"}}, "text": "This is clearly too slow as there are O(2n)\npossible subsequences.\nO(n2) DP Algorithm\nInstead of trying all possible subsequences, we can consider the problem with a di\u21b5erent\napproach. We can write the state of this problem with just one parameter: i. Let LIS(i)\nbe the LIS ending at index i. We know that LIS(0) = 1 as the \ufb01rst number in A is itself a\nsubsequence. For i \u22651, LIS(i) is slightly more complex. We need to \ufb01nd the index j such\nthat j < i and A[j] < A[i] and LIS(j) is the largest. Once we have found this index j,\nwe know that LIS(i) = LIS(j)+1. We can write this recurrence as follows:\nint memo[MAX_N];\n// MAX_N up to 10^4\nint LIS(int i) {\n// O(n^2) overall\nif (i == 0) return 1;\n// can\u2019t extend anymore\nint &ans = memo[i];\nif (ans != -1) return ans;\n// was computed before\nans = 1;\n// at least i itself\nfor (int j = 0; j < i; ++j)\n// O(n) here\nif (A[j] < A[i])\n// increasing condition\nans = max(ans, LIS(j)+1);\n// pick the max\nreturn ans;\n}\n// in int main()\nmemset(memo, -1, sizeof memo);\nprintf(\"LIS length is %d\\n\\n\", LIS(n-1));\n// with O(n^2) DP\nThe answer is the largest value of LIS(k), 8k 2 [0..n-1]. However, if we use a sentinel\nvalue A[n] = Inf, then every A[j] 8j 2 [0..n-1] will extend by one more unit to reach\nA[n]. Thus the answer is LIS(n)-1.\nThere are clearly many overlapping sub-problems in LIS problem because to compute\nLIS(i), we need to compute LIS(j) 8j 2 [0..i-1]. However, there are only n distinct\nstates, the indices of the LIS ending at index i, 8i 2 [0..n-1]. As we need to compute\neach state with an O(n) loop, this DP algorithm runs in O(n2).\nIf needed, the LIS solution(s) can be reconstructed by storing the predecessor information\n(the arrows in Figure 3.13) and tracing the arrows from index k that contain the highest\nvalue of LIS(k). For example, LIS(5) is the optimal \ufb01nal state. In Figure 3.13, we can\ntrace the arrows as follows: LIS(5) ! LIS(4) ! LIS(3) ! LIS(0), so the optimal solution\n(read backwards) is index {0, 3, 4, 5} or {-7, 2, 3, 8a}.\n177\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nO(n log k) Greedy + Divide and Conquer Algorithm\nAs of year 2020, recent LIS problem is unlikely to be solvable using O(n2) DP algorithm\npresented earlier. Instead, we need to use the following non-DP solution: output-sensitive\nO(n log k) Greedy + D&C algorithm37 (where k is the length of the LIS) by maintaining an\narray that is always sorted and therefore amenable to binary search.\nLet vi L and vi L id be resizeable array such that L[i]/L id[i] represents the smallest\nending value/its index of all length-i increasing subsequences found so far, respectively. The\nsize of L is k and never decreases. Though this de\ufb01nition is slightly complicated, it is easy\nto see that it is always ordered\u2014L[i-1] will always be smaller than L[i] as the second-last\nelement of any LIS (of length-i) is smaller than its last element by de\ufb01nition. As such, for\nevery next element A[i], we can binary search array L in O(log k) to determine the lower\nbound pos, the position where we can either greedily lower the content of L[pos] to a lower\nnumber to facilitate potentially longer increasing subsequence in the future, or to extend the\nLIS by +1 if pos == k.\nNote that the content of L is not the actual LIS.", "mimetype": "text/plain", "start_char_idx": 534742, "end_char_idx": 537997, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "69d36dc7-323b-443e-816b-ea8566566973": {"__data__": {"id_": "69d36dc7-323b-443e-816b-ea8566566973", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "02512f5c-1172-4850-9c8e-40a38cf8919a", "node_type": "1", "metadata": {}, "hash": "45c1c2701ed7a3b269f8f8ea15d6ea2cfe8368569057d0af612c9df5b52af3d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "54eef8ca-ca40-4ab8-b607-e39c8fe7e12e", "node_type": "1", "metadata": {}, "hash": "25869262390ebf1b2114b06672fd0e7cabdc47f42acf97c551113fec7a1304be", "class_name": "RelatedNodeInfo"}}, "text": "The\nsize of L is k and never decreases. Though this de\ufb01nition is slightly complicated, it is easy\nto see that it is always ordered\u2014L[i-1] will always be smaller than L[i] as the second-last\nelement of any LIS (of length-i) is smaller than its last element by de\ufb01nition. As such, for\nevery next element A[i], we can binary search array L in O(log k) to determine the lower\nbound pos, the position where we can either greedily lower the content of L[pos] to a lower\nnumber to facilitate potentially longer increasing subsequence in the future, or to extend the\nLIS by +1 if pos == k.\nNote that the content of L is not the actual LIS. To facilitate reconstruction of the actual\nLIS (if asked38), we need to also remember the predecessor/parent array vi p (see Section\n2.4.1) that is updated every time we process A[i]. The code is shown below (it will be much\nshorter if the solution reconstruction path is removed).\nvi p;\n// predecessor array\nvoid print_LIS(int i) {\n// backtracking routine\nif (p[i] == -1) { printf(\"%d\", A[i]); return; }// base case\nprint_LIS(p[i]);\n// backtrack\nprintf(\" %d\", A[i]);\n}\n// inside int main()\nint k = 0, lis_end = 0;\nvi L(n, 0), L_id(n, 0);\np.assign(n, -1);\nfor (int i = 0; i < n; ++i) {\n// O(n log k)\nint pos = lower_bound(L.begin(), L.begin()+k, A[i]) - L.begin();\nL[pos] = A[i];\n// greedily overwrite this\nL_id[pos] = i;\n// remember the index too\np[i] = pos ? L_id[pos-1] : -1;\n// predecessor info\nif (pos == k) {\n// can extend LIS?\nk = pos+1;\n// k = longer LIS by +1\nlis_end = i;\n// keep best ending i\n}\n}\nprintf(\"Final LIS is of length %d: \", k);\nprint_LIS(lis_end); printf(\"\\n\");\nSource code: ch3/dp/LIS.cpp|java|py|ml\n37We classify this O(n log k) LIS algorithm (\u201cpatience sorting\u201d) under DP category due to legacy reason.\n38The code can be much simpler if this is not asked.\n178\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nThis O(n log k) algorithm is probably less intuitive than the O(n2) algorithm. Therefore,\nwe elaborate the step by step process below using the following test case Example: n = 11,\nA = {\u22127, 10, 9, 2a, 3a, 8a, 8b, 1, 2b, 3b, 4} (the su\ufb03x a/b are added for clarity):\n\u2022 Initially, at A[0] = -7, we have L = {-7}.\n\u2022 We can insert A[1] = 10 at L[1] so that we have a length-2 LIS, L = {-7, 10}.\n\u2022 For A[2] = 9, we replace L[1] so that we have a \u2018better\u2019 length-2 LIS ending:\nL = {-7, 9}.\nThis is a greedy strategy. By storing the LIS with smaller ending value,\nwe maximize our ability to further extend the LIS with future values.\n\u2022 For A[3] = 2a, we replace L[1] to get an \u2018even better\u2019 length-2 LIS ending:\nL = {-7, 2a}.\n\u2022 We insert A[4] = 3a at L[2] so that we have a longer LIS, L = {-7, 2a, 3a}.\n\u2022 We insert A[5] = 8a at L[3] so that we have a longer LIS, L = {-7, 2a, 3a, 8a}.\n\u2022 For A[6] = 8b, nothing changes as L[3] = 8a (same value).\nL = {-7, 2a, 3a, 8a} remains unchanged.\n\u2022 For A[7] = 1, we improve L[1] so that L = {-7, 1, 3a, 8a}.\nThis illustrates how the array L is not the LIS of A. If we maintain L id and P, we can\nreconstruct the LIS back at the end.", "mimetype": "text/plain", "start_char_idx": 537366, "end_char_idx": 540410, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "54eef8ca-ca40-4ab8-b607-e39c8fe7e12e": {"__data__": {"id_": "54eef8ca-ca40-4ab8-b607-e39c8fe7e12e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "69d36dc7-323b-443e-816b-ea8566566973", "node_type": "1", "metadata": {}, "hash": "e4014a91e0da4d477ae28e9dde435edf89ee0b8bac3bd11447574099aea7baee", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "737a7657-def7-4a13-a2dd-ea5889e96d95", "node_type": "1", "metadata": {}, "hash": "30895774dbacd4ca1665f168d3f1e4ec25e85ccab26ba1952b78422863a182ea", "class_name": "RelatedNodeInfo"}}, "text": "\u2022 We insert A[4] = 3a at L[2] so that we have a longer LIS, L = {-7, 2a, 3a}.\n\u2022 We insert A[5] = 8a at L[3] so that we have a longer LIS, L = {-7, 2a, 3a, 8a}.\n\u2022 For A[6] = 8b, nothing changes as L[3] = 8a (same value).\nL = {-7, 2a, 3a, 8a} remains unchanged.\n\u2022 For A[7] = 1, we improve L[1] so that L = {-7, 1, 3a, 8a}.\nThis illustrates how the array L is not the LIS of A. If we maintain L id and P, we can\nreconstruct the LIS back at the end. Previously, only A[3] = 2a points back to A[0]\n= -7. Now, A[7] = 1 also points back to A[0] = -7.\nThis step is important as there can be longer subsequences in the future that may\nextend the length-2 subsequence at L[1] = 1, which we will see soon.\n\u2022 For A[8] = 2b, we improve L[2] so that L = {-7, 1, 2b, 8a}.\n\u2022 For A[9] = 3b, we improve L[3] so that L = {-7, 1, 2b, 3b}.\n\u2022 We insert A[10] = 4 at L[4] so that we have a longer LIS, L = {-7, 1, 2b, 3b, 4}.\nThe answer is the \ufb01nal (longest) length of the sorted array L at the end of the process\n(which is 5 for this example) and can be reconstructed using print LIS(lis end)\nroutine (which is \u22127 ! 1 ! 2b ! 3b ! 4 for this example).\nc. 0-1 Knapsack (Subset-Sum)\nProblem39: Given n items, each with its own value Vi and weight Wi, 8i 2 [0..n-1], and a\nmaximum knapsack size S, compute the maximum value of the items that we can carry, if we\ncan either40 ignore or take a particular item (hence the term 0-1 for ignore/take). Assume\nthat 1 \uf8ffn \uf8ff1000; 1 \uf8ffS \uf8ff10 000.\nExample: n = 4, V = {100, 70, 50, 10}, W = {10, 4, 6, 12}, S = 12.\nIf we select item 0 with weight 10 and value 100, we cannot take any other item. Not optimal.\nIf we select item 3 with weight 12 and value 10, we cannot take any other item. Not optimal.\nIf we select items 1 and 2, we have total weight 10 and total value 120. This is the maximum.\n39This is also known as the NP-complete Subset-Sum problem with a similar problem description: Given\na set of integers and an integer S, is there a (non-empty) subset that has a sum equal to S?\n40There are other variants of this problem, e.g., the Fractional Knapsack problem with Greedy solution.\n179\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nO(nS) Algorithm\nWe can simply use the classic DP function dp(id, remW) where id is the index of the current\nitem to be considered (from id = 0 until N-1) and remW is the remaining weight left in the\nknapsack (from remW = initial knapsack size S down to 0)\nint dp(int id, int remW) {\nif ((id == N) || (remW == 0)) return 0;\n// two base cases\nint &ans = memo[id][remW];\nif (ans != -1) return ans;\n// computed before\nif (W[id] > remW) return ans = dp(id+1, remW); // no choice, skip\nreturn ans = max(dp(id+1, remW),\n// has choice, skip\nV[id]+dp(id+1, remW-W[id]));\n// or take\n}\nThe answer can be found by calling dp(0, S). Note the overlapping sub-problems in this\n0-1 Knapsack problem.", "mimetype": "text/plain", "start_char_idx": 539965, "end_char_idx": 542808, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "737a7657-def7-4a13-a2dd-ea5889e96d95": {"__data__": {"id_": "737a7657-def7-4a13-a2dd-ea5889e96d95", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "54eef8ca-ca40-4ab8-b607-e39c8fe7e12e", "node_type": "1", "metadata": {}, "hash": "25869262390ebf1b2114b06672fd0e7cabdc47f42acf97c551113fec7a1304be", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0cf25ae8-d2c0-4ec3-ac51-0140398bfcc3", "node_type": "1", "metadata": {}, "hash": "b1fa6442969c1fcc375e0bd8203383d26162542735ef60736f3f2eb41bb9798e", "class_name": "RelatedNodeInfo"}}, "text": "Note the overlapping sub-problems in this\n0-1 Knapsack problem. Example: After taking item 0 and ignoring items 1 and 2, we arrive\nat state (3, 2)\u2014at the third item (id = 3) with two units of weight left (remW = 2). After\nignoring item 0 and taking items 1 and 2, we also arrive at the same state (3, 2). We will\nshow a visualization of this 0-1 Knapsack DP recursion DAG in Section 4.6.3. Although\nthere are overlapping sub-problems, there are only O(nS) possible distinct states (as id can\nvary between [0..n-1] and remW can vary between [0..S])! We can compute each of these\nstates in O(1), thus the overall time complexity41 of this DP solution is O(nS).\nNote: The top-down version of this DP solution is often faster than the bottom-up\nversion. This is because not all states are actually visited, and hence the critical DP states\ninvolved are actually only a (very small) subset of the entire state space. Remember that\nthe top-down DP only visits the required states whereas the bottom-up DP visits all distinct\nstates. Both versions are provided in our source code library.\nSource code: ch3/dp/UVa10130.cpp|java|py|ml\nd. Coin-Change (CC) - The General Version\nProblem: Given a target amount V cents and a list of denominations for n coins, i.e., we\nhave coinValue[i] (in cents, positive integers) for coin types i 2 [0..n-1], what is the\nminimum number of coins that we must use to represent V ? Assume that we have unlimited\nsupply of coins of any type and 1 \uf8ffn \uf8ff1000; 1 \uf8ffV \uf8ff10 000 (also see Section 3.4.1).\nExample 1: V = 10, n = 2, coinValue = {1, 5}; We can use:\nA. Ten 1 cent coins = 10 \u21e51 = 10; Total coins used = 10\nB. One 5 cents coin + Five 1 cent coins = 1 \u21e55 + 5 \u21e51 = 10; Total coins used = 6\nC. Two 5 cents coins = 2 \u21e55 = 10; Total coins used = 2 ! Optimal\nWe can use the Greedy algorithm if the coin denominations are suitable (see Section 3.4.1).\nExample 1 above is solvable with the Greedy algorithm. However, for general cases, we have\nto use DP. See Example 2 below:\nExample 2: V = 7, n = 4, coinValue = {1, 3, 4, 5}\nThe Greedy approach will produce 3 coins as its result as 5+1+1 = 7, but the optimal\nsolution is actually 2 coins (from 4+3)!\n41If S is large such that nS > 1M, this DP solution is not feasible, even with the space saving technique!\n180\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nO(nV ) Algorithm\nSolution: Use these Complete Search recurrence relations for change(value), where value\nis the remaining amount of cents that we need to represent in coins:\n1. change(0) = 0 // we need 0 coins to produce 0 cents\n2. change(< 0) = 1 // in practice, we can return a large positive value\n3. change(value) = min(1 + change(value-coinValue[i])) 8i 2 [0..n-1]\nThe answer can be found in the return value of change(V).\nFigure 3.14: Coin Change\nFigure 3.14 (and the recursion DAG of this DP Coin-Change in Section 4.6.3) shows that:\nchange(0) = 0 and change(< 0) = 1: These are the base cases.\nchange(1) = 1, from 1 + change(1-1), as 1 + change(1-5) is infeasible (returns 1).\nchange(2) = 2, from 1 + change(2-1), as 1 + change(2-5) is also infeasible (returns 1).\n... same thing for change(3) and change(4).", "mimetype": "text/plain", "start_char_idx": 542745, "end_char_idx": 545904, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0cf25ae8-d2c0-4ec3-ac51-0140398bfcc3": {"__data__": {"id_": "0cf25ae8-d2c0-4ec3-ac51-0140398bfcc3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "737a7657-def7-4a13-a2dd-ea5889e96d95", "node_type": "1", "metadata": {}, "hash": "30895774dbacd4ca1665f168d3f1e4ec25e85ccab26ba1952b78422863a182ea", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4c7d79c2-68a3-42cf-879e-384021a7d199", "node_type": "1", "metadata": {}, "hash": "a318edb83885e424b54c8e03c33d2e85349c6a36ab1a34f188e5831ae9852ea7", "class_name": "RelatedNodeInfo"}}, "text": "Figure 3.14: Coin Change\nFigure 3.14 (and the recursion DAG of this DP Coin-Change in Section 4.6.3) shows that:\nchange(0) = 0 and change(< 0) = 1: These are the base cases.\nchange(1) = 1, from 1 + change(1-1), as 1 + change(1-5) is infeasible (returns 1).\nchange(2) = 2, from 1 + change(2-1), as 1 + change(2-5) is also infeasible (returns 1).\n... same thing for change(3) and change(4).\nchange(5) = 1, from 1 + change(5-5) = 1 coin, smaller than 1 + change(5-1) = 5 coins.\n... and so on until change(10).\nThe answer is in change(V), which is change(10) = 2 in this example.\nWe can see that there are a lot of overlapping sub-problems in this Coin Change problem\n(e.g., both change(10) and change(6) require the value of change(5)). However, there are\nonly O(V ) possible distinct states (as value can vary between [0..V])! As we need to try\nn types of coins per state, the overall time complexity42 of this DP solution is O(nV ).\nO(nV ) Algorithm for the Counting Variant\nA variant of this problem is to count the number of possible (canonical) ways to get value V\ncents using a list of denominations of n coins. For Example 1 above, the answer is 3 ways:\n{A: 1+1+1+1+1 + 1+1+1+1+1, B: 5 + 1+1+1+1+1, C: 5+5}.\nSolution: Use this classic DP function: dp(type, value), where value is the same as\nabove but we now have one more parameter type for the index of the coin type that we are\ncurrently considering. This parameter type is important as this solution considers the coin\ntypes sequentially. Once we choose to ignore a certain coin type, we should not consider it\nagain to avoid double-counting:\nint dp(int type, int value) {\nif (value == 0) return 1;\n// one way, use nothing\nif ((value < 0) || (type == N)) return 0;\n// invalid or done\nint &ans = memo[type][value];\nif (ans != -1) return ans;\n// was computed before\nreturn ans = dp(type+1, value) +\n// ignore this type\ndp(type, value-coinValue[type]);\n// one more of this type\n}\n42If V is large such that nV > 1M, this DP solution is not feasible even with the space saving technique!\nLater in Book 2, we will learn that the time complexities of O(nS) for 0-1 Knapsack DP and O(nV ) for\nCoin Change DP are called \u2018pseudo-polynomial\u2019.\n181\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nThere are only O(nV ) possible distinct states. Since each state can be computed in O(1),\nthe overall time complexity43 of this DP solution is O(nV ). The answer can be found by\ncalling ways(0, V). Note: If the coin values are not changed and you are given many queries\nwith di\u21b5erent V, then we can choose not to reset the memo table. Therefore, we run this\nO(nV ) algorithm once and just perform an O(1) lookup for subsequent queries.\nSource code (this coin change variant): ch3/dp/UVa00674.cpp|java|py|ml\ne. Traveling-Salesman-Problem (TSP)\nProblem: Given n cities (1 \uf8ffn \uf8ff19) and their pairwise distances in the form of a symmetric\nmatrix dist of size n \u21e5n, compute the minimum cost of making a tour44 that starts from\nany city s, goes through all the other n \u22121 cities exactly once, and \ufb01nally returns to the\nstarting city s.\nExample: The graph shown in Figure 3.15 has n = 4 cities. Therefore, we have up to 4! =\n24 possible tours (permutations of 4 cities).", "mimetype": "text/plain", "start_char_idx": 545516, "end_char_idx": 548724, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4c7d79c2-68a3-42cf-879e-384021a7d199": {"__data__": {"id_": "4c7d79c2-68a3-42cf-879e-384021a7d199", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0cf25ae8-d2c0-4ec3-ac51-0140398bfcc3", "node_type": "1", "metadata": {}, "hash": "b1fa6442969c1fcc375e0bd8203383d26162542735ef60736f3f2eb41bb9798e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "091820a0-24c0-4db1-b3f4-dd04c696811f", "node_type": "1", "metadata": {}, "hash": "09e0f0da2ffd56ba09fb57319e6c871d6bacc5d982aeac125a7d7f7af2e34d16", "class_name": "RelatedNodeInfo"}}, "text": "Therefore, we run this\nO(nV ) algorithm once and just perform an O(1) lookup for subsequent queries.\nSource code (this coin change variant): ch3/dp/UVa00674.cpp|java|py|ml\ne. Traveling-Salesman-Problem (TSP)\nProblem: Given n cities (1 \uf8ffn \uf8ff19) and their pairwise distances in the form of a symmetric\nmatrix dist of size n \u21e5n, compute the minimum cost of making a tour44 that starts from\nany city s, goes through all the other n \u22121 cities exactly once, and \ufb01nally returns to the\nstarting city s.\nExample: The graph shown in Figure 3.15 has n = 4 cities. Therefore, we have up to 4! =\n24 possible tours (permutations of 4 cities). One of the minimum tours is A-B-C-D-A with a\ncost of 20+30+12+35 = 97 (notice that there can be more than one optimal solution, e.g.,\nthe other n-1 other symmetrical cycles: B-C-D-A-B, C-D-A-B-C, and D-A-B-C-D). Therefore\na common technique to solve the TSP problem is to \ufb01x one vertex, usually vertex A/0 and\nonly consider the permutations of the other n-1 vertices.\nFigure 3.15: A Complete Weighted Graph K4\nO(n!) Complete Search Algorithm\nA \u2018brute force\u2019 TSP solution (either iterative or recursive) that tries all O((n \u22121)!) possible\ntours (\ufb01xing the \ufb01rst city to vertex A in order to take advantage of symmetry) is only\ne\u21b5ective when n is at most 12 as 11! \u21e140M. When n > 12, this brute force solution will get\nTLE in programming contests. However, if there are multiple test cases, the limit for this\n\u2018brute force\u2019 TSP solution is probably just n = 11.\nO(2n\u22121 \u21e5n2) DP Algorithm\nWe can utilize DP for TSP since the computation of sub-tours is clearly overlapping, e.g., the\ntour A\u2212B \u2212C\u2212best sequence of (n\u22123) other cities that \ufb01nally returns to A clearly overlaps\nthe tour A \u2212C \u2212B\u2212the same best sequence of (n \u22123) other cities that also returns to A. If\nwe can avoid re-computing the lengths of such sub-tours, we can save a lot of computation\ntime. However, a distinct state in TSP depends on two parameters: the last city/vertex\nvisited c and something that we may have not seen before\u2014a set of visited cities.\nThere are many ways to represent a set. However, since we are going to pass this set\ninformation around as a parameter of a recursive function (if using top-down DP), the repre-\nsentation that we use must be lightweight and e\ufb03cient! In Section 2.2, we have presented a\n43If V is large such that nV > 1M, this DP solution is not feasible even with the space saving technique!\n44Such a tour is called a Hamiltonian tour, which is a cycle in an undirected graph which visits each vertex\nexactly once and also returns to the starting vertex. Later in Book 2, we will learn that TSP is an NP-hard\noptimization problem.\n182\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nviable option: the bitmask. If we have n-1 cities (ignoring the \ufb01xed starting city A/vertex 0),\nwe use a binary integer of length n-1 (saving one bit here is bene\ufb01cial). If bit i is \u20180\u2019 (o\u21b5)/\u20181\u2019\n(on), we say that item (city) i + 1 has been visited/has not been visited, respectively. For\nexample: mask= 1810 = 100102 implies that items (cities) {2, 5} have not been visited45\nyet. We will use fast bit manipulation techniques like LSOne(S) to quickly identify which \u20181\u2019\nbit(s) are still available46.\nThe C++ code of this classic DP function dp(u, mask) is shown below. Parameter u is\nthe current vertex. The \u20181\u2019/on bits in mask describes available vertices.\n// what is the minimum cost if we are at vertex u and have visited vertices\n// that are described by the off (0 bit) in mask?", "mimetype": "text/plain", "start_char_idx": 548097, "end_char_idx": 551608, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "091820a0-24c0-4db1-b3f4-dd04c696811f": {"__data__": {"id_": "091820a0-24c0-4db1-b3f4-dd04c696811f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4c7d79c2-68a3-42cf-879e-384021a7d199", "node_type": "1", "metadata": {}, "hash": "a318edb83885e424b54c8e03c33d2e85349c6a36ab1a34f188e5831ae9852ea7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a00682a1-bdd1-4df0-a918-7d20e17c388e", "node_type": "1", "metadata": {}, "hash": "951f05722b8168f259aebdd27080e3d31a36dc578eb6a5b6922ad9cef0e9372a", "class_name": "RelatedNodeInfo"}}, "text": "If bit i is \u20180\u2019 (o\u21b5)/\u20181\u2019\n(on), we say that item (city) i + 1 has been visited/has not been visited, respectively. For\nexample: mask= 1810 = 100102 implies that items (cities) {2, 5} have not been visited45\nyet. We will use fast bit manipulation techniques like LSOne(S) to quickly identify which \u20181\u2019\nbit(s) are still available46.\nThe C++ code of this classic DP function dp(u, mask) is shown below. Parameter u is\nthe current vertex. The \u20181\u2019/on bits in mask describes available vertices.\n// what is the minimum cost if we are at vertex u and have visited vertices\n// that are described by the off (0 bit) in mask?\nint dp(int u, int mask) {\n// mask = free coordinates\nif (mask == 0) return dist[u][0];\n// close the tour\nint &ans = memo[u][mask];\nif (ans != -1) return ans;\n// computed before\nans = 2000000000;\nint m = mask;\nwhile (m) {\n// up to O(n)\nint two_pow_v = LSOne(m);\n// but this is fast\nint v = __builtin_ctz(two_pow_v)+1;\n// offset v by +1\nans = min(ans, dist[u][v] + dp(v, mask^two_pow_v)); // keep the min\nm -= two_pow_v;\n}\nreturn ans;\n}\nThere are only O(2n\u22121 \u21e5n) distinct states because there are n cities and we remember up\nto 2n\u22121 other cities that have been visited in each tour (we assume that the starting city 0\nis always visited). Each state can be computed in O(k) if we use LSOne(mask) technique\nalthough the worst case is O(n), thus the overall time complexity of this DP solution is\nO(2n\u22121 \u21e5n2). This allows us to solve up to47 n \u21e1[18..19] as 192 \u21e5218 \u21e194M. This is not\na huge improvement over the brute force solution but if the programming contest problem\ninvolving TSP has input size 11 \uf8ffn \uf8ff19, then DP is the solution, not brute force. The\nanswer can be found by calling dp(0, (1<<(n-1))-1): We start from city 0 and assume\nthe other n-1 cities are still available/have not been visited (city 0 is always visited since the\nstart). This DP solution for TSP is called the Held-Karp DP algorithm [25].\nSource code: ch3/dp/beepers UVa10496.cpp|java|py|ml\nUsually, DP TSP problems in programming contests require some kind of graph prepro-\ncessing to generate the distance matrix dist before running the DP solution. These variants\nare discussed in the section about problem decomposition in Book 2.\n45Remember that in mask, indices start from 0 and are counted from the right and we need to o\u21b5set the\nindex by +1 as we have assumed that city A/vertex 0 has been visited.\n46It is bene\ufb01cial to set \u20181\u2019 to be \u2018not yet visited/available\u2019 and \u20180\u2019 to be \u2018visited/unavailable\u2019 in this case\nto take advantage of the fast LSOne(S) operation.\n47As programming contest problems usually require exact solutions, the DP-TSP solution presented here\nis already one of the best solutions. In real life, the TSP often needs to be solved for instances with thousands\nof cities. To solve larger problems like that, we have non-exact approaches like the ones presented in [23].\n183\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nDP solutions that involve a (small) set of Booleans as one of the parameters are more\nwell known as the DP with bitmask technique. More challenging DP problems involving this\ntechnique are discussed in the section about more advanced DP in Book 2.\nWe have added a tool for learning DP in VisuAlgo recursion visualization. This time, if\nthe recursive function goes to the same state more than once (overlapping sub-problems),\nVisuAlgo will highlight that vertex. Moreover, we can also redraw the Recursion Tree with\nsuch overlapping sub-problems as a Recursion DAG.", "mimetype": "text/plain", "start_char_idx": 550995, "end_char_idx": 554496, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a00682a1-bdd1-4df0-a918-7d20e17c388e": {"__data__": {"id_": "a00682a1-bdd1-4df0-a918-7d20e17c388e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "091820a0-24c0-4db1-b3f4-dd04c696811f", "node_type": "1", "metadata": {}, "hash": "09e0f0da2ffd56ba09fb57319e6c871d6bacc5d982aeac125a7d7f7af2e34d16", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a54c614a-4953-4373-ac65-18bd0fdfd974", "node_type": "1", "metadata": {}, "hash": "882e1e6acd8e861e06640afbcff1eb2e9d0f5f645056c590d3dae3f71f1c8f68", "class_name": "RelatedNodeInfo"}}, "text": "In real life, the TSP often needs to be solved for instances with thousands\nof cities. To solve larger problems like that, we have non-exact approaches like the ones presented in [23].\n183\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nDP solutions that involve a (small) set of Booleans as one of the parameters are more\nwell known as the DP with bitmask technique. More challenging DP problems involving this\ntechnique are discussed in the section about more advanced DP in Book 2.\nWe have added a tool for learning DP in VisuAlgo recursion visualization. This time, if\nthe recursive function goes to the same state more than once (overlapping sub-problems),\nVisuAlgo will highlight that vertex. Moreover, we can also redraw the Recursion Tree with\nsuch overlapping sub-problems as a Recursion DAG. We can re-draw Figure 3.2 (recursion\ntree of DP-TSP recurrence) as a recursion DAG by not repeating vertex (state) that has been\ncomputed before, but instead we draw more than one incoming edges for such overlapping\nstates (see Figure 4.42). This is best explained live, so please visit:\nVisualization: https://visualgo.net/en/recursion\nExercise 3.5.2.1: The solution for the Range Minimum Query: RMQ(i, j) on 1D arrays in\nSection 2.4.4 uses Segment Tree. This is overkill if the given array is static and unchanged\nthroughout all the queries. Use a DP technique to answer RMQ(i, j) in O(n log n) pre-\nprocessing and O(1) per query.\nExercise 3.5.2.2: Can we use an iterative Complete Search that tries all possible subsets\nof n items in Section 3.2.1 to solve the 0-1 Knapsack problem? Why?\nExercise 3.5.2.3*: Given a sequence A of N integers (N \uf8ff200K), \ufb01nd the the minimum\nnumber of subsets of increasing sequences of A. For example, if A = {5, 1, 3, 7, 4, 9, 6, 8, 2},\nthe answer is 3 subsets of increasing sequences, e.g., {{5, 7, 9}, {1, 3, 4, 6, 8}, {2}}. Design an\ne\ufb03cient algorithm to solve this. Hint: Study Dilworth\u2019s Theorem.\nExercise 3.5.2.3*: What is/are the additional change(s) compared to the code shown here\nso that the DP TSP solution can handle n = 20 (1 test case) in 1s?\n3.5.3\nNon-Classical Examples\nAlthough DP is a very popular problem type with high frequency of appearance in recent\nprogramming contests, the classical DP problems in their pure forms usually never appear\nin modern IOIs or ICPCs anymore. We study them to understand DP, but we have to\nlearn to solve many other non-classical DP problems (which may become classic in the near\nfuture) and develop our \u2018DP skills\u2019 in the process. In this subsection, we discuss two more\nnon-classical examples, adding to the UVa 11450 - Wedding Shopping problem that we have\ndiscussed in detail earlier. We have also selected some easier non-classical DP problems as\nprogramming exercises. Once you have cleared most of these problems, you are welcome to\nexplore the more challenging ones in the other sections in this book, e.g., Section 4.6.1 and\nvarious DP-related sections later.\n1. UVa 10943 - How do you add?\nAbridged problem description: Given an integer n, how many ways can K non-negative\nintegers less than or equal to n add up to n? Constraints: 1 \uf8ffn, K \uf8ff100. Example: For\nn = 20 and K = 2, there are 21 ways: 0 + 20, 1 + 19, 2 + 18, 3 + 17, . . . , 20 + 0.\nMathematically, the number of ways can be expressed as (n+k\u22121)C(k\u22121) (see Binomial\nCoe\ufb03cients which also requires DP in Book 2).\nWe will use this simple problem to re-\nillustrate Dynamic Programming principles that we have discussed in this section, especially\n184\n\nCHAPTER 3.", "mimetype": "text/plain", "start_char_idx": 553691, "end_char_idx": 557213, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a54c614a-4953-4373-ac65-18bd0fdfd974": {"__data__": {"id_": "a54c614a-4953-4373-ac65-18bd0fdfd974", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a00682a1-bdd1-4df0-a918-7d20e17c388e", "node_type": "1", "metadata": {}, "hash": "951f05722b8168f259aebdd27080e3d31a36dc578eb6a5b6922ad9cef0e9372a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9d4ae3e9-054a-42ff-8ef3-376c2791e575", "node_type": "1", "metadata": {}, "hash": "9d1c7d7728a2bee5eccfe31a96d481de734e973ac8235d96c0cdb1807124a282", "class_name": "RelatedNodeInfo"}}, "text": "1. UVa 10943 - How do you add?\nAbridged problem description: Given an integer n, how many ways can K non-negative\nintegers less than or equal to n add up to n? Constraints: 1 \uf8ffn, K \uf8ff100. Example: For\nn = 20 and K = 2, there are 21 ways: 0 + 20, 1 + 19, 2 + 18, 3 + 17, . . . , 20 + 0.\nMathematically, the number of ways can be expressed as (n+k\u22121)C(k\u22121) (see Binomial\nCoe\ufb03cients which also requires DP in Book 2).\nWe will use this simple problem to re-\nillustrate Dynamic Programming principles that we have discussed in this section, especially\n184\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\nthe process of deriving appropriate states for a problem and deriving correct transitions from\none state to another given the base case(s).\nFirst, we have to determine the parameters of this problem that can represent distinct\nstates of this problem. There are only two parameters in this problem, n and K. Therefore,\nthere are only 4 possible combinations:\n1. If we do not choose any of them, we cannot represent a state. This option is ignored.\n2. If we choose only n, then we do not know how many numbers \uf8ffn have been used.\n3. If we choose only K, then we do not know the target sum n.\n4. Therefore, the state of this problem should be represented by a pair (or tuple) (n, K).\nThe order of chosen parameter(s) does not matter, i.e., the pair (K, n) is also OK.\nNext, we have to determine the base case(s). It turns out that this problem is very easy\nwhen K = 1. Whatever n is, there is only one way to add exactly one number less than or\nequal to n to get n: use n itself. There is no other base case for this problem.\nFor the general case, we have this recursive formulation which is not too di\ufb03cult to derive:\nat state (n, K) where K > 1, we can split n into one number X 2 [0..n] and n \u2212X, i.e.,\nn = X + (n \u2212X). By doing this, we arrive at the sub-problem (n \u2212X, K \u22121), i.e., given a\nnumber n \u2212X, how many ways can K \u22121 numbers less than or equal to n \u2212X add up to\nn \u2212X? We can then sum all these ways.\nThese ideas can be written as the following Complete Search recurrence ways(n, K):\n1. ways(n, 1) = 1 // we can only use 1 number to add up to n, the number n itself\n2. ways(n, K) = Pn\nX=0 ways(n-X, K-1) // sum all possible ways, recursively\nThis problem has overlapping sub-problems. For example, the test case n = 1, K = 3 has\noverlapping sub-problems: The state (n = 0, K = 1) is reached twice (see Figure 4.35 in\nSection 4.6.1). However, there are only n\u21e5K possible states of (n, K). The cost of computing\neach state is O(n). Thus, the overall time complexity is O(n2 \u21e5K). As 1 \uf8ffn, K \uf8ff100, this\nis feasible. The answer can be found by calling ways(n, K).\nNote that this problem just needs the result modulo 1M (i.e., the last 6 digits of the answer,\nexcluding leading zeroes). See Book 2 for a discussion on modular arithmetic.\nSource code: ch3/dp/UVa10943.cpp|java|py|ml\n2. UVa 10003 - Cutting Sticks\nAbridged problem statement: Given a stick of length 1 \uf8ffl \uf8ff1000 and 1 \uf8ffn \uf8ff50 cuts to\nbe made to the stick (the cut coordinates A, lying in the range [0..l], are given). The cost\nof a cut is determined by the length of the stick to be cut. Your task is to \ufb01nd a cutting\nsequence so that the overall cost is minimized.", "mimetype": "text/plain", "start_char_idx": 556652, "end_char_idx": 559895, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9d4ae3e9-054a-42ff-8ef3-376c2791e575": {"__data__": {"id_": "9d4ae3e9-054a-42ff-8ef3-376c2791e575", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a54c614a-4953-4373-ac65-18bd0fdfd974", "node_type": "1", "metadata": {}, "hash": "882e1e6acd8e861e06640afbcff1eb2e9d0f5f645056c590d3dae3f71f1c8f68", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5b504746-7a4f-45e1-a7fb-16e1d447bd50", "node_type": "1", "metadata": {}, "hash": "8c61fbfa142824a1aded20254338356824e02d913c8dafdd78fe6584d8f375b0", "class_name": "RelatedNodeInfo"}}, "text": "The answer can be found by calling ways(n, K).\nNote that this problem just needs the result modulo 1M (i.e., the last 6 digits of the answer,\nexcluding leading zeroes). See Book 2 for a discussion on modular arithmetic.\nSource code: ch3/dp/UVa10943.cpp|java|py|ml\n2. UVa 10003 - Cutting Sticks\nAbridged problem statement: Given a stick of length 1 \uf8ffl \uf8ff1000 and 1 \uf8ffn \uf8ff50 cuts to\nbe made to the stick (the cut coordinates A, lying in the range [0..l], are given). The cost\nof a cut is determined by the length of the stick to be cut. Your task is to \ufb01nd a cutting\nsequence so that the overall cost is minimized.\nExample: l = 100, n = 3, and cut coordinates: A = {25, 50, 75} (already sorted)\nFigure 3.16: Cutting Sticks Illustration\nIf we cut from left to right, then we will incur cost = 225.\n1. First cut is at coordinate 25, total cost so far = 100;\n2. Second cut is at coordinate 50, total cost so far = 100 + 75 = 175;\n3. Third cut is at coordinate 75, \ufb01nal total cost = 175 + 50 = 225;\n185\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nHowever, the optimal answer is 200.\n1. First cut is at coordinate 50, total cost so far = 100; (this cut is shown in Figure 3.16)\n2. Second cut is at coordinate 25, total cost so far = 100 + 50 = 150;\n3. Third cut is at coordinate 75, \ufb01nal total cost = 150 + 50 = 200;\nHow do we tackle this problem? An initial approach might be this Complete Search algo-\nrithm: try all possible cutting points. Before that, we have to select an appropriate state\nde\ufb01nition for the problem: the (intermediate) sticks. We can describe a stick with its two\nendpoints: left and right. However, these two values can be huge48 and this can compli-\ncate the solution later when we want to memoize their values. We can take advantage of\nthe fact that there are only n + 1 smaller sticks after cutting the original stick n times. The\nendpoints of each smaller stick can be described by 0, the cutting point coordinates, and l.\nTherefore, we will add two more coordinates so that A = {0, the original A, and l}. This\nway, we can denote a stick by the indices of its endpoints in A.\nWe can then use these recurrences for cut(left, right), where left/right are the\nleft/right indices of the current stick w.r.t. A. Originally, the stick is described by left = 0\nand right = n+1, i.e., a stick with length [0..l]:\n1. cut(i-1, i) = 0, 8i 2 [1..n+1] // if left+1 = right where left and right are\nthe indices in A, then we have a stick segment that does not need to be divided further.\n2. cut(left, right) = min(cut(left, i) + cut(i, right) + (A[right]-A[left]))\n8i 2 [left+1..right-1] // try all possible cutting points and pick the best.\nThe cost of a cut is the length of the current stick, captured in (A[right]-A[left]).\nThe answer can be found at cut(0, n+1).\nNow let\u2019s analyze the time complexity. Initially, we have n choices for the cutting points.\nOnce we cut at a certain cutting point, we are left with n \u22121 further choices for the second\ncutting point. This repeats until we are left with zero cutting points. Trying all possible\ncutting points this way leads to an O(n!) algorithm, which is impossible for 1 \uf8ffn \uf8ff50.\nHowever, this problem has overlapping sub-problems. For example, in Figure 3.16 above,\ncutting at index 2 (cutting point = 50) produces two states: (0, 2) and (2, 4). The same\nstate (2, 4) can also be reached by cutting at index 1 (cutting point 25) and then cutting at\nindex 2 (cutting point 50).", "mimetype": "text/plain", "start_char_idx": 559286, "end_char_idx": 562728, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5b504746-7a4f-45e1-a7fb-16e1d447bd50": {"__data__": {"id_": "5b504746-7a4f-45e1-a7fb-16e1d447bd50", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9d4ae3e9-054a-42ff-8ef3-376c2791e575", "node_type": "1", "metadata": {}, "hash": "9d1c7d7728a2bee5eccfe31a96d481de734e973ac8235d96c0cdb1807124a282", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f3645bf1-aca8-4b4d-b1a0-f96bfefee913", "node_type": "1", "metadata": {}, "hash": "9f10114bca42276de5adb61ae917e145ede32d857527448604467f7599400069", "class_name": "RelatedNodeInfo"}}, "text": "Now let\u2019s analyze the time complexity. Initially, we have n choices for the cutting points.\nOnce we cut at a certain cutting point, we are left with n \u22121 further choices for the second\ncutting point. This repeats until we are left with zero cutting points. Trying all possible\ncutting points this way leads to an O(n!) algorithm, which is impossible for 1 \uf8ffn \uf8ff50.\nHowever, this problem has overlapping sub-problems. For example, in Figure 3.16 above,\ncutting at index 2 (cutting point = 50) produces two states: (0, 2) and (2, 4). The same\nstate (2, 4) can also be reached by cutting at index 1 (cutting point 25) and then cutting at\nindex 2 (cutting point 50). Thus, the search space is actually not that large. There are only\n(n+2)\u21e5(n+2) possible left/right indices or O(n2) distinct states and they can be memoized.\nThe time required to compute one state is O(n). Thus, the overall time complexity (of the\ntop-down DP) is O(n3). As n \uf8ff50, this is a feasible solution.\nSource code: ch3/dp/UVa10003.cpp|java|py (Knuth)|ml\nExercise 3.5.3.1*: Almost all of the source code for this section that is available in the\nGitHub repository: https://github.com/stevenhalim/cpbook-code: (LIS, Coin Change,\nTSP, and UVa 10003 - Cutting Sticks) are written in a top-down DP fashion due to the\npreferences of the authors of this book. Rewrite them using the bottom-up DP approach.\nExercise 3.5.3.2*: Solve the Cutting Sticks problem in O(n2). Hint: Use the Knuth-Yao\nDP Speedup by utilizing that the recurrence satis\ufb01es the Quadrangle Inequality (see the\ndetails in Book 2). Study ch3/dp/UVa10003 knuth td.py for the details.\n48This UVa 10003 is a rather old problem. In modern programming competitions, usually these (stick\nendpoint) values are huge so that contestants need to represent the state using other (smaller) means.\n186\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\n3.5.4\nDynamic Programming in Programming Contests\nBasic (Greedy and) DP techniques are always included in popular algorithm textbooks, e.g.,\nIntroduction to Algorithms [5], Algorithm Design [35], Algorithms [6], etc. In this section,\nwe have discussed six classical DP problems and their solutions. A brief summary is shown\nin Table 3.4. These classical DP problems, if they are to appear in a programming contest\ntoday, will likely occur only as part of bigger and harder problems.\n1D RSQ\n2D RSQ\nLIS\nKnapsack\nCC\nTSP\nState\n(i)\n(i,j)\n(i)\n(id,remW)\n(v)\n(pos,mask)\nSpace\nO(n)\nO(n2)\nO(n)\nO(nS)\nO(V )\nO(2nn)\nTransition\nsubarray\nsubmatrix\nall j < i\ntake/ignore\nall n coins\nall n cities\nTime\nO(n)\nO(n3)\nO(n2)\nO(nS)\nO(nV )\nO(2nn2)\nTable 3.4: Summary of Classical DP Problems in this Section\nTo help keep up with the growing di\ufb03culty and creativity required in these techniques\n(especially the non-classical DP), we recommend that you attempt more recent programming\ncontest problems and read their post-contest solutions/editorials, if any.\nIn the past (1990s), a contestant who is good at DP can become a \u2018king of programming\ncontests\u2019 as DP problems were usually the \u2018decider problems\u2019.\nNow, mastering DP is a\nbasic requirement! You cannot do well in programming contests without this knowledge.\nHowever, we have to keep reminding the readers of this book not to claim that they know\nDP if they only memorize the solutions of the classical DP problems! Try to master the art of\nproblem solving with DP: learn to determine the states (the DP table) that can uniquely and\ne\ufb03ciently represent sub-problems and also how to \ufb01ll up that DP table, either via top-down\nrecursion or bottom-up iteration.\nThere is no better way to master these problem solving paradigms than solving real\nprogramming problems!", "mimetype": "text/plain", "start_char_idx": 562067, "end_char_idx": 565743, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f3645bf1-aca8-4b4d-b1a0-f96bfefee913": {"__data__": {"id_": "f3645bf1-aca8-4b4d-b1a0-f96bfefee913", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5b504746-7a4f-45e1-a7fb-16e1d447bd50", "node_type": "1", "metadata": {}, "hash": "8c61fbfa142824a1aded20254338356824e02d913c8dafdd78fe6584d8f375b0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "35e563a8-9cf4-48af-8f65-b5a626108753", "node_type": "1", "metadata": {}, "hash": "528b7973ba642be7c29f92cfb7f792b497f4b293e29eb9bd2261fb42fa9fe3cb", "class_name": "RelatedNodeInfo"}}, "text": "In the past (1990s), a contestant who is good at DP can become a \u2018king of programming\ncontests\u2019 as DP problems were usually the \u2018decider problems\u2019.\nNow, mastering DP is a\nbasic requirement! You cannot do well in programming contests without this knowledge.\nHowever, we have to keep reminding the readers of this book not to claim that they know\nDP if they only memorize the solutions of the classical DP problems! Try to master the art of\nproblem solving with DP: learn to determine the states (the DP table) that can uniquely and\ne\ufb03ciently represent sub-problems and also how to \ufb01ll up that DP table, either via top-down\nrecursion or bottom-up iteration.\nThere is no better way to master these problem solving paradigms than solving real\nprogramming problems! Here, we list several examples. Once you are familiar with the\nexamples shown in this section, study the newer DP problems that have begun to appear in\nrecent programming contests.\nStarred programming exercises solvable using Dynamic Programming:\na. Max 1D/2D Range Sum\n1. Entry Level: UVa 10684 - The Jackpot * (standard; Kadane\u2019s algorithm)\n2. UVa 00787 - Maximum Sub ... * (max 1D range product; be careful\nwith 0; use Java BigInteger)\n3. UVa 01105 - Co\u21b5ee Central * (LA 5132 - WorldFinals Orlando11; more\nadvanced 2D Range Sum Queries)\n4. UVa 10755 - Garbage Heap * (max 2D range sum in 2 of the 3 dimen-\nsions; max 1D range sum with Kadane\u2019s algorithm on the 3rd dimension)\n5. Kattis - commercials * (transform each input by -P; Kadane\u2019s algorithm)\n6. Kattis - prozor * (2D range sum with \ufb01x range; output formatting)\n7. Kattis - sellingspatulas * (-8 per time slot initially; read sale data; 1D range\nsum; complete search)\nExtra UVa: 00108, 00507, 00836, 00983, 10074, 10667, 10827, 11951, 12640,\n13095.\nExtra Kattis: alicedigital, foldedmap, purplerain, shortsell.\nAlso see more examples in Book 2.\n187\n\n3.5.\nDYNAMIC PROGRAMMING\nc\u20ddSteven, Felix, Suhendry\nb. Longest Increasing Subsequence (LIS)\n1. Entry Level: UVa 00481 - What Goes Up? * (O(n log k) LIS+solution)\n2. UVa 01196 - Tiling Up Blocks * (LA 2815 - Kaohsiung03; sort all the\nblocks in increasing L[i], then we get the classical LIS problem)\n3. UVa 10534 - Wavio Sequence * (must use O(n log k) LIS twice)\n4. UVa 11790 - Murcia\u2019s Skyline * (combination of LIS+LDS; weighted)\n5. Kattis - increasingsubsequence * (LIS; n \uf8ff200; print lexicographically small-\nest solution, 99% similar to \u2018longincsubseq\u2019)\n6. Kattis - nesteddolls * (sort in one dimension; Dilworth\u2019s theorem; LIS in the\nother; also available at UVa 11368 - Nested Dolls)\n7. Kattis - trainsorting * (max(LIS(i)+LDS(i)-1), 8i 2 [0 . . . n-1]; also available\nat UVa 11456 - Trainsorting)\nExtra UVa: 00111, 00231, 00437, 00497, 10131, 10154.\nExtra Kattis: alphabet, longincsubseq, manhattanmornings, studentsko.\nc. 0-1 Knapsack (Subset-Sum)\n1. Entry Level: UVa 10130 - SuperSale * (very basic 0-1 Knapsack problem)\n2. UVa 01213 - Sum of Di\u21b5erent Primes * (LA 3619 - Yokohama06;\nextension of 0-1 Knapsack; s: (id, remN, remK) instead of s: (id, remN))\n3. UVa 11566 - Let\u2019s Yum Cha * (Knapsack variant: double each dim sum;\nadd one parameter to see if we have bought too many dishes)\n4.", "mimetype": "text/plain", "start_char_idx": 564983, "end_char_idx": 568154, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "35e563a8-9cf4-48af-8f65-b5a626108753": {"__data__": {"id_": "35e563a8-9cf4-48af-8f65-b5a626108753", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f3645bf1-aca8-4b4d-b1a0-f96bfefee913", "node_type": "1", "metadata": {}, "hash": "9f10114bca42276de5adb61ae917e145ede32d857527448604467f7599400069", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2adb80b9-5b48-40cf-9a74-9f7cb3dce652", "node_type": "1", "metadata": {}, "hash": "23ea39998f48448d94100d12205bc0e0eee0a9322b224685494f4d8f75fa1680", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: alphabet, longincsubseq, manhattanmornings, studentsko.\nc. 0-1 Knapsack (Subset-Sum)\n1. Entry Level: UVa 10130 - SuperSale * (very basic 0-1 Knapsack problem)\n2. UVa 01213 - Sum of Di\u21b5erent Primes * (LA 3619 - Yokohama06;\nextension of 0-1 Knapsack; s: (id, remN, remK) instead of s: (id, remN))\n3. UVa 11566 - Let\u2019s Yum Cha * (Knapsack variant: double each dim sum;\nadd one parameter to see if we have bought too many dishes)\n4. UVa 11832 - Account Book * (interesting DP; s: (id, val); use o\u21b5set to\nhandle negative numbers; t: plus or minus; print solution)\n5. Kattis - knapsack * (basic DP Knapsack; print the solution)\n6. Kattis - orders * (interesting Knapsack variant; print the solution)\n7. Kattis - presidentialelections * (pre-process the input to discard non winnable\nstates; be careful of negative total voters; then standard DP Knapsack)\nExtra UVa: 00431, 00562, 00990, 10261, 10616, 10664, 10690, 10819, 11003,\n11341, 11658, 12621.\nExtra Kattis: muzicari, ninepacks.\nAlso see NP-hard problems in Book 2.\nd. Coin-Change (CC)\n1. Entry Level: UVa 00674 - Coin Change * (basic Coin-Change problem)\n2. UVa 00242 - Stamps and ...\n* (LA 5181 - WorldFinals Nashville95;\nComplete Search + DP Coin-Change)\n3. UVa 10448 - Unique World * (after dealing with traversal on tree, you\ncan reduce the original problem into Coin-Change; not trivial)\n4. UVa 11259 - Coin Changing Again * (part of the problem is DP Coin-\nChange with restricted number of coins per type; inclusion-exclusion)\n5. Kattis - bagoftiles * (count number of ways to do Coin-Change; meet in\nthe middle; DP combinatorics (n choose k) to \ufb01nd the answer for a+b)\n6. Kattis - canonical * (complete search possible range of counter examples; do\nboth greedy Coin-Change and DP Coin-Change)\n7. Kattis - exactchange2 * (a variation to the Coin-Change problem; also\navailable at UVa 11517 - Exact Change)\nExtra UVa: 00147, 00166, 00357, 10313, 11137.\nAlso see NP-hard problems in Book 2.\n188\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\ne. Traveling-Salesman-Problem (TSP)\n1. Entry Level: Kattis - beepers * (DP or recursive backtracking with su\ufb03cient\npruning; also available at UVa 10496 - Collecting Beepers)\n2. UVa 00216 - Getting in Line * (LA 5155 - WorldFinals KansasCity92;\nDP TSP problem; but still solvable with backtracking)\n3. UVa 11795 - Mega Man\u2019s Mission * (DP TSP variant; counting paths\non DAG; DP+bitmask; let Mega Buster owned by a dummy \u2018Robot 0\u2019)\n4. UVa 12841 - In Puzzleland (III) * (simply \ufb01nd and print the lexico-\ngraphically smallest Hamiltonian-Path; use DP TSP technique)\n5. Kattis - bustour * (LA 6028 - WorldFinals Warsaw12; DP TSP variant; also\navailable at UVa 01281 - Bus Tour)\n6. Kattis - cycleseasy * (Count number of Hamiltonian-Tours)\n7. Kattis - errands * (map location names to integer indices; DP TSP)\nExtra Kattis: maximizingyourpay, pokemongogo, race.\nAlso see NP-hard problems in Book 2.\nf. DP level 1\n1. Entry Level: UVa 10003 - Cutting Sticks * (s: (l, r))\n2. UVa 10912 - Simple Minded ... * (s: (len, last, sum); t: try next char)\n3.", "mimetype": "text/plain", "start_char_idx": 567712, "end_char_idx": 570781, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2adb80b9-5b48-40cf-9a74-9f7cb3dce652": {"__data__": {"id_": "2adb80b9-5b48-40cf-9a74-9f7cb3dce652", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "35e563a8-9cf4-48af-8f65-b5a626108753", "node_type": "1", "metadata": {}, "hash": "528b7973ba642be7c29f92cfb7f792b497f4b293e29eb9bd2261fb42fa9fe3cb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "26f81cb3-be38-4548-8613-8d465df3cf20", "node_type": "1", "metadata": {}, "hash": "638864adf0b212ad31836b31fc907be60e2347822da5236a879b61ce03675b5c", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - bustour * (LA 6028 - WorldFinals Warsaw12; DP TSP variant; also\navailable at UVa 01281 - Bus Tour)\n6. Kattis - cycleseasy * (Count number of Hamiltonian-Tours)\n7. Kattis - errands * (map location names to integer indices; DP TSP)\nExtra Kattis: maximizingyourpay, pokemongogo, race.\nAlso see NP-hard problems in Book 2.\nf. DP level 1\n1. Entry Level: UVa 10003 - Cutting Sticks * (s: (l, r))\n2. UVa 10912 - Simple Minded ... * (s: (len, last, sum); t: try next char)\n3. UVa 11420 - Chest of ... * (s: (prev, id, numlck); lock/unlock this chest)\n4. UVa 13141 - Growing Trees * (s: (level, branch previously); t: not\nbranching if branch previously or branching (one side) otherwise)\n5. Kattis - nikola * (s: (pos, last jump); t: jump forward or backward)\n6. Kattis - spiderman * (simple DP; go up or down; print solution)\n7. Kattis - ticketpricing * (LA 6867 - RockyMountain15; see UVa 11450 dis-\ncussed in this section; real life problem; print part of the solution)\nExtra UVa: 00116, 01261, 10036, 10337, 10446, 10520, 10688, 10721, 10910,\n10943, 10980, 11026, 11407, 11450, 11703, 12654, 12951.\nExtra Kattis: keyboardconcert, permutationdescent, weightofwords, wordclouds.\ng. DP level 2\n1. Entry Level: UVa 12324 - Philip J. Fry ... * (spheres > n are useless)\n2. UVa 00662 - Fast Food * (s: (L, R, k), that denotes the minimum distance\nsum to cover restaurants at index [L..R] with k depots left)\n3. UVa 12862 - Intrepid climber * (1D DP to compute the path cost from\nevery vertex that goes up to the mountain top; compute answer)\n4. UVa 12955 - Factorial * (there are only 8 eligible factorials under 100 000;\nwe can use DP; s: (i, sum); t: take/stay, take/move, don\u2019t take/move)\n5. Kattis - kutevi * (s: (360 integer degrees))\n6. Kattis - tight * (s: (i, j); #tight words of length i that end in digit j divided\nby #words: (k + 1)n; also available at UVa 10081 - Tight words)\n7. Kattis - walrusweights * (backtracking with memoization)\nExtra UVa: 10039, 10069, 10086, 10120, 10164, 10239, 10400, 10465, 10651,\n11485, 11514, 11908.\nExtra Kattis: debugging, drivinglanes, watersheds.\nh. Also see Chapter 4 and a few others for more DP-related programming exercises.\n189\n\n3.6.\nSOLUTION TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\n3.6\nSolution to Non-Starred Exercises\nExercise 3.2.1.1: The solution is a simple recursive backtracking with bitmask. See our\nimplementation at ch3/cs/UVa11742.java.\nExercise 3.2.1.2: Interesting usage of C++ STL next permutation is shown below:\nint n = 7, k = 3;\nvector<int> taken(n, 0);\n// initially none taken\nfor (int i = n-k; i < n; ++i) taken[i] = 1;\n// last k are taken\ndo {\n// iterate C(7, 3) = 35x\nfor (int i = 0; i < n; ++i)\nif (taken[i])\nprintf(\"%d \", i);\nprintf(\"\\n\");\n}\nwhile (next_permutation(taken.begin(), taken.end()));\nExercise 3.3.1.1: This problem can be solved without the \u2018Binary Search the Answer\u2019\ntechnique. Simulate the journey once.", "mimetype": "text/plain", "start_char_idx": 570305, "end_char_idx": 573208, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "26f81cb3-be38-4548-8613-8d465df3cf20": {"__data__": {"id_": "26f81cb3-be38-4548-8613-8d465df3cf20", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2adb80b9-5b48-40cf-9a74-9f7cb3dce652", "node_type": "1", "metadata": {}, "hash": "23ea39998f48448d94100d12205bc0e0eee0a9322b224685494f4d8f75fa1680", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "87123bb9-c1be-45c2-b433-7eee74da94c1", "node_type": "1", "metadata": {}, "hash": "e69a3a51ad465a0613a1efde04ec86f29e6086f2398df4154e27cc611d5ca407", "class_name": "RelatedNodeInfo"}}, "text": "See our\nimplementation at ch3/cs/UVa11742.java.\nExercise 3.2.1.2: Interesting usage of C++ STL next permutation is shown below:\nint n = 7, k = 3;\nvector<int> taken(n, 0);\n// initially none taken\nfor (int i = n-k; i < n; ++i) taken[i] = 1;\n// last k are taken\ndo {\n// iterate C(7, 3) = 35x\nfor (int i = 0; i < n; ++i)\nif (taken[i])\nprintf(\"%d \", i);\nprintf(\"\\n\");\n}\nwhile (next_permutation(taken.begin(), taken.end()));\nExercise 3.3.1.1: This problem can be solved without the \u2018Binary Search the Answer\u2019\ntechnique. Simulate the journey once. We just need to \ufb01nd the largest fuel requirement in\nthe entire journey and make the fuel tank be su\ufb03cient for it. For problem like this one,\nthose who are stronger in Mathematics will try to \ufb01nd this more elegant and faster solution\nwhereas those who are stronger in Competitive Programming techniques will use BSTA\napproach and rely on Computer\u2019s speed as the extra O(log ans) factor is virtually negligible.\nExercise 3.3.1.2: A sample BSTA code when the (smallest) answer lies in an integer range\n[lo..hi] is as follows:\nint lo = 0, hi = 1e6;\nfor (int i = 0; i < 50; ++i) {\n// log_2(1e6/1e-9) ~= 49\nint mid = (lo+hi) >> 1;\n// looping 50x is enough\n// int mid = lo + (hi-lo) >> 1;\n// alternative way\ncan(mid) ? hi = mid : lo = mid;\n// ternary operator\n}\nExercise 3.5.1.1: Garment g = 0, take the third model (cost 8); Garment g = 1, take\nthe \ufb01rst model (cost 10); Garment g = 2, take the \ufb01rst model (cost 7); Money used = 25.\nNothing left. Test case D is also solvable with Greedy algorithm.\nExercise 3.5.1.2: No, this state formulation does not work. We need to know how much\nmoney we have left at each sub-problem so that we can determine if we still have enough\nmoney to buy a certain model of the current garment.\nExercise 3.5.1.3: Please see the implementation at ch3/dp/UVa11450 td.py.\nExercise 3.5.2.1: The solution uses Sparse Table data structure discussed in Book 2.\nExercise 3.5.2.2: The iterative Complete Search solution to generate and check all possible\nsubsets of size n runs in O(n \u21e52n). This is OK for n \uf8ff20 but too slow when n > 20. The\nDP solution presented in Section 3.5.2 runs in O(n \u21e5S). If S is not that large, we can have\na much larger n than just 20 items as long as n \u21e5S < 1M.\n190\n\nCHAPTER 3. PROBLEM SOLVING PARADIGMS\nc\u20ddSteven, Felix, Suhendry\n3.7\nChapter Notes\nHere is one important advice for this chapter: please do not just memorize the solutions\nfor each problem discussed (except for classic greedy algorithms), but instead remember\nand internalize the thought process and problem solving strategies used. Good problem\nsolving skills are more important than memorized solutions for well-known Computer Science\nproblems when dealing with (often creative and novel) contest problems.\nMany problems in IOI or ICPC require a combination of these problem solving strategies\n(see Book 2). If we have to nominate only one chapter in this book that contestants have to\nreally master, we would choose this one, especially for IOI contestants.\nIn Table 3.5, we compare the four problem solving techniques based on their likely re-\nsults for various problem types. In Table 3.5 and the list of programming exercises in this\nsection (and later in Chapter 8), we see that there are more Complete Search (CS) problems\n(excluding harder CS in Book 2) than DP (excluding harder DP in Book 2)/Greedy (exclud-\ning MST+SSSP problems in Chapter 4) problems, with D&C problems being the fewest.", "mimetype": "text/plain", "start_char_idx": 572668, "end_char_idx": 576118, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "87123bb9-c1be-45c2-b433-7eee74da94c1": {"__data__": {"id_": "87123bb9-c1be-45c2-b433-7eee74da94c1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "26f81cb3-be38-4548-8613-8d465df3cf20", "node_type": "1", "metadata": {}, "hash": "638864adf0b212ad31836b31fc907be60e2347822da5236a879b61ce03675b5c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1531d0a3-9773-49a9-baf4-4c08b11c96ac", "node_type": "1", "metadata": {}, "hash": "b4063a80fcf84f4cbf9fc12b1826711a15fb8bc28bd5e5f10066e6cfc7fa06f3", "class_name": "RelatedNodeInfo"}}, "text": "Many problems in IOI or ICPC require a combination of these problem solving strategies\n(see Book 2). If we have to nominate only one chapter in this book that contestants have to\nreally master, we would choose this one, especially for IOI contestants.\nIn Table 3.5, we compare the four problem solving techniques based on their likely re-\nsults for various problem types. In Table 3.5 and the list of programming exercises in this\nsection (and later in Chapter 8), we see that there are more Complete Search (CS) problems\n(excluding harder CS in Book 2) than DP (excluding harder DP in Book 2)/Greedy (exclud-\ning MST+SSSP problems in Chapter 4) problems, with D&C problems being the fewest.\nTherefore, we recommend that readers concentrate on improving their CS, DP, Greedy, and\nD&C skills, in that order.\nCS Problem\nD&C Problem\nGreedy Problem\nDP Problem\nCS Solution\nAC\nTLE/AC\nTLE/AC\nTLE/AC\nD&C Solution\nWA\nAC\nWA\nWA\nGreedy Solution\nWA\nWA\nAC\nWA\nDP Solution\nMLE/TLE/AC\nMLE/TLE/AC\nMLE/TLE/AC\nAC\nFrequency\nHigh\n(Very) Low\nMedium-High\nHigh\nTable 3.5: Comparison of Problem Solving Techniques (Rule of Thumb only)\nWe will conclude this chapter by remarking that for some real-life problems, especially those\nthat are classi\ufb01ed as NP-hard [5], many of the approaches discussed in this chapter will\nnot work. For example, the 0-1 Knapsack (Subset-Sum) Problem which has an O(nS)\nDP complexity is too slow if S is big; Coin-Change Problem which has an O(nV ) DP\ncomplexity is too slow if V is big; TSP which has a O(2n\u22121 \u21e5n2) DP complexity is too slow\nif n is any larger than 19. For such problems, we can resort to heuristics or local search\ntechniques such as Tabu Search [23, 22], Genetic Algorithms, Ant-Colony Optimizations,\nSimulated Annealing, Beam Search, etc. However, all these heuristic-based searches are not\nin the IOI syllabus [16] and also not widely used in ICPC as of year 2020.\nStatistics of CP Editions\n1st\n2nd\n3rd\n4th\nNumber of Pages\n32\n32\n52\n63 (+21%)\nWritten Exercises\n7\n16\n21\n9+10*=19 (-10%)\nProgramming Exercises\n109\n194\n245\n568 (+132%)\nThe breakdown of the number of programming exercises from each section is shown below:\nSection\nTitle\nAppearance\n% in Chapter\n% in Book\n3.2\nComplete Search\n257\n\u21e145%\n\u21e17.4%\n3.3\nDivide and Conquer\n59\n\u21e110%\n\u21e11.7%\n3.4\nGreedy\n118\n\u21e121%\n\u21e13.4%\n3.5\nDynamic Programming\n134\n\u21e124%\n\u21e13.9%\nTotal\n568\n\u21e116.4%\n191\n\n3.7.\nCHAPTER NOTES\nc\u20ddSteven, Felix, Suhendry\nThis page is intentionally left blank to keep the number of pages per chapter even.\n192\n\nChapter 4\nGraph\nEveryone is on average \u21e1six steps away from any other person on Earth\n\u2014 Stanley Milgram - the Six Degrees of Separation experiment in 1969, [56]\n4.1\nOverview and Motivation\nMany real-life problems can be classi\ufb01ed as graph problems. Some have e\ufb03cient1 (polyno-\nmial) solutions. Some do not have them yet2 (see Book 2). In this relatively big chapter with\nlots of \ufb01gures, we discuss graph problems3 that commonly appear in programming contests,\nthe algorithms to solve them, and the practical implementations of these algorithms. We\ncover topics ranging from basic graph traversals, minimum spanning trees, single-source/all-\npairs shortest paths, and discuss graphs with special properties. Later in Chapter 8-9, we\nwill cover network \ufb02ows, graph matching4, and harder graph problems.\nThis chapter is unfortunately not written for readers who have zero knowledge of graph\ntheory. In writing this chapter, we assume that the readers are already familiar with the\nbasic graph terminologies listed in Table 4.1.", "mimetype": "text/plain", "start_char_idx": 575427, "end_char_idx": 578932, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1531d0a3-9773-49a9-baf4-4c08b11c96ac": {"__data__": {"id_": "1531d0a3-9773-49a9-baf4-4c08b11c96ac", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "87123bb9-c1be-45c2-b433-7eee74da94c1", "node_type": "1", "metadata": {}, "hash": "e69a3a51ad465a0613a1efde04ec86f29e6086f2398df4154e27cc611d5ca407", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e8071a64-431c-424e-9c9d-84857be6e6b0", "node_type": "1", "metadata": {}, "hash": "314cdd2a9d0aab384d78f0e4c9508687ee0b8f98467fe2348366d055f4d2566e", "class_name": "RelatedNodeInfo"}}, "text": "Some have e\ufb03cient1 (polyno-\nmial) solutions. Some do not have them yet2 (see Book 2). In this relatively big chapter with\nlots of \ufb01gures, we discuss graph problems3 that commonly appear in programming contests,\nthe algorithms to solve them, and the practical implementations of these algorithms. We\ncover topics ranging from basic graph traversals, minimum spanning trees, single-source/all-\npairs shortest paths, and discuss graphs with special properties. Later in Chapter 8-9, we\nwill cover network \ufb02ows, graph matching4, and harder graph problems.\nThis chapter is unfortunately not written for readers who have zero knowledge of graph\ntheory. In writing this chapter, we assume that the readers are already familiar with the\nbasic graph terminologies listed in Table 4.1. We will elaborate on how to implement and\napply e\ufb03cient graph algorithms to graph problems that commonly appear in programming\ncontests. Therefore, if you encounter any unfamiliar term in Table 4.1, please read other\nreference books like [5, 51] (or browse the Internet) and search for that particular term.\nVertices/Nodes\nEdges\nSet V ; size |V |\nSet E; size |E|\nGraph G(V, E)\nUn/Weighted\nUn/Directed\nIn/Out Degree\nSparse/Dense\nComponent\nPath\nCycle\nIsolated\nReachable\nConnected\nSelf-Loop\nMultiple Edges\nMultigraph\nSimple Graph\nSub-Graph\nCut Vertex\nBridge\nSCC\nMatching\nLine\nDAG\nTree/Forest\nBipartite\nEulerian\nComplete\nGrid Graph\nWheel Graph\nLine Graph\nHamiltonian\nIsomorphism\nTable 4.1: List of Important Graph Terminologies\n1In 1965, Jack Edmonds published his famous paper \u2018Paths, Trees, and Flowers [10]. In the paper, he\nwrote that algorithms with polynomial time complexity are e\ufb03cient algorithms.\n2Many hard graph problems are classi\ufb01ed as NP-hard/complete problems [18]. If P is really 6= NP\u2014which\nmany Computer Scientists currently believe, then there is no polynomial algorithm for these problems.\n3Most graph problems in programming contests involve simple graph, i.e., graph with no self-loop nor\nmultiple edges between the same pair of vertices. The non-simple graphs, i.e., the multigraphs, usually have\nmore complicated solutions and/or special cases which make them not suitable for programming contests.\n4Graph matching is an interesting problem in programming contests. Although it has several polynomial\nsolutions for general graph [10], the algorithm is a bit complex so that in this chapter, we only discuss the\nsimpler version of this problem on special Bipartite Graph in Section 4.6.3.\n193\n\n4.1.\nOVERVIEW AND MOTIVATION\nc\u20ddSteven, Felix, Suhendry\nWe also assume that the readers have read the various ways to represent graph information\nthat have been discussed earlier in Section 2.4.1. That is, we will directly use the terms like:\nAdjacency Matrix, Adjacency List, Edge List, and implicit graph without rede\ufb01ning them.\nPlease revise Section 2.4.1 if you are not yet familiar with these graph data structures.\nOur research on graph problems in recent ICPC (Asia) Regional and World Finals con-\ntests reveals that there is at least one (and possibly more) graph problem(s) in an ICPC\nproblem set. However, since the range of graph problems is so big, each speci\ufb01c graph prob-\nlem only has a small probability of appearance. So the question is: \u201cWhich ones do we have\nto focus on?\u201d. In our opinion, there is no clear answer for this question. If you want to do\nwell in ICPC, you have no choice but to study and master all these materials.\nFor IOI, the syllabus [16] restricts IOI tasks to a subset of material mentioned in this\nchapter. This is logical as high school students competing in IOI are not expected to be\nwell-versed with too many problem-speci\ufb01c algorithms. To assist the readers aspiring to\ntake part in the IOI, we will mention whether a particular section in this chapter is currently\noutside the syllabus.\nTo help the reader in understanding the graph algorithms discussed in this Chapter,\nwe have built lots of visualization algorithms in VisuAlgo (https://visualgo.net).\nIn\nfact, VisuAlgo was started as a project of visualizing graph algorithms before we extend\nit to include many other data structures and algorithms [24].", "mimetype": "text/plain", "start_char_idx": 578157, "end_char_idx": 582297, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e8071a64-431c-424e-9c9d-84857be6e6b0": {"__data__": {"id_": "e8071a64-431c-424e-9c9d-84857be6e6b0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1531d0a3-9773-49a9-baf4-4c08b11c96ac", "node_type": "1", "metadata": {}, "hash": "b4063a80fcf84f4cbf9fc12b1826711a15fb8bc28bd5e5f10066e6cfc7fa06f3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "20e1f495-27f3-4ccc-9296-d26dbcdccf84", "node_type": "1", "metadata": {}, "hash": "27de3565b91135cf036b9d94f4d625bda864283fecb2b4cd1b0f9a1d59dfec57", "class_name": "RelatedNodeInfo"}}, "text": "In our opinion, there is no clear answer for this question. If you want to do\nwell in ICPC, you have no choice but to study and master all these materials.\nFor IOI, the syllabus [16] restricts IOI tasks to a subset of material mentioned in this\nchapter. This is logical as high school students competing in IOI are not expected to be\nwell-versed with too many problem-speci\ufb01c algorithms. To assist the readers aspiring to\ntake part in the IOI, we will mention whether a particular section in this chapter is currently\noutside the syllabus.\nTo help the reader in understanding the graph algorithms discussed in this Chapter,\nwe have built lots of visualization algorithms in VisuAlgo (https://visualgo.net).\nIn\nfact, VisuAlgo was started as a project of visualizing graph algorithms before we extend\nit to include many other data structures and algorithms [24]. We encourage the reader to\ntry various graph visualizations in VisuAlgo with your own input graph and see the graph\nalgorithm animated live in front of you.\nPro\ufb01le of Algorithm Inventors\nRobert Endre Tarjan (born 1948) is an American computer scientist. He is the discoverer\nof several important graph algorithms. The most important one in the context of competitive\nprogramming is the algorithm for \ufb01nding Strongly Connected Components in a directed\ngraph and the algorithm to \ufb01nd Articulation Points and Bridges in an undirected graph\n(discussed in Section 4.2 together with other DFS variants invented by him and his colleagues\n[55]). He also invented Tarjan\u2019s o\u21b5-line Least Common Ancestor algorithm, invented\nSplay Tree data structure, and analyze the time complexity of the Union-Find Disjoint\nSets data structure (see Section 2.4.2).\nJohn Edward Hopcroft (born 1939) is an American computer scientist. He is the Professor\nof Computer Science at Cornell University. Hopcroft received the Turing Award\u2014the most\nprestigious award in the \ufb01eld and often recognized as the \u2018Nobel Prize of computing\u2019 (jointly\nwith Robert Endre Tarjan in 1986)\u2014for fundamental achievements in the design and analysis\nof algorithms and data structures. Along with his work with Tarjan on planar graphs (and\nsome other graph algorithms like \ufb01nding articulation points/bridges using DFS) he is\nalso known for the Hopcroft-Karp algorithm for \ufb01nding matchings in Bipartite Graphs,\ninvented together with Richard Manning Karp [26] (see Book 2).\nSambasiva Rao Kosaraju is a professor of Computer Science at Johns Hopkins University,\nwho has done extensive work in the design and analysis of parallel and sequential algorithms.\nIn 1978, he wrote a paper describing a method to e\ufb03ciently compute strongly connected\nmembers of a directed graph, a method later called as the Kosaraju\u2019s algorithm.\n194\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.2\nGraph Traversal\n4.2.1\nOverview and Motivation\nSuppose that we already store our graph in a graph data structure as in Section 2.4.1 (or the\ngraph is implicit). We can know some basic properties of the graph like the size of V , E, the\nlist of neighbors of a certain vertex u, etc. However, to gain more meaningful information\nabout the graph like the (indirect) connectivity between two vertices u and v, the number\nof Connected Components (CC) of the graph, etc, we need to traverse/explore it.\nFirst, we need to decide where we start. Sometimes it can be arbitrary (and usually we\nconveniently choose the \ufb01rst vertex\u2014vertex 0) or the problem mandates us to start from\na designated source vertex s. There are two basic graph traversal algorithms: Depth First\nSearch (DFS) and Breadth First Search (BFS). Both do similar thing: from one vertex u,\ngo to another unvisited vertex v by following the edge (u, v). They are just using di\u21b5erent\nunderlying data structure (a\u2013usually implicit\u2013stack for DFS versus a queue for BFS) and\nthus their vertex visitation order is (usually5) di\u21b5erent.\n4.2.2\nDepth First Search (DFS)\nDepth First Search\u2014abbreviated as DFS\u2014is a simple algorithm for traversing a graph.\nStarting from a distinguished source vertex, DFS will traverse the graph \u2018depth-\ufb01rst\u2019. Every\ntime DFS hits a branching point (a vertex with more than one neighbors), DFS will choose\none of the unvisited neighbor(s) and visit this neighbor vertex.", "mimetype": "text/plain", "start_char_idx": 581437, "end_char_idx": 585666, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "20e1f495-27f3-4ccc-9296-d26dbcdccf84": {"__data__": {"id_": "20e1f495-27f3-4ccc-9296-d26dbcdccf84", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e8071a64-431c-424e-9c9d-84857be6e6b0", "node_type": "1", "metadata": {}, "hash": "314cdd2a9d0aab384d78f0e4c9508687ee0b8f98467fe2348366d055f4d2566e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f3a149d5-39bb-4d66-9110-e2b871e141f8", "node_type": "1", "metadata": {}, "hash": "496493d583ad584a910f462a82872c3919aee269df517498675007d0d910974c", "class_name": "RelatedNodeInfo"}}, "text": "Both do similar thing: from one vertex u,\ngo to another unvisited vertex v by following the edge (u, v). They are just using di\u21b5erent\nunderlying data structure (a\u2013usually implicit\u2013stack for DFS versus a queue for BFS) and\nthus their vertex visitation order is (usually5) di\u21b5erent.\n4.2.2\nDepth First Search (DFS)\nDepth First Search\u2014abbreviated as DFS\u2014is a simple algorithm for traversing a graph.\nStarting from a distinguished source vertex, DFS will traverse the graph \u2018depth-\ufb01rst\u2019. Every\ntime DFS hits a branching point (a vertex with more than one neighbors), DFS will choose\none of the unvisited neighbor(s) and visit this neighbor vertex. DFS repeats this process and\ngoes deeper until it reaches a vertex where it cannot go any deeper. When this happens,\nDFS will \u2018backtrack\u2019 and explore another unvisited neighbor(s), if any.\nThis graph traversal behavior can be implemented easily with the recursive code below.\nOur DFS implementation uses the help of a global vector of integers: vi dfs_num to distin-\nguish the state of each vertex. For the basic DFS implementation, we only use vi dfs num\nto distinguish between UNVISITED versus VISITED states. Initially, all values in dfs_num are\nset to UNVISITED. We will use vi dfs_num for other purposes later6. Calling dfs(u) starts\nDFS from a vertex u, marks vertex u as VISITED, and then recursively visits each UNVISITED\nneighbor v of u (i.e., edge (u, v) exists in the graph and dfs_num[v] == UNVISITED).\nenum { UNVISITED = -1, VISITED = -2 };\n// basic flags\nvi dfs_num;\n// initially all UNVISITED\nvoid dfs(int u) {\n// normal usage\ndfs_num[u] = VISITED;\n// mark u as visited\nfor (auto &[v, w] : AL[u])\n// C++17 style, w ignored\nif (dfs_num[v] == UNVISITED)\n// to avoid cycle\ndfs(v);\n// recursively visits v\n}\nOn the sample graph in Figure 4.1\u2014left, dfs(0)\u2014calling DFS from a starting vertex u = 0\u2014\nwill trigger this sequence of visitation: 0 ! 1 ! 2 ! 3 ! 4 (see Figure 4.1\u2014right). This\nsequence is \u2018depth-\ufb01rst\u2019, i.e., DFS goes to the deepest possible vertex from the start vertex\nbefore attempting another branch (there is none in this case).\n5We need to construct special graphs so that both DFS and BFS visit exactly the same sequence of\nvertices, e.g., a line graph with one of its endpoint as the source vertex.\n6If your intention is just to use the basic form of DFS, you can actually change the code from vi dfs num\ninto a more compact vector<bool> visited.\n195\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\nFigure 4.1: Left: Sample Graph, Right: Running dfs(0) on Sample Graph\nNote that this sequence of visitation depends very much on the way we order the neighbors\nof a vertex7, i.e., the sequence 0 ! 1 ! 3 ! 4 (backtrack to 3) ! 2 is also a possible\nvisitation sequence on the same graph.\nOne call of dfs(u) will only visit all vertices that are directly or indirectly connected to\n(reachable by) vertex u. That is why vertices {5, 6, 7, 8} in Figure 4.1 remain unvisited\n(unreachable) after calling dfs(0). Later in Section 4.2.4, we will extend this a bit so that\nwe can explore the entire graph, even if there are multiple Connected Components.\nThe time complexity of DFS (and BFS later in Section 4.2.3) depends on the graph\ndata structure used. If the graph with V vertices and E edges is stored as an Adjacency\nMatrix (AM), Adjacency List (AL), and Edge List (EL), respectively, we require O(V ),\nO(k), and O(E) to enumerate the list of neighbors of a vertex, respectively (note: k is the\nnumber of actual neighbors of a vertex). Since DFS and BFS explores all outgoing edges of\neach of the V vertices, it\u2019s runtime depends on the underlying graph data structure speed in\nenumerating neighbors.", "mimetype": "text/plain", "start_char_idx": 585024, "end_char_idx": 588691, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f3a149d5-39bb-4d66-9110-e2b871e141f8": {"__data__": {"id_": "f3a149d5-39bb-4d66-9110-e2b871e141f8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "20e1f495-27f3-4ccc-9296-d26dbcdccf84", "node_type": "1", "metadata": {}, "hash": "27de3565b91135cf036b9d94f4d625bda864283fecb2b4cd1b0f9a1d59dfec57", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e4707514-89d9-4daf-bc92-44468f41403d", "node_type": "1", "metadata": {}, "hash": "fe533532d29e023a82e9671bfbe00eac23579c2acc9f68ccc082f09699710343", "class_name": "RelatedNodeInfo"}}, "text": "Later in Section 4.2.4, we will extend this a bit so that\nwe can explore the entire graph, even if there are multiple Connected Components.\nThe time complexity of DFS (and BFS later in Section 4.2.3) depends on the graph\ndata structure used. If the graph with V vertices and E edges is stored as an Adjacency\nMatrix (AM), Adjacency List (AL), and Edge List (EL), respectively, we require O(V ),\nO(k), and O(E) to enumerate the list of neighbors of a vertex, respectively (note: k is the\nnumber of actual neighbors of a vertex). Since DFS and BFS explores all outgoing edges of\neach of the V vertices, it\u2019s runtime depends on the underlying graph data structure speed in\nenumerating neighbors. Therefore, the time complexity of DFS and BFS are O(V \u21e5V = V 2),\nO(max(V, PV \u22121\ni=0 ki) = V +E), and O(V \u21e5E = V E) to traverse graph stored in an AM, AL,\nand EL, respectively. As AL is the most e\ufb03cient data structure for graph traversal, it may\nbe bene\ufb01cial to convert an AM or an EL-based input graph into an AL \ufb01rst (see Exercise\n2.4.1.4*) before actually traversing the graph.\nDFS versus Recursive Backtracking\nThe DFS code shown here is similar to the recursive backtracking code shown earlier in\nSection 3.2.2.\nIf we compare the pseudocode of a typical backtracking code (replicated\nbelow) with the DFS code shown above, we can see that the main di\u21b5erence is the \ufb02agging\nof visited vertices (states). Backtracking (automatically) un-\ufb02ag visited vertices (reset the\nstate to previous state) when the recursion backtracks (as there is no global vi dfs num\nthat keeps track of the visitation status) to allow re-visitation of those vertices (states)\nfrom another branch. By not allowing re-visitation of vertices of a graph even from another\nbranch (via the global vi dfs num checks), DFS runs in O(V + E), but the time complexity\nof backtracking is exponential. In short, backtracking allows us to explore all (up to V !)\npaths from source vertex (but slow), but DFS only explores one of such path (and fast).\nvoid backtrack(state) {\nfor (each neighbor of state) {\n// try all permutations\nif (neighbor is an end-state) continue;\n// base (terminating) case\nif (neighbor is an invalid-state) continue;\n// optional: for speed up\nbacktrack(neighbor);\n}\n}\n7For simplicity, we usually just order the vertices based on their ascending vertex numbers, e.g., in Figure\n4.1, vertex 1 has vertex {0, 2, 3} as its neighbor, in that order.\n196\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.2.3\nBreadth First Search (BFS)\nBreadth First Search\u2014abbreviated as BFS\u2014is another graph traversal algorithm. Starting\nfrom a distinguished source vertex, BFS will traverse the graph \u2018breadth-\ufb01rst\u2019. That is, BFS\nwill visit the source vertex, then the vertices that are direct neighbors of the source vertex\n(\ufb01rst layer), neighbors of direct neighbors (second layer), and so on, layer by layer.\nBFS starts with the insertion of the source vertex s into a queue, then processes the\nqueue as follows: take out the front most vertex u from the queue, enqueue all unvisited\nneighbors of u (usually, the neighbors are ordered based on their vertex numbers), and mark\nthem as visited. With the help of the queue, BFS will visit vertex s and all vertices in the\nconnected component that contains s layer by layer. BFS algorithm also runs in O(V + E),\nO(V 2), and O(V E) on a graph represented using an AL, AM, and EL, respectively (similar\nexplanation as with DFS analysis).\nImplementing BFS is easy if we utilize C++ STL, Java API, or Python/OCaml standard\nlibrary. We use queue to order the sequence of visitation and vector<int> (or vi) dist\nto record if a vertex u has been visited (dist[u] is no longer INF) or not (dist[u] is still\nINF)\u2014which at the same time also records the distance (layer number) of each vertex from\nthe source vertex. This distance computation feature is used later to solve a special case of\nSingle-Source Shortest Paths problem (see Section 4.4.2 and Book 2).", "mimetype": "text/plain", "start_char_idx": 587999, "end_char_idx": 591952, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4707514-89d9-4daf-bc92-44468f41403d": {"__data__": {"id_": "e4707514-89d9-4daf-bc92-44468f41403d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f3a149d5-39bb-4d66-9110-e2b871e141f8", "node_type": "1", "metadata": {}, "hash": "496493d583ad584a910f462a82872c3919aee269df517498675007d0d910974c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "075d378b-1cd4-4457-a226-4c53ce9489a9", "node_type": "1", "metadata": {}, "hash": "315e6c5f9ff0b4d446a1ec0ac065fa8c5035d91b93079a53e00197f46c71addf", "class_name": "RelatedNodeInfo"}}, "text": "BFS algorithm also runs in O(V + E),\nO(V 2), and O(V E) on a graph represented using an AL, AM, and EL, respectively (similar\nexplanation as with DFS analysis).\nImplementing BFS is easy if we utilize C++ STL, Java API, or Python/OCaml standard\nlibrary. We use queue to order the sequence of visitation and vector<int> (or vi) dist\nto record if a vertex u has been visited (dist[u] is no longer INF) or not (dist[u] is still\nINF)\u2014which at the same time also records the distance (layer number) of each vertex from\nthe source vertex. This distance computation feature is used later to solve a special case of\nSingle-Source Shortest Paths problem (see Section 4.4.2 and Book 2).\n// inside int main()---no recursion\nvi dist(V, INF); dist[s] = 0;\n// initial distances\nqueue<int> q; q.push(s);\n// start from source\nwhile (!q.empty()) {\nint u = q.front(); q.pop();\n// queue: layer by layer!\nfor (auto &[v, w] : AL[u]) {\n// C++17 style, w ignored\nif (dist[v] != INF) continue;\n// already visited, skip\ndist[v] = dist[u]+1;\n// now set dist[v] != INF\nq.push(v);\n// for the next iteration\n}\n}\nFigure 4.2: Example Partial Animation of BFS, see VisuAlgo for a Live Animation\nIf we run BFS from vertex 5 (i.e., the source vertex s = 5) on the connected undirected\ngraph in Figure 4.2, we will visit the vertices in the following order: {5 (source vertex (layer\n0), see Figure 4.2\u2014left}, {1, 6, 10 (layer 1), see Figure 4.2\u2014middle}, {0, 2, 11, 9 (layer 2)},\n{4, 3, 12, 8 (layer 3)}, and \ufb01nally {7 (layer 4), see Figure 4.2\u2014right, which is also the BFS\n(and also Shortest Paths) spanning tree of the initial graph rooted at s = 5}.\n197\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\n4.2.4\nFinding Connected Components (Undirected Graph)\nDFS and BFS are not only useful for traversing a graph (implicit or explicit). They can be\nused to solve many other graph problems. The \ufb01rst few problems discussed in this section\ncan be solved with either DFS or BFS although some of the last few problems are more\nsuitable for DFS only.\nThe fact that one single call of dfs(u) (or bfs(u)) from source vertex u will only visit\nvertices that are actually connected to (or reachable by) u can be utilized to \ufb01nd (and to\ncount the number of) Connected Components (CCs) in an undirected graph (see Section\n4.2.10 for a similar problem on directed graph). We can simply use the following code to\nrestart DFS (or BFS) from one of the remaining unvisited vertices to \ufb01nd the next Connected\nComponent. This process is repeated until all vertices have been visited and has an overall\ntime complexity of O(V + E) as each vertex and edge is only visited once, despite we\npotentially call dfs(u) (or bfs from source vertex u) up to V times.\n// inside int main()---this is the DFS solution\ndfs_num.assign(V, UNVISITED);\nint numCC = 0;\nfor (int u = 0; u < V; ++u)\n// for each u in [0..V-1]\nif (dfs_num[u] == UNVISITED) {\n// if that u is unvisited\nprintf(\"CC %d:\", ++numCC);\ndfs(u);\nprintf(\"\\n\");\n}\nprintf(\"There are %d connected components\\n\", numCC);\n// For the sample graph in Figure 4.1, the output is like this:\n// CC 1: 0 1 2 3 4\n// CC 2: 5\n// CC 3: 6 7 8\n// There are 3 connected components\nSource code: ch4/traversal/dfs cc.cpp|java|py|ml\nExercise 4.2.4.1: What are the minimum and maximum number of CCs in an undirected\ngraph G with V vertices and E (0 \uf8ffE \uf8ffV \u21e5(V \u22121)/2) edges?", "mimetype": "text/plain", "start_char_idx": 591277, "end_char_idx": 594619, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "075d378b-1cd4-4457-a226-4c53ce9489a9": {"__data__": {"id_": "075d378b-1cd4-4457-a226-4c53ce9489a9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e4707514-89d9-4daf-bc92-44468f41403d", "node_type": "1", "metadata": {}, "hash": "fe533532d29e023a82e9671bfbe00eac23579c2acc9f68ccc082f09699710343", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "54b24a89-1196-4580-8a2b-a9063e64aadf", "node_type": "1", "metadata": {}, "hash": "6b1e2c72b4dc8729e877ed248411f8201f339ea1cdcebac3223b4e27f0b688ee", "class_name": "RelatedNodeInfo"}}, "text": "Exercise 4.2.4.2: UVa 00459 - Graph Connectivity is basically this problem of \ufb01nding\nconnected components of an undirected graph. Solve it using the DFS solution shown above!\nHowever, we can also use Union-Find Disjoint Sets data structure (see Section 2.4.2) or BFS\n(see Section 4.2.3) to solve this graph problem. How?\nExercise 4.2.4.3*: Draw an undirected unweighted simple graph with exactly 7 vertices\nand 11 edges such that there are exactly 3 Connected Components. Is it possible?\nExercise 4.2.4.4*: You are given an undirected graph with V vertices, E edges, and the\nentire sequence of K distinct vertices that have to be removed from the graph one after\nanother (1 \uf8ffV, E \uf8ff200 000; 1 \uf8ffK \uf8ffV ). Every time a vertex is removed, report the\ncurrent number of CCs in the graph. Can you solve this problem in O(V + E) instead of\nthe obvious but extremely slow O(K \u21e5(V + E))?\n198\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.2.5\nFlood Fill (Implicit 2D Grid Graph)\nDFS (or BFS) can be used for other purposes than just \ufb01nding (and counting the number\nof) connected components. Here, we show how a modi\ufb01cation of the O(V + E) dfs(u) (we\ncan also use bfs(u)) can be used to label (also known in CS terminology as \u2018to color\u2019) and\ncount the size of each component. This variant is more famously known as \u2018\ufb02ood \ufb01ll\u2019 and\nusually performed on implicit graphs (usually 2D grids).\nint dr[] = { 1, 1, 0,-1,-1,-1, 0, 1};\n// the order is:\nint dc[] = { 0, 1, 1, 1, 0,-1,-1,-1};\n// S/SE/E/NE/N/NW/W/SW\nint floodfill(int r, int c, char c1, char c2) {\n// returns the size of CC\nif ((r < 0) || (r >= R)) return 0;\n// outside grid, part 1\nif ((c < 0) || (c >= C)) return 0;\n// outside grid, part 2\nif (grid[r][c] != c1) return 0;\n// does not have color c1\nint ans = 1;\n// (r, c) has color c1\ngrid[r][c] = c2;\n// to avoid cycling\nfor (int d = 0; d < 8; ++d)\nans += floodfill(r+dr[d], c+dc[d], c1, c2);\n// the code is neat as\nreturn ans;\n// we use dr[] and dc[]\n}\nSample Application: UVa 00469 - Wetlands of Florida\nLet\u2019s see an example below (UVa 00469 - Wetlands of Florida). The implicit graph is a 2D\ngrid where the vertices are the cells in the grid. \u2018W\u2019 denotes a wet cell and \u2018L\u2019 denotes a land\ncell. The edges are the connections between a \u2018W\u2019 cell and its S/SE/E/NE/N/NW/W/SW\n\u2018W\u2019 cell(s). That is, a wet area is de\ufb01ned as connected cells labeled with \u2018W\u2019. We can label\n(and simultaneously count the size of) a wet area by using floodfill function. The example\nbelow shows an execution of floodfill from row 2, column 1 (0-based indexing), replacing\nthe \u2018W\u2019s to \u2018.\u2019s.\nWe remark that there are a good number of \ufb02ood \ufb01ll problems in UVa and Kattis online\njudges [44, 34] with a high pro\ufb01le example: UVa 01103 - Ancient Messages (ICPC World\nFinals 2011 problem). It may be good for the readers to attempt a few \ufb02ood \ufb01ll problems\nlisted in the programming exercises of this section to master this technique!", "mimetype": "text/plain", "start_char_idx": 594620, "end_char_idx": 597512, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "54b24a89-1196-4580-8a2b-a9063e64aadf": {"__data__": {"id_": "54b24a89-1196-4580-8a2b-a9063e64aadf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "075d378b-1cd4-4457-a226-4c53ce9489a9", "node_type": "1", "metadata": {}, "hash": "315e6c5f9ff0b4d446a1ec0ac065fa8c5035d91b93079a53e00197f46c71addf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5fb3adb6-49f4-4767-b5a8-fb0bd7221819", "node_type": "1", "metadata": {}, "hash": "4df40f78b45160e9df5142cafb9692faf606e50192507318ec57edb0f8d7aad1", "class_name": "RelatedNodeInfo"}}, "text": "That is, a wet area is de\ufb01ned as connected cells labeled with \u2018W\u2019. We can label\n(and simultaneously count the size of) a wet area by using floodfill function. The example\nbelow shows an execution of floodfill from row 2, column 1 (0-based indexing), replacing\nthe \u2018W\u2019s to \u2018.\u2019s.\nWe remark that there are a good number of \ufb02ood \ufb01ll problems in UVa and Kattis online\njudges [44, 34] with a high pro\ufb01le example: UVa 01103 - Ancient Messages (ICPC World\nFinals 2011 problem). It may be good for the readers to attempt a few \ufb02ood \ufb01ll problems\nlisted in the programming exercises of this section to master this technique!\n// inside int main()\n// read the grid as a global 2D array + read (row, col) query coordinates\nprintf(\"%d\\n\", floodfill(row, col, \u2018W\u2019, \u2018.\u2019)); // count size of wet area\n// LLLLLLLLL\nLLLLLLLLL\n// LLWWLLWLL\nLL..LLWLL\n// The size of CC\n// LWWLLLLLL (R2,C1) L..LLLLLL\n// with one \u2018W\u2019\n// LWWWLWWLL\nL...L..LL\n// at (R2, C1) is 12\n// LLLWWWLLL ======> LLL...LLL\n// LLLLLLLLL\nLLLLLLLLL\n// Notice that all these\n// LLLWWLLWL\nLLLWWLLWL\n// connected \u2018W\u2019s are\n// LLWLWLLLL\nLLWLWLLLL\n// replaced with \u2018.\u2019s\n// LLLLLLLLL\nLLLLLLLLL\n// after floodfill\nSource code: ch4/traversal/UVa00469.cpp|java|py|ml\n199\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\n4.2.6\nTopological Sort (Directed Acyclic Graph)\nTopological sort/ordering of a Directed Acyclic Graph (DAG) is a linear ordering of the\nvertices in the DAG so that vertex u comes before vertex v if directed edge u ! v exists\nin the DAG (see Figure 4.3). Every DAG has at least one (a Singly Linked List-like DAG),\npossibly more than one topological sorts, and up to n! topological sorts (a DAG with n\nvertices and 0 edge). There is no possible topological ordering of a non DAG.\nOne application of topological sorting is to \ufb01nd a possible sequence of modules that a\nUniversity student has to take to ful\ufb01ll graduation requirement. Each module has certain\npre-requisites to be met. These pre-requisites are never cyclic, so they can be modeled as a\nDAG. Topological sorting this module pre-requisites DAG gives the student a linear list of\nmodules to be taken one after another without violating the pre-requisites constraints.\nSimple DFS Variant\nThere are several algorithms to \ufb01nd one topological sort of a DAG. The simplest way is to\nslightly modify the DFS implementation that we presented earlier in Section 4.2.2. This\nalgorithm will only output one (of possibly many other) valid topological sort of a given\nDAG. See Exercise 4.2.6.1 and Exercise 4.2.6.2* for other variations.\nFigure 4.3: Left: A DAG, Right: The Same DAG Redrawn in its Topological Sort Order\nvoid toposort(int u) {\ndfs_num[u] = VISITED;\nfor (auto &[v, w] : AL[u])\nif (dfs_num[v] == UNVISITED)\ntoposort(v);\nts.push_back(u);\n// this is the only change\n}\n// inside int main()\ndfs_num.assign(V, UNVISITED);\n// global variable\nts.clear();\n// global variable\nfor (int u = 0; u < V; ++u)\n// same as finding CCs\nif (dfs_num[u] == UNVISITED)\ntoposort(u);\nreverse(ts.begin(), ts.end());\n// reverse ts or\nfor (auto &u : ts)\n// simply read the content\nprintf(\" %d\", u);\n// of ts backwards\nprintf(\"\\n\");\n// For the sample graph in Figure 4.3, the output is like this:\n// 7 6 0 1 2 5 3 4\nSource code: ch4/traversal/toposort.cpp|java|py\n200\n\nCHAPTER 4.", "mimetype": "text/plain", "start_char_idx": 596899, "end_char_idx": 600162, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5fb3adb6-49f4-4767-b5a8-fb0bd7221819": {"__data__": {"id_": "5fb3adb6-49f4-4767-b5a8-fb0bd7221819", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "54b24a89-1196-4580-8a2b-a9063e64aadf", "node_type": "1", "metadata": {}, "hash": "6b1e2c72b4dc8729e877ed248411f8201f339ea1cdcebac3223b4e27f0b688ee", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aa1ac5a5-622f-44f5-8bd2-502973bac1e2", "node_type": "1", "metadata": {}, "hash": "919ab94b9935011b57c9e1acd3ed52e4b259033d526a7efd5a47937639b5cf41", "class_name": "RelatedNodeInfo"}}, "text": "GRAPH\nc\u20ddSteven, Felix, Suhendry\nIn toposort(u), we append u to the back of a list (vector) of explored vertices only after\nvisiting all the vertices in the subtree below u in the DFS spanning tree, i.e., u\u2019s children, if\nany. This is a kind of post-order traversal in (binary) tree traversal terminology and doing\nthis satis\ufb01es the topological sort requirement.\nWe append u to the back of this vector because C++ STL vector, Java ArrayList,\nand Python list only support e\ufb03cient O(1) insertion from the back. The list will be in\nreversed order, but we can work around this issue by reversing the print order in the output\nphase. Alternatively, we can also use C++ STL list, Java LinkedList, or Python deque\ninstead as they have e\ufb03cient O(1) insertion from the front too. However, because we have\nsaid in Chapter 2 that we want to avoid using Linked List data structure in competitive\nprogramming, we decided to use vi ts here.\nThis simple algorithm for \ufb01nding (one valid) topological sort is due to Robert Endre\nTarjan. It runs in O(V + E) as with DFS as it does the same work as the original DFS plus\none additional constant operation.\nKahn\u2019s Algorithm\nNext, we show an alternative algorithm for \ufb01nding a topological sort (that is possibly di\u21b5erent\nfrom the one found by the DFS modi\ufb01cation algorithm above): Kahn\u2019s algorithm [33]. It\nlooks like a \u2018modi\ufb01ed BFS\u2019 albeit the chosen data structure is actually much more \ufb02exible\n(see Exercise 4.2.6.2*). Some problems, e.g., UVa 11060 - Beverages, requires this Kahn\u2019s\nalgorithm to produce the required topological sort instead of the DFS-based algorithm shown\nearlier. Here, the problem requires us to prioritize certain (lower index) vertices \ufb01rst. A\nPriority Queue data structure can help us satisfy this requirement.\n// enqueue vertices with zero in-degree into a min (priority) queue pq\npriority_queue<int, vi, greater<int>> pq;\n// min priority queue\nfor (int u = 0; u < N; ++u)\nif (in_degree[u] == 0)\n// next to be processed\npq.push(u);\n// smaller index first\nwhile (!pq.empty()) {\n// Kahn\u2019s algorithm\nint u = pq.top(); pq.pop();\n// process u here\nfor (auto &v : AL[u]) {\n--in_degree[v];\n// virtually remove u->v\nif (in_degree[v] > 0) continue;\n// not a candidate, skip\npq.push(v);\n// enqueue v in pq\n}\n}\nSource code: ch4/traversal/UVa11060.cpp|java|py|ml\nExercise 4.2.6.1: The topological sort code shown above can only generate one valid\ntopological ordering of the vertices of a DAG. What should we do if we want to output all\n(or count the number of) valid topological orderings of the vertices of a DAG?\nExercise 4.2.6.2*: If we replace priority queue pq in the code above with (a queue|a stack|a\nvector|a hash table|a set), does Kahn\u2019s algorithm remains correct? Why or why not?\nExercise 4.2.6.3*: Draw a graph with V = 7 vertices and any number of directed edges so\nthat there are exactly (a). 840 and (b). 21 unique topological orderings!\n201\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\n4.2.7\nBipartite Graph Check (Undirected Graph)\nBipartite Graph is a special graph (discussed in more details later in Section 4.6) with the\nfollowing characteristics: the set of vertices V can be partitioned into two disjoint sets V1\nand V2 and all undirected edges (u, v) 2 E have the property that u 2 V1 and v 2 V2. This\nmakes a Bipartite Graph free from odd-length cycle (see Exercise 4.2.7.1).\nBipartite Graph with n and m vertices in set V1 and V2, respectively, can still be a dense\ngraph. See Exercise 4.2.7.2 for characteristics of a Bipartite Graph with many edges.\nBipartite Graph has important applications that we will see later in Section 4.6.3 and in\nBook 2.", "mimetype": "text/plain", "start_char_idx": 600163, "end_char_idx": 603787, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aa1ac5a5-622f-44f5-8bd2-502973bac1e2": {"__data__": {"id_": "aa1ac5a5-622f-44f5-8bd2-502973bac1e2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5fb3adb6-49f4-4767-b5a8-fb0bd7221819", "node_type": "1", "metadata": {}, "hash": "4df40f78b45160e9df5142cafb9692faf606e50192507318ec57edb0f8d7aad1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "159c0ce9-0550-433e-ad21-7308cb963196", "node_type": "1", "metadata": {}, "hash": "a032b2397023a0e97c443e7a289ca00106255db9650ee6852d11a5b33b0e8329", "class_name": "RelatedNodeInfo"}}, "text": "This\nmakes a Bipartite Graph free from odd-length cycle (see Exercise 4.2.7.1).\nBipartite Graph with n and m vertices in set V1 and V2, respectively, can still be a dense\ngraph. See Exercise 4.2.7.2 for characteristics of a Bipartite Graph with many edges.\nBipartite Graph has important applications that we will see later in Section 4.6.3 and in\nBook 2. In this subsection, we just want to check if a graph is bipartite (or 2/bi-colorable8)\nto solve problems like UVa 10004 - Bicoloring.\nWe can use either BFS or DFS for this check, but we feel that BFS is more natural. The\nmodi\ufb01ed BFS code below starts by coloring the source vertex (zeroth layer) with value 0,\ncolor the direct neighbors of the source vertex (\ufb01rst layer) with value 1, color the neighbors\nof direct neighbors (second layer) with value 0 again, and so on, alternating between value 0\nand value 1 as the only two valid colors. If we encounter any violation(s) along the way\u2014an\nedge with two endpoints having the same color, then we can conclude that the given input\ngraph is not a Bipartite Graph.\n// inside int main()\nint s = 0;\nqueue<int> q; q.push(s);\nvi color(n, INF); color[s] = 0;\nbool isBipartite = true;\n// add a Boolean flag\nwhile (!q.empty() && isBipartite) {\n// as with original BFS\nint u = q.front(); q.pop();\nfor (auto &v : AL[u]) {\nif (color[v] == INF) {\n// don\u2019t record distances\ncolor[v] = 1-color[u];\n// just record two colors\nq.push(v);\n}\nelse if (color[v] == color[u]) {\n// u & v have same color\nisBipartite = false;\n// a coloring conflict :(\nbreak;\n// optional speedup\n}\n}\n}\nSource code: ch4/traversal/UVa10004.cpp|java|py|ml\nExercise 4.2.7.1: Prove this statement: \u201cAn undirected graph is Bipartite if and only if it\nhas no odd-length cycle\u201d!\nExercise 4.2.7.2: A simple graph with V vertices is found out to be a Bipartite Graph.\nWhat is the maximum possible number of edges that this graph has?\nExercise 4.2.7.3: Prove this statement: \u201cA tree is also a Bipartite Graph\u201d!\nExercise 4.2.7.4*: Implement bipartite check using DFS instead!\n8See Book 2 to see the general, NP-complete version of this problem: Graph-Coloring.\n202\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.2.8\nCycle Check (Directed Graph)\nOne graph property that sometimes tested in programming contest is whether the graph\nhas a cycle (cyclic) or not (acyclic). An undirected graph is by nature a cyclic graph as\nall its bidirectional edges form trivial cycles. A directed graph that happens to have two\ndirected edges between the same pair of vertices also has this trivial cycle problem. Hence\ncycle check is usually de\ufb01ned as \ufb01nding a non-trivial cycle of length 3 edges (or more) in\na given directed graph. A Directed Acyclic Graph (DAG) is a special graph that opens up\nmany e\ufb03cient topological sort-based solutions (see Section 4.2.6).\nRunning DFS on a connected/disconnected graph generates a DFS spanning tree/forest9,\nrespectively. With the help of one more vertex state: EXPLORED (that means visited but not\nyet completed) on top of VISITED (visited and completed), we can use this DFS spanning\ntree/forest to classify graph edges into three types:\n1. Tree edge: This is an edge that is part of DFS spanning tree.\nWe can detect this when DFS moves from vertex u currently with state: EXPLORED\nto another vertex v with state: UNVISITED. In fact, this is the necessary condition for\nDFS to advance its traversal.\n2. Back/Bidirectional edge: This is an edge that is either part of a non-trivial cycle\n(back edge) or a trivial cycle (bidirectional edge).\nWe can detect this when DFS moves from vertex u currently with state: EXPLORED to\nanother vertex v with state: EXPLORED too, which implies that vertex v is an ancestor\nof vertex u in the DFS spanning tree.", "mimetype": "text/plain", "start_char_idx": 603433, "end_char_idx": 607155, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "159c0ce9-0550-433e-ad21-7308cb963196": {"__data__": {"id_": "159c0ce9-0550-433e-ad21-7308cb963196", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aa1ac5a5-622f-44f5-8bd2-502973bac1e2", "node_type": "1", "metadata": {}, "hash": "919ab94b9935011b57c9e1acd3ed52e4b259033d526a7efd5a47937639b5cf41", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e677c92a-3dfd-452d-a54f-aad2deddd8d1", "node_type": "1", "metadata": {}, "hash": "0e4541257c89138030a46d7a397ed24ec4a9addad17adf638cd104e601231c24", "class_name": "RelatedNodeInfo"}}, "text": "With the help of one more vertex state: EXPLORED (that means visited but not\nyet completed) on top of VISITED (visited and completed), we can use this DFS spanning\ntree/forest to classify graph edges into three types:\n1. Tree edge: This is an edge that is part of DFS spanning tree.\nWe can detect this when DFS moves from vertex u currently with state: EXPLORED\nto another vertex v with state: UNVISITED. In fact, this is the necessary condition for\nDFS to advance its traversal.\n2. Back/Bidirectional edge: This is an edge that is either part of a non-trivial cycle\n(back edge) or a trivial cycle (bidirectional edge).\nWe can detect this when DFS moves from vertex u currently with state: EXPLORED to\nanother vertex v with state: EXPLORED too, which implies that vertex v is an ancestor\nof vertex u in the DFS spanning tree. If this ancestor v of u is the direct parent of u\n(this information is stored in vi dfs parent), then this cycle is actually a trivial cycle\ncaused by a bidirectional edge. Otherwise, this cycle is a non-trivial cycle.\nFinding at least one back edge (cycle) in a directed graph is sometimes tested in\nprogramming contest.\n3. Forward/Cross edges (rarely used in programming contest).\nWe can detect this when DFS moves from vertex u currently with state: EXPLORED to\nanother vertex v with state: VISITED.\nFigure 4.4: dfs(0) when Run on the First CC of Sample Graph in Figure 4.1\nFigure 4.4\u2014left and middle shows a frozen animation of calling dfs(0) only (that does not\nable to reach vertices {5, 6, 7, 8}) on the sample graph in Figure 4.1. We can see that\n0 ! 1 ! 2 ! 3 ! 1 is a (true) cycle and we classify edge (3 ! 1) as a back edge, whereas\nmany other edges, e.g., 0 ! 1 ! 0 is not a cycle but it is just a bi-directional edge (0-1).\n9A spanning tree of a connected graph G is a tree that spans (covers) all vertices of G but only using\na subset of the edges of G. A disconnected graph G has several connected components. Each component\nhas its own spanning subtree(s). All spanning subtrees of G, one from each component, form what we call\na spanning forest.\n203\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\nIn Figure 4.4\u2014right, we see that when later DFS backtracks to vertex 1 and explore edge\n1 ! 3, it will \ufb01nd a forward/cross edge. The code for this DFS variant is as follows:\nvoid cycleCheck(int u) {\n// check edge properties\ndfs_num[u] = EXPLORED;\n// color u as EXPLORED\nfor (auto &[v, w] : AL[u]) {\n// C++17 style, w ignored\nprintf(\"Edge (%d, %d) is a \", u, v);\nif (dfs_num[v] == UNVISITED) {\n// EXPLORED->UNVISITED\nprintf(\"Tree Edge\\n\");\ndfs_parent[v] = u;\n// a tree edge u->v\ncycleCheck(v);\n}\nelse if (dfs_num[v] == EXPLORED) {\n// EXPLORED->EXPLORED\nif (v == dfs_parent[u])\n// differentiate them\nprintf(\"Bidirectional Edge\\n\");\n// a trivial cycle\nelse\nprintf(\"Back Edge (Cycle)\\n\");\n// a non trivial cycle\n}\nelse if (dfs_num[v] == VISITED)\n// EXPLORED->VISITED\nprintf(\"Forward/Cross Edge\\n\");\n// rare application\n}\ndfs_num[u] = VISITED;\n// color u as VISITED/DONE\n}\n// inside int main()\ndfs_num.assign(V, UNVISITED);\ndfs_parent.assign(V, -1);\nfor (int u = 0; u < V; ++u)\nif (dfs_num[u] == UNVISITED)\ncycleCheck(u);\nFor the sample undirected graph in Figure 4.1, the analysis is like this: Edges (0, 1), (1, 2),\n(2, 3), (3, 4), (6, 7), and (6, 8) are bidirectional edges. Edge 3 ! 1 is a back edge (part of a\ncycle), and edge 1 ! 3 is a forward/cross edge.\nFor the sample directed graph in Figure 4.7, the analysis is like this: Edge 2 ! 1 and\n6 !", "mimetype": "text/plain", "start_char_idx": 606330, "end_char_idx": 609819, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e677c92a-3dfd-452d-a54f-aad2deddd8d1": {"__data__": {"id_": "e677c92a-3dfd-452d-a54f-aad2deddd8d1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "159c0ce9-0550-433e-ad21-7308cb963196", "node_type": "1", "metadata": {}, "hash": "a032b2397023a0e97c443e7a289ca00106255db9650ee6852d11a5b33b0e8329", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d4b4d6b0-7837-4ba8-b7ee-97743637a9e7", "node_type": "1", "metadata": {}, "hash": "6b923b4b01f2c5f1cc25e720caf1b2e8fbdd2842b5a11235fe70f5bebd020cdc", "class_name": "RelatedNodeInfo"}}, "text": "Edge 3 ! 1 is a back edge (part of a\ncycle), and edge 1 ! 3 is a forward/cross edge.\nFor the sample directed graph in Figure 4.7, the analysis is like this: Edge 2 ! 1 and\n6 ! 4 are back edges (part of a cycle).\nSource code: ch4/traversal/cyclecheck.cpp|java|py\nExercise 4.2.8.1: What is the time complexity of cycleCheck routine above? As it is\nanother modi\ufb01cation of O(V + E) DFS, is it O(V + E) too or is it faster than that?\nExercise 4.2.8.2: Give a small directed graph test case so that a cycleCheck routine that\nonly uses two vertex states (UNVISITED versus VISITED) will accidentally classify some graph\nto have a non-trivial cycle (has a back edge) while actually the graph is acyclic.\nExercise 4.2.8.3*: The cycleCheck routine above is a DFS modi\ufb01cation. Can we use a\nBFS (modi\ufb01cation) to do the same for an undirected graph? Or for a directed graph?\n204\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.2.9\nFinding Articulation Points and Bridges (Undirected Graph)\nProblem: Given a road map (an undirected graph) with sabotage costs associated to all\nintersections (vertices) and roads (edges), sabotage either a single intersection or a single\nroad such that the road network breaks down (disconnected) and do so in the least cost way.\nThis is a problem of \ufb01nding the least cost Articulation Point (intersection) or the least cost\nBridge (road) in an undirected graph (road map).\nAn \u2018Articulation Point\u2019 is de\ufb01ned as a vertex in a graph G whose removal (all edges\nincident to this vertex are also removed) disconnects G. A graph without any articulation\npoint is called \u2018Biconnected\u2019. Similarly, a \u2018Bridge\u2019 is de\ufb01ned as an edge in a graph G whose\nremoval disconnects G. These two problems are usually de\ufb01ned for undirected graphs (they\nare more challenging for directed graphs and require another algorithm to solve, see [32]).\nNa\u00a8\u0131ve Algorithm\nA na\u00a8\u0131ve algorithm to \ufb01nd articulation points is as follows (can be tweaked to \ufb01nd bridges):\n1. Run O(V + E) DFS (or BFS) to count number of Connected Components (CCs) of\nthe original graph. Usually, the input is a connected graph, so this check will usually\ngive us one Connected Component.\n2. For each vertex v 2 V // O(V \u21e5(V + E)) = O(V 2 + V E)\n(a) (Virtually) cut (remove) vertex v and its incident edges,\n(b) Run O(V + E) DFS (or BFS) and see if the number of CCs increases,\n(c) If yes, v is an articulation point/cut vertex; Restore v and its incident edges.\nThis na\u00a8\u0131ve algorithm calls DFS (or BFS) O(V ) times, thus it runs in O(V \u21e5(V + E)) =\nO(V 2 + V E). But this is not the best algorithm as we can actually just run the O(V + E)\nDFS once to identify all the articulation points and bridges. This DFS variant, due to John\nEdward Hopcroft and Robert Endre Tarjan (see [55] and problem 22.2 in [5]), is just another\nextension of the previous DFS code shown earlier.\nTwo More DFS Attributes: dfs num and dfs low\nWe now maintain two more numbers when running DFS: dfs_num(u) and dfs_low(u).\nNow, dfs_num(u) stores the iteration counter (starting from 0) when the vertex u is visited\nfor the \ufb01rst time (not just for distinguishing UNVISITED versus EXPLORED/VISITED).\nLet R be the set of vertices that are in the DFS spanning subtree rooted at u (including u\nitself). The other number dfs_low(u) stores the lowest dfs_num in R or the lowest dfs_num\nof a vertex not in R that is reachable by a back edge (see Section 4.2.8) from a vertex in\nR. Initially is dfs_low(u) = dfs_num(u) when vertex u is visited for the \ufb01rst time. Then,\ndfs_low(u) can only be made smaller if DFS encounters a back edge that connects a vertex\nu in R to another vertex v not in R that has lower dfs_num(v).", "mimetype": "text/plain", "start_char_idx": 609644, "end_char_idx": 613286, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4b4d6b0-7837-4ba8-b7ee-97743637a9e7": {"__data__": {"id_": "d4b4d6b0-7837-4ba8-b7ee-97743637a9e7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e677c92a-3dfd-452d-a54f-aad2deddd8d1", "node_type": "1", "metadata": {}, "hash": "0e4541257c89138030a46d7a397ed24ec4a9addad17adf638cd104e601231c24", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "04dd4beb-8f76-40d8-b789-ab091ed11cba", "node_type": "1", "metadata": {}, "hash": "e398f68fc7e5d475e2737e127514d65b22e7ce41cc0f4b6555af44204ecf2a22", "class_name": "RelatedNodeInfo"}}, "text": "Now, dfs_num(u) stores the iteration counter (starting from 0) when the vertex u is visited\nfor the \ufb01rst time (not just for distinguishing UNVISITED versus EXPLORED/VISITED).\nLet R be the set of vertices that are in the DFS spanning subtree rooted at u (including u\nitself). The other number dfs_low(u) stores the lowest dfs_num in R or the lowest dfs_num\nof a vertex not in R that is reachable by a back edge (see Section 4.2.8) from a vertex in\nR. Initially is dfs_low(u) = dfs_num(u) when vertex u is visited for the \ufb01rst time. Then,\ndfs_low(u) can only be made smaller if DFS encounters a back edge that connects a vertex\nu in R to another vertex v not in R that has lower dfs_num(v). This update may a\u21b5ect\nother ancestor vertices of u too. Note that we do not update dfs_low(u) if edge (u, v) is a\nbidirectional edge.\nSee Figure 4.5 for clarity. In the \ufb01gure, the dfs_num and dfs_low values are written as\ndfs_num,dfs_low under each vertex. There are two undirected graphs: Left and Right side.\nIn both graphs, we run the DFS variant from vertex 0.\nSuppose for the graph in Figure 4.5\u2014left side, the sequence of visitation is 0 (at iteration\n0) ! 1 (1) ! 2 (2) (backtrack to 1) ! 4 (3) ! 3 (4) (backtrack to 4) ! 5 (5). As there is\nno back edge in this graph, all dfs_low = dfs_num at the end.\n205\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\nFigure 4.5: Two More DFS Attributes: dfs num and dfs low\nSuppose for the graph in Figure 4.5\u2014right side, the sequence of visitation is 0 (at iteration\n0) ! 1 (1) ! 2 (2) (backtrack to 1) ! 3 (3) (backtrack to 1) ! 4 (4) ! 5 (5). At this\npoint in the DFS spanning tree, there is an important back edge that forms a cycle, i.e.,\nedge 5 ! 1 that is part of non-trivial cycle 1 ! 4 ! 5 ! 1. This causes vertices 1 (itself),\n4 (indirectly), and 5 (the vertex that discovers back edge 5 ! 1) to all able to reach vertex\n1 (with dfs_num 1). Thus dfs_low of {1, 4, 5} are all 1.\nUsing dfs num and dfs low Information\nWhen we are in a vertex u with v as its neighbor and dfs_low(v) \u2265dfs_num(u), then u is\nclearly an articulation vertex. This is because the fact that dfs_low(v) is not smaller than\ndfs_num(u) implies that there is no back edge from a vertex in the subtree rooted at v that\ncan reach another vertex w with a lower dfs_num(w) than dfs_num(u). A vertex w with\nlower dfs_num(w) than vertex u with dfs_num(u) implies that w is the ancestor of u in the\nDFS spanning tree. This means that to reach the ancestor(s) of u from v, one must pass\nthrough a critical, articulation point vertex u. Therefore, removing vertex u will disconnect\nthe graph, i.e., disconnects vertex u with vertex v.\nHowever, there is one special case: the root of the DFS spanning tree (the vertex chosen\nas the start of DFS call) is an articulation point only if it has more than one children in the\nDFS spanning tree (a trivial case that is not detected by this algorithm).\nFigure 4.6: Finding Articulation Points with dfs num and dfs low\nSee Figure 4.6 for more details. This \ufb01gure is the portrayal of the DFS spanning trees rooted\nat vertex 0 of the original input graph in Figure 4.5. On the graph in Figure 4.6\u2014left, vertices\n1 and 4 are articulation points, because for example in edge 1 ! 2, we see that dfs_low(2)\n\u2265dfs_num(1) (vertex 2 can only reach ancestor of vertex 1 via articulation point vertex 1)\nand similarly in edge 4 ! 5, we also see that dfs_low(5) \u2265dfs_num(4).", "mimetype": "text/plain", "start_char_idx": 612598, "end_char_idx": 616005, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04dd4beb-8f76-40d8-b789-ab091ed11cba": {"__data__": {"id_": "04dd4beb-8f76-40d8-b789-ab091ed11cba", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d4b4d6b0-7837-4ba8-b7ee-97743637a9e7", "node_type": "1", "metadata": {}, "hash": "6b923b4b01f2c5f1cc25e720caf1b2e8fbdd2842b5a11235fe70f5bebd020cdc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9bed1b83-2d62-47cc-b9e7-9c76a5ef2803", "node_type": "1", "metadata": {}, "hash": "4b3580f63a38d306bb92381194d5e17d1225944efe990b2db838e1cff1746d61", "class_name": "RelatedNodeInfo"}}, "text": "Figure 4.6: Finding Articulation Points with dfs num and dfs low\nSee Figure 4.6 for more details. This \ufb01gure is the portrayal of the DFS spanning trees rooted\nat vertex 0 of the original input graph in Figure 4.5. On the graph in Figure 4.6\u2014left, vertices\n1 and 4 are articulation points, because for example in edge 1 ! 2, we see that dfs_low(2)\n\u2265dfs_num(1) (vertex 2 can only reach ancestor of vertex 1 via articulation point vertex 1)\nand similarly in edge 4 ! 5, we also see that dfs_low(5) \u2265dfs_num(4).\nOn the graph in Figure 4.6\u2014right, only vertex 1 is the articulation point, because for\nexample in edge 1 ! 5, dfs_low(5) \u2265dfs_num(1). On the other hand, vertex 4 is not\nan articulation point because when we examine edge 4 ! 5, we see that dfs_low(5) <\ndfs_num(4), or in another words: vertex 5 can reach the ancestor of vertex 4 (i.e., vertex 1)\nnot via vertex 4 but via another path (e.g., path 5 ! 1).\n206\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nThe process to \ufb01nd bridges is similar. When dfs_low(v) > dfs_num(u), then edge (u, v) is\na bridge (notice that we remove the equality test \u2018=\u2019 for \ufb01nding bridges). In Figure 4.5\u2014left,\nall edges are bridges as it is a tree. In Figure 4.5\u2014right, almost all edges are bridges except\nedges (1, 4), (4, 5), and (5, 1) (they actually form a cycle). This is because\u2014for example\u2014for\nedge (1, 4), we have dfs_low(4) \uf8ffdfs_num(1), i.e., even if this edge (1, 4) is removed, we\nknow for sure that vertex 4 can still reach vertex 1 via another path as dfs_low(4) = 1\n(that other path is actually path 4 ! 5 ! 1). The code is shown below:\nvi dfs_num, dfs_low, dfs_parent, articulation_vertex;\nint dfsNumberCounter, dfsRoot, rootChildren;\nvoid articulationPointAndBridge(int u) {\ndfs_num[u] = dfsNumberCounter++;\ndfs_low[u] = dfs_num[u];\n// dfs_low[u]<=dfs_num[u]\nfor (auto &[v, w] : AL[u]) {\nif (dfs_num[v] == UNVISITED) {\n// a tree edge\ndfs_parent[v] = u;\nif (u == dfsRoot) ++rootChildren;\n// special case, root\narticulationPointAndBridge(v);\nif (dfs_low[v] >= dfs_num[u])\n// for articulation point\narticulation_vertex[u] = 1;\n// store this info first\nif (dfs_low[v] > dfs_num[u])\n// for bridge\nprintf(\" (%d, %d) is a bridge\\n\", u, v);\ndfs_low[u] = min(dfs_low[u], dfs_low[v]);\n// subtree, always update\n}\nelse if (v != dfs_parent[u])\n// if a non-trivial cycle\ndfs_low[u] = min(dfs_low[u], dfs_num[v]);\n// then can update\n}\n}\n// inside int main()\ndfs_num.assign(V, UNVISITED); dfs_low.assign(V, 0);\ndfs_parent.assign(V, -1); articulation_vertex.assign(V, 0);\ndfsNumberCounter = 0;\nprintf(\"Bridges:\\n\");\nfor (int u = 0; u < V; ++u)\nif (dfs_num[u] == UNVISITED) {\ndfsRoot = u; rootChildren = 0;\narticulationPointAndBridge(u);\narticulation_vertex[dfsRoot] = (rootChildren > 1); // special case\n}\nprintf(\"Articulation Points:\\n\");\nfor (int u = 0; u < V; ++u)\nif (articulation_vertex[u])\nprintf(\" Vertex %d\\n\", u);\nSource code: ch4/traversal/articulation.cpp|java|py\n207\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\n4.2.10\nFinding Strongly Connected Components (Directed Graph)\nYet another application of DFS is to \ufb01nd Strongly Connected Components (SCCs) in a\ndirected graph, e.g., UVa 11838 - Come and Go.", "mimetype": "text/plain", "start_char_idx": 615498, "end_char_idx": 618650, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9bed1b83-2d62-47cc-b9e7-9c76a5ef2803": {"__data__": {"id_": "9bed1b83-2d62-47cc-b9e7-9c76a5ef2803", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "04dd4beb-8f76-40d8-b789-ab091ed11cba", "node_type": "1", "metadata": {}, "hash": "e398f68fc7e5d475e2737e127514d65b22e7ce41cc0f4b6555af44204ecf2a22", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "316c77f3-760e-40bc-b7cc-bec6cc17a976", "node_type": "1", "metadata": {}, "hash": "b7101772adc063c055882f5537e4243ca4de65ca9e5686e3415ee7a1d393e797", "class_name": "RelatedNodeInfo"}}, "text": "GRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\n4.2.10\nFinding Strongly Connected Components (Directed Graph)\nYet another application of DFS is to \ufb01nd Strongly Connected Components (SCCs) in a\ndirected graph, e.g., UVa 11838 - Come and Go.\nThis is a di\u21b5erent problem to \ufb01nding\nConnected Components (CCs) in an undirected graph. In Figure 4.7, we have a directed\ngraph. Although this graph looks like it has one CC (running dfs(0) does reach all vertices\nin the graph), it is actually not an SCC (for example, vertex 1 cannot go to vertex 0). In\ndirected graphs, we are more interested with the notion of SCC instead of the more basic\nCC. An SCC is de\ufb01ned as such: if we pick any pair of vertices u and v in the SCC, we can\n\ufb01nd a path from u to v and vice versa. There are actually three SCCs in Figure 4.7, as\nhighlighted with the three boxes: {0}, {1, 2, 3}, and {4, 5, 6, 7}. Note that if these SCCs\nare contracted (replaced by larger vertices), they form a DAG (see Book 2).\nThere are at least two known algorithms to \ufb01nd SCCs: Kosaraju\u2019s\u2014explained in [5] and\nTarjan\u2019s algorithm [55]. In this section, we explore both versions. Kosaraju\u2019s algorithm is\neasier to understand but Tarjan\u2019s version extends naturally from our previous discussion of\n\ufb01nding Articulation Points and Bridges\u2014also due to Tarjan.\nKosaraju\u2019s Algorithm\nTo understand how Kosaraju\u2019s algorithm works, we need to do two observations.\nFirst, running dfs(u) on a directed graph where u is part of its \u201csmallest SCC\u201d (SCC\nwhere all outgoing edges of the vertices in the SCC only point to another member of the SCC\nitself) will only visit vertices in that smallest SCC. For example in Figure 4.7\u2014left, if we run\ndfs(4) (or dfs(5), dfs(6), or dfs(7)), we can only visit vertices {4, 5, 6, 7}. Notice that\nif we run dfs(3) for example, we will be able to reach vertices {1, 2, 3} as well as vertices\n{4, 5, 6, 7} due to presence of edge 3 ! 4 that can cause \u2018leakage\u2019. The question is how to\n\ufb01nd the \u201csmallest SCC\u201d?\nSecond, the SCCs of the original directed graph and the SCCs of the transposed graph\nare identical.\nKosaraju\u2019s algorithm combine the two ideas. Running DFS on the original directed graph,\nwe can record the explored vertices in decreasing \ufb01nishing order (or post-order, similar as in\n\ufb01nding topological sort10 in Section 4.2.6). For example in Figure 4.7\u2014left, the decreasing\n\ufb01nishing order of the 8 vertices is {0, 1, 3, 4, 5, 7, 6, 2}. In turns out that on the transposed\ngraph, these ordering can help us identify the \u201csmallest SCC\u201d (read [5] for the details).\nFigure 4.7: Execution of Two Passes Kosaraju\u2019s Algorithm\nRunning dfs(0) on the transposed graph (see Figure 4.7\u2014right), we immediately get stuck\nas there is no outgoing edge of vertex 0. Hence we \ufb01nd our \ufb01rst (and smallest) SCC. If we\nthen proceed with dfs(1), we have the next smallest SCC {1, 2, 3} (as now DFS will not go\nvia edge 1 ! 0 as vertex 0 has been visited, i.e., we have \u201cvirtually removed\u201d the \ufb01rst SCC).\nWe skip dfs(3) as it will not do anything. Finally, if we then proceed with dfs(4), we have\nthe next (and \ufb01nal) smallest SCC {4, 5, 6, 7} (as now DFS will not go via edge 4 ! 3 as\nvertex 3 has been visited, i.e., we again have \u201cvirtually removed\u201d the second SCC).\n10But this may not be a valid topological sort as the original directed graph will very likely be cyclic.\n208\n\nCHAPTER 4.", "mimetype": "text/plain", "start_char_idx": 618417, "end_char_idx": 621759, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "316c77f3-760e-40bc-b7cc-bec6cc17a976": {"__data__": {"id_": "316c77f3-760e-40bc-b7cc-bec6cc17a976", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9bed1b83-2d62-47cc-b9e7-9c76a5ef2803", "node_type": "1", "metadata": {}, "hash": "4b3580f63a38d306bb92381194d5e17d1225944efe990b2db838e1cff1746d61", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4ca516a4-f1dc-4ec7-b35f-90a45bcd5210", "node_type": "1", "metadata": {}, "hash": "087243be1349feaed6621b17f76a76f43d6c738827c6285d58e7333fc3606d40", "class_name": "RelatedNodeInfo"}}, "text": "Hence we \ufb01nd our \ufb01rst (and smallest) SCC. If we\nthen proceed with dfs(1), we have the next smallest SCC {1, 2, 3} (as now DFS will not go\nvia edge 1 ! 0 as vertex 0 has been visited, i.e., we have \u201cvirtually removed\u201d the \ufb01rst SCC).\nWe skip dfs(3) as it will not do anything. Finally, if we then proceed with dfs(4), we have\nthe next (and \ufb01nal) smallest SCC {4, 5, 6, 7} (as now DFS will not go via edge 4 ! 3 as\nvertex 3 has been visited, i.e., we again have \u201cvirtually removed\u201d the second SCC).\n10But this may not be a valid topological sort as the original directed graph will very likely be cyclic.\n208\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nThese two passes of DFS is enough to \ufb01nd the SCCs of the original directed graph. The\nsimple C++ implementation of Kosaraju\u2019s algorithm is shown below.\nvoid Kosaraju(int u, int pass) { // pass = 1 (original), 2 (transpose)\ndfs_num[u] = 1;\nvii &neighbor = (pass == 1) ? AL[u] : AL_T[u]; // by ref to avoid copying\nfor (auto &[v, w] : neighbor)\n// C++17 style, w ignored\nif (dfs_num[v] == UNVISITED)\nKosaraju(v, pass);\nS.push_back(u);\n// similar to toposort\n}\n// inside int main()\nS.clear();\n// first pass\ndfs_num.assign(N, UNVISITED);\n// record the post-order\nfor (int u = 0; u < N; ++u)\n// of the original graph\nif (dfs_num[u] == UNVISITED)\nKosaraju(u, 1);\nnumSCC = 0;\n// second pass\ndfs_num.assign(N, UNVISITED);\n// explore the SCCs\nfor (int i = N-1; i >= 0; --i)\n// based on the\nif (dfs_num[S[i]] == UNVISITED)\n// first pass result\n++numSCC, Kosaraju(S[i], 2);\n// on transposed graph\nprintf(\"There are %d SCCs\\n\", numSCC);\nTarjan\u2019s Algorithm\nFigure 4.8: Left: Directed Graph; Middle+Right: DFS Spanning Tree Snapshots\nThe basic idea of Tarjan\u2019s algorithm is that SCCs form subtrees in the DFS spanning tree\n(compare the original directed graph and the two snapshots of its DFS spanning trees in\nFigure 4.8). On top of computing dfs_num(u) and dfs_low(u) for each vertex, we also\nappend vertex u to the back of a stack S (here the stack is implemented with a vector)\nand keep track of the vertices that are currently explored via vi visited. The condition\nto update dfs_low(u) is slightly di\u21b5erent from the previous DFS algorithm for \ufb01nding\narticulation points and bridges. Here, only vertices that currently have visited \ufb02ag turned\non (part of the current SCC) that can update dfs_low(u). Now, if we have vertex u in\nthis DFS spanning tree with dfs_low(u) = dfs_num(u), we can conclude that u is the root\n(start) of an SCC (observe vertex 0, 1, and 4) in Figure 4.8 and the members of those SCCs\nare identi\ufb01ed by popping the current content of stack S until we reach vertex u again.\n209\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\nIn Figure 4.8\u2014middle, the content of S is {0, 1, 3, 2, 4, 5, 7, 6} when vertex 4 is found as\nroot of an SCC (dfs low(4) = dfs num(4) = 4), so we pop elements in S one by one until\nwe reach vertex 4 and we have this SCC: {4, 5, 6, 7}. Next, in Figure 4.8\u2014right, the content\nof S is {0, 1, 3, 2} when vertex 1 is identi\ufb01ed as the root of another SCC (dfs low(1) =\ndfs num(1) = 1), so we pop elements in S one by one until we reach vertex 1 and we have\nSCC: {1, 2, 3}.", "mimetype": "text/plain", "start_char_idx": 621142, "end_char_idx": 624294, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4ca516a4-f1dc-4ec7-b35f-90a45bcd5210": {"__data__": {"id_": "4ca516a4-f1dc-4ec7-b35f-90a45bcd5210", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "316c77f3-760e-40bc-b7cc-bec6cc17a976", "node_type": "1", "metadata": {}, "hash": "b7101772adc063c055882f5537e4243ca4de65ca9e5686e3415ee7a1d393e797", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bc703d50-b163-4f8d-9ebb-4c0513f3df80", "node_type": "1", "metadata": {}, "hash": "94423fb5c2eb50c18a8ee5e304f98054a6eacbbabbe553004aed783a674a8daa", "class_name": "RelatedNodeInfo"}}, "text": "Next, in Figure 4.8\u2014right, the content\nof S is {0, 1, 3, 2} when vertex 1 is identi\ufb01ed as the root of another SCC (dfs low(1) =\ndfs num(1) = 1), so we pop elements in S one by one until we reach vertex 1 and we have\nSCC: {1, 2, 3}. Finally, we have the last SCC with one member only: {0}.\nThe C++ implementation of Tarjan\u2019s algorithm is shown below. This code is basically\na tweak of the standard DFS code. The recursive part is similar to standard DFS and the\nSCC reporting part will run in amortized O(V ) times, as each vertex will only belong to one\nSCC and thus reported only once. In overall, this algorithm still runs in O(V + E).\nint dfsNumberCounter, numSCC;\n// global variables\nvi dfs_num, dfs_low, visited;\nstack<int> St;\nvoid tarjanSCC(int u) {\ndfs_low[u] = dfs_num[u] = dfsNumberCounter;\n// dfs_low[u]<=dfs_num[u]\ndfsNumberCounter++;\n// increase counter\nSt.push(u);\n// remember the order\nvisited[u] = 1;\nfor (auto &[v, w] : AL[u]) {\nif (dfs_num[v] == UNVISITED)\ntarjanSCC(v);\nif (visited[v])\n// condition for update\ndfs_low[u] = min(dfs_low[u], dfs_low[v]);\n}\nif (dfs_low[u] == dfs_num[u]) {\n// a root/start of an SCC\n++numSCC;\n// when recursion unwinds\nwhile (1) {\nint v = St.top(); St.pop();\nvisited[v] = 0;\nif (u == v) break;\n}\n}\n}\n// inside int main()\ndfs_num.assign(V, UNVISITED); dfs_low.assign(V, 0); visited.assign(V, 0);\nwhile (!St.empty()) St.pop();\ndfsNumberCounter = numSCC = 0;\nfor (int u = 0; u < V; ++u)\nif (dfs_num[u] == UNVISITED)\ntarjanSCC(u);\nSource code: ch4/traversal/UVa11838.cpp|java|py|ml\nExercise 4.2.10.1: Prove (or disprove) this statement: \u201cIf two vertices are in the same\nSCC, then there is no path between them that ever leaves the SCC\u201d!\n210\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.2.11\nGraph Traversal in Programming Contests\nIt is remarkable that the simple DFS and BFS traversal algorithms have so many interesting\nvariants that can be used to solve various graph problems on top of their basic form for\ntraversing a graph. In IOI (as per latest IOI syllabus in year 2020 [16]) and ICPC, any of\nthese variants can appear.\nUsing DFS (or BFS) to \ufb01nd connected components in an undirected graph is rarely asked\nper se although its variant: \ufb02ood \ufb01ll, is one of the most frequent problem type in the past.\nHowever, we feel that the number of (new) \ufb02ood \ufb01ll problems is getting smaller.\nTopological sort is rarely used per se, but it is a useful pre-processing step for \u2018DP on\n(implicit) DAG\u2019, see Section 4.6.1. The simplest version of topological sort code is very easy\nto memorize as it is just a simple DFS variant. The alternative Kahn\u2019s algorithm (that only\nprocess vertices with 0-incoming degrees) is also equally simple and may be important for\nsome topological sort applications.\nE\ufb03cient O(V + E) solutions for Bipartite Graph check, Cycle (back edge) check, and\n\ufb01nding articulation points/bridges are good to know but as seen in the UVa and Kattis\nonline judge (and recent ICPC regionals in Asia), not many problems use them now.\nThe knowledge of Kosaraju\u2019s or Tarjan\u2019s SCC algorithm may come in handy to solve\nmodern problems where one of its sub-problem involves directed graphs that \u2018requires trans-\nformation\u2019 to DAG by contracting cycles\u2014see the details in Book 2. The library code shown\nin this book may be something that you should bring into a programming contest that allows\nhard copy printed library code like ICPC.", "mimetype": "text/plain", "start_char_idx": 624063, "end_char_idx": 627445, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bc703d50-b163-4f8d-9ebb-4c0513f3df80": {"__data__": {"id_": "bc703d50-b163-4f8d-9ebb-4c0513f3df80", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4ca516a4-f1dc-4ec7-b35f-90a45bcd5210", "node_type": "1", "metadata": {}, "hash": "087243be1349feaed6621b17f76a76f43d6c738827c6285d58e7333fc3606d40", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "47debdbf-a2a9-4d09-9159-aea64f35bd83", "node_type": "1", "metadata": {}, "hash": "0b963d07eac006ab86303aacc6babcc8133cd89b35f8635604e031861252ea0e", "class_name": "RelatedNodeInfo"}}, "text": "The alternative Kahn\u2019s algorithm (that only\nprocess vertices with 0-incoming degrees) is also equally simple and may be important for\nsome topological sort applications.\nE\ufb03cient O(V + E) solutions for Bipartite Graph check, Cycle (back edge) check, and\n\ufb01nding articulation points/bridges are good to know but as seen in the UVa and Kattis\nonline judge (and recent ICPC regionals in Asia), not many problems use them now.\nThe knowledge of Kosaraju\u2019s or Tarjan\u2019s SCC algorithm may come in handy to solve\nmodern problems where one of its sub-problem involves directed graphs that \u2018requires trans-\nformation\u2019 to DAG by contracting cycles\u2014see the details in Book 2. The library code shown\nin this book may be something that you should bring into a programming contest that allows\nhard copy printed library code like ICPC. Note that Kosaraju\u2019s algorithm requires graph\ntranspose routine (or build two graph data structures upfront) that is mentioned brie\ufb02y in\nSection 2.4.1 and it needs two passes through the graph data structure whereas Tarjan\u2019s\nalgorithm does not need graph transpose routine and it only needs only one pass. However,\nwe reckon that these two SCC \ufb01nding algorithms are equally good and can be used to solve\nmany (if not all) SCC problems listed in this book.\nOther graph traversal problems that do not \ufb01t into categories above are currently listed\nunder Really Ad Hoc category. Some of them are interestingly very creative.\nAlthough many of the graph problems discussed in this section can be solved by either\nDFS or BFS. Personally, we feel that many of them are easier to be solved using the recursive\nand more memory friendly DFS. We do not normally use BFS for pure graph traversal\nproblems but we will use it to solve the Single-Source Shortest Paths problems on unweighted\ngraph (see Section 4.4.2). Table 4.2 shows important comparison between these two popular\ngraph traversal algorithms.\nO(V + E) DFS (Depth-\ufb01rst)\nO(V + E) BFS (Breadth-\ufb01rst)\nPros\nUsually use less memory\nCan solve SSSP\nCan \ufb01nd cut vertices, bridges, SCC\non unweighted graphs\nCons\nCannot solve SSSP\nUsually use more memory\non unweighted graphs\n(bad for large graph)\nCode\nSlightly easier to code\nJust a bit longer to code\nTable 4.2: Graph Traversal Algorithm Decision Table\nWe have provided the animation of DFS/BFS algorithm and (many of) their variants in\nVisuAlgo. Use it to further strengthen your understanding of these algorithms by providing\nyour own input graph and/or source vertex and see the graph algorithm being animated live\non that particular input graph. The URL is shown below.\nVisualization: https://visualgo.net/en/dfsbfs\n211\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\nProgramming Exercises related to Graph Traversal:\na. Finding Connected Components\n1. Entry Level: Kattis - wheresmyinternet * (check connectivity to vertex 1)\n2. UVa 00459 - Graph Connectivity * (also solvable with UFDS)\n3. UVa 11749 - Poor Trade Advisor * (\ufb01nd the largest CC with highest\naverage PPA; also solvable with UFDS)\n4. UVa 11906 - Knight in a War Grid * (DFS/BFS for reachability, several\ntricky cases; be careful when M = 0, N = 0, or = N)\n5. Kattis - dominoes2 * (unlike UVa 11504, we treat SCCs as CCs; also available\nat UVa 11518 - Dominos 2)\n6. Kattis - reachableroads * (report number of CC-1)\n7. Kattis - terraces * (group cells with similar height together; if it cannot \ufb02ow\nto any other component with lower height, add this CC-size to answer)\nExtra UVa: 00260, 00280, 10687, 11841, 11902.\nExtra Kattis: cartrouble, daceydice, foldingacube, moneymatters, pearwise,\nsecuritybadge.\nb. Flood Fill, Easier\n1. Entry Level: UVa 00572 - Oil Deposits * (count number of CCs)\n2. UVa 00352 - The Seasonal War * (count number of CCs; see UVa 00572)\n3.", "mimetype": "text/plain", "start_char_idx": 626629, "end_char_idx": 630371, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "47debdbf-a2a9-4d09-9159-aea64f35bd83": {"__data__": {"id_": "47debdbf-a2a9-4d09-9159-aea64f35bd83", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bc703d50-b163-4f8d-9ebb-4c0513f3df80", "node_type": "1", "metadata": {}, "hash": "94423fb5c2eb50c18a8ee5e304f98054a6eacbbabbe553004aed783a674a8daa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "464020d2-e8b6-46b9-9bc0-f57eb9f27c35", "node_type": "1", "metadata": {}, "hash": "1634ebf3a38e66c3b51e34564fc84fb8188cead6a01e11d6a43a46d00d86a5ec", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - reachableroads * (report number of CC-1)\n7. Kattis - terraces * (group cells with similar height together; if it cannot \ufb02ow\nto any other component with lower height, add this CC-size to answer)\nExtra UVa: 00260, 00280, 10687, 11841, 11902.\nExtra Kattis: cartrouble, daceydice, foldingacube, moneymatters, pearwise,\nsecuritybadge.\nb. Flood Fill, Easier\n1. Entry Level: UVa 00572 - Oil Deposits * (count number of CCs)\n2. UVa 00352 - The Seasonal War * (count number of CCs; see UVa 00572)\n3. UVa 00871 - Counting Cells in a Blob * (\ufb01nd the largest CC size)\n4. UVa 11953 - Battleships * (interesting twist of \ufb02ood \ufb01ll problem)\n5. Kattis - amoebas * (easy \ufb02ood\ufb01ll)\n6. Kattis - countingstars * (basic \ufb02ood \ufb01ll problem; count CCs)\n7. Kattis - gold * (\ufb02ood \ufb01ll with extra blocking constraint; also available at\nUVa 11561 - Getting Gold)\nExtra UVa: 00469, 00657, 00722, 10336, 11244, 11470.\nExtra Kattis: \ufb02oodit.\nc. Flood Fill, Harder\n1. Entry Level: UVa 11094 - Continents * (tricky \ufb02ood \ufb01ll; scrolling)\n2. UVa 00852 - Deciding victory in Go * (interesting board game \u2018Go\u2019)\n3. UVa 01103 - Ancient Messages * (LA 5130 - WorldFinals Orlando11;\nmajor hint: each hieroglyph has unique number of white CCs)\n4. UVa 11585 - Nurikabe * (polynomial-time veri\ufb01er for an NP-complete\npuzzle Nurikabe; this veri\ufb01er requires clever usage of \ufb02ood \ufb01ll algorithm)\n5. Kattis - 10kindsofpeople * (intelligent \ufb02ood \ufb01ll; just run once to avoid TLE\nas there are many queries)\n6. Kattis - coast * (intelligent \ufb02ood \ufb01ll; give sentinel to represent sea; \ufb02ood\ufb01ll\nfrom sea; count crossings to lands)\n7. Kattis - islands3 * (optimistic \ufb02ood \ufb01ll; assume all Cs are Ls)\nExtra UVa: 00601, 00705, 00758, 00776, 00782, 00784, 00785, 10592, 10707,\n10946, 11110.\nExtra Kattis: island, vindiagrams.\n212\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nd. Topological Sort\n1. Entry Level: Kattis - builddeps * (the graph is acyclic; toposort with DFS\nfrom the changed \ufb01le)\n2. UVa 00200 - Rare Order * (toposort)\n3. UVa 00872 - Ordering * (similar to UVa 00124; use backtracking)\n4. UVa 11060 - Beverages * (Kahn\u2019s algorithm\u2014modi\ufb01ed BFS toposort)\n5. Kattis - brexit * (toposort; chain reaction; modi\ufb01ed Kahn\u2019s algorithm)\n6. Kattis - conservation * (modi\ufb01ed Kahn\u2019s algorithm; greedily process all steps\nin a certain lab before alternating to the other lab)\n7. Kattis - pickupsticks * (cycle check + toposort if DAG; also available at item\nUVa 11686 - Pick up sticks)\nExtra UVa: 00124, 10305.\nExtra Kattis: brexitnegotiations, collapse, digicomp2, easyascab, grapevine,\nmanagingpackaging.\nAlso see: DP on (implicit) DAG problems (see Section 4.6.1).\ne. Bipartite or Cycle Check\n1. Entry Level: Kattis - runningmom * (\ufb01nd a cycle in a directed graph)\n2. UVa 10004 - Bicoloring * (Bipartite Graph check)\n3.", "mimetype": "text/plain", "start_char_idx": 629872, "end_char_idx": 632634, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "464020d2-e8b6-46b9-9bc0-f57eb9f27c35": {"__data__": {"id_": "464020d2-e8b6-46b9-9bc0-f57eb9f27c35", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "47debdbf-a2a9-4d09-9159-aea64f35bd83", "node_type": "1", "metadata": {}, "hash": "0b963d07eac006ab86303aacc6babcc8133cd89b35f8635604e031861252ea0e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "49195315-41bc-4a7a-b48d-3134fc835c35", "node_type": "1", "metadata": {}, "hash": "4343553200061d9c5d39f5eff14a90423ad3cb86f6bc6bdf6db5d5b4c6e44f7d", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - conservation * (modi\ufb01ed Kahn\u2019s algorithm; greedily process all steps\nin a certain lab before alternating to the other lab)\n7. Kattis - pickupsticks * (cycle check + toposort if DAG; also available at item\nUVa 11686 - Pick up sticks)\nExtra UVa: 00124, 10305.\nExtra Kattis: brexitnegotiations, collapse, digicomp2, easyascab, grapevine,\nmanagingpackaging.\nAlso see: DP on (implicit) DAG problems (see Section 4.6.1).\ne. Bipartite or Cycle Check\n1. Entry Level: Kattis - runningmom * (\ufb01nd a cycle in a directed graph)\n2. UVa 10004 - Bicoloring * (Bipartite Graph check)\n3. UVa 10116 - Robot Motion * (traversal on implicit graph; cycle check)\n4. UVa 10505 - Montesco vs Capuleto * (bipartite; take max(left, right))\n5. Kattis - hoppers * (the answer is number of CC-1 if there is at least one\nbipartite component in the graph; or number of CC otherwise)\n6. Kattis - molekule * (undirected tree is also Bipartite/bi-colorable; bi-color it\nwith 0 and 1; direct all edges from 0 to 1 (or vice versa))\n7. Kattis - torn2pieces * (construct graph from strings; traversal from source\nto target; reachability check; print path)\nExtra UVa: 00840, 10510, 11080, 11396,\nExtra Kattis: amanda, ballsandneedles, breakingbad, familydag, pubs.\nf. Finding Articulation Points/Bridges\n1. Entry Level: UVa 00315 - Network * (\ufb01nding articulation points)\n2. UVa 10765 - Doves and Bombs * (\ufb01nding articulation points)\n3. UVa 12363 - Hedge Mazes * (LA 5796 - Latin America; transform input\nto graph of its bridges; see if b is reachable from a with only the bridges)\n4. UVa 12783 - Weak Links * (\ufb01nding bridges)\n5. Kattis - birthday * (check if the input graph contains any bridge; N is small\nthough so weaker solution can still be accepted)\n6. Kattis - caveexploration * (\ufb01nd size of bi-connected components that contains\nvertex 0; identify the bridges)\n7. Kattis - intercept * (Articulation Points in SSSP Spanning DAG; clever mod-\ni\ufb01cation of Dijkstra\u2019s)\nExtra UVa: 00610, 00796, 10199.\nExtra Kattis: kingpinescape.\n213\n\n4.2.\nGRAPH TRAVERSAL\nc\u20ddSteven, Felix, Suhendry\ng. Finding Strongly Connected Components\n1. Entry Level: UVa 11838 - Come and Go * (see if input graph is an SCC)\n2. UVa 00247 - Calling Circles * (SCC + printing solution)\n3. UVa 11709 - Trust Groups * (\ufb01nd the number of SCCs)\n4. UVa 11770 - Lighting Away * (similar to UVa 11504)\n5. Kattis - cantinaofbabel * (build directed graph \u2018can speak\u2019; compute the\nlargest SCC of \u2018can speak\u2019; keep this largest SCC)\n6. Kattis - dominos * (count the number of SCCs without incoming edge from\na vertex outside that SCC; also available at UVa 11504 - Dominos)\n7. Kattis - equivalences * (contract input directed graph into SCCs; count SCCs\nthat have in-/out-degrees = 0; report the max)\nExtra UVa: 01229.\nExtra Kattis: loopycabdrivers, reversingroads, test2.\nh. Ad Hoc Graph Traversal\n1. Entry Level: UVa 12376 - As Long as I Learn, I Live * (simulated\ngreedy traversal on DAG)\n2. UVa 00824 - Coast Tracker * (traversal on implicit graph)\n3. UVa 11831 - Sticker Collector ... * (traversal on implicit graph)\n4. UVa 12442 - Forwarding Emails * (modi\ufb01ed DFS; special graph)\n5. Kattis - faultyrobot * (interesting graph traversal variant)\n6.", "mimetype": "text/plain", "start_char_idx": 632056, "end_char_idx": 635238, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "49195315-41bc-4a7a-b48d-3134fc835c35": {"__data__": {"id_": "49195315-41bc-4a7a-b48d-3134fc835c35", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "464020d2-e8b6-46b9-9bc0-f57eb9f27c35", "node_type": "1", "metadata": {}, "hash": "1634ebf3a38e66c3b51e34564fc84fb8188cead6a01e11d6a43a46d00d86a5ec", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c5ca4760-838f-42a3-903d-47ba895f0514", "node_type": "1", "metadata": {}, "hash": "38507e592cac30e44c867659ba76bc05c183ab034930084e41ff76c43a5d7975", "class_name": "RelatedNodeInfo"}}, "text": "Kattis - equivalences * (contract input directed graph into SCCs; count SCCs\nthat have in-/out-degrees = 0; report the max)\nExtra UVa: 01229.\nExtra Kattis: loopycabdrivers, reversingroads, test2.\nh. Ad Hoc Graph Traversal\n1. Entry Level: UVa 12376 - As Long as I Learn, I Live * (simulated\ngreedy traversal on DAG)\n2. UVa 00824 - Coast Tracker * (traversal on implicit graph)\n3. UVa 11831 - Sticker Collector ... * (traversal on implicit graph)\n4. UVa 12442 - Forwarding Emails * (modi\ufb01ed DFS; special graph)\n5. Kattis - faultyrobot * (interesting graph traversal variant)\n6. Kattis - promotions * (modi\ufb01ed DFS; special graph; DAG; also available at\nUVa 13015 - Promotions)\n7. Kattis - succession * ((upwards) traversal of family DAG; use unordered maps;\nmake the founder has very large starting blood to avoid fraction)\nExtra UVa: 00118, 00168, 00173, 00318, 00614, 00781, 10113, 10377, 12582,\n12648, 13038.\nExtra Kattis: ads, brickwall, droppingdirections, hogwarts2, jetpack, kingofthe-\nwaves, silueta.\nOthers: IOI 2011 - Tropical Garden (graph traversal; DFS; involving cycle).\nPro\ufb01le of Algorithm Inventor\nEdward Forrest Moore (1925-2003) was an American professor of Mathematics and Com-\nputer Science. He (re-)invented and popularized the Breadth First Search (BFS) algorithm\nin his paper [41]. In the same work, he also improved the Bellman-Ford algorithm into the\nfaster Bellman-Ford-Moore algorithm.\n214\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.3\nMinimum Spanning Tree (MST)\n4.3.1\nOverview and Motivation\nProblem: Given a connected, undirected, and weighted graph G = (V, E) (see Figure 4.9\u2014\nleft), select a subset of edges E0 \u2713E such that the graph G0 = (V, E0) is (still) connected\nand the total weight of the selected edges E0 is minimal!\nFigure 4.9: Example of an MST Problem\nTo satisfy the connectivity criteria, we need at least V -1 edges that form a tree and this tree\nmust span (cover) all V 2 G\u2014the spanning tree! There can be several valid spanning trees\nin G, i.e., see Figure 4.9\u2014middle and right, including the DFS and BFS spanning trees that\nwe have learned in previous Section 4.2 or even the SSSP spanning trees that we will learn\nlater in Section 4.4. Among these possible spanning trees11 of G, there are some (at least\none) that satisfy the minimal weight criteria.\nThis problem is called the Minimum Spanning Tree (MST) problem and has many prac-\ntical applications. For example, we can model a problem of building road network in remote\nvillages as an MST problem. The vertices are the villages. The edges are the potential roads\nthat may be built between those villages. The cost of building a road that connects village\ni and j is the weight of edge (i, j). The MST of this graph is therefore the minimum cost\nroad network that connects all these villages. UVa [44] and Kattis [34] online judges have\nsome basic MST problems like this, e.g., UVa 00908, 01174, 01208, 10034, 11631, Kattis -\nislandhopping, minspantree, etc.\nThis MST problem can be solved with several well-known algorithms, i.e., Kruskal\u2019s\nand Prim\u2019s algorithms. Both are Greedy algorithms and explained in many CS textbooks\n[5, 51, 38, 53, 40, 1, 35, 6]. The MST weight produced by these two algorithms is unique,\nbut there can be more than one spanning tree with the same MST weight.\n4.3.2\nKruskal\u2019s Algorithm\nJoseph Bernard Kruskal Jr.\u2019s algorithm \ufb01rst sorts E edges based on non-decreasing weight.", "mimetype": "text/plain", "start_char_idx": 634663, "end_char_idx": 638069, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c5ca4760-838f-42a3-903d-47ba895f0514": {"__data__": {"id_": "c5ca4760-838f-42a3-903d-47ba895f0514", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "49195315-41bc-4a7a-b48d-3134fc835c35", "node_type": "1", "metadata": {}, "hash": "4343553200061d9c5d39f5eff14a90423ad3cb86f6bc6bdf6db5d5b4c6e44f7d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "82d4b21c-b6f3-42be-80b3-dfb4045929c3", "node_type": "1", "metadata": {}, "hash": "55e59ab39ec937536e565daa9614f4d35992e4b685f491320461eda5bb2fd153", "class_name": "RelatedNodeInfo"}}, "text": "UVa [44] and Kattis [34] online judges have\nsome basic MST problems like this, e.g., UVa 00908, 01174, 01208, 10034, 11631, Kattis -\nislandhopping, minspantree, etc.\nThis MST problem can be solved with several well-known algorithms, i.e., Kruskal\u2019s\nand Prim\u2019s algorithms. Both are Greedy algorithms and explained in many CS textbooks\n[5, 51, 38, 53, 40, 1, 35, 6]. The MST weight produced by these two algorithms is unique,\nbut there can be more than one spanning tree with the same MST weight.\n4.3.2\nKruskal\u2019s Algorithm\nJoseph Bernard Kruskal Jr.\u2019s algorithm \ufb01rst sorts E edges based on non-decreasing weight.\nThis can be easily done by storing the edges in an Edge List data structure (see Section\n2.4.1) and then sort the edges based on non-decreasing weight. Then, Kruskal\u2019s algorithm\ngreedily tries to add each edge into the MST as long as such addition does not form a cycle.\nThis cycle check can be done easily using the lightweight Union-Find Disjoint Sets (UFDS)\ndata structure discussed in Section 2.4.2. Conceptually, Kruskal\u2019s algorithm maintains forest\nof (small) trees (possibly disjoint) that gradually merging into one MST.\n11Interested readers should read up the advanced mathematics topic of \u2018Kirchho\u21b5\u2019s Matrix Tree Theorem\u2019\non how to count the number of spanning trees in a graph in polynomial time.\n215\n\n4.3.\nMINIMUM SPANNING TREE (MST)\nc\u20ddSteven, Felix, Suhendry\nThe code is short (because we have separated the Union-Find Disjoint Sets implementa-\ntion code in a separate class). The overall runtime of this algorithm is O(sorting + trying to\nadd each edge \u21e5cost of Union-Find operations) = O(E log E + E \u21e5(\u21e11)) = O(E log E) =\nO(E log V 2) = O(2 \u21e5E log V ) = O(E log V ).\n// inside int main(), our own UFDS code has been included\nint V, E; scanf(\"%d %d\", &V, &E);\nvector<iii> EL(E);\nfor (int i = 0; i < E; ++i) {\nint u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n// read as (u, v, w)\nEL[i] = {w, u, v};\n// reorder as (w, u, v)\n}\nsort(EL.begin(), EL.end());\n// sort by w, O(E log E)\n// note: std::tuple has built-in comparison function\nint mst_cost = 0, num_taken = 0;\n// no edge has been taken\nUnionFind UF(V);\n// all V are disjoint sets\n// note: the runtime cost of UFDS is very light\nfor (auto &[w, u, v] : EL) {\n// C++17 style\nif (UF.isSameSet(u, v)) continue;\n// already in the same CC\nmst_cost += w;\n// add w of this edge\nUF.unionSet(u, v);\n// link them\n++num_taken;\n// 1 more edge is taken\nif (num_taken == V-1) break;\n// optimization\n}\n// note: the number of disjoint sets must eventually be 1 for a valid MST\nprintf(\"MST cost = %d (Kruskal\u2019s)\\n\", mst_cost);\nSource code: ch4/mst/kruskal.cpp|java|py|ml\nFigure 4.10 shows partial execution of Kruskal\u2019s algorithm on the graph in Figure 4.9\u2014left.\nNotice that the \ufb01nal MST is not unique. In Figure 4.10\u2013right, we can also have another\nMST with the same minimum cost of 18 by replacing edge 0-1 with edge 0-2.\nFigure 4.10: Animation of Kruskal\u2019s Algorithm for an MST Problem\nExercise 4.3.2.1: In the code above, we stop Kruskal\u2019s as soon as it has taken V -1 edges\ninto the MST. Why this early termination does not change the correctness of Kruskal\u2019s\nalgorithm? Is there other ways to implement the same optimization using UFDS?\n216\n\nCHAPTER 4.", "mimetype": "text/plain", "start_char_idx": 637459, "end_char_idx": 640671, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "82d4b21c-b6f3-42be-80b3-dfb4045929c3": {"__data__": {"id_": "82d4b21c-b6f3-42be-80b3-dfb4045929c3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c5ca4760-838f-42a3-903d-47ba895f0514", "node_type": "1", "metadata": {}, "hash": "38507e592cac30e44c867659ba76bc05c183ab034930084e41ff76c43a5d7975", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9350a3b4-adf8-4c48-b84d-d4f3495efe3b", "node_type": "1", "metadata": {}, "hash": "180b9553a2b7c8c9e4bb60fe0bd06ed9db8f1267e5b9999eb3d4f1a13d05ef39", "class_name": "RelatedNodeInfo"}}, "text": "Notice that the \ufb01nal MST is not unique. In Figure 4.10\u2013right, we can also have another\nMST with the same minimum cost of 18 by replacing edge 0-1 with edge 0-2.\nFigure 4.10: Animation of Kruskal\u2019s Algorithm for an MST Problem\nExercise 4.3.2.1: In the code above, we stop Kruskal\u2019s as soon as it has taken V -1 edges\ninto the MST. Why this early termination does not change the correctness of Kruskal\u2019s\nalgorithm? Is there other ways to implement the same optimization using UFDS?\n216\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.3.3\nPrim\u2019s Algorithm\nRobert Clay Prim\u2019s (or Vojt\u02c6ech Jarn\u00b4\u0131k\u2019s) algorithm \ufb01rst takes a starting vertex (for simplic-\nity, we take vertex 0), \ufb02ags it as \u2018taken\u2019, and enqueues a pair of information into a priority\nqueue: the weight w and the other end point u of the edge (0, u) that is not taken yet. These\npairs are dynamically sorted in the priority queue based on increasing weight, and if tie, by\nincreasing vertex number. Then, Prim\u2019s algorithm greedily selects the pair (w, u) in front of\nthe priority queue\u2014which has the minimum weight w\u2014if the end point of this edge\u2014which\nis u\u2014has not been taken before. This is to prevent cycle. If this pair (w, u) is valid, then\nthe weight w is added into the MST cost, u is marked as taken, and pair (w0, v) of each edge\n(u, v) with weight w0 that is incident to u is enqueued into the priority queue if v has not\nbeen taken before. This process is repeated until the priority queue is empty. Conceptually,\nPrim\u2019s algorithm grows an MST (always a single component/tree) from the starting vertex\nuntil it spans the entire graph.\nThe code length is about the same as Kruskal\u2019s and also runs in O(process each edge\nonce \u21e5cost of enqueue/dequeue) = O(E \u21e5log E) = O(E log V ).\nvector<vii> AL;\n// the graph stored in AL\nvi taken;\n// to avoid cycle\npriority_queue<ii> pq;\n// to select shorter edges\n// C++ STL priority_queue is a max heap, we use -ve sign to reverse order\nvoid process(int u) { // set u as taken and enqueue neighbors of u\ntaken[u] = 1;\nfor (auto &[v, w] : AL[u])\nif (!taken[v])\npq.emplace(-w, -v);\n// sort by non-dec weight\n}\n// then by inc id\n// inside int main() --- assume the graph is stored in AL, pq is empty\nint V, E; scanf(\"%d %d\", &V, &E);\nAL.assign(V, vii());\nfor (int i = 0; i < E; ++i) {\nint u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n// read as (u, v, w)\nAL[u].emplace_back(v, w);\nAL[v].emplace_back(u, w);\n}\ntaken.assign(V, 0);\n// no vertex is taken\nprocess(0);\n// take+process vertex 0\nint mst_cost = 0, num_taken = 0;\n// no edge has been taken\nwhile (!pq.empty()) {\n// up to O(E)\nauto [w, u] = pq.top(); pq.pop();\n// C++17 style\nw = -w; u = -u;\n// negate to reverse order\nif (taken[u]) continue;\n// already taken, skipped\nmst_cost += w;\n// add w of this edge\nprocess(u);\n// take+process vertex u\n++num_taken;\n// 1 more edge is taken\nif (num_taken == V-1) break;\n// optimization\n}\nprintf(\"MST cost = %d (Prim\u2019s)\\n\", mst_cost);\n217\n\n4.3.\nMINIMUM SPANNING TREE (MST)\nc\u20ddSteven, Felix, Suhendry\nFigure 4.11: Animation of Prim\u2019s Algorithm for the same graph as in Figure 4.9\u2014left\nFigure 4.11 shows partial execution of Prim\u2019s algorithm on the same graph shown in Figure\n4.9\u2014left. Please compare it with Figure 4.10 to study the similarities and di\u21b5erences between\nKruskal\u2019s and Prim\u2019s algorithms.\nUnderstanding (partial) sequence of static pictures maybe a bit challenging.", "mimetype": "text/plain", "start_char_idx": 640176, "end_char_idx": 643542, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9350a3b4-adf8-4c48-b84d-d4f3495efe3b": {"__data__": {"id_": "9350a3b4-adf8-4c48-b84d-d4f3495efe3b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "82d4b21c-b6f3-42be-80b3-dfb4045929c3", "node_type": "1", "metadata": {}, "hash": "55e59ab39ec937536e565daa9614f4d35992e4b685f491320461eda5bb2fd153", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6403085f-ae51-46ed-8355-3aa29b08b8c1", "node_type": "1", "metadata": {}, "hash": "29051f9a1bb87ae258de1ff81b782fae471405cbdb608cf9e86754ed1a1d5554", "class_name": "RelatedNodeInfo"}}, "text": "MINIMUM SPANNING TREE (MST)\nc\u20ddSteven, Felix, Suhendry\nFigure 4.11: Animation of Prim\u2019s Algorithm for the same graph as in Figure 4.9\u2014left\nFigure 4.11 shows partial execution of Prim\u2019s algorithm on the same graph shown in Figure\n4.9\u2014left. Please compare it with Figure 4.10 to study the similarities and di\u21b5erences between\nKruskal\u2019s and Prim\u2019s algorithms.\nUnderstanding (partial) sequence of static pictures maybe a bit challenging. Therefore,\nwe have provided the animation of both Kruskal\u2019s and Prim\u2019s algorithms in VisuAlgo. Use\nit to further strengthen your understanding of these two MST algorithms either by using our\nsample graphs or by providing your own input graph (undirected weighted graph) and then\nsee the selected MST algorithm (either Kruskal\u2019s or Prim\u2019s) being animated live on that\nparticular input graph. The URL for the various MST algorithms and source code example\nare shown below.\nVisualization: https://visualgo.net/en/mst\nSource code: ch4/mst/prim.cpp|java|py|ml\n4.3.4\nOther Applications\nVariants of basic MST problem are interesting. In this section, we will explore some of them.\nFigure 4.12: From left to right: MST, \u2018Maximum\u2019 ST, \u2018Minimum\u2019 SS, MS \u2018Forest\u2019\nMaximum Spanning Tree\nThis is a simple variant where we want the Maximum instead of the Minimum Spanning\nTree (ST), e.g., UVa 01234 - RACING (note that this problem is written in such a way that\nit does not look like an MST problem). In Figure 4.12\u2014B, we see an example of a Maximum\nST. Compare it with the corresponding MST (Figure 4.12\u2014A).\nThe solution for this variant is very simple. For Kruskal\u2019s algorithm, we simply sort\nthe edges based on non-increasing weight. For Prim\u2019s algorithm, we simply order the edges\nusing max priority queue. Or, we can insert negative edge weights to reverse the order.\n218\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n\u2018Minimum\u2019 Spanning Subgraph\nIn this variant, we do not start with a clean slate. Some edges in the given graph have already\nbeen \ufb01xed and must be taken as part of the solution, for example: UVa 10147 - Highways.\nThese default edges may form a non-tree in the \ufb01rst place. Our task is to continue selecting\nthe remaining edges (if necessary) to make the graph connected in the least cost way. The\nresulting Spanning Subgraph may not be a tree and even if it is a tree, it may not be the\nMST. That\u2019s why we put the term \u2018Minimum\u2019 in quotes and use the term \u2018subgraph\u2019 rather\nthan \u2018tree\u2019. In Figure 4.12\u2014C, we see an example when one edge (0, 1) is already \ufb01xed. The\nactual MST is 10+13+17 = 40 which omits the edge (0, 1) (Figure 4.12\u2014A). However, the\nsolution for this example must be (25)+10+13 = 48 which uses the edge (0, 1).\nThe solution for this variant is simple. For Kruskal\u2019s algorithm, we \ufb01rst take into account\nall the \ufb01xed edges and their costs. Then, we continue running Kruskal\u2019s algorithm on the\nremaining free edges until we have a spanning subgraph (or spanning tree).\nFor Prim\u2019s\nalgorithm, we give higher priorities to these \ufb01xed edges so that we will always take them\nand their costs.\nMinimum \u2018Spanning Forest\u2019\nIn this variant, we want to form a forest of K connected components (K subtrees) in the\nleast cost way where K is given beforehand in the problem description, for example: Kattis -\narcticnetwork (also available at UVa 10369 - Arctic Networks). In Figure 4.12\u2014A, we observe\nthat the MST for this graph is 10+13+17 = 40. But if we are happy with a spanning forest\nwith 2 connected components, then the solution is just 10+13 = 23 on Figure 4.12\u2014D. That\nis, we omit the edge (2, 3) with weight 17 which will connect these two components into one\nspanning tree if taken.\nTo get the minimum spanning forest is simple. For Kruskal\u2019s algorithm, we run it as\nper normal.", "mimetype": "text/plain", "start_char_idx": 643111, "end_char_idx": 646838, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6403085f-ae51-46ed-8355-3aa29b08b8c1": {"__data__": {"id_": "6403085f-ae51-46ed-8355-3aa29b08b8c1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9350a3b4-adf8-4c48-b84d-d4f3495efe3b", "node_type": "1", "metadata": {}, "hash": "180b9553a2b7c8c9e4bb60fe0bd06ed9db8f1267e5b9999eb3d4f1a13d05ef39", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "62c72ac7-89c5-44a0-885c-844999408084", "node_type": "1", "metadata": {}, "hash": "b94ac20cf28e9274fa1c0bb5eafb3cb2921255fc03680e38a8f458084542102f", "class_name": "RelatedNodeInfo"}}, "text": "Minimum \u2018Spanning Forest\u2019\nIn this variant, we want to form a forest of K connected components (K subtrees) in the\nleast cost way where K is given beforehand in the problem description, for example: Kattis -\narcticnetwork (also available at UVa 10369 - Arctic Networks). In Figure 4.12\u2014A, we observe\nthat the MST for this graph is 10+13+17 = 40. But if we are happy with a spanning forest\nwith 2 connected components, then the solution is just 10+13 = 23 on Figure 4.12\u2014D. That\nis, we omit the edge (2, 3) with weight 17 which will connect these two components into one\nspanning tree if taken.\nTo get the minimum spanning forest is simple. For Kruskal\u2019s algorithm, we run it as\nper normal. However, as soon as the number of connected components equals to the desired\npre-determined number K, we can terminate Kruskal\u2019s algorithm. For Prim\u2019s algorithm, we\nrun it as per normal to get the MST and then delete the K-1 longest edges of the MST.\nMiniMax (and MaxiMin)\nFigure 4.13: Minimax (UVa 10048 [44])\nThe MiniMax path problem is a problem of \ufb01nding the minimum of maximum edge weight\namong all possible paths between two vertices i to j. The cost for a path from i to j is\ndetermined by the maximum edge weight along this path. Among all these possible paths\nfrom i to j, pick the one with the minimum max-edge-weight.\nThe reverse problem of\nMaxiMin is de\ufb01ned similarly.\nThe MiniMax path problem between vertex i and j can be solved by modeling it as an\nMST problem. With a rationale that the problem prefers a path with low individual edge\nweights even if the path is longer in terms of number of vertices/edges involved, then having\nthe MST (using Kruskal\u2019s or Prim\u2019s) of the given weighted graph is a correct step. The MST\n219\n\n4.3.\nMINIMUM SPANNING TREE (MST)\nc\u20ddSteven, Felix, Suhendry\nis connected thus ensuring a path between any pair of vertices. The MiniMax path solution\nis thus the max edge weight along the unique path between vertex i and j in this MST.\nThe overall time complexity is O(build MST + one traversal on the resulting tree). As\nE = V -1 in a tree, any traversal on tree is just O(V ). Thus the complexity of this approach\nis O(E log V + V ) = O(E log V ).\nFigure 4.13\u2014left is a sample test case of UVa 10048 - Audiophobia. We have a graph\nwith 7 vertices and 9 edges. The 6 chosen edges of the MST are shown as thick lines in\nFigure 4.13\u2014right. Now, if we are asked to \ufb01nd the MiniMax path between vertex 0 and 6\nin Figure 4.13\u2014right, we simply traverse the MST from vertex 0 to 6. There will only be\none way, path: 0-2-5-3-6. The maximum edge weight found along the path is the required\nMiniMax cost: 80 (due to edge 5-3).\nSecond Best Spanning Tree\nFigure 4.14: Second Best ST (from UVa 10600 [44])\nSometimes, alternative solutions are important. In the context of \ufb01nding the MST, we may\nwant not just the MST, but also the second best spanning tree, in case the MST is not\nworkable, for example: UVa 10600 - ACM contest and blackout. Figure 4.14 shows the MST\n(left) and the second best ST (right). We can see that the second best ST is actually the\nMST with just two edges di\u21b5erence, i.e., one edge is taken out from the MST and another\nchord12 edge is added into the MST. Here, edge 3-4 is taken out and edge 1-4 is added in.\nFigure 4.15: Finding the Second Best Spanning Tree from the MST\n12A chord edge is de\ufb01ned as an edge in graph G that is not selected in the MST of G.\n220\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nA solution for this variant is a modi\ufb01ed Kruskal\u2019s: sort the edges in O(E log E) = O(E log V ),\nthen \ufb01nd the MST using Kruskal\u2019s in O(E).", "mimetype": "text/plain", "start_char_idx": 646150, "end_char_idx": 649737, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "62c72ac7-89c5-44a0-885c-844999408084": {"__data__": {"id_": "62c72ac7-89c5-44a0-885c-844999408084", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6403085f-ae51-46ed-8355-3aa29b08b8c1", "node_type": "1", "metadata": {}, "hash": "29051f9a1bb87ae258de1ff81b782fae471405cbdb608cf9e86754ed1a1d5554", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d85f620b-8926-462e-a0e0-d08bcd62afbe", "node_type": "1", "metadata": {}, "hash": "820209d6aa42aaeced9d99b2ddff4eea7a048ea841445431d565f754dbd0a09e", "class_name": "RelatedNodeInfo"}}, "text": "Figure 4.14 shows the MST\n(left) and the second best ST (right). We can see that the second best ST is actually the\nMST with just two edges di\u21b5erence, i.e., one edge is taken out from the MST and another\nchord12 edge is added into the MST. Here, edge 3-4 is taken out and edge 1-4 is added in.\nFigure 4.15: Finding the Second Best Spanning Tree from the MST\n12A chord edge is de\ufb01ned as an edge in graph G that is not selected in the MST of G.\n220\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nA solution for this variant is a modi\ufb01ed Kruskal\u2019s: sort the edges in O(E log E) = O(E log V ),\nthen \ufb01nd the MST using Kruskal\u2019s in O(E). Next, for each edge in the MST (there are at\nmost V -1 edges in the MST), temporarily \ufb02ag it so that it cannot be chosen, then try to\n\ufb01nd the MST again in O(E) but now excluding that \ufb02agged edge. Note that we do not\nhave to re-sort the edges at this point. The best spanning tree found after this process is\nthe second best ST. Figure 4.15 shows this algorithm on the given graph. In overall, this\nalgorithm runs in O(sort the edges once + \ufb01nd the original MST + \ufb01nd the second best\nST) = O(E log V + E + V E) = O(V E).\nExercise 4.3.4.1*: There are better solutions for the Second Best ST problem shown above.\nSolve this problem with a solution that is better than O(V E). Hints: You can use either\nLowest Common Ancestor (LCA) or Union-Find Disjoint-Sets.\nExercise 4.3.4.2*: Can we solve the Second Best ST problem using Prim\u2019s algorithm?\nWhat is the best time complexity of this approach? (compare with Exercise 4.3.4.1*).\nExercise 4.3.4.3*: Can you solve the MST problem faster than O(E log V ) if the input\ngraph is guaranteed to have edge weights that lie between a small integer range of [0..100]?\nIs the potential speed-up signi\ufb01cant?\nExercise 4.3.4.4*: Prove the correctness of both Kruskal\u2019s and Prim\u2019s algorithm!\n4.3.5\nMST in Programming Contests\nTo solve many MST problems in today\u2019s programming contests, we can rely on either\nKruskal\u2019s or Prim\u2019s algorithm. There are a few other MST algorithms but we reckon that\nthey are not needed for Competitive Programming. Kruskal\u2019s algorithm is the author\u2019s pref-\nerence as it is easy to understand and links well with the Union-Find Disjoint Sets data\nstructure (see Section 2.4.2) that is used to check for cycles. But Prim\u2019s algorithm is also\nsimple and only needs built-in data structures (a Priority Queue and a Boolean array).\nThe default (and the most common) usage of Kruskal\u2019s/Prim\u2019s algorithm is to solve the\nMinimum ST problem, but the easy variant of Maximum ST is also possible (UVa 01234,\n10842). Note that most MST problems in programming contests only ask for the unique\nMST cost and not the actual MST itself although it is easy to modify Kruskal\u2019s/Prim\u2019s\nalgorithm to do this. This is because there can be di\u21b5erent MSTs with the same minimum\ncost\u2014usually it is too troublesome to write a special checker program to judge that.\nThe other MST variants discussed in this book like the \u2018Minimum\u2019 Spanning Subgraph\n(UVa 10147, 10397), Minimum \u2018Spanning Forest\u2019 (UVa 01216, Kattis - arcticnetwork), Sec-\nond best ST (UVa 10462, 10600), MiniMax/MaxiMin (UVa 00534, 00544, 10048, 10099,\nKattis - millionairemadness, muddyhike) are actually rare.\nNowadays, the more general trend for MST problems is for the problem authors to write\nthe MST problem in such a way that it is not clear that the problem is actually an MST\nproblem (e.g., UVa 01013, 01216, 01234, 01235, 01265, 10457, Kattis - lostmap).", "mimetype": "text/plain", "start_char_idx": 649109, "end_char_idx": 652599, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d85f620b-8926-462e-a0e0-d08bcd62afbe": {"__data__": {"id_": "d85f620b-8926-462e-a0e0-d08bcd62afbe", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "62c72ac7-89c5-44a0-885c-844999408084", "node_type": "1", "metadata": {}, "hash": "b94ac20cf28e9274fa1c0bb5eafb3cb2921255fc03680e38a8f458084542102f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "12c30ae7-9b7b-4425-8027-dd3868a8d8e1", "node_type": "1", "metadata": {}, "hash": "812637385b74cdeff0ac2913188e59bbb9ae5d5ed8b6bd57373ca7bd0a4712f6", "class_name": "RelatedNodeInfo"}}, "text": "The other MST variants discussed in this book like the \u2018Minimum\u2019 Spanning Subgraph\n(UVa 10147, 10397), Minimum \u2018Spanning Forest\u2019 (UVa 01216, Kattis - arcticnetwork), Sec-\nond best ST (UVa 10462, 10600), MiniMax/MaxiMin (UVa 00534, 00544, 10048, 10099,\nKattis - millionairemadness, muddyhike) are actually rare.\nNowadays, the more general trend for MST problems is for the problem authors to write\nthe MST problem in such a way that it is not clear that the problem is actually an MST\nproblem (e.g., UVa 01013, 01216, 01234, 01235, 01265, 10457, Kattis - lostmap). Therefore,\nthe ability to model the given problem as a graph (here, as an MST) problem, i.e., the graph\nmodeling technique, is very important. However, once the contestants spot the underlying\ngraph and/or the greedy selection of edges, the problem may become \u2018easy\u2019.\nNote that there are harder MST problem variants that may require more sophisticated\nalgorithm to solve, e.g., Steiner tree (see Book 2), Arborescence problem, degree constrained\nMST, k-MST, etc.\n221\n\n4.3.\nMINIMUM SPANNING TREE (MST)\nc\u20ddSteven, Felix, Suhendry\nProgramming Exercises related to Minimum Spanning Tree:\na. Standard\n1. Entry Level: Kattis - islandhopping * (MST on small complete graph)\n2. UVa 11228 - Transportation ... * (split output for short vs long edges)\n3. UVa 11631 - Dark Roads * (weight of (all graph edges - all MST edges))\n4. UVa 11747 - Heavy Cycle Edges * (sum the edge weights of the chords)\n5. Kattis - cats * (standard MST)\n6. Kattis - lostmap * (actually just a standard MST problem)\n7. Kattis - minspantree * (standard MST problem; check if a spanning tree is\nformed; also output the edges in any spanning tree in lexicographic order)\nExtra UVa: 00908, 01174, 01208, 01235, 11710, 11733.\nExtra Kattis: communicationssatellite, drivingrange, freckles, jurrasicjigsaw,\nsvemir.\nOthers: IOI 2003 - Trail Maintenance (use e\ufb03cient incremental MST).\nb. Variants\n1. Entry Level: UVa 10048 - Audiophobia * (classic MiniMax path problem)\n2. UVa 01013 - Island Hopping * (LA 2478 - WorldFinals Honolulu02; very\ninteresting MST variant)\n3. UVa 01265 - Tour Belt * (LA 4848 - Daejeon10; very interesting non-\nstandard variant of \u2018maximum\u2019 spanning tree)\n4. UVa 10457 - Magic Car * (interesting MST modeling)\n5. Kattis - millionairemadness * (MiniMax path problem)\n6. Kattis - muddyhike * (MiniMax path problem)\n7. Kattis - naturereserve * (Prim\u2019s algorithm from multiple sources)\nExtra UVa: 00534, 00544, 01160, 01216, 01234, 10099, 10147, 10397, 10462,\n10600, 10842.\nExtra Kattis: arcticnetwork, \ufb01retrucksarered, inventing, landline, redbluetree,\nspider, treehouses.\nPro\ufb01le of Algorithm Inventors\nJoseph Bernard Kruskal, Jr. (1928-2010) was an American computer scientist. His best\nknown work related to competitive programming is the Kruskal\u2019s algorithm for computing\nthe Minimum Spanning Tree (MST) of a weighted graph. MST have interesting applications\nin construction and pricing of communication networks.\nRobert Clay Prim (born 1921) is an American mathematician and computer scientist.\nIn 1957, at Bell Laboratories, he developed Prim\u2019s algorithm for solving the MST problem.\nPrim knows Kruskal as they worked together in Bell Laboratories. Prim\u2019s algorithm, was\noriginally discovered earlier in 1930 by Vojt\u02c6ech Jarn\u00b4\u0131k and rediscovered independently by\nPrim. Thus Prim\u2019s algorithm sometimes also known as Jarn\u00b4\u0131k-Prim algorithm.\nVojt\u02c6ech Jarn\u00b4\u0131k (1897-1970) was a Czech mathematician.", "mimetype": "text/plain", "start_char_idx": 652036, "end_char_idx": 655480, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "12c30ae7-9b7b-4425-8027-dd3868a8d8e1": {"__data__": {"id_": "12c30ae7-9b7b-4425-8027-dd3868a8d8e1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d85f620b-8926-462e-a0e0-d08bcd62afbe", "node_type": "1", "metadata": {}, "hash": "820209d6aa42aaeced9d99b2ddff4eea7a048ea841445431d565f754dbd0a09e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "47ec6063-7b80-4c92-b55f-7d81a1f08061", "node_type": "1", "metadata": {}, "hash": "6fbdf2321609a0546460edd2f7de2841750b3e9e198c7a6c38c38a12af46ad69", "class_name": "RelatedNodeInfo"}}, "text": "(1928-2010) was an American computer scientist. His best\nknown work related to competitive programming is the Kruskal\u2019s algorithm for computing\nthe Minimum Spanning Tree (MST) of a weighted graph. MST have interesting applications\nin construction and pricing of communication networks.\nRobert Clay Prim (born 1921) is an American mathematician and computer scientist.\nIn 1957, at Bell Laboratories, he developed Prim\u2019s algorithm for solving the MST problem.\nPrim knows Kruskal as they worked together in Bell Laboratories. Prim\u2019s algorithm, was\noriginally discovered earlier in 1930 by Vojt\u02c6ech Jarn\u00b4\u0131k and rediscovered independently by\nPrim. Thus Prim\u2019s algorithm sometimes also known as Jarn\u00b4\u0131k-Prim algorithm.\nVojt\u02c6ech Jarn\u00b4\u0131k (1897-1970) was a Czech mathematician. He developed the graph algorithm\nnow known as Prim\u2019s algorithm. In the era of fast and widespread publication of scienti\ufb01c\nresults nowadays, Prim\u2019s algorithm would have been credited to Jarn\u00b4\u0131k instead of Prim.\n222\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.4\nSingle-Source Shortest Paths (SSSP)\n4.4.1\nOverview and Motivation\nProblem: Given a weighted graph G and a source vertex s, what are the shortest paths from\ns to all other vertices of G?\nThis problem is called the Single-Source Shortest Paths (SSSP) problem on a weighted\ngraph. It is a classical problem in graph theory and has many practical real life applications.\nFor example, we can model the city that we live in as a graph. The vertices are the road\njunctions. The edges are the roads. The time taken to traverse a road is the weight of the\nedge. You are currently in one road junction. What is the shortest possible time to reach\nanother certain road junction?\nThere are e\ufb03cient algorithms to solve the SSSP problem. If the graph is unweighted,\nwe can use the e\ufb03cient O(V + E) BFS algorithm shown earlier in Section 4.2.3. For a\ngeneral weighted graph, BFS does not work correctly and we should use algorithms like\nthe O((V + E) log V ) Dijkstra\u2019s algorithm or the O(V E) Bellman-Ford algorithm. These\nalgorithms and their variations are discussed below.\nExercise 4.4.1.1*: Prove that the shortest path between two vertices u and v in a graph G\nthat has no negative and no zero-weight weight cycle must be a simple path (acyclic)! What\nis the corollary of this proof?\nExercise 4.4.1.2*: Prove: Subpaths of shortest paths from u to v are shortest paths!\nExercise 4.4.1.3*: Prove or disprove: If there is only one possible path from vertex u to\nvertex v in a general weighted graph and u is reachable from the source vertex s, then the\nshortest path from s to v must be s ! . . . ! u ! . . . ! v!\n4.4.2\nOn Unweighted Graph: BFS\nLet\u2019s revisit Section 4.2.3. The fact that BFS visits vertices of a graph layer by layer from a\nsource vertex (see Figure 4.2) makes BFS a natural choice for solving the SSSP problems on\nunweighted graphs (or when all edges have constant weight13 C). In an unweighted graph,\nthe distance between two neighboring vertices connected with an edge is simply one unit.\nTherefore, the layer count of a vertex u is precisely the shortest path value from the source\nvertex s to that u. The shortest path from source vertex 5 to vertex 7 in Figure 4.2 is 4 as\n7 is in the fourth layer in BFS sequence of visitation.\nSSSP on unweighted graph is one of the most popular SSSP problems in programming\ncontests. It comes with many \ufb02avors, as we shall see below. Master them, as many of these\nvariations will reappear later in SSSP on weighted graph too.\nSingle-Source Single-Destination Shortest Paths (SSSDSP)\nSome Shortest Paths problems specify both source vertex s and destination/target/sink ver-\ntex t, i.e., we may not need to compute the shortest paths from s to all other vertices but\nwe can possibly terminate early.\nOn unweighted graph, a simple improvement for BFS if we also given the destination\nvertex t is to do extra check at the start of the BFS while loop.", "mimetype": "text/plain", "start_char_idx": 654712, "end_char_idx": 658638, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "47ec6063-7b80-4c92-b55f-7d81a1f08061": {"__data__": {"id_": "47ec6063-7b80-4c92-b55f-7d81a1f08061", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "12c30ae7-9b7b-4425-8027-dd3868a8d8e1", "node_type": "1", "metadata": {}, "hash": "812637385b74cdeff0ac2913188e59bbb9ae5d5ed8b6bd57373ca7bd0a4712f6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a0d2e95c-d2c5-4cb7-9ae3-1a01263383d0", "node_type": "1", "metadata": {}, "hash": "f6998a4ca4a4b20ccee8e335e17a2241657fea3ecd25b26aa00eaaeeae946970", "class_name": "RelatedNodeInfo"}}, "text": "SSSP on unweighted graph is one of the most popular SSSP problems in programming\ncontests. It comes with many \ufb02avors, as we shall see below. Master them, as many of these\nvariations will reappear later in SSSP on weighted graph too.\nSingle-Source Single-Destination Shortest Paths (SSSDSP)\nSome Shortest Paths problems specify both source vertex s and destination/target/sink ver-\ntex t, i.e., we may not need to compute the shortest paths from s to all other vertices but\nwe can possibly terminate early.\nOn unweighted graph, a simple improvement for BFS if we also given the destination\nvertex t is to do extra check at the start of the BFS while loop. When we pop up the front\n13We can replace all edge weights with ones. The SSSP answers obtained after running an SSSP algorithm\nfor unweighted graph (BFS) is then multiplied back with that constant C to get the actual answers.\n223\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nmost vertex u from the queue, we check if that vertex u is the destination vertex t. If it is, we\nbreak the loop there. The worst time complexity is still O(V + E) if the destination vertex\nt is at the max layer V -1, but BFS will generally stop sooner if the destination vertex is\nsomewhat closer to the source vertex s. This improvement strategy of immediately stopping\nupon encountering t is correct, as BFS explores vertices of the unweighted graph layer by\nlayer. This technique also works on non-negative weighted graphs.\nSingle-Destination Shortest Paths (SDSP)\nSome other Shortest Paths problems are as follows: instead of a single-source s, a single-\ndestination vertex t is given and we are asked what are the shortest paths from > 1 source\nvertices to t. It is better to think backwards (recall one of the tips at Section 3.2.3). Instead\nof running an SSSP algorithm multiple times frontally, we can transpose the graph (reverse\nthe direction of all its edges) and run the SSSP algorithm just once with the destination\nvertex t as the source vertex. This technique works on weighted graphs too.\nMulti-Sources Shortest Paths (MSSP)\nSome (seemingly harder) Shortest Paths problems may involve more than a single source. We\ncall this variant the Multi-Sources Shortest Paths (MSSP) and can be on either unweighted\nor weighted graph. This time, transposing the graph does not make any sense. A na\u00a8\u0131ve\nsolution for MSSP on unweighted graph is to call BFS, the solution for SSSP on unweighted\ngraph, multiple times. If there are K possible sources, such a solution will run in a rather\nslow O(K \u21e5(V + E))\u2014Remember that K = O(V ).\nFortunately, this variant is actually not harder than the SSSP version. We can simply\nenqueue all the sources and set dist[s] = 0 for each source s upfront during the initial-\nization step before running the BFS loop as per normal. As this is just one BFS call, its\nruntime remains O(V + E). Another way of looking at this technique is to imagine that\nthere exists a (virtual) super source vertex that is (virtually) connected to all those source\nvertices with (virtual) cost 0 (so these additional 0-weighted edges do not actually contribute\nto the actual shortest paths). This technique works on weighted graphs too.\nShortest Path Reconstruction\nA few Shortest Paths problems require us to actually reconstruct the actual shortest path\nfrom the source vertex s to some other vertices, not just to \ufb01nd the shortest path values\nfrom source vertex s. For example, in Figure 4.2, the shortest path from 5 to 7 is 5 ! 1 !\n2 ! 3 ! 7. Such reconstruction is easy if we store the tree edges along the shortest path\nspanning tree. This can be easily done using vector of integers vi p (see Section 2.4.1).\nEach vertex v remembers its parent u (p[v] = u) in the shortest path spanning tree. For\nthis example, vertex 7/3/2/1 remembers 3/2/1/5 as its parent, respectively. To reconstruct\nthe actual shortest path, we can do a simple recursion from the last vertex 7 until we hit\nthe source vertex 5. This technique works on weighted graphs too.\nOn 0/1-Weighted Graph: BFS+Deque\nAnother rare variation of SSSP on \u2018unweighted\u2019 graph is given below.", "mimetype": "text/plain", "start_char_idx": 657984, "end_char_idx": 662109, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a0d2e95c-d2c5-4cb7-9ae3-1a01263383d0": {"__data__": {"id_": "a0d2e95c-d2c5-4cb7-9ae3-1a01263383d0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "47ec6063-7b80-4c92-b55f-7d81a1f08061", "node_type": "1", "metadata": {}, "hash": "6fbdf2321609a0546460edd2f7de2841750b3e9e198c7a6c38c38a12af46ad69", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7ef2cdd7-418f-4923-ab27-8f78e129dbaa", "node_type": "1", "metadata": {}, "hash": "c3372300df4f5be5518459d2e147308090cd427c115d18a7ff293ba7c421a791", "class_name": "RelatedNodeInfo"}}, "text": "1 !\n2 ! 3 ! 7. Such reconstruction is easy if we store the tree edges along the shortest path\nspanning tree. This can be easily done using vector of integers vi p (see Section 2.4.1).\nEach vertex v remembers its parent u (p[v] = u) in the shortest path spanning tree. For\nthis example, vertex 7/3/2/1 remembers 3/2/1/5 as its parent, respectively. To reconstruct\nthe actual shortest path, we can do a simple recursion from the last vertex 7 until we hit\nthe source vertex 5. This technique works on weighted graphs too.\nOn 0/1-Weighted Graph: BFS+Deque\nAnother rare variation of SSSP on \u2018unweighted\u2019 graph is given below. We call it the SSSP\non 0/1-weighted graph.\nGiven an R \u21e5C grid map like the one shown below, determine the shortest path from\nany cell labeled as \u2018A\u2019 to any cell labeled as \u2018B\u2019. You can only walk through cells labeled\n224\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nwith \u2018.\u2019 in N/E/S/W direction (counted as one unit) and cells labeled with alphabet \u2018A\u2019-\u2018Z\u2019\n(counted as zero unit)! Can you solve this in O(R \u21e5C)?\n....................CCCC.\n// The answer for this test case is 13 units\nAAAAA...............CCCC.\n// Solution: Walk 11 steps east from\nAAAAA.AAA...........CCCC.\n// the rightmost A to leftmost C in this row\nAAAAAAAAA....###....CCCC.\n// Then, from the rightmost C in this row,\nAAAAAAAAA................\n// walk 2 steps south\nAAAAAAAAA................\n// to\n.......DD..............BB\n// the leftmost B in this row\nNotice that this problem requires the Multi-Sources technique discussed earlier (all the \u2018A\u2019\ncells are the source vertices) and it also has di\u21b5erent\u2013but only two\u2013weights: 0 (for walking\nthrough alphabet cells) or 1 (for walking through \u2018.\u2019\ncells).\nObviously we will want to\nprioritize walking through alphabet cells, as each such movement is \u2018free\u2019. Should we use\nthe general solution for SSSP on weighted graphs discussed in Section 4.4.3?\nIt turns out that we can just use deque (see Section 2.2.5) instead of queue for this. We\npush to the front/back of deque if the edge weight is 0/1, respectively. This way, we keep\nprioritizing the weight 0 edges \ufb01rst before considering the weight 1 edges.\nAs the destination vertices are also given (all the \u2018B\u2019 cells are the destination vertices),\nwe can also stop the BFS early upon encountering the \ufb01rst \u2018B\u2019 cell.\nAs we only replace queue with deque inside the BFS code and both deque push front\n(not available in queue) and push back operations are O(1), the time complexity of this\nsolution remains O(V + E), or O(R \u21e5C) in this case.\nC++ code below shows BFS for Unweighted SSSDSP with shortest path reconstruction.\nvoid printPath(int u) {\n// extract info from vi p\nif (u == s) { printf(\"%d\", s); return; }\n// base case, at source s\nprintPath(p[u]);\n// recursive\nprintf(\" %d\", u);\n// output: s -> ... -> t\n}\n// inside int main(), suppose s and t have been defined\nvi dist(V, INF); dist[s] = 0;\n// INF = 1e9 here\nqueue<int> q; q.push(s);\np.assign(V, -1);\n// p is global\nwhile (!q.empty()) {\nint u = q.front(); q.pop();\nif (u == t) break;\n// addition: destination t\nfor (auto &[v, w] : AL[u]) {\n// C++17 style, w ignored\nif (dist[v] != INF) continue;\n// already visited, skip\ndist[v] = dist[u]+1;\np[v] = u;\n// addition\nq.push(v);\n}\n}\nprintPath(t), printf(\"\\n\");\n// addition\nSource code: ch4/sssp/bfs.cpp|java|py|ml\n225\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nKnight Moves\nIn chess, a knight can move in an interesting \u2018L-shaped\u2019 way.", "mimetype": "text/plain", "start_char_idx": 661488, "end_char_idx": 664938, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7ef2cdd7-418f-4923-ab27-8f78e129dbaa": {"__data__": {"id_": "7ef2cdd7-418f-4923-ab27-8f78e129dbaa", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a0d2e95c-d2c5-4cb7-9ae3-1a01263383d0", "node_type": "1", "metadata": {}, "hash": "f6998a4ca4a4b20ccee8e335e17a2241657fea3ecd25b26aa00eaaeeae946970", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "966e6019-4b2c-459a-9336-3878b710fd9b", "node_type": "1", "metadata": {}, "hash": "1cae01185efcf1ce905813a62a531efca64c81fd0159c70aab53275fc9bb3a98", "class_name": "RelatedNodeInfo"}}, "text": "SINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nKnight Moves\nIn chess, a knight can move in an interesting \u2018L-shaped\u2019 way. Formally, a knight can move\nfrom a cell (r1, c1) to another cell (r2, c2) in an n \u21e5n chessboard if and only if (r1 \u2212r2)2 +\n(c1 \u2212c2)2 = 5. A common query14 is the length of shortest moves to move a knight from a\nstarting cell to another target cell. There can be many queries on the same chessboard.\nIf the chessboard size is small, we can a\u21b5ord to run one BFS per query from the given\nstarting cell. Each cell has at most 8 edges connected to another cells (some cells around\nthe border of the chessboard have less edges). We stop BFS as soon as we reach the target\ncell. We can use BFS on this shortest path problem as the graph is unweighted. As there\nare up to O(n2) cells in the chessboard, the overall time complexity is O(n2 + 8n2) = O(n2)\nper query or O(Qn2) if there are Q queries.\nHowever, the solution above is not the most e\ufb03cient way to solve this problem. If the\ngiven chessboard is large and there are several queries, e.g., n = 1000 and Q = 16 in UVa\n11643 - Knight Tour, the approach above will get TLE.\nA better solution is to realize that if the chessboard is large enough and we pick two\nrandom cells (ra, ca) and (rb, cb) in the middle of the chessboard with shortest knight moves\nof d steps between them, shifting the cell positions by a constant factor does not change the\nanswer, i.e. the shortest knight moves from (ra +k, ca +k) and (rb +k, cb +k) is also d steps,\nfor a constant factor k.\nTherefore, we can just run one BFS from an arbitrary source cell and do some adjustments\nto the answer. However, there are a few special (literally) corner cases to be handled. Finding\nthese special cases can be a headache and many Wrong Answers are expected if one does\nnot know them yet. To make this section interesting, we purposely leave this crucial last\nstep as a starred exercise. Try solving UVa 11643 after you get these answers.\nExercise 4.4.2.1*: Find those special cases of UVa 11643 and address them. Hints:\n1. Separate cases when 3 \uf8ffn \uf8ff4 and n \u22655.\n2. Literally concentrate on corner cells and side cells.\n3. What happen if the starting cell and the target cell are too close?\n14Another variant is Knight\u2019s tour: a sequence of knight moves on an n\u21e5n (as well as irregular) chessboard\nsuch that the knight visits every square exactly once. This variant is a special case of an NP-hard problem\nHamiltonian-Tour that has a linear solution.\n226\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.4.3\nOn Weighted Graph: Dijkstra\u2019s\nIf the given graph has edges with di\u21b5erent15 weights, the fast O(V + E) and simple BFS\ndoes not work. This is because there can be a \u2018longer\u2019 path (in terms of number of vertices\nand edges involved in the path) that has smaller total weight than the \u2018shorter\u2019 path found\nby BFS. For example, in Figure 4.16\u2014left, the shortest path from source vertex 0 to vertex\n3 is not via direct edge 0 ! 3 with weight 7 that is normally found by BFS, but a \u2018detour\u2019\npath: 0 ! 1 ! 3 with smaller total weight 2 + 3 = 5 (see Figure 4.18\u2014right).\nTo solve the SSSP problem on weighted graph, we use a greedy Edsger Wybe Dijkstra\u2019s\nalgorithm. There are several ways to implement this classic algorithm mentioned in various\ntextbooks, e.g., [5, 35, 6]. In fact, Dijkstra\u2019s original paper that describes this algorithm [8]\ndid not describe a speci\ufb01c implementation. We present two versions below.\nOn Non-Negative Weighted Graph: Original Dijkstra\u2019s\nDijkstra\u2019s algorithm starts with the standard initial condition for all SSSP algorithm.", "mimetype": "text/plain", "start_char_idx": 664802, "end_char_idx": 668405, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "966e6019-4b2c-459a-9336-3878b710fd9b": {"__data__": {"id_": "966e6019-4b2c-459a-9336-3878b710fd9b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7ef2cdd7-418f-4923-ab27-8f78e129dbaa", "node_type": "1", "metadata": {}, "hash": "c3372300df4f5be5518459d2e147308090cd427c115d18a7ff293ba7c421a791", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ca96cf2f-ec15-48c9-868b-e75d14d47fd3", "node_type": "1", "metadata": {}, "hash": "365d1dc4be7cff4b008ab739d7d9f138532c129ebbd07210fcfc847952c0d9c2", "class_name": "RelatedNodeInfo"}}, "text": "3 with weight 7 that is normally found by BFS, but a \u2018detour\u2019\npath: 0 ! 1 ! 3 with smaller total weight 2 + 3 = 5 (see Figure 4.18\u2014right).\nTo solve the SSSP problem on weighted graph, we use a greedy Edsger Wybe Dijkstra\u2019s\nalgorithm. There are several ways to implement this classic algorithm mentioned in various\ntextbooks, e.g., [5, 35, 6]. In fact, Dijkstra\u2019s original paper that describes this algorithm [8]\ndid not describe a speci\ufb01c implementation. We present two versions below.\nOn Non-Negative Weighted Graph: Original Dijkstra\u2019s\nDijkstra\u2019s algorithm starts with the standard initial condition for all SSSP algorithm. At\nthe beginning, we only know dist[s] = 0 (the shortest path from s to s itself is clearly 0)\nwhile dist[u] = 1 for all other V -1 vertices that are not s. Dijkstra\u2019s algorithm uses a\nPriority Queue (pq) data structure of vertex information pair (dist[u], u) to dynamically\norder (sort) the pairs by non-decreasing dist[u] values (vertex number u is unique). We\ninsert V vertex information pairs of all V vertices into pq upfront and this already takes\nO(V log V ) so far.\nDijkstra\u2019s algorithm will then process these vertices greedily: the vertex with the shortest\ndist[u] \ufb01rst (also see Section 3.4.1 about greedy algorithm with pq and Exercise 4.4.3.4*\nfor a proof of correctness of this greedy strategy). Obviously at the start, the source vertex s\n(with the smallest possible dist[s] = 0) will be processed \ufb01rst while the rest (currently with\nunknown/in\ufb01nitely large shortest path distance values) will be behind in pq. Then, Dijkstra\u2019s\nalgorithm tries to relax each neighbor v of u = s. The relax(u, v, w u v) operation sets\ndist[v] = min(dist[v], dist[u]+w u v). This opens up the possibilities of other shorter\npaths from vertex v to some other vertices as the shortest path distance values from source\nvertex s to v, i.e., dist[v], will be lowered from initially 1 into a (much) lower number.\nWe also update (lower) that information in pq and let pq dynamically (re-)order the vertices\nbased on non-decreasing dist[u] values.\nUnfortunately, C++ STL priority queue/Java PriorityQueue/Python heapQ\u2014that\nhas a Binary Heap data structure internally\u2014does not have built-in capabilities (yet) to alter\nthe key values after they are inserted into pq. Fortunately, we can get around this issue by\nusing C++ STL set/Java TreeSet/OCaml Set\u2014internally a balanced Binary Search Tree\ndata structure\u2014instead. With16 C++ STL set/Java TreeSet/OCaml Set, we can update\n(lower) old (higher dist[u], u) into new (lower dist[u], u) by \ufb01rst deleting old (higher\ndist[u], u) in O(log V ) time and re-inserting new (lower dist[u], u) also in O(log V ) time.\nDijkstra\u2019s algorithm then repeats the same process until pq is empty: it greedily takes\nout vertex information pair (dist[u], u) from the front of pq and relax each outgoing edge\nu ! v of u, updating (lowering) dist[v] and the associated pair in pq if the edge relaxation\nis successful.\nAs each of the V vertices and each of the E edges are processed just once, the time com-\nplexity of Dijkstra\u2019s algorithm is O((V + E) log V ). The extra O(log V ) is for pq operations\n15We have shown in Section 4.4.2 that the SSSP problem on weighted graph with constant weight C on\nall edges or weighted graph with only 0/1-weighted edges are still solvable with BFS.\n16As of year 2020, Python standard library does not have built-in balanced BST equivalent yet. Hence, if\nyou are a Python user, please use the Modi\ufb01ed Dijkstra\u2019s version instead.\n227\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\n(we enqueue/dequeue V vertices into/from pq, respectively and we update (lower) shortest\npath values at most E times. Note: O(log E) = O(log V 2) = O(2 \u21e5log V ) = O(log V )).", "mimetype": "text/plain", "start_char_idx": 667780, "end_char_idx": 671532, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ca96cf2f-ec15-48c9-868b-e75d14d47fd3": {"__data__": {"id_": "ca96cf2f-ec15-48c9-868b-e75d14d47fd3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "966e6019-4b2c-459a-9336-3878b710fd9b", "node_type": "1", "metadata": {}, "hash": "1cae01185efcf1ce905813a62a531efca64c81fd0159c70aab53275fc9bb3a98", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a4046b38-68a8-4f7d-97be-10949973f986", "node_type": "1", "metadata": {}, "hash": "0a0f4aaa67a064dda7421de7c31a2a11597ac3edf8c8400c78ef91a52b3ac2f9", "class_name": "RelatedNodeInfo"}}, "text": "The extra O(log V ) is for pq operations\n15We have shown in Section 4.4.2 that the SSSP problem on weighted graph with constant weight C on\nall edges or weighted graph with only 0/1-weighted edges are still solvable with BFS.\n16As of year 2020, Python standard library does not have built-in balanced BST equivalent yet. Hence, if\nyou are a Python user, please use the Modi\ufb01ed Dijkstra\u2019s version instead.\n227\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\n(we enqueue/dequeue V vertices into/from pq, respectively and we update (lower) shortest\npath values at most E times. Note: O(log E) = O(log V 2) = O(2 \u21e5log V ) = O(log V )).\nTo strengthen your understanding about this Dijkstra\u2019s algorithm, we show a step by\nstep example of running this Dijkstra\u2019s algorithm on a small weighted graph and source\nvertex s = 0. Take a careful look at the content of set<ii> pq at each step.\n1. Figure 4.16\u2014left: At the beginning, only dist[s] = dist[0] = 0,\nset<ii> pq initially contains {(0, 0), (1, 1), (1, 2), (1, 3), (1, 4)}.\nFigure 4.16: Dijkstra\u2019s Animation on a Weighted Graph (from UVa 00341 [44]), Steps 1+2\n2. Figure 4.16\u2014right: Dequeue the vertex information pair at the front of pq: (0, 0).\nRelax edges incident to vertex 0 to get dist[1] = 2, dist[2] = 6, and dist[3] = 7.\nWhile doing this, we simultaneously update (lower) the keys in set<ii> pq.\nset<ii> pq now contains {(2, 1), (6, 2), (7, 3), (1, 4)}.\n3. Figure 4.17\u2014left: Dequeue the vertex information pair at the front of pq: (2, 1).\nRelax edges incident to vertex 1 to get dist[3] = min(dist[3], dist[1]+w(1,3))\n= min(7, 2+3) = 5 and dist[4] = 8 and update the keys in pq.\nset<ii> pq now contains {(5, 3), (6, 2), (8, 4)}.\nBy now, edge 0 ! 3 is not going to be part of the SSSP spanning tree from s = 0.\nFigure 4.17: Dijkstra\u2019s Animation, Steps 3+4\n4. Figure 4.17\u2014right: We dequeue (5, 3) and try to do relax(3, 4, 5), i.e., 5+5 = 10.\nBut dist[4] = 8 (from path 0 ! 1 ! 4), so dist[4] is unchanged.\nset<ii> pq now contains {(6, 2), (8, 4)}.\nBy now, edge 3 ! 4 is also not going to be part of the SSSP spanning tree from s = 0.\n5. Figure 4.18\u2014left: We dequeue (6, 2) and do relax(2, 4, 1), making dist[4] = 7.\nThe shorter path from 0 to 4 is now 0 ! 2 ! 4 instead of 0 ! 1 ! 4.\nset<ii> pq now contains {(7, 4)}.\nBy now, edge 1 ! 4 is also not going to be part of the SSSP spanning tree from s = 0.\n228\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nFigure 4.18: Dijkstra\u2019s Animation, Steps 5+6\n6. Figure 4.18\u2014right: Finally, (7, 4) is processed but nothing changes.\nset<ii> pq is now empty and Dijkstra\u2019s algorithm stops here.\nThe \ufb01nal SSSP spanning tree describes the shortest paths from s to other vertices.\nOur short C++ code is shown below and it looks very similar to Prim\u2019s algorithm and BFS\ncode shown in Section 4.3.3 and 4.4.2, respectively. We call this implementation the Original\nDijkstra\u2019s algorithm as we will modify them in the next subsection.", "mimetype": "text/plain", "start_char_idx": 670881, "end_char_idx": 673816, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a4046b38-68a8-4f7d-97be-10949973f986": {"__data__": {"id_": "a4046b38-68a8-4f7d-97be-10949973f986", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ca96cf2f-ec15-48c9-868b-e75d14d47fd3", "node_type": "1", "metadata": {}, "hash": "365d1dc4be7cff4b008ab739d7d9f138532c129ebbd07210fcfc847952c0d9c2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a1d0c310-32d6-4c3c-aaab-0cf3066e1f25", "node_type": "1", "metadata": {}, "hash": "9d3889b1330e07fc752ae5d7bd765baa7e41ac45c4dace0a8e2f2c9412a7dd55", "class_name": "RelatedNodeInfo"}}, "text": "By now, edge 1 ! 4 is also not going to be part of the SSSP spanning tree from s = 0.\n228\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nFigure 4.18: Dijkstra\u2019s Animation, Steps 5+6\n6. Figure 4.18\u2014right: Finally, (7, 4) is processed but nothing changes.\nset<ii> pq is now empty and Dijkstra\u2019s algorithm stops here.\nThe \ufb01nal SSSP spanning tree describes the shortest paths from s to other vertices.\nOur short C++ code is shown below and it looks very similar to Prim\u2019s algorithm and BFS\ncode shown in Section 4.3.3 and 4.4.2, respectively. We call this implementation the Original\nDijkstra\u2019s algorithm as we will modify them in the next subsection.\n// inside int main()\nvi dist(V, INF); dist[s] = 0;\n// INF = 1e9 here\nset<ii> pq;\n// balanced BST version\nfor (int u = 0; u < V; ++u)\n// dist[u] = INF\npq.emplace(dist[u], u);\n// but dist[s] = 0\n// sort the pairs by non-decreasing distance from s\nwhile (!pq.empty()) {\n// main loop\nauto [d, u] = *pq.begin();\n// shortest unvisited u\npq.erase(pq.begin());\nfor (auto &[v, w] : AL[u]) {\n// all edges from u\nif (dist[u]+w >= dist[v]) continue;\n// not improving, skip\npq.erase(pq.find({dist[v], v}));\n// erase old pair\ndist[v] = dist[u]+w;\n// relax operation\npq.emplace(dist[v], v);\n// enqueue better pair\n}\n}\nfor (int u = 0; u < V; ++u)\nprintf(\"SSSP(%d, %d) = %d\\n\", s, u, dist[u]);\nOn Non-Negative Cycle Graph: Modi\ufb01ed Dijkstra\u2019s\nThere is another way to implement Dijkstra\u2019s algorithm, especially for those who insist to\nuse C++ STL priority queue/Java PriorityQueue/Python heapq even though it does not\nhave built-in capabilities (yet) to alter the key values after they are inserted into Priority\nQueue. Dijkstra\u2019s algorithm will only lower dist[u] values and never increase the values.\nThis one sided update has an alternative Priority Queue solution.\nTo di\u21b5erentiate this Dijkstra\u2019s implementation with the previous one (called the Original\nDijkstra\u2019s algorithm), we call this version as the Modi\ufb01ed Dijkstra\u2019s algorithm.\n229\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nModi\ufb01ed Dijkstra\u2019s algorithm works 99% similar with the Original Dijkstra\u2019s algorithm\nas it also maintains a Priority Queue (pq) that stores the same vertex information pairs. But\nthis time, pq only contains one item initially: the base case (0, s) which is true for the source\nvertex s. Then, Modi\ufb01ed Dijkstra\u2019s implementation repeats the following similar process\nuntil pq is empty: it greedily takes out vertex information pair (d, u) from the front of pq.\nIf the shortest path distance from s to u recorded in d is greater than dist[u], it ignores u;\notherwise, it processes u. The reason for this special check is shown below.\nWhen this algorithm process u, it tries to relax each neighbor v of u. Every time it\nsuccessfully relaxes an edge u ! v, it will always enqueue a pair (newer/shorter distance\nfrom s to v, v) into pq and will always leave the inferior pair (older/longer distance from s\nto v, v) inside pq. This is called as \u2018Lazy Deletion\u2019 and it causes more than one copy of the\nsame vertex in pq with di\u21b5erent distances from the source. That is why we have to process\nonly the \ufb01rst dequeued vertex information pair which has the correct/shortest distance (other\ncopies will have the outdated/longer distance). This Lazy Deletion technique works as the\npq update operations in Modi\ufb01ed Dijkstra\u2019s only lower the dist[u] values.\nOn non-negative weighted graph, the time complexity of this Modi\ufb01ed Dijkstra\u2019s is iden-\ntical with the Original Dijkstra\u2019s. Again, each vertex will only be processed once. Each time\na vertex is processed, we try to relax its neighbors once (total E edges).", "mimetype": "text/plain", "start_char_idx": 673172, "end_char_idx": 676809, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a1d0c310-32d6-4c3c-aaab-0cf3066e1f25": {"__data__": {"id_": "a1d0c310-32d6-4c3c-aaab-0cf3066e1f25", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a4046b38-68a8-4f7d-97be-10949973f986", "node_type": "1", "metadata": {}, "hash": "0a0f4aaa67a064dda7421de7c31a2a11597ac3edf8c8400c78ef91a52b3ac2f9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fc74c24d-2187-40b2-b17e-1fa5dc5e1f70", "node_type": "1", "metadata": {}, "hash": "eb72eedb3b6ce6651a760263604586e28d8b7606692c6a096f67abee65dc322c", "class_name": "RelatedNodeInfo"}}, "text": "This is called as \u2018Lazy Deletion\u2019 and it causes more than one copy of the\nsame vertex in pq with di\u21b5erent distances from the source. That is why we have to process\nonly the \ufb01rst dequeued vertex information pair which has the correct/shortest distance (other\ncopies will have the outdated/longer distance). This Lazy Deletion technique works as the\npq update operations in Modi\ufb01ed Dijkstra\u2019s only lower the dist[u] values.\nOn non-negative weighted graph, the time complexity of this Modi\ufb01ed Dijkstra\u2019s is iden-\ntical with the Original Dijkstra\u2019s. Again, each vertex will only be processed once. Each time\na vertex is processed, we try to relax its neighbors once (total E edges). Because of the\nLazy Deletion technique, we may have up to O(E) items in the pq at the same time, but\nthis is still O(log E) = O(log V ) per each dequeue or enqueue operations. Thus, the time\ncomplexity remains at O((V + E) log V ).\nTo strengthen your understanding about this Modi\ufb01ed Dijkstra\u2019s algorithm, we show\na similar step by step example of running this Modi\ufb01ed Dijkstra\u2019s implementation on\nthe same small weighted graph and s = 0.\nJust take a careful look at the content of\npriority_queue<ii> pq at each step that is di\u21b5erent with the Original Dijkstra\u2019s version.\n1. Figure 4.16\u2014left: At the beginning, only dist[s] = dist[0] = 0,\npriority_queue<ii> pq initially contains {(0, 0)}.\n2. Figure 4.16\u2014right: Dequeue the vertex information pair at the front of pq: (0, 0).\nRelax edges incident to vertex 0 to get dist[1] = 2, dist[2] = 6, and dist[3] = 7.\nWe always enqueue new vertex information pair upon a successful edge relaxation.\npriority_queue<ii> pq now contains {(2, 1), (6, 2), (7, 3)}.\n3. Figure 4.17\u2014left: Dequeue the vertex information pair at the front of pq: (2, 1).\nRelax edges incident to vertex 1 to get dist[3] = min(dist[3], dist[1]+w(1,3))\n= min(7, 2+3) = 5 and dist[4] = 8 and immediately enqueue two more pairs in pq.\npriority_queue<ii> pq now contains {(5, 3), (6, 2), (7, 3), (8, 4)}.\nSee that we have 2 entries of vertex 3 in pq with increasing distance from s. We do not\nimmediately delete the inferior pair (7, 3) from the pq and rely on future iterations of\nour Modi\ufb01ed Dijkstra\u2019s to correctly pick the one with minimal distance later, which is\npair (5, 3). This is called as \u2018lazy deletion\u2019.\nBy now, edge 0 ! 3 is not going to be part of the SSSP spanning tree from s = 0.\n4. Figure 4.17\u2014right: We dequeue (5, 3) and try to do relax(3, 4, 5), i.e., 5+5 = 10.\nBut dist[4] = 8 (from path 0 ! 1 ! 4), so dist[4] is unchanged.\npriority_queue<ii> pq now contains {(6, 2), (7, 3), (8, 4)}.\nBy now, edge 3 ! 4 is also not going to be part of the SSSP spanning tree from s = 0.\n5. Figure 4.18\u2014left: We dequeue (6, 2) and do relax(2, 4, 1), making dist[4] = 7.\nThe shorter path from 0 to 4 is now 0 ! 2 ! 4 instead of 0 ! 1 ! 4.\npriority_queue<ii> pq now contains {(7, 3), (7, 4), (8, 4)} (2 entries of vertex 4).\nBy now, edge 1 ! 4 is also not going to be part of the SSSP spanning tree from s = 0.\n230\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n6. Figure 4.18\u2014right: We do several bookkeeping at this step.", "mimetype": "text/plain", "start_char_idx": 676131, "end_char_idx": 679244, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc74c24d-2187-40b2-b17e-1fa5dc5e1f70": {"__data__": {"id_": "fc74c24d-2187-40b2-b17e-1fa5dc5e1f70", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a1d0c310-32d6-4c3c-aaab-0cf3066e1f25", "node_type": "1", "metadata": {}, "hash": "9d3889b1330e07fc752ae5d7bd765baa7e41ac45c4dace0a8e2f2c9412a7dd55", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "64e41ea4-f089-414e-bd82-d8db9412fbdd", "node_type": "1", "metadata": {}, "hash": "ed9bfd5fa1b949ea6b08a292082e26c43e9f78c9ffdd16b2d9b21d9cdb6a35fa", "class_name": "RelatedNodeInfo"}}, "text": "4 is also not going to be part of the SSSP spanning tree from s = 0.\n5. Figure 4.18\u2014left: We dequeue (6, 2) and do relax(2, 4, 1), making dist[4] = 7.\nThe shorter path from 0 to 4 is now 0 ! 2 ! 4 instead of 0 ! 1 ! 4.\npriority_queue<ii> pq now contains {(7, 3), (7, 4), (8, 4)} (2 entries of vertex 4).\nBy now, edge 1 ! 4 is also not going to be part of the SSSP spanning tree from s = 0.\n230\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n6. Figure 4.18\u2014right: We do several bookkeeping at this step.\nWe dequeue (7, 3) but ignore it as we know that its d > dist[3] (i.e., 7 > 5). This\nis when the actual deletion of the inferior pair (7, 3) is executed rather than at step\n3 previously. By deferring it until now, the inferior pair (7, 3) is now located at the\nfront of pq for the standard O(log V ) deletion of C++ STL priority queue to work.\npriority_queue<ii> pq now contains only {(7, 4), (8, 4)}.\nWe then dequeue (7, 4) and process it, but nothing changes.\npriority_queue<ii> pq now contains only {(8, 4)}.\nFinally, we dequeue (8, 4) but ignore it again as its d > dist[4] (i.e., 8 > 7).\npriority_queue<ii> pq is now empty and the Modi\ufb01ed Dijkstra\u2019s stops here.\nThe \ufb01nal SSSP spanning tree describes the shortest paths from s to other vertices.\nOur short C++ code is shown below and it is very identical with the Original Dijkstra\u2019s\nversion. The main di\u21b5erence is the way both variants use Priority Queue data structures.\n// inside int main()\nvi dist(V, INF); dist[s] = 0;\n// INF = 1e9 here\npriority_queue<ii, vector<ii>, greater<ii>> pq;\npq.emplace(0, s);\n// sort the pairs by non-decreasing distance from s\nwhile (!pq.empty()) {\n// main loop\nauto [d, u] = pq.top(); pq.pop();\n// shortest unvisited u\nif (d > dist[u]) continue;\n// a very important check\nfor (auto &[v, w] : AL[u]) {\n// all edges from u\nif (dist[u]+w >= dist[v]) continue;\n// not improving, skip\ndist[v] = dist[u]+w;\n// relax operation\npq.emplace(dist[v], v);\n// enqueue better pair\n}\n}\nfor (int u = 0; u < V; ++u)\nprintf(\"SSSP(%d, %d) = %d\\n\", s, u, dist[u]);\nSource code: ch4/sssp/dijkstra.cpp|java|py|ml\nSSSP on Weighted Graph Variants\nAll SSSP on unweighted graph variants discussed in Section 4.4.2 are also applicable on\nweighted graph too, i.e., the SSSDSP variant (but only on non-negative weighted graph), the\nSDSP variant, the MSSP variant, Shortest Path Reconstruction, including solving the 0/1-\nweighted graph variant using the (slightly) slower Dijkstra\u2019s algorithm instead of BFS+deque.\nNext, we will discuss one other variant that is speci\ufb01c for weighted graphs.\nSSSP on Non-Negative Cycle Graph\nIf the input graph has at least one (or more) negative edge weight(s), the Original Dijkstra\u2019s\nalgorithm [5, 35, 6] will likely produce wrong answer as such negative edge weights violate\nthe assumption required for the greedy algorithm to work (see Exercise 4.4.3.4*).\nIn\nFigure 4.19\u2014left, we have a graph with one negative edge weight but no negative weight\ncycle\u2014keep an eye on vertex 4 and edge 3 ! 4.\n231\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nFigure 4.19: Original Dijkstra\u2019s Fails on a Negative Weight Graph, s = 0\nIn Figure 4.19\u2014middle, we see that the Original Dijkstra\u2019s wrongly propagates shortest path\ndistance from 0 ! 1 !", "mimetype": "text/plain", "start_char_idx": 678745, "end_char_idx": 681991, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "64e41ea4-f089-414e-bd82-d8db9412fbdd": {"__data__": {"id_": "64e41ea4-f089-414e-bd82-d8db9412fbdd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fc74c24d-2187-40b2-b17e-1fa5dc5e1f70", "node_type": "1", "metadata": {}, "hash": "eb72eedb3b6ce6651a760263604586e28d8b7606692c6a096f67abee65dc322c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3e6e80e9-2e24-4f20-a2ec-10cbfe4c0717", "node_type": "1", "metadata": {}, "hash": "20029c91614d1e7f5b0fc3e0bab01c8e213a0e024332cde22a622cf1608f1cb7", "class_name": "RelatedNodeInfo"}}, "text": "In\nFigure 4.19\u2014left, we have a graph with one negative edge weight but no negative weight\ncycle\u2014keep an eye on vertex 4 and edge 3 ! 4.\n231\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nFigure 4.19: Original Dijkstra\u2019s Fails on a Negative Weight Graph, s = 0\nIn Figure 4.19\u2014middle, we see that the Original Dijkstra\u2019s wrongly propagates shortest path\ndistance from 0 ! 1 ! 3 to vertex 4, causing vertex 4 to believe that the shortest path from\nsource vertex 0 is 0 ! 1 ! 3 ! 4 with value 6. In Figure 4.19\u2014right, we see that the very\nlast relax(2, 3, -10) operation causes the shortest path from source vertex 0 to vertex\n3 to change into 0 ! 2 ! 3 with value 10+(-10) = 0. Vertex 4 has no way to know this\nmistake as the Original Dijkstra\u2019s will stop as soon as the last vertex 2 is processed.\nNote that if you run our current implementation of Original Dijkstra\u2019s on a graph\nlike in Figure 4.19, you will get unde\ufb01ned behavior because C++ STL set encounters\na problem when trying to erase the old vertex information pair. In the example above,\npq.find({dist[3], 3}) or pq.find({10, 3}) will return pq.end() as pair {10, 3} is al-\nready processed and is no longer in the Priority Queue (set). Trying to erase this pair via\nthe chained operation pq.erase(pq.find({dist[3], 3})) causes unde\ufb01ned behavior.\nHowever, the Modi\ufb01ed Dijkstra\u2019s algorithm will work just \ufb01ne, albeit slower. This is\nbecause Modi\ufb01ed Dijkstra\u2019s algorithm will keep inserting new vertex information pair into\npq every time it manages to do a successful relax operation. Figure 4.19\u2014middle and Figure\n4.20\u2014left depicts the same situation after identical initial steps between the Original and\nthe Modi\ufb01ed Dijkstra\u2019s. However, the next few actions of Modi\ufb01ed Dijkstra\u2019s are di\u21b5erent.\nFigure 4.20\u2014middle, we see that vertex 3 is re-enqueued into pq. Figure 4.20\u2014right, we\nsee that vertex 3 now correctly propagates shortest path distance 0 ! 2 ! 3 to vertex 4,\ncausing vertex 4 to now have the correct shortest path of 0 ! 2 ! 3 ! 4 of value 3.\nFigure 4.20: Modi\ufb01ed Dijkstra\u2019s Can Work on a Non-Negative Cycle Graph, s = 0\nIf the weighted graph has no negative (weight) cycle, Modi\ufb01ed Dijkstra\u2019s algorithm will keep\npropagating the shortest path distance information until there is no more possible relaxation\n(which implies that all shortest paths from the source have been found). However, when\ngiven a graph with negative weight cycle, the Modi\ufb01ed Dijkstra\u2019s algorithm will hopelessly\ntrapped in an in\ufb01nite loop. Example: See the graph in Figure 4.22. Cycle 1 ! 2 ! 3 ! 1\nis a negative cycle with weight 15 + 0 + (-42) = -27. Modi\ufb01ed Dijkstra\u2019s will keep looping\nforever as it is always possible to continue relaxing the edges along a negative cycle.\nOn graph with (a few) negative weight edges but no negative cycle, Modi\ufb01ed Dijkstra\u2019s\nruns slower than O((V +E) log V ) due to the need of re-processing already processed vertices\nbut the shortest paths values will eventually be correct, unlike the Original Dijkstra\u2019s that\nstops after at most O((V + E) log V ) operations but gives wrong answer on such a graph.\n232\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nIn either case, the early termination technique when the destination vertex t is also given in\nthe SSSDSP variant will not work on such a graph.\nHowever on an extreme case, we can actually setup a graph that has negative weights\nbut no negative cycle that can signi\ufb01cantly slow down Modi\ufb01ed Dijkstra\u2019s algorithm, see\nFigure 4.2117. On such test case like in Figure 4.21, Modi\ufb01ed Dijkstra\u2019s will \ufb01rst take the\nbottom path 0 ! 2 ! 4 ! 6 !", "mimetype": "text/plain", "start_char_idx": 681597, "end_char_idx": 685187, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3e6e80e9-2e24-4f20-a2ec-10cbfe4c0717": {"__data__": {"id_": "3e6e80e9-2e24-4f20-a2ec-10cbfe4c0717", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "64e41ea4-f089-414e-bd82-d8db9412fbdd", "node_type": "1", "metadata": {}, "hash": "ed9bfd5fa1b949ea6b08a292082e26c43e9f78c9ffdd16b2d9b21d9cdb6a35fa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0e373c6e-7abf-4cd7-89d6-c0039b2c2832", "node_type": "1", "metadata": {}, "hash": "1196ba217b385b449efc30a967852ef746915402a09f46062669b387dc9ba2af", "class_name": "RelatedNodeInfo"}}, "text": "232\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nIn either case, the early termination technique when the destination vertex t is also given in\nthe SSSDSP variant will not work on such a graph.\nHowever on an extreme case, we can actually setup a graph that has negative weights\nbut no negative cycle that can signi\ufb01cantly slow down Modi\ufb01ed Dijkstra\u2019s algorithm, see\nFigure 4.2117. On such test case like in Figure 4.21, Modi\ufb01ed Dijkstra\u2019s will \ufb01rst take the\nbottom path 0 ! 2 ! 4 ! 6 ! 8 ! 10 with cost 0 + 0 + 0 + 0 + 0 = 0 before \ufb01nding\n0 ! 2 ! 4 ! 6 ! 8 ! 9 ! 10 with lower cost 0+0+0+0+1+(\u22122) = \u22121 and so on until\nit explores all 25 possible paths from vertex 0 to vertex 10. It terminates with the correct\nanswer of path 0 ! 1 ! 2 ! 3 ! 4 ! 5 ! 6 ! 7 ! 8 ! 9 ! 10 with cost \u221231. Each\nadditional triangle (two more vertices and three more edges) in such a graph increases the\nruntime by twofold. Hence, Modi\ufb01ed Dijkstra\u2019s can be made to run in exponential time. The\ndi\ufb03culty of this test case for Modi\ufb01ed Dijkstra\u2019s is best appreciated using a live animation\nso please also check VisuAlgo for the animation.\nFigure 4.21: Modi\ufb01ed Dijkstra\u2019s Can Be Made to Run in Exponential Time\nExercise 4.4.3.1: The source code for the Original Dijkstra\u2019s algorithm shown above uses\nset<ii> instead of multiset<ii>. What if there are two (or more) di\u21b5erent vertices that\nhave similar shortest path distance values from the source vertex s?\nExercise 4.4.3.2: The source code for the Modi\ufb01ed Dijkstra\u2019s algorithm shown above\nuses priority queue<ii, vector<ii>, greater<ii>> pq; to sort pairs of integers by\nincreasing distance from source s. Can we get the same e\u21b5ect without de\ufb01ning comparison\noperator for the priority queue? Hint: We have used similar technique with Kruskal\u2019s\nalgorithm implementation in Section 4.3.2.\nExercise 4.4.3.3: The source code for the Modi\ufb01ed Dijkstra\u2019s algorithm shown above has\nthis important check if (d > dist[u]) continue;. What if that line is removed? What\nwill happen to the Modi\ufb01ed Dijkstra\u2019s algorithm?\nExercise 4.4.3.4*: Prove the correctness of Dijkstra\u2019s algorithm (both variants) on non-\nnegative weighted graphs!\nExercise 4.4.3.5*: Dijkstra\u2019s algorithm (both variants) will run in O(V 2 log V ) if run on\na complete non-negative weighted graph where E = O(V 2). Show how to modify Dijkstra\u2019s\nimplementation so that it runs in O(V 2) instead such complete graph! Hint: Avoid PQ.\nPro\ufb01le of Algorithm Inventor\nEdsger Wybe Dijkstra (1930-2002) was a Dutch computer scientist. One of his famous\ncontributions to computer science is the shortest path-algorithm known as Dijkstra\u2019s algo-\nrithm [8]. He does not like \u2018GOTO\u2019 statement and in\ufb02uenced the widespread deprecation of\n\u2018GOTO\u2019 and its replacement: structured control constructs. One of his famous Computing\nphrase: \u201ctwo or more, use a for\u201d.\n17This test case is contributed by a Competitive Programming Book reader: Francisco Criado.\n233\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\n4.4.4\nOn Small Graph (with Negative Cycle): Bellman-Ford\nTo solve the SSSP problem in the potential presence of negative weight cycle(s), we can\nuse the more generic (but slower) Bellman-Ford algorithm. This algorithm was invented by\nRichard Ernest Bellman (the pioneer of DP techniques) and Lester Randolph Ford, Jr (the\nsame person who invented Ford-Fulkerson method for the Network Flow problem\u2014discussed\nin Book 2). The main idea of this algorithm is simple: relax all E edges (in arbitrary order)\nV -1 times!", "mimetype": "text/plain", "start_char_idx": 684703, "end_char_idx": 688202, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0e373c6e-7abf-4cd7-89d6-c0039b2c2832": {"__data__": {"id_": "0e373c6e-7abf-4cd7-89d6-c0039b2c2832", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3e6e80e9-2e24-4f20-a2ec-10cbfe4c0717", "node_type": "1", "metadata": {}, "hash": "20029c91614d1e7f5b0fc3e0bab01c8e213a0e024332cde22a622cf1608f1cb7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "64861338-bd52-4209-9ba0-dd38ea526402", "node_type": "1", "metadata": {}, "hash": "c4b8a3d5a8215de852da46319187d04464e54f198faa19015275e34baa3f589c", "class_name": "RelatedNodeInfo"}}, "text": "One of his famous Computing\nphrase: \u201ctwo or more, use a for\u201d.\n17This test case is contributed by a Competitive Programming Book reader: Francisco Criado.\n233\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\n4.4.4\nOn Small Graph (with Negative Cycle): Bellman-Ford\nTo solve the SSSP problem in the potential presence of negative weight cycle(s), we can\nuse the more generic (but slower) Bellman-Ford algorithm. This algorithm was invented by\nRichard Ernest Bellman (the pioneer of DP techniques) and Lester Randolph Ford, Jr (the\nsame person who invented Ford-Fulkerson method for the Network Flow problem\u2014discussed\nin Book 2). The main idea of this algorithm is simple: relax all E edges (in arbitrary order)\nV -1 times!\nInitially dist[s] = 0, the base case. If we relax an edge (s, u), then dist[u] will have\nthe correct value. If we then relax an edge (u, v), then dist[v] will also have the correct\nvalue. If we have relaxed all E edges V -1 times, then the shortest path from the source\nvertex to the furthest vertex from the source (which will be a simple path with V -1 edges)\nshould have been correctly computed (see Exercise 4.4.4.1* for proof of correctness). The\nbasic Bellman-Ford C++ code is very simple, simpler than BFS and Dijkstra\u2019s code:\n// inside int main()\nvi dist(V, INF); dist[s] = 0;\n// INF = 1e9 here\nfor (int i = 0; i < V-1; ++i)\n// total O(V*E)\nfor (int u = 0; u < V; ++u)\n// these two loops = O(E)\nif (dist[u] != INF)\n// important check\nfor (auto &[v, w] : AL[u])\n// C++17 style\ndist[v] = min(dist[v], dist[u]+w);\nThe complexity of Bellman-Ford algorithm is O(V 3) if the graph is stored as an Adjacency\nMatrix or O(V E) if the graph is stored as an Adjacency List or Edge List. This is simply\nbecause if we use Adjacency Matrix, we need O(V 2) to enumerate all the edges in our graph\nwhereas it is just O(E) using either Adjacency List or Edge List. Both time complexities\nare (much) slower compared to Dijkstra\u2019s and this is one of the main reason why we don\u2019t\nnormally use Bellman-Ford to solve standard SSSP on weighted graph.\nFor some improvement, we can add a Boolean \ufb02ag modified = false in the outermost\nloop (the one that repeats all E edges relaxation V -1 times).\nIf at least one relaxation\noperation is done in the inner loops (the one that explores all E edges), set modified = true.\nWe immediately break the outermost loop if variable modified is still false after all E edges\nhave been examined. If this no-relaxation happens at the (outermost) loop iteration i, then\nthere will be no further relaxation in iteration i + 1, i + 2, . . . , i = V -1 either. This way, the\ntime complexity of Bellman-Ford becomes O(kV ) where k is the number of iteration of the\noutermost loop. Note that k is still O(V ) though.\nBellman-Ford will never be trapped in an in\ufb01nite loop even if the given graph has negative\ncycle(s). In fact, Bellman-Ford algorithm can be used to detect the presence of negative cycle\n(e.g., UVa 00558 - Wormholes) although such SSSP problem is ill-de\ufb01ned.\nFigure 4.22: Bellman-Ford can detect the presence of negative cycle (UVa 00558 [44])\n234\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nIt can be proven (see Exercise 4.4.4.1*) that after relaxing all E edges V -1 times, we\nshould have solved the SSSP problem, i.e., we cannot relax any more edge. As the corollary:\nif we can still relax an edge, there must be at least one negative cycle in our weighted graph.\nThis is a useful feature of the Bellman-Ford algorithm.\nFor example, in Figure 4.22\u2014left, we see a simple graph with a negative cycle.", "mimetype": "text/plain", "start_char_idx": 687463, "end_char_idx": 691034, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "64861338-bd52-4209-9ba0-dd38ea526402": {"__data__": {"id_": "64861338-bd52-4209-9ba0-dd38ea526402", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0e373c6e-7abf-4cd7-89d6-c0039b2c2832", "node_type": "1", "metadata": {}, "hash": "1196ba217b385b449efc30a967852ef746915402a09f46062669b387dc9ba2af", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cbcb136e-dcb6-4092-a715-687f97c07afc", "node_type": "1", "metadata": {}, "hash": "05f53ced1e3bc9f3d908f49796cc28d2f039d5f799b27d22f14c6564cdda1d8e", "class_name": "RelatedNodeInfo"}}, "text": "Figure 4.22: Bellman-Ford can detect the presence of negative cycle (UVa 00558 [44])\n234\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nIt can be proven (see Exercise 4.4.4.1*) that after relaxing all E edges V -1 times, we\nshould have solved the SSSP problem, i.e., we cannot relax any more edge. As the corollary:\nif we can still relax an edge, there must be at least one negative cycle in our weighted graph.\nThis is a useful feature of the Bellman-Ford algorithm.\nFor example, in Figure 4.22\u2014left, we see a simple graph with a negative cycle. After 1\npass, dist[1] = 72 and dist[2] = dist[3] = 114. After V -1 = 6\u22121 = 5 passes, dist[1]\n= -36 and dist[2] = dist[3] = 6 and Bellman-Ford algorithm stops. However, as there\nis a negative cycle, we can still do successful edge relaxations, e.g., we can still relax dist[2]\n= -36+15 = -21. This is lower than the current value of dist[2] = 6. The presence of a\nnegative cycle (of weight 15+0-42 = -27) causes the vertices reachable from this negative\ncycle to have ill-de\ufb01ned shortest paths information. This is because one can simply traverse\nthis negative cycle in\ufb01nite number of times to make all reachable vertices from this negative\ncycle to have negative in\ufb01nity shortest paths information. Notice that in Figure 4.22\u2014right,\nvertex 4 is a\u21b5ected by the negative cycle whereas vertex 5 is not. The additional code to\ncheck for negative cycle after running the O(V E) Bellman-Ford is shown below.\nOur more complete Bellman-Ford C++ code is shown below. It shows Bellman-Ford with\noptimization and additional negative cycle check18.\n// inside int main()\nvi dist(V, INF); dist[s] = 0;\n// INF = 1e9 here\nfor (int i = 0; i < V-1; ++i) {\n// total O(V*E)\nbool modified = false;\n// optimization\nfor (int u = 0; u < V; ++u)\n// these two loops = O(E)\nif (dist[u] != INF)\n// important check\nfor (auto &[v, w] : AL[u]) {\n// C++17 style\nif (dist[u]+w >= dist[v]) continue;\n// not improving, skip\ndist[v] = dist[u]+w;\n// relax operation\nmodified = true;\n// optimization\n}\nif (!modified) break;\n// optimization\n}\nbool hasNegativeCycle = false;\nfor (int u = 0; u < V; ++u)\n// one more pass to check\nif (dist[u] != INF)\nfor (auto &[v, w] : AL[u])\n// C++17 style\nif (dist[v] > dist[u]+w)\n// should be false\nhasNegativeCycle = true;\n// if true => -ve cycle\nif (hasNegativeCycle)\nprintf(\"Negative Cycle Exist\\n\");\nelse {\nfor (int u = 0; u < V; ++u)\nprintf(\"SSSP(%d, %d) = %d\\n\", s, u, dist[u]);\n}\nSource code: ch4/sssp/bellman ford.cpp|java|py|ml\n18There is another algorithm that can do negative cycle check: the O(V 3) Floyd-Warshall algorithm\napplications that is discussed in Section 4.5.3.\n235\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nBellman-Ford-Moore (SPFA) Algorithm\nA known improvement for Bellman-Ford algorithm is Moore\u2019s improvement (let\u2019s just call\nit as Bellman-Ford-Moore algorithm19). Bellman-Ford-Moore utilizes a queue to eliminate\nredundant operations in the standard Bellman-Ford algorithm. This algorithm was discov-\nered by Moore in 1957 [41] and independently by Bellman in 1958 [2]. Bellman-Ford-Moore\nrequires two additional data structures on top of Bellman-Ford code shown earlier:\n1. A queue<int> to store the next vertex to be processed (due to successful relaxation).\n2. vi in queue of size V to quickly check if a vertex is currently in the queue or not.", "mimetype": "text/plain", "start_char_idx": 690491, "end_char_idx": 693834, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cbcb136e-dcb6-4092-a715-687f97c07afc": {"__data__": {"id_": "cbcb136e-dcb6-4092-a715-687f97c07afc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "64861338-bd52-4209-9ba0-dd38ea526402", "node_type": "1", "metadata": {}, "hash": "c4b8a3d5a8215de852da46319187d04464e54f198faa19015275e34baa3f589c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3d58f128-51bc-4f87-b7aa-ae0384b91819", "node_type": "1", "metadata": {}, "hash": "c0caecc1a60065d3ab62b50e64aaeccf896c421cc22a7821047bbf047b2c5ff3", "class_name": "RelatedNodeInfo"}}, "text": "235\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nBellman-Ford-Moore (SPFA) Algorithm\nA known improvement for Bellman-Ford algorithm is Moore\u2019s improvement (let\u2019s just call\nit as Bellman-Ford-Moore algorithm19). Bellman-Ford-Moore utilizes a queue to eliminate\nredundant operations in the standard Bellman-Ford algorithm. This algorithm was discov-\nered by Moore in 1957 [41] and independently by Bellman in 1958 [2]. Bellman-Ford-Moore\nrequires two additional data structures on top of Bellman-Ford code shown earlier:\n1. A queue<int> to store the next vertex to be processed (due to successful relaxation).\n2. vi in queue of size V to quickly check if a vertex is currently in the queue or not.\nOur short C++ code that implements Bellman-Ford-Moore is shown below:\n// inside int main()\nvi dist(V, INF); dist[s] = 0;\n// INF = 1e9 here\nqueue<int> q; q.push(s);\n// like BFS queue\nvi in_queue(V, 0); in_queue[s] = 1;\n// unique to SPFA\nwhile (!q.empty()) {\nint u = q.front(); q.pop(); in_queue[u] = 0; // pop from queue\nfor (auto &[v, w] : AL[u]) {\n// C++17 style\nif (dist[u]+w >= dist[v]) continue;\n// not improving, skip\ndist[v] = dist[u]+w;\n// relax operation\nif (in_queue[v]) continue;\n// v already in q, skip\nq.push(v);\nin_queue[v] = 1;\n// v is currently in q\n}\n}\nfor (int u = 0; u < V; ++u)\nprintf(\"SSSP(%d, %d) = %d\\n\", s, u, dist[u]);\nSource code: ch4/sssp/bellman ford moore.cpp|java|py|ml\nThe true time complexity of this algorithm is hard to analyze. It runs in O(kE) where k is a\nnumber that depends on the input graph. The maximum k can still be V (which results in\nBellman-Ford-Moore having the same worst case time complexity as the O(V E) Bellman-\nFord algorithm). However, we have tested that for many SSSP problems in UVa/Kattis\nonline judge that are listed in this book, Bellman-Ford-Moore (which uses a queue) can be\nas fast as a good implementation of Dijkstra\u2019s algorithm (which uses a priority queue).\nAs Bellman-Ford-Moore is somewhat similar with the Modi\ufb01ed Dijkstra\u2019s algorithm, it\ncan deal with graph with negative weight edge as long as it has no negative cycle20. If\nthe graph has at least one negative cycle that is reachable from the source vertex s, the\npure form of Bellman-Ford-Moore fails to terminate as the vertices along the negative cycle\nrepeatedly reenter the queue. However, it can be slightly modi\ufb01ed\u2014similar with standard\nBellman-Ford check\u2014to detect negative weight cycle in O(V E).\nExercise 4.4.4.1*: Why just by relaxing all E edges (in any order) of our weighted graph\nV -1 times, Bellman-Ford algorithm will get the correct SSSP information? Prove it!\n19In Chinese Computer Science community, this algorithm is known as Shortest Path \u2018Faster\u2019 Algorithm\n(SPFA) as Duan Fanding published it in Chinese in 1994 [13]. The keyword \u2018faster\u2019 in the SPFA name is\npotentially misleading as it is not theoretically nor empirically faster than Dijkstra\u2019s algorithm.\n20We use Bellman-Ford-Moore as a subroutine of Min Cost Max Flow (MCMF) algorithm in Book 2.\n236\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.4.5\nSSSP in Programming Contests\nSummary of Classic SSSP Variations\nIn Table 4.3, we summarize the basic forms and all variants of SSSP problems that we have\ndiscussed in this section, together with one example from UVa and Kattis online judge each.\nIt is a good idea to at least solve at least one problem per each variant.", "mimetype": "text/plain", "start_char_idx": 693116, "end_char_idx": 696507, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3d58f128-51bc-4f87-b7aa-ae0384b91819": {"__data__": {"id_": "3d58f128-51bc-4f87-b7aa-ae0384b91819", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cbcb136e-dcb6-4092-a715-687f97c07afc", "node_type": "1", "metadata": {}, "hash": "05f53ced1e3bc9f3d908f49796cc28d2f039d5f799b27d22f14c6564cdda1d8e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b8b21f69-38f1-4343-b0b7-1b75c059e6af", "node_type": "1", "metadata": {}, "hash": "a42420c680758b7d796bf52c9f551386ed199adf5965ecc36b552c63c9f2ecc2", "class_name": "RelatedNodeInfo"}}, "text": "The keyword \u2018faster\u2019 in the SPFA name is\npotentially misleading as it is not theoretically nor empirically faster than Dijkstra\u2019s algorithm.\n20We use Bellman-Ford-Moore as a subroutine of Min Cost Max Flow (MCMF) algorithm in Book 2.\n236\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.4.5\nSSSP in Programming Contests\nSummary of Classic SSSP Variations\nIn Table 4.3, we summarize the basic forms and all variants of SSSP problems that we have\ndiscussed in this section, together with one example from UVa and Kattis online judge each.\nIt is a good idea to at least solve at least one problem per each variant.\nVariant Name\nUVa\nKattis\nSSSP on Unweighted Graph, Basic\n00336\nconquestcampaign\nSSSP on Weighted Graph, Basic\n10986\nshortestpath1\nSSSP on Negative Cycle Graph, Basic\n00558\nshortestpath3\nSSSP on Implicit Graph, Unweighted\n10653\ngrid\nSSSP on Implicit Graph, Weighted\n00929\nblockcrusher\nSS Single-Destination SP\n01148\n\ufb02owerytrails\nSingle-Destination SP\n01112\ndetour\nMulti-Sources SP\n13127\n\ufb01restation\nWith shortest path reconstruction\n11049\ndetour\nOn 0/1-Weighted Graph\n11573\nshowroom\nBasic State-Space Search (also see Book 2)\n10150\nfulltank\nTable 4.3: Classic SSSP Variations and Some Example Problems\nBased on our experience, many shortest paths problems are not posed on weighted graphs\nthat require Dijkstra\u2019s (or other more advanced) algorithms. If you look at the programming\nexercises listed in Section 4.4 (and in Book 2), you will see that many of them (\u21e1half) are\nposed on unweighted graphs that are solvable with just BFS (see Section 4.4.2).\nAlso according to our experience, many shortest paths problems involving weighted\ngraphs are not posed on graphs that have negative weight that require Bellman-Ford (or\nother similarly slow) algorithm, or worse, on graphs that have negative cycle where the\nSSSP problem is ill-de\ufb01ned. If you look at the programming exercises listed in Section 4.4,\nyou will see that very few of them are posed on graphs that have negative weight (cycle)\nand thus must be solved with heavy Bellman-Ford algorithm (see Section 4.4.4).\nTherefore as a rule of thumb, if you are given an SSSP problem, simply decide21 if the\ngraph that you are dealing with is weighted. If it is unweighted, just use the fast O(V + E)\nBFS algorithm. Otherwise, we should use the slightly slower O((V + E) log V ) Dijkstra\u2019s\nalgorithm (either version).\nVisuAlgo\nWe have provided the animation of almost all popular SSSP algorithms that we have dis-\ncussed in this section inside VisuAlgo. Use it to further strengthen your understanding of\nthese SSSP algorithms by providing your own input graph (directed weighted/unweighted)\n(general/special) graph plus a source vertex and then see the SSSP algorithm being animated\nlive on that particular input graph. We believe that the live animation is much better than\nthe static text inside this book. The URL for the visualization is shown below.\nVisualization: https://visualgo.net/en/sssp\n21Technically, you should be able to solve almost all SSSP problems by using O((V + E) log V ) Dijkstra\u2019s\nalgorithm most of the time as the O(log V ) di\u21b5erence is not that big, see Table 4.4.\n237\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nSample Application: Kattis - fulltank/UVa 11367 - Full Tank?\nThe most important part for solving the SSSP problems is not the knowledge of various SSSP\nalgorithms, but actually about graph modeling skill \u2014 the ability to spot the underlying\ngraph in the problem statement. We repeatedly mention this throughout this chapter because\nit is important. We illustrate this with one example.", "mimetype": "text/plain", "start_char_idx": 695899, "end_char_idx": 699503, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b8b21f69-38f1-4343-b0b7-1b75c059e6af": {"__data__": {"id_": "b8b21f69-38f1-4343-b0b7-1b75c059e6af", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3d58f128-51bc-4f87-b7aa-ae0384b91819", "node_type": "1", "metadata": {}, "hash": "c0caecc1a60065d3ab62b50e64aaeccf896c421cc22a7821047bbf047b2c5ff3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0af3b05b-de1c-4c1d-b2ae-2ee2f8a61ad0", "node_type": "1", "metadata": {}, "hash": "af28fba7212abe1c94fa791ea281a30644b358e4facd141fc3fe2ec10d24e7c8", "class_name": "RelatedNodeInfo"}}, "text": "The URL for the visualization is shown below.\nVisualization: https://visualgo.net/en/sssp\n21Technically, you should be able to solve almost all SSSP problems by using O((V + E) log V ) Dijkstra\u2019s\nalgorithm most of the time as the O(log V ) di\u21b5erence is not that big, see Table 4.4.\n237\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nSample Application: Kattis - fulltank/UVa 11367 - Full Tank?\nThe most important part for solving the SSSP problems is not the knowledge of various SSSP\nalgorithms, but actually about graph modeling skill \u2014 the ability to spot the underlying\ngraph in the problem statement. We repeatedly mention this throughout this chapter because\nit is important. We illustrate this with one example.\nAbridged problem description: Given a connected weighted graph length that stores the\nroad length between E pairs of cities i and j (1 \uf8ffV \uf8ff1000, 0 \uf8ffE \uf8ff10 000), the price\np[i] of fuel at each city i, and the fuel tank capacity c of a car (1 \uf8ffc \uf8ff100), determine the\ncheapest trip cost from starting city s to ending city e using a car with fuel capacity c. All\ncars use one unit of fuel per unit of distance and start with an empty fuel tank.\nWith this problem, we want to discuss the importance of graph modeling. The explicitly\ngiven graph in this problem is a weighted graph of the road network. However, we cannot\nsolve this problem with just this graph. This is because the state22 of this problem requires\nnot just the current location (city) but also the fuel level at that location. Otherwise, we\ncannot determine whether the car has enough fuel to make a trip along a certain road\n(because we cannot refuel in the middle of the road). Therefore, we use a pair of information\nto represent the state: (location, fuel) and by doing so, the total number of vertices of the\nmodi\ufb01ed graph explodes from just 1000 vertices to 1000 \u21e5100 = 100 000 vertices. We call\nthe modi\ufb01ed graph: \u2018State-Space\u2019 graph.\nIn the State-Space graph, the source vertex is state (s, 0)\u2014at starting city s with empty\nfuel tank and the target vertices are states (e, any)\u2014at ending city e with any level of fuel\nbetween [0..c].\nThere are two types of edge in the State-Space graph: 0-weighted edge\nthat goes from vertex (x, fuelx) to vertex (y, fuelx \u2212length(x, y)) if the car has su\ufb03cient\nfuel to travel from vertex x to vertex y, and the p[x]-weighted edge that goes from vertex\n(x, fuelx) to vertex (x, fuelx + 1) if the car can refuel at vertex x by one unit of fuel (note\nthat the fuel level cannot exceed the fuel tank capacity c). Now, running Dijkstra\u2019s on this\nweighted State-Space graph gives us the solution for this problem (also see Book 2 for more\ndiscussions).\nWhat\u2019s Next?\nWe remark that recent programming contest problems involving SSSP are no longer written\nas straightforward SSSP problems shown in Table 4.3 but written in a much more creative\nfashion, e.g., (UVa 10067, 10801, 11367, 11492, 12160, Kattis - getshorty, emptyingbaltic,\nshoppingmalls, tide, etc). Therefore, to do well in programming contests, make sure that\nyou have this graph modeling soft skill.\nIn Section 4.5, we will discuss All-Pairs Shortest Paths (APSP) problem. In Section\n4.6.1, we will discuss shortest paths problem on special graphs. Then in Book 2, we will\ndiscuss the harder versions of SSSP problem that require more complex graph modeling\nand/or technique like Meet in the Middle/Bidirectional Search.\nExercise 4.4.5.1: The graph modeling for Kattis - fulltank/UVa 11367 - Full Tank? above\ntransform the SSSP problem on weighted graph into SSSP problem on weighted State-Space\ngraph. Can we solve this problem with DP? If we can, why? If we cannot, why not? Hint:\nRead Section 4.6.1 and also try Exercise 4.6.1.1.", "mimetype": "text/plain", "start_char_idx": 698764, "end_char_idx": 702498, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0af3b05b-de1c-4c1d-b2ae-2ee2f8a61ad0": {"__data__": {"id_": "0af3b05b-de1c-4c1d-b2ae-2ee2f8a61ad0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b8b21f69-38f1-4343-b0b7-1b75c059e6af", "node_type": "1", "metadata": {}, "hash": "a42420c680758b7d796bf52c9f551386ed199adf5965ecc36b552c63c9f2ecc2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "55bb1aa3-9096-4fe8-a422-e0485256687e", "node_type": "1", "metadata": {}, "hash": "b45e0774b6c851d5220feb5b162d958309a88a874fd5a1796cb1cb3be874e0aa", "class_name": "RelatedNodeInfo"}}, "text": "In Section 4.5, we will discuss All-Pairs Shortest Paths (APSP) problem. In Section\n4.6.1, we will discuss shortest paths problem on special graphs. Then in Book 2, we will\ndiscuss the harder versions of SSSP problem that require more complex graph modeling\nand/or technique like Meet in the Middle/Bidirectional Search.\nExercise 4.4.5.1: The graph modeling for Kattis - fulltank/UVa 11367 - Full Tank? above\ntransform the SSSP problem on weighted graph into SSSP problem on weighted State-Space\ngraph. Can we solve this problem with DP? If we can, why? If we cannot, why not? Hint:\nRead Section 4.6.1 and also try Exercise 4.6.1.1.\n22Recall: State is a subset of parameters of the problem that can succinctly describes the problem.\n238\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nProgramming Exercises related to Single-Source Shortest Paths (SSSP) Problems:\na. On Unweighted Graph: BFS, Easier\n1. Entry Level: UVa 00336 - A Node Too Far * (simple SSSP; BFS)\n2. UVa 00429 - Word Transformation * (each word is a vertex, connect 2\nwords with an edge if di\u21b5er by 1 letter)\n3. UVa 10653 - Bombs; NO they ... * (need e\ufb03cient BFS implementation)\n4. UVa 12160 - Unlock the Lock * (LA 4408 - KualaLumpur08; s: (4-digits\nnumber); edges: button pushes; BFS)\n5. Kattis - buttonbashing * (very similar to UVa 12160)\n6. Kattis - grid * (modi\ufb01ed BFS with step size multiplier)\n7. Kattis - horror * (SSSP from all sources = horror movies; report lowest ID\nwith the highest unweighted SSSP distance)\nExtra UVa: 00388, 00627, 00762, 00924, 01148, 10009, 10610, 10959.\nExtra Kattis: conquestcampaign, elevatortrouble, erraticants, onaverageth-\neyrepurple, spiral, wettiles.\nb. On Unweighted Graph: BFS, Harder\n1. Entry Level: Kattis - lost * (interesting twist of BFS/SSSP spanning tree)\n2. UVa 11352 - Crazy King * (\ufb01lter the graph \ufb01rst; then it becomes SSSP)\n3. UVa 11792 - Krochanska is Here * (be careful with \u2018important station\u2019)\n4. UVa 12826 - Incomplete Chessboard * (SSSP from (r1, c1) to (r2, c2)\navoiding (r3, c3); BFS)\n5. Kattis - \ufb01re2 * (very similar to UVa 11624)\n6. Kattis - mallmania * (multi-sources BFS from m1; get minimum at border\nof m2; also available at UVa 11101 - Mall Mania)\n7. Kattis - oceancurrents * (0/1-weighted SSSP; BFS+deque; also available at\nUVa 11573 - Ocean Currents)\nExtra UVa: 00314, 00383, 00859, 00949, 10044, 10067, 10977, 10993, 11049,\n11377.\nExtra Kattis: beehives2, dungeon, erdosnumbers, \ufb01re3, landlocked, lava, show-\nroom, sixdegrees, slikar, zoning.\nc. Knight Moves\n1. Entry Level: UVa 00439 - Knight Moves * (one BFS per query is enough)\n2. UVa 00633 - Chess Knight * (alternating Knight Moves and Bishop\nMoves (limited to distance 2)); solvable with just one BFS per query)\n3. UVa 10426 - Knights\u2019 Nightmare * (for each knight, do BFS when the\nmonster is sleep/awake; try: one awake the monster, the rest go around)\n4. UVa 10477 - The Hybrid Knight * (s: (row, col, knight state); implicit\nunweighted graph; di\u21b5erent edges per di\u21b5erent knight state)\n5. Kattis - grasshopper * (BFS on implicit Knight jump graph)\n6.", "mimetype": "text/plain", "start_char_idx": 701866, "end_char_idx": 704914, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55bb1aa3-9096-4fe8-a422-e0485256687e": {"__data__": {"id_": "55bb1aa3-9096-4fe8-a422-e0485256687e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0af3b05b-de1c-4c1d-b2ae-2ee2f8a61ad0", "node_type": "1", "metadata": {}, "hash": "af28fba7212abe1c94fa791ea281a30644b358e4facd141fc3fe2ec10d24e7c8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "df366276-0ad7-4421-b5a1-bfd1a663f6a5", "node_type": "1", "metadata": {}, "hash": "0dfdc02b7510c3fc3d65cc0918ae8363a9b09ed8fb2f5bb26d77d337ba741705", "class_name": "RelatedNodeInfo"}}, "text": "c. Knight Moves\n1. Entry Level: UVa 00439 - Knight Moves * (one BFS per query is enough)\n2. UVa 00633 - Chess Knight * (alternating Knight Moves and Bishop\nMoves (limited to distance 2)); solvable with just one BFS per query)\n3. UVa 10426 - Knights\u2019 Nightmare * (for each knight, do BFS when the\nmonster is sleep/awake; try: one awake the monster, the rest go around)\n4. UVa 10477 - The Hybrid Knight * (s: (row, col, knight state); implicit\nunweighted graph; di\u21b5erent edges per di\u21b5erent knight state)\n5. Kattis - grasshopper * (BFS on implicit Knight jump graph)\n6. Kattis - hidingplaces * (SSSP from (r, c); \ufb01nd cells with max distance; print)\n7. Kattis - knightjump * (unweighted SSSP from the cell that contains \u2018K\u2019 to\n(1, 1) using Knight jump movements; avoid \u2018#\u2019 cells)\n239\n\n4.4.\nSINGLE-SOURCE SHORTEST PATHS (SSSP)\nc\u20ddSteven, Felix, Suhendry\nd. On Weighted Graph: Dijkstra\u2019s, Easier\n1. Entry Level: Kattis - shortestpath1 * (very standard Dijkstra\u2019s problem)\n2. UVa 01112 - Mice and Maze * (LA 2425 - SouthwesternEurope01; SDSP)\n3. UVa 10986 - Sending email * (direct Dijkstra\u2019s application)\n4. UVa 13127 - Bank Robbery * (Dijkstra\u2019s from multiple sources)\n5. Kattis - \ufb02owerytrails * (Dijkstra\u2019s; record predecessor graph as there can be\nmultiple shortest paths; also available at UVa 12878 - Flowery Trails)\n6. Kattis - shortestpath2 * (Dijkstra\u2019s with modi\ufb01cation; edges only available\nperiodically; be careful with P = 0 case)\n7. Kattis - texassummers * (Dijkstra\u2019s; complete weighted graph; print path)\nExtra UVa: 00929.\nExtra Kattis: george, getshorty, hopscotch50, subway2.\ne. On Weighted Graph: Dijkstra\u2019s, Harder\n1. Entry Level: Kattis - visualgo * (Dijkstra\u2019s produces SSSP spanning DAG\nif there are multiple shortest paths from s to t; counting paths on DAG)\n2. UVa 00589 - Pushing Boxes * (weighted SSSP: move box from s to t +\nunweighted SSSP: move player to correct position to push the box)\n3. UVa 12047 - Highest Paid Toll * (clever usage of Dijkstra\u2019s; run Dijk-\nstra\u2019s from source and from destination)\n4. UVa 12950 - Even Obsession * (clever usage of Dijstra\u2019s; instead of\nextending by one edge, we can extend by two edges at a time)\n5. Kattis - blockcrusher * (Dijkstra\u2019s from top row to bottom row; print path)\n6. Kattis - emptyingbaltic * (Dijkstra\u2019s variant; grow spanning tree from drain)\n7. Kattis - invasion * (SSSP with multiple and successive sources; multiple calls\nof Dijkstra\u2019s (gets lighter each time if pruned properly))\nExtra UVa: 00157, 00523, 00721, 01202, 10166, 10187, 10356, 10603, 10801,\n10967, 11338, 11492, 11833, 12144.\nExtra Kattis: backpackbuddies, detour, \ufb01restation, forestfruits, fulltank, grue-\nsomecave, passingsecrets, shoppingmalls, tide, wine.\nOthers: IOI 2011 - Crocodile (can be modeled as an SSSP problem).\nf. On Small Graph (with Negative Cycle): Bellman-Ford\n1. Entry Level: UVa 00558 - Wormholes * (check if negative cycle exists)\n2. UVa 10449 - Tra\ufb03c * (\ufb01nd the minimum weight path, which may be\nnegative; be careful: 1 + negative weight is lower than 1)\n3. UVa 11280 - Flying to Fredericton * (modi\ufb01ed Bellman-Ford)\n4.", "mimetype": "text/plain", "start_char_idx": 704348, "end_char_idx": 707432, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "df366276-0ad7-4421-b5a1-bfd1a663f6a5": {"__data__": {"id_": "df366276-0ad7-4421-b5a1-bfd1a663f6a5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "55bb1aa3-9096-4fe8-a422-e0485256687e", "node_type": "1", "metadata": {}, "hash": "b45e0774b6c851d5220feb5b162d958309a88a874fd5a1796cb1cb3be874e0aa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2be2bfb0-b7eb-4196-bf01-e71f9154f193", "node_type": "1", "metadata": {}, "hash": "1f6677bf433e44bb9a818b9d6d03b79f33633c8c581751f1430cd3d732d65722", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: backpackbuddies, detour, \ufb01restation, forestfruits, fulltank, grue-\nsomecave, passingsecrets, shoppingmalls, tide, wine.\nOthers: IOI 2011 - Crocodile (can be modeled as an SSSP problem).\nf. On Small Graph (with Negative Cycle): Bellman-Ford\n1. Entry Level: UVa 00558 - Wormholes * (check if negative cycle exists)\n2. UVa 10449 - Tra\ufb03c * (\ufb01nd the minimum weight path, which may be\nnegative; be careful: 1 + negative weight is lower than 1)\n3. UVa 11280 - Flying to Fredericton * (modi\ufb01ed Bellman-Ford)\n4. UVa 12768 - Inspired Procrastination * (insert \u2212F as edge weight; see\nif negative cycle exists; or \ufb01nd min SSSP value from s = 1)\n5. Kattis - hauntedgraveyard * (Bellman-Ford; negative cycle check needed)\n6. Kattis - shortestpath3 * (Bellman-Ford; do DFS/BFS from vertices that are\npart of any negative cycle)\n7. Kattis - xyzzy * (check \u2018positive\u2019 cycle; check connectedness; also available\nat UVa 10557 - XYZZY)\nExtra UVa: 00423.\nExtra Kattis: crosscountry.\n240\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.5\nAll-Pairs Shortest Paths (APSP)\n4.5.1\nOverview and Motivation\nAbridged problem description: Given a connected, weighted graph G with V \uf8ff100 and\ntwo vertices s and d, \ufb01nd the maximum possible value of dist[s][i]+dist[i][d] over all\npossible i 2 [0..V -1]. This is the key idea to solve UVa 11463 - Commandos. What is the\nbest way to implement the solution code for this problem?\nThis problem requires the shortest path information from all possible sources (all possible\nvertices) of G. We can make V calls of Dijkstra\u2019s algorithm that we have learned earlier in\nSection 4.4.3 above. However, can we solve this problem in a shorter way\u2014in terms of code\nlength? The answer is yes. If the given weighted graph has V \uf8ff450, then there is another\nalgorithm that is much simpler to code.\nLoad the small graph into an Adjacency Matrix AM and then run the following four-liner\ncode with three nested loops shown below. When it terminates, AM[i][j] will contain the\nshortest path distance between two pair of vertices i and j in G. The original problem (UVa\n11463 above) now becomes easy.\n// inside int main()\n// precondition: AM[i][j] contains the weight of edge (i, j)\n// or INF (1B) if there is no such edge, use memset(AM, 63, sizeof AM)\n// Adjacency Matrix AM is a 32-bit signed integer array\nfor (int k = 0; k < V; ++k)\n// loop order is k->i->j\nfor (int i = 0; i < V; ++i)\nfor (int j = 0; j < V; ++j)\nAM[i][j] = min(AM[i][j], AM[i][k]+AM[k][j]);\nSource code: ch4/floyd warshall.cpp|java|py|ml\nThis algorithm is called Floyd-Warshall algorithm, invented by Robert W Floyd [15] and\nStephen Warshall [60]. Floyd-Warshall is a DP algorithm that clearly runs in O(V 3) due to\nits 3 nested loops23. Therefore, it can only be used for graph with V \uf8ff450 in programming\ncontest setting. In general, Floyd-Warshall solves another classical graph problem: the All-\nPairs Shortest Paths (APSP) problem. It is an alternative algorithm (for small graphs)\ncompared to calling SSSP algorithm multiple times (assuming non-negative edge weights):\n1. V calls of O((V + E) log V ) Dijkstra\u2019s = O(V 3 log V ) if E = O(V 2).\n2. V calls of O(V E) Bellman-Ford = O(V 4) if E = O(V 2).\nIn programming contest setting, Floyd-Warshall main attractiveness is basically its imple-\nmentation speed\u2014four short lines only.", "mimetype": "text/plain", "start_char_idx": 706916, "end_char_idx": 710230, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2be2bfb0-b7eb-4196-bf01-e71f9154f193": {"__data__": {"id_": "2be2bfb0-b7eb-4196-bf01-e71f9154f193", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "df366276-0ad7-4421-b5a1-bfd1a663f6a5", "node_type": "1", "metadata": {}, "hash": "0dfdc02b7510c3fc3d65cc0918ae8363a9b09ed8fb2f5bb26d77d337ba741705", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2ccc1970-bb12-46ad-a341-d9d54f45fa00", "node_type": "1", "metadata": {}, "hash": "ee78bae5c73543b95381704c4d1b75c0ec117b61fdb9258aea33780db3d5c2c1", "class_name": "RelatedNodeInfo"}}, "text": "Floyd-Warshall is a DP algorithm that clearly runs in O(V 3) due to\nits 3 nested loops23. Therefore, it can only be used for graph with V \uf8ff450 in programming\ncontest setting. In general, Floyd-Warshall solves another classical graph problem: the All-\nPairs Shortest Paths (APSP) problem. It is an alternative algorithm (for small graphs)\ncompared to calling SSSP algorithm multiple times (assuming non-negative edge weights):\n1. V calls of O((V + E) log V ) Dijkstra\u2019s = O(V 3 log V ) if E = O(V 2).\n2. V calls of O(V E) Bellman-Ford = O(V 4) if E = O(V 2).\nIn programming contest setting, Floyd-Warshall main attractiveness is basically its imple-\nmentation speed\u2014four short lines only. If the given graph is small (V \uf8ff450), do not hesitate\nto use this algorithm\u2014even if you only need a solution for the SSSP problem.\nExercise 4.5.1.1: Is there a reason why AM[i][j] must be set to 1B (109) to indicate that\nthere is no edge between i to j? Why don\u2019t we use 231-1 (MAX INT)?\nExercise 4.5.1.2: In Section 4.4.4, we di\u21b5erentiate graph with negative weight edges but\nno negative cycle and graph with negative weight cycle.\nWill this short Floyd-Warshall\nalgorithm works on graph with negative weight and/or negative cycle?\n23Floyd-Warshall must use Adjacency Matrix so that the weight of edge (i, j) can be accessed and then\npossibly modi\ufb01ed in O(1).\n241\n\n4.5.\nALL-PAIRS SHORTEST PATHS (APSP)\nc\u20ddSteven, Felix, Suhendry\n4.5.2\nFloyd-Warshall Algorithm\nWe provide this section for the bene\ufb01t of readers who are interested to know why Floyd-\nWarshall works. This section can be skipped if you just want to use this algorithm per se.\nHowever, examining this section can further strengthen your DP skill. Note that there are\ngraph problems that have no classical algorithm yet and must be solved with DP techniques\n(see Section 4.6.1).\nFigure 4.23: Floyd-Warshall Explanation 1\nThe basic idea behind Floyd-Warshall is to gradually allow the usage of intermediate ver-\ntices (vertex [0..k]) to form the shortest paths. We denote the shortest path value from\nvertex i to vertex j using only intermediate vertices [0..k] as sp(i,j,k). Let the ver-\ntices be labeled from 0 to V -1.\nWe start with direct edges only when k = \u22121, i.e.,\nsp(i,j,-1) = weight of edge (i, j). Then, we \ufb01nd the shortest paths between any two\nvertices with the help of restricted intermediate vertices from vertex [0..k].\nIn Fig-\nure 4.23, we want to \ufb01nd sp(3,4,4)\u2014the shortest path from vertex 3 to vertex 4, us-\ning any intermediate vertex in the graph (vertex [0..4]).\nThe eventual shortest path\nis path 3-0-2-4 with cost 3.\nBut how to reach this solution?\nWe know that by using\nonly direct edges, sp(3,4,-1) = 5, as shown in Figure 4.23. The solution for sp(3,4,4)\nwill eventually be reached from sp(3,2,2)+sp(2,4,2). But with using only direct edges,\nsp(3,2,-1)+sp(2,4,-1) = 3+1 = 4 is still > 3.\nFigure 4.24: Floyd-Warshall Explanation 2\nFloyd-Warshall then gradually allow k = 0, then k = 1, k = 2 . . . , up to k = V -1.\nWhen we allow k = 0, i.e., vertex 0 can now be used as an intermediate vertex, then\nsp(3,4,0) is reduced as sp(3,4,0) = sp(3,0,-1) + sp(0,4,-1) = 1+3 = 4, as shown in\n242\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nFigure 4.24.", "mimetype": "text/plain", "start_char_idx": 709543, "end_char_idx": 712761, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2ccc1970-bb12-46ad-a341-d9d54f45fa00": {"__data__": {"id_": "2ccc1970-bb12-46ad-a341-d9d54f45fa00", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2be2bfb0-b7eb-4196-bf01-e71f9154f193", "node_type": "1", "metadata": {}, "hash": "1f6677bf433e44bb9a818b9d6d03b79f33633c8c581751f1430cd3d732d65722", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b37734f1-1a9b-4530-aa5c-74f0364f41f5", "node_type": "1", "metadata": {}, "hash": "a9bec5bf0bbad5d94f32906e4c0cc51054d377c0b10109dc7029f32b33561171", "class_name": "RelatedNodeInfo"}}, "text": "But with using only direct edges,\nsp(3,2,-1)+sp(2,4,-1) = 3+1 = 4 is still > 3.\nFigure 4.24: Floyd-Warshall Explanation 2\nFloyd-Warshall then gradually allow k = 0, then k = 1, k = 2 . . . , up to k = V -1.\nWhen we allow k = 0, i.e., vertex 0 can now be used as an intermediate vertex, then\nsp(3,4,0) is reduced as sp(3,4,0) = sp(3,0,-1) + sp(0,4,-1) = 1+3 = 4, as shown in\n242\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nFigure 4.24. Note that with k = 0, sp(3,2,0)\u2014which we will need later\u2014also drop from\n3 to sp(3,0,-1) + sp(0,2,-1) = 1+1 = 2. Floyd-Warshall will process sp(i,j,0) for all\nother pairs considering only vertex 0 as the intermediate vertex but there is only one more\nchange: sp(3,1,0) from 1 down to 3.\nFigure 4.25: Floyd-Warshall Explanation 3\nWhen we allow k = 1, i.e., vertex 0 and 1 can now be used as intermediate vertices, then\nit happens that there is no change to sp(3,2,1), sp(2,4,1), nor to sp(3,4,1). However,\ntwo other values change: sp(0,3,1) and sp(2,3,1) as shown in Figure 4.25 but these two\nvalues will not a\u21b5ect the \ufb01nal computation of the shortest path between vertex 3 and 4.\nFigure 4.26: Floyd-Warshall Explanation 4\nWhen we allow k = 2, i.e., vertex 0, 1, and 2 now can be used as the intermediate vertices,\nthen sp(3,4,2) is reduced again as sp(3,4,2) = sp(3,2,2)+sp(2,4,2) = 2+1 = 3 as\nshown in Figure 4.26. Floyd-Warshall repeats this process for k = 3 and \ufb01nally k = 4 but\nsp(3,4,4) remains at 3 and this is the \ufb01nal answer.\nFormally, we de\ufb01ne Floyd-Warshall DP recurrences as follow.\nLet Dk\ni,j be the shortest\ndistance from i to j with only [0..k] as intermediate vertices. Then, Floyd-Warshall base\ncase and recurrence are as follow:\nD\u22121\ni,j = weight(i, j). This is the base case when we do not use any intermediate vertices.\nDk\ni,j = min(Dk\u22121\ni,j , Dk\u22121\ni,k + Dk\u22121\nk,j ) = min(not using vertex k, using vertex k), for k \u22650.\nThis DP formulation must be \ufb01lled layer by layer (by increasing k). To \ufb01ll out an entry in\nthe table k, we make use of the entries in the table k-1. For example, to calculate D2\n3,4, (row\n3, column 4, in table k = 2, index start from 0), we look at the minimum of D1\n3,4 or the\n243\n\n4.5.\nALL-PAIRS SHORTEST PATHS (APSP)\nc\u20ddSteven, Felix, Suhendry\nsum of D1\n3,2 + D1\n2,4 (see Figure 4.27). The na\u00a8\u0131ve implementation is to use a 3-dimensional\nmatrix D[k][i][j] of size O(V 3). However, since to compute layer k we only need to know\nthe values from layer k-1, we can drop dimension k and compute D[i][j] \u2018on-the-\ufb02y\u2019 (see\nthe space saving technique discussed in Section 3.5.1). Thus, Floyd-Warshall algorithm just\nneed O(V 2) space although it still runs in O(V 3).\nFigure 4.27: Floyd-Warshall DP Table\n4.5.3\nOther Applications\nThe main purpose of Floyd-Warshall is to solve the APSP problem.", "mimetype": "text/plain", "start_char_idx": 712327, "end_char_idx": 715086, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b37734f1-1a9b-4530-aa5c-74f0364f41f5": {"__data__": {"id_": "b37734f1-1a9b-4530-aa5c-74f0364f41f5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2ccc1970-bb12-46ad-a341-d9d54f45fa00", "node_type": "1", "metadata": {}, "hash": "ee78bae5c73543b95381704c4d1b75c0ec117b61fdb9258aea33780db3d5c2c1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7601a4c3-90b8-4fa4-ac73-5ba24aba0b49", "node_type": "1", "metadata": {}, "hash": "b012f46567bf771825bb7a7a5473d3ab1b721bed65e44fbaa82734b7f91c1188", "class_name": "RelatedNodeInfo"}}, "text": "The na\u00a8\u0131ve implementation is to use a 3-dimensional\nmatrix D[k][i][j] of size O(V 3). However, since to compute layer k we only need to know\nthe values from layer k-1, we can drop dimension k and compute D[i][j] \u2018on-the-\ufb02y\u2019 (see\nthe space saving technique discussed in Section 3.5.1). Thus, Floyd-Warshall algorithm just\nneed O(V 2) space although it still runs in O(V 3).\nFigure 4.27: Floyd-Warshall DP Table\n4.5.3\nOther Applications\nThe main purpose of Floyd-Warshall is to solve the APSP problem. However, Floyd-Warshall\nis frequently used in other problems too, as long as the input graph is small. Here we list\ndown several problem variants that are also solvable with Floyd-Warshall.\nSolving the SSSP Problem on a Small (Weighted) Graph\nIf we have the All-Pairs Shortest Paths (APSP) information, we also know the Single-\nSource Shortest Paths (SSSP) information from any possible source. If the given (weighted)\ngraph is small V \uf8ff450, it may be bene\ufb01cial, in terms of coding time, to use the four-\nliner Floyd-Warshall code rather than the longer BFS algorithm (for unweighted graph) or\nDijkstra\u2019s/Bellman-Ford algorithms (for weighted graph).\nPrinting the Shortest Paths\nA common issue encountered by programmers who use the four-liner Floyd-Warshall with-\nout understanding how it works is when they are asked to print the shortest paths too.\nIn BFS/Dijkstra\u2019s/Bellman-Ford/SPFA algorithms, we just need to remember the shortest\npaths spanning tree by using a 1D vi p to store the parent information for each vertex. In\nFloyd-Warshall, we need to store a 2D parent matrix. The modi\ufb01ed code is shown below.\n// inside int main()\n// let p be a 2D parent matrix, where p[i][j] is the last vertex before j\n// on a shortest path from u to v, i.e., i -> ... -> p[i][j] -> j\nfor (int i = 0; i < V; ++i)\nfor (int i = 0; j < V; ++j)\np[i][j] = i;\n// initialization\nfor (int k = 0; k < V; ++k)\nfor (int i = 0; i < V; ++i)\nfor (int j = 0; j < V; ++j)\nif (AM[i][k]+AM[k][j] < AM[i][j]) {\n// use if statement\nAM[i][j] = AM[i][k]+AM[k][j];\np[i][j] = p[k][j];\n// update the p matrix\n}\n// when we need to print the shortest paths, we can call the method below:\n244\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nvoid printPath(int i, int j) {\nif (i != j) printPath(i, p[i][j]);\nprintf(\" %d\", v);\n}\nTransitive Closure (Warshall\u2019s Algorithm)\nStephen Warshall [60] developed an algorithm for the Transitive Closure problem: Given a\ngraph, determine if vertex i is connected to j, directly or indirectly. This variant uses logical\nbitwise operators which is (much) faster than arithmetic operators.\nInitially, AM[i][j]\ncontains 1 (true) if vertex i is directly connected to vertex j, 0 (false) otherwise. After\nrunning O(V 3) Warshall\u2019s algorithm below, we can check if any two vertices i and j are\ndirectly or indirectly connected by checking AM[i][j].\nfor (int k = 0; k < V; ++k)\nfor (int i = 0; i < V; ++i)\nfor (int j = 0; j < V; ++j)\nAM[i][j] |= (AM[i][k] & AM[k][j]);\nMiniMax and MaxiMin (Revisited)\nWe have seen the MiniMax (and MaxiMin) path problem earlier in Section 4.3.4.\nThe\nsolution using Floyd-Warshall is shown below. First, initialize AM[i][j] to be the weight of\nedge (i, j). This is the default MiniMax cost for two vertices that are directly connected.\nFor pair (i, j) without any direct edge, set AM[i][j] = INF.", "mimetype": "text/plain", "start_char_idx": 714587, "end_char_idx": 717903, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7601a4c3-90b8-4fa4-ac73-5ba24aba0b49": {"__data__": {"id_": "7601a4c3-90b8-4fa4-ac73-5ba24aba0b49", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b37734f1-1a9b-4530-aa5c-74f0364f41f5", "node_type": "1", "metadata": {}, "hash": "a9bec5bf0bbad5d94f32906e4c0cc51054d377c0b10109dc7029f32b33561171", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6cf9c5c8-a429-4b8e-b762-9c079b356f8a", "node_type": "1", "metadata": {}, "hash": "503a04794966593baf583a4292c0354f53b78b96ed17115f1bdbcc84357275e9", "class_name": "RelatedNodeInfo"}}, "text": "for (int k = 0; k < V; ++k)\nfor (int i = 0; i < V; ++i)\nfor (int j = 0; j < V; ++j)\nAM[i][j] |= (AM[i][k] & AM[k][j]);\nMiniMax and MaxiMin (Revisited)\nWe have seen the MiniMax (and MaxiMin) path problem earlier in Section 4.3.4.\nThe\nsolution using Floyd-Warshall is shown below. First, initialize AM[i][j] to be the weight of\nedge (i, j). This is the default MiniMax cost for two vertices that are directly connected.\nFor pair (i, j) without any direct edge, set AM[i][j] = INF. Then, we try all possible\nintermediate vertex k. The MiniMax cost AM[i][j] is the minimum of either (itself) or (the\nmaximum between AM[i][k] or AM[k][j]). This approach can only be used if V \uf8ff450.\nfor (int k = 0; k < V; ++k)\nfor (int i = 0; i < V; ++i)\n// reverse min and max\nfor (int j = 0; j < V; ++j)\n// for MaxiMin problem\nAM[i][j] = min(AM[i][j], max(AM[i][k], AM[k][j]));\nFinding the (Cheapest/Negative) Cycle\nIn Section 4.4.4, we have seen how Bellman-Ford terminates after O(V E) steps regardless of\nthe type of input graph (as it relax all E edges at most V -1 times) and how Bellman-Ford\ncan be used to check if the given graph has negative cycle. Floyd-Warshall also terminates\nafter O(V 3) steps regardless of the type of input graph. This feature allows Floyd-Warshall\nto be used to detect whether the (small) graph has a cycle, a negative cycle, and even \ufb01nding\nthe cheapest (non-negative) cycle among all possible cycles (the girth of the graph).\nTo do this, we initially set the main diagonal of the Adjacency Matrix to have a very\nlarge value, i.e., AM[i][i] = INF (1B). Then, we run the O(V 3) Floyd-Warshall algorithm.\nNow, we check the value of AM[i][i], which now means the shortest cyclic path weight\nstarting from vertex i that goes through up to V -1 other intermediate vertices and returns\nback to i. If AM[i][i] is no longer INF for any i 2 [0..V-1], then we have a cycle. The\nsmallest non-negative AM[i][i], 8i 2 [0..V-1] is the cheapest cycle. If AM[i][i] < 0 for\nany i 2 [0..V-1], then we have a negative cycle because if we take this cyclic path one\nmore time, we will get an even shorter \u2018shortest\u2019 path.\n245\n\n4.5.\nALL-PAIRS SHORTEST PATHS (APSP)\nc\u20ddSteven, Felix, Suhendry\nFinding the Diameter of a Graph\nThe diameter of a graph is de\ufb01ned as the maximum shortest path distance between any pair\nof vertices of that graph. To \ufb01nd the diameter of a graph, we \ufb01rst \ufb01nd the shortest path\nbetween each pair of vertices (i.e., the APSP problem). The maximum distance found is the\ndiameter of the graph. UVa 01056 - Degrees of Separation, which is an ICPC World Finals\nproblem in 2006, is precisely this problem. To solve this problem, we can \ufb01rst run an O(V 3)\nFloyd-Warshall to compute the required APSP information. Then, we can \ufb01gure out what\nis the diameter of the graph by \ufb01nding the maximum value in the APSP-processed AM in\nO(V 2). However, we can only do this for a small graph with V \uf8ff450.\nFinding the SCCs of a Directed Graph\nIn Section 4.2.2, we have learned how the O(V +E) Tarjan\u2019s algorithm can be used to identify\nthe SCCs of a directed graph. However, the code is a bit long.", "mimetype": "text/plain", "start_char_idx": 717425, "end_char_idx": 720520, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6cf9c5c8-a429-4b8e-b762-9c079b356f8a": {"__data__": {"id_": "6cf9c5c8-a429-4b8e-b762-9c079b356f8a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7601a4c3-90b8-4fa4-ac73-5ba24aba0b49", "node_type": "1", "metadata": {}, "hash": "b012f46567bf771825bb7a7a5473d3ab1b721bed65e44fbaa82734b7f91c1188", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "67d6d349-d8fc-4870-bda8-36b410558650", "node_type": "1", "metadata": {}, "hash": "7e2f56215a09c12ef065f4375d937f1aeee23f3df89a224aaccfc13a484b3335", "class_name": "RelatedNodeInfo"}}, "text": "The maximum distance found is the\ndiameter of the graph. UVa 01056 - Degrees of Separation, which is an ICPC World Finals\nproblem in 2006, is precisely this problem. To solve this problem, we can \ufb01rst run an O(V 3)\nFloyd-Warshall to compute the required APSP information. Then, we can \ufb01gure out what\nis the diameter of the graph by \ufb01nding the maximum value in the APSP-processed AM in\nO(V 2). However, we can only do this for a small graph with V \uf8ff450.\nFinding the SCCs of a Directed Graph\nIn Section 4.2.2, we have learned how the O(V +E) Tarjan\u2019s algorithm can be used to identify\nthe SCCs of a directed graph. However, the code is a bit long. If the input graph is small\n(e.g., UVa 00247 - Calling Circles, UVa 01229 - Sub-dictionary, UVa 10731 - Test), we can\nalso identify the SCCs of the graph in O(V 3) using Warshall\u2019s transitive closure algorithm\nand then use the following check: to \ufb01nd all members of an SCC that contains vertex i,\ncheck all other vertices j 2 [0..V-1]. If AM[i][j] && AM[j][i] is true, then both vertex\ni and j belong to the same SCC.\nExercise 4.5.3.1: How to \ufb01nd the transitive closure of a graph with V \uf8ff1000, E \uf8ff100 000?\nSuppose that there are only Q (1 \uf8ffQ \uf8ff100) transitive closure queries for this problem in\nform of this question: is vertex u connected to vertex v, directly or indirectly? What if the\ninput graph is directed? Does this directed property simplify the problem?\nExercise 4.5.3.2: Arbitrage is the trading of one currency for another with the hopes\nof taking advantage of small di\u21b5erences in conversion rates among several currencies in\norder to achieve a pro\ufb01t. For example (UVa 00436 - Arbitrage (II)): if 1.0 United States\ndollar (USD) buys 0.5 British pounds (GBP), 1.0 GBP buys 10.0 French francs (FRF24),\nand 1.0 FRF buys 0.21 USD, then an arbitrage trader can start with 1.0 USD and buy\n1.0 \u21e50.5 \u21e510.0 \u21e50.21 = 1.05 USD thus earning a pro\ufb01t of 5 percent. This problem is\nactually a problem of \ufb01nding a pro\ufb01table cycle. It is akin to the problem of \ufb01nding cycle\nwith Floyd-Warshall shown in this section. Solve this problem using Floyd-Warshall!\nExercise 4.5.3.3*: How to solve Some-Pairs Shortest Paths problem faster than O(V 3) if\nthe graph has non-negative weight edges and we only need Shortest Paths information from\nK (1 \uf8ffK < V/(log V )) independent source vertices to V other vertices?\nExercise 4.5.3.4*: Show how to solve the APSP problem faster than O(V 3) if the weighted\ngraph can have some negative weight edges but it is sparse, i.e., E = O(V ).\n4.5.4\nAPSP in Programming Contests\nVarious algorithms on weighted graphs discussed in Section 4.4: Dijkstra\u2019s (two versions),\nBellman-Ford (or its SPFA improvement), plus one more algorithm in this section: Floyd-\nWarshall can actually be used to solve the Single-Source Shortest Paths (SSSP) problem\ndiscussed in the previous Section 4.4, but each with its own terms and conditions.\nIn order to help the readers in deciding which algorithm to choose depending on various\ngraph criteria, we present a Shortest Paths algorithm decision table within the context of\n24At the moment (year 2020), France actually uses Euro as its currency.\n246\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nprogramming contest in Table 4.4. The terminologies used are as follows: \u2018Best\u2019 ! the\nmost suitable algorithm; \u2018Ok\u2019 ! a correct algorithm but not the best; \u2018Bad\u2019 ! a (very)\nslow algorithm; \u2018WA\u2019 ! an incorrect algorithm; and \u2018Overkill\u2019 ! a correct algorithm but\nunnecessary.", "mimetype": "text/plain", "start_char_idx": 719875, "end_char_idx": 723344, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "67d6d349-d8fc-4870-bda8-36b410558650": {"__data__": {"id_": "67d6d349-d8fc-4870-bda8-36b410558650", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6cf9c5c8-a429-4b8e-b762-9c079b356f8a", "node_type": "1", "metadata": {}, "hash": "503a04794966593baf583a4292c0354f53b78b96ed17115f1bdbcc84357275e9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bea0a649-6bb3-4d32-b387-6702794f15ae", "node_type": "1", "metadata": {}, "hash": "3873ef5bc0ad1b626db1eea16098abab690d8c7606bb69efeba124b93d76c4fe", "class_name": "RelatedNodeInfo"}}, "text": "In order to help the readers in deciding which algorithm to choose depending on various\ngraph criteria, we present a Shortest Paths algorithm decision table within the context of\n24At the moment (year 2020), France actually uses Euro as its currency.\n246\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nprogramming contest in Table 4.4. The terminologies used are as follows: \u2018Best\u2019 ! the\nmost suitable algorithm; \u2018Ok\u2019 ! a correct algorithm but not the best; \u2018Bad\u2019 ! a (very)\nslow algorithm; \u2018WA\u2019 ! an incorrect algorithm; and \u2018Overkill\u2019 ! a correct algorithm but\nunnecessary. Assumption: Max 100M operations in \u21e11s time limit, 1 test case only.\nGraph\nBFS\nDijkstra\u2019s\nBellman-Ford\nFloyd-Warshall\nCriteria\nO(V + E)\nO((V +E) log V )\nO(V E)\nO(V 3)\nMax Size\nV + E \uf8ff100M\nV + E \uf8ff1M\nV E \uf8ff100M\nV \uf8ff450\nUnweighted\nBest\nOk\nBad\nBad in general\nWeighted\nWA\nBest\nOk\nBad in general\nNegative weight\nWA\nModi\ufb01ed Ok\nOk\nBad in general\nNegative cycle\nCannot detect\nCannot detect\nCan detect\nCan detect\nSmall graph\nWA if weighted\nOverkill\nOverkill\nBest\nTable 4.4: Shortest Paths Algorithm Decision Table\nFrom Table 4.4, we can see that when the given weighted graph is small (V \uf8ff450)\u2014which\nhappens quite often in the past (less so recently), it is clear from this section that the O(V 3)\nFloyd-Warshall is the best way to go.\nWe can think of two possible reasons on why Floyd-Warshall algorithm can be used in\nprogramming contests despite its high time complexity. The obvious reason is the fact that\nthe given shortest path problem requires shortest path information between many (up to all)\npairs, not just from one source to the rest.\nThe less obvious reason is because shortest paths is a sub-problem of the main, (much)\nmore complex, problem.\nTo make the (hard) problem still doable during contest time,\nthe problem author purposely sets the input size to be small so that the shortest paths\nsub-problem is solvable with the four liner Floyd-Warshall (e.g., UVa 10171, 10793, 11463,\nKattis - transportationplanning). A non-competitive programmer will take longer route to\ndeal with this sub-problem.\nWhat\u2019s Next?\nWe will discuss shortest path problems a few more time in this book, e.g., in Section 4.6.1\n(shortest paths on Tree, on DAG), and in Book 2 (State-Space Search).\nPro\ufb01le of Algorithm Inventors\nRichard Ernest Bellman (1920-1984) was an American applied mathematician. Other\nthan inventing the Bellman-Ford algorithm for \ufb01nding shortest paths in graphs that have\nnegative weighted edges (and possibly negative weight cycle), Richard Bellman is more well\nknown by his invention of the Dynamic Programming technique in 1953.\nLester Randolph Ford, Jr. (1927-2017) was an American mathematician specializing in\nnetwork \ufb02ow problems. Ford\u2019s 1956 paper with Fulkerson on the max \ufb02ow problem and the\nFord-Fulkerson method for solving it, established the max-\ufb02ow min-cut theorem.\nRobert W Floyd (1936-2001) was an eminent American computer scientist. Floyd\u2019s con-\ntributions include the design of Floyd\u2019s algorithm [15] that \ufb01nds all shortest paths in a\ngraph. Floyd worked closely with Donald Ervin Knuth, in particular as the major reviewer\nfor Knuth\u2019s \u2018The Art of Computer Programming\u2019 book. Floyd also invented the faster O(n)\nbuild heap routine from an unsorted array.\n247\n\n4.5.\nALL-PAIRS SHORTEST PATHS (APSP)\nc\u20ddSteven, Felix, Suhendry\nProgramming Exercises for Floyd-Warshall algorithm:\na. Floyd-Warshall Standard Application (for APSP or SSSP on small graph)\n1. Entry Level: UVa 00821 - Page Hopping * (LA 5221 - WorldFinals\nOrlando00; one of the easiest ICPC WorldFinals problem)\n2.", "mimetype": "text/plain", "start_char_idx": 722772, "end_char_idx": 726341, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bea0a649-6bb3-4d32-b387-6702794f15ae": {"__data__": {"id_": "bea0a649-6bb3-4d32-b387-6702794f15ae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "67d6d349-d8fc-4870-bda8-36b410558650", "node_type": "1", "metadata": {}, "hash": "7e2f56215a09c12ef065f4375d937f1aeee23f3df89a224aaccfc13a484b3335", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c2aa1c65-2c93-4d7a-9c3a-aa645b1ea611", "node_type": "1", "metadata": {}, "hash": "67d225cade84508b3f0cd25467bfe1854faa630a54396b5fc2aadb67167751d0", "class_name": "RelatedNodeInfo"}}, "text": "Floyd\u2019s con-\ntributions include the design of Floyd\u2019s algorithm [15] that \ufb01nds all shortest paths in a\ngraph. Floyd worked closely with Donald Ervin Knuth, in particular as the major reviewer\nfor Knuth\u2019s \u2018The Art of Computer Programming\u2019 book. Floyd also invented the faster O(n)\nbuild heap routine from an unsorted array.\n247\n\n4.5.\nALL-PAIRS SHORTEST PATHS (APSP)\nc\u20ddSteven, Felix, Suhendry\nProgramming Exercises for Floyd-Warshall algorithm:\na. Floyd-Warshall Standard Application (for APSP or SSSP on small graph)\n1. Entry Level: UVa 00821 - Page Hopping * (LA 5221 - WorldFinals\nOrlando00; one of the easiest ICPC WorldFinals problem)\n2. UVa 01247 - Interstar Transport * (LA 4524 - Hsinchu09; Floyd-Warshall\nwith modi\ufb01cation: prefer shortest path with less intermediate vertices)\n3. UVa 10354 - Avoiding Your Boss * (\ufb01nd and remove edges involved in\nboss\u2019s shortest paths; re-run shortest paths from home to market)\n4. UVa 11463 - Commandos * (solution is easy with APSP information)\n5. Kattis - allpairspath * (basic Floyd-Warshall; tricky negative cycle checks)\n6. Kattis - importspaghetti * (smallest cycle; print path by breaking the self-loop\ninto i - other vertex j - i)\n7. Kattis - transportationplanning * (APSP; FW; for each unused edge, use it\nand see how much distance is reduced; get minimum; O(n4))\nExtra UVa: 00341, 00567, 01233 10171, 10525, 10724, 10793, 10803, 10947,\n11015, 12319, 13249.\nExtra Kattis: hotels, slowleak.\nb. Variants\n1. Entry Level: UVa 01056 - Degrees of ...\n* (LA 3569 - WorldFinals\nSanAntonio06; \ufb01nding diameter of a small graph with Floyd-Warshall)\n2. UVa 00869 - Airline Comparison * (run Warshall\u2019s 2x on di\u21b5erent graph;\ncompare the two Adjacency Matrices)\n3. UVa 10342 - Always Late * (Floyd-Warshall to get APSP values; to get\nthe second best shortest path, try to make a single mistake)\n4. UVa 10987 - Anti\ufb02oyd * (creative usage of Floyd-Warshall algorithm; if\nwe can detour without increasing cost, then delete the direct edge)\n5. Kattis - arbitrage * (arbitrage problem; similar to UVa 00104 and 00436)\n6. Kattis - kastenlauf * (n \uf8ff100; Warshall\u2019s transitive closure problem)\n7. Kattis - secretchamber * (LA 8047 - WorldFinals RapidCity17; Warshall\u2019s\ntransitive closure; also available at UVa 01757 - Secret Chamber ...)\nExtra UVa: 00104, 00125, 00186, 00274, 00334, 00436, 00925, 01198, 10246,\n10331, 10436, 11047.\nExtra Kattis: assembly, isahasa.\nAlso see: Floyd-Warshall used as sub-routine of more complex problems in\nBook 2 (section about Problem Decomposition).\nPro\ufb01le of Algorithm Inventor\nStephen Warshall (1935-2006) was a computer scientist who invented the transitive\nclosure algorithm, now known as Warshall\u2019s algorithm [60]. This algorithm was later\nnamed as Floyd-Warshall as Floyd independently invented essentially similar algorithm.\n248\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.6\nSpecial Graphs\nSome basic graph problems have simpler/faster polynomial algorithms if the given graph is\nspecial. Based on our experience, we have identi\ufb01ed the following four25 special graphs that\ncommonly appear in programming contests (in decreasing estimated frequency): Directed\nAcyclic Graph (DAG), Tree, Bipartite Graph, and Eulerian Graph. Problem au-\nthors may force the contestants to use specialized algorithms for these special graphs by\ngiving a large input size to judge a correct algorithm for general graph as Time Limit Ex-\nceeded (TLE) (see a survey by [17]).", "mimetype": "text/plain", "start_char_idx": 725701, "end_char_idx": 729128, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c2aa1c65-2c93-4d7a-9c3a-aa645b1ea611": {"__data__": {"id_": "c2aa1c65-2c93-4d7a-9c3a-aa645b1ea611", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bea0a649-6bb3-4d32-b387-6702794f15ae", "node_type": "1", "metadata": {}, "hash": "3873ef5bc0ad1b626db1eea16098abab690d8c7606bb69efeba124b93d76c4fe", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a93e5b70-9208-4de1-9529-c0fd4780f777", "node_type": "1", "metadata": {}, "hash": "de28142637cc8fa15baa2b6d9044095fb87664a1a7db70f655b435fdb21a43b2", "class_name": "RelatedNodeInfo"}}, "text": "This algorithm was later\nnamed as Floyd-Warshall as Floyd independently invented essentially similar algorithm.\n248\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.6\nSpecial Graphs\nSome basic graph problems have simpler/faster polynomial algorithms if the given graph is\nspecial. Based on our experience, we have identi\ufb01ed the following four25 special graphs that\ncommonly appear in programming contests (in decreasing estimated frequency): Directed\nAcyclic Graph (DAG), Tree, Bipartite Graph, and Eulerian Graph. Problem au-\nthors may force the contestants to use specialized algorithms for these special graphs by\ngiving a large input size to judge a correct algorithm for general graph as Time Limit Ex-\nceeded (TLE) (see a survey by [17]). In this section, we discuss some popular graph problems\non these special graphs (see Figure 4.28)\u2014many of which have been discussed earlier on gen-\neral graphs. Note that at the time of writing (year 2020), all four special graphs discussed\nin this section are included in the IOI syllabus [16].\nFigure 4.28: Special Graphs (L-to-R): DAG, Tree, Bipartite Graph, Eulerian Graph\n4.6.1\nDirected Acyclic Graph\nA Directed Acyclic Graph (DAG) is a special graph with the following characteristics: di-\nrected and has no cycle. DAG guarantees the absence of cycle by de\ufb01nition. This makes\nproblems that can be modeled as a DAG very suitable to be solved with Dynamic Program-\nming (DP) techniques (see Section 3.5). After all, a DP recurrence must be acyclic. We can\nview DP states as vertices in an implicit DAG and the acyclic transitions between DP states\nas directed edges of that implicit DAG. Topological sort of this DAG (see Section 4.2.6)\nallows each overlapping sub-problem (subgraph of the DAG) to be processed just once.\n(Single-Source) Shortest/Longest Paths on DAG\nThe Single-Source Shortest Paths (SSSP) problem becomes much simpler if the given graph\nis a DAG. This is because a DAG has at least one topological order! We can use an O(V +E)\ntopological sort algorithm in Section 4.2.6 to \ufb01nd one such topological order, then relax the\noutgoing edges of these vertices according to this order. The topological order will ensure\nthat if we have a vertex Y that has an incoming edge from a vertex X, then vertex Y is\nrelaxed after vertex X has obtained the correct shortest distance value. Thus, the shortest\ndistance value propagation is correct with just one O(V + E) linear pass! This is also the\nessence of the Dynamic Programming (DP) principle to avoid re-computation of overlapping\nsub-problems in Section 3.5. When we compute bottom-up DP, we essentially \ufb01ll the DP\ntable using the topological order of the underlying implicit DAG of DP recurrences.\nThe (Single-Source)26 Longest Paths problem is a problem of \ufb01nding the longest (sim-\nple27) paths from a starting vertex s to other vertices. The decision version of this problem\n25There are a few other rare special graphs (see Section 4.6.5).\n26Actually this can be multi-sources, as we can start from any vertex with 0 incoming degree.\n27On general graph with positive weighted edges, the longest path problem is ill-de\ufb01ned as one can take a\n249\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\nis NP-complete on a general graph28. However, the problem is again easy if the graph has\nno cycle, which is true in a DAG. The solution for the Longest Paths on DAG29 is just a\nminor tweak from the DP solution for the SSSP on DAG, as shown above. One technique is\nto multiply all edge weights by -1 and run the same SSSP solution as above. Finally, negate\nthe resulting values to get the actual results.\nThe Longest Paths on DAG has applications in project scheduling, e.g., UVa 00452 -\nProject Scheduling about Project Evaluation and Review Technique (PERT). We can model\nsub projects dependency as a DAG and the time needed to complete a sub project as vertex\nweight. The shortest possible time to \ufb01nish the entire project is determined by the longest\npath in this DAG (a.k.a. the critical path) that starts from any vertex (sub project) with\n0 incoming degree.", "mimetype": "text/plain", "start_char_idx": 728387, "end_char_idx": 732451, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a93e5b70-9208-4de1-9529-c0fd4780f777": {"__data__": {"id_": "a93e5b70-9208-4de1-9529-c0fd4780f777", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c2aa1c65-2c93-4d7a-9c3a-aa645b1ea611", "node_type": "1", "metadata": {}, "hash": "67d225cade84508b3f0cd25467bfe1854faa630a54396b5fc2aadb67167751d0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bdd83ef0-09f0-4f91-a6b2-f797268f2753", "node_type": "1", "metadata": {}, "hash": "1cb4e1d8f9d2733a93ce1f6d5dc551da08d9e441f6ea7b1fa3c7349be7b3fe59", "class_name": "RelatedNodeInfo"}}, "text": "However, the problem is again easy if the graph has\nno cycle, which is true in a DAG. The solution for the Longest Paths on DAG29 is just a\nminor tweak from the DP solution for the SSSP on DAG, as shown above. One technique is\nto multiply all edge weights by -1 and run the same SSSP solution as above. Finally, negate\nthe resulting values to get the actual results.\nThe Longest Paths on DAG has applications in project scheduling, e.g., UVa 00452 -\nProject Scheduling about Project Evaluation and Review Technique (PERT). We can model\nsub projects dependency as a DAG and the time needed to complete a sub project as vertex\nweight. The shortest possible time to \ufb01nish the entire project is determined by the longest\npath in this DAG (a.k.a. the critical path) that starts from any vertex (sub project) with\n0 incoming degree. See Figure 4.29 for an example with 6 sub projects, their estimated\ncompletion time units, and their dependencies. The longest path 0 ! 1 ! 2 ! 4 ! 5 with\n16 time units determines the shortest possible time to \ufb01nish the whole project. In order to\nachieve this, all sub projects along the longest (critical) path must be on time.\nFigure 4.29: The Longest Path on this DAG\nCounting Paths in DAG\nAbridged problem description of UVa 00988 - Many paths, one destination: In life, one has\nmany paths to choose, leading to many di\u21b5erent lives. Enumerate how many di\u21b5erent lives\none can live, given a speci\ufb01c set of choices at each point in time. One is given a list of events,\nand a number of choices that can be selected, for each event. The objective is to count how\nmany ways to go from the event that started it all (birth, index 0) to an event where one\nhas no further choices (that is, death, index n).\nFigure 4.30: Example of Counting Paths in DAG - Bottom-Up\npositive cycle and use that cycle to create an in\ufb01nitely long path. This is the same issue as the negative cycle\nin shortest path problem. That is why for general graph, we use the term: \u2018longest simple path problem\u2019.\nAll paths in DAG are simple by de\ufb01nition so we can just use the term \u2018longest path problem\u2019.\n28The decision version of this problem asks if the general graph has a simple path of total weight \u2265k.\n29The LIS problem in Section 3.5.2 can also be modeled as \ufb01nding the Longest Paths on implicit DAG.\n250\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nClearly the underlying graph of the problem above is a DAG as one can move forward in\ntime, but cannot go backward. The number of such paths can be found easily by computing\none (any) topological order in O(V + E) (in this problem, vertex 0/birth will always be the\n\ufb01rst in the topological order and the vertex n/death will always be the last in the topological\norder). We start by setting num paths[0] = 1. Then, we process the remaining vertices\none by one according to the topological order. When processing a vertex u, we update each\nneighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps,\nwe will know the number of paths in num paths[n]. Figure 4.30 shows an example with 9\nevents and eventually 6 di\u21b5erent possible life scenarios.\nBottom-Up versus Top-Down Implementations\nBefore we continue, we want to remark that all three solutions for shortest/longest/counting\npaths on/in DAG above are Bottom-Up DP solutions. We start from known base case(s)\n(the source vertex/vertices) and then we use topological order of the DAG to propagate the\ncorrect information to neighboring vertices without ever needing to backtrack.\nWe have seen in Section 3.5 that DP can also be written in Top-Down fashion.", "mimetype": "text/plain", "start_char_idx": 731625, "end_char_idx": 735204, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bdd83ef0-09f0-4f91-a6b2-f797268f2753": {"__data__": {"id_": "bdd83ef0-09f0-4f91-a6b2-f797268f2753", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a93e5b70-9208-4de1-9529-c0fd4780f777", "node_type": "1", "metadata": {}, "hash": "de28142637cc8fa15baa2b6d9044095fb87664a1a7db70f655b435fdb21a43b2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aa5f738b-bb9f-401a-8d87-c88c357515b3", "node_type": "1", "metadata": {}, "hash": "deaa82f521707a61b9e2c4a534c42b5a75dd856da102122efd30e425d7c2eeb9", "class_name": "RelatedNodeInfo"}}, "text": "Then, we process the remaining vertices\none by one according to the topological order. When processing a vertex u, we update each\nneighbor v of u by setting num paths[v] += num paths[u]. After such O(V + E) steps,\nwe will know the number of paths in num paths[n]. Figure 4.30 shows an example with 9\nevents and eventually 6 di\u21b5erent possible life scenarios.\nBottom-Up versus Top-Down Implementations\nBefore we continue, we want to remark that all three solutions for shortest/longest/counting\npaths on/in DAG above are Bottom-Up DP solutions. We start from known base case(s)\n(the source vertex/vertices) and then we use topological order of the DAG to propagate the\ncorrect information to neighboring vertices without ever needing to backtrack.\nWe have seen in Section 3.5 that DP can also be written in Top-Down fashion. Using\nUVa 00988 as an illustration, we can also write the DP solution as follows: let numPaths(i)\nbe the number of paths starting from vertex i to destination n. We can write the solution\nusing these Complete Search recurrence relations:\n1. numPaths(n) = 1 // at destination n, there is only one possible path\n2. numPaths(i) = P\nj numPaths(j), 8j adjacent to i\nTo avoid re-computations, we memoize the number of paths for each vertex i. There are\nO(V ) distinct vertices (states) and each vertex is only processed once. There are O(E) edges\nand each edge is also visited at most once. Therefore the time complexity of this Top-Down\napproach is also O(V + E), same as the Bottom-Up approach shown earlier. Figure 4.31\nshows the similar DAG but the values are computed from destination to source (follow the\ndotted back arrows). Compare this Figure 4.31 with the previous Figure 4.30 where the\nvalues are computed from source to destination.\nFigure 4.31: Example of Counting Paths in DAG - Top-Down\nConverting General Graph to DAG\nIn the more challenging contest problems, the given graph in the problem statement is not\nan explicit DAG. However, after further understanding, the given graph can be modeled as\na DAG if we add one (or more) parameter(s). Once you have the DAG, the next step is\nto apply Dynamic Programming technique (either Top-Down or Bottom-Up). We illustrate\nthis concept with an example problem.\n251\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\nSPOJ FISHER - Fishmonger\nAbridged problem statement: Given the number of cities 3 \uf8ffn \uf8ff50, available time 1 \uf8fft \uf8ff\n1000, and two n \u21e5n matrices (one gives travel times and another gives tolls between two\ncities), choose a route from the port city (vertex 0) in such a way that the \ufb01shmonger has to\npay as little tolls as possible to arrive at the market city (vertex n-1) within a certain time\nt. The \ufb01shmonger does not have to visit all cities. Output two information: The total tolls\nthat is actually used and the actual traveling time. See Figure 4.32\u2014left, for the original\ninput graph of this problem.\nNotice that there are two potentially con\ufb02icting requirements in this problem. The \ufb01rst\nrequirement is to minimize tolls along the route. The second requirement is to ensure that\nthe \ufb01shmonger arrive in the market city within allocated time, which may cause him to pay\nhigher tolls in some part along the path. The second requirement is a hard constraint for\nthis problem. That is, we must satisfy it, otherwise we do not have a solution.\nFigure 4.32: The Given General Graph (left) is Converted to DAG\nGreedy SSSP algorithm like Dijkstra\u2019s (see Section 4.4.3)\u2014on its pure form\u2014does not work\nfor this problem. Picking a path with the shortest travel time to help the \ufb01shmonger to\narrive at market city n-1 using time \uf8fft may not lead to the smallest possible tolls. Picking\npath with the cheapest tolls may not ensure that the \ufb01shmonger arrives at market city n-1\nusing time \uf8fft. These two requirements are not independent!\nHowever, if we attach a parameter: t left (time left) to each vertex, then the given\ngraph turns into a DAG as shown in Figure 4.32\u2014right.", "mimetype": "text/plain", "start_char_idx": 734382, "end_char_idx": 738334, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "aa5f738b-bb9f-401a-8d87-c88c357515b3": {"__data__": {"id_": "aa5f738b-bb9f-401a-8d87-c88c357515b3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bdd83ef0-09f0-4f91-a6b2-f797268f2753", "node_type": "1", "metadata": {}, "hash": "1cb4e1d8f9d2733a93ce1f6d5dc551da08d9e441f6ea7b1fa3c7349be7b3fe59", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5269fb2e-a072-416b-80a1-a59a72e544fc", "node_type": "1", "metadata": {}, "hash": "bffed1158c15dcd6bfcdbd09f3684ae89da55323cbccb3af51d50a30fdcab55f", "class_name": "RelatedNodeInfo"}}, "text": "That is, we must satisfy it, otherwise we do not have a solution.\nFigure 4.32: The Given General Graph (left) is Converted to DAG\nGreedy SSSP algorithm like Dijkstra\u2019s (see Section 4.4.3)\u2014on its pure form\u2014does not work\nfor this problem. Picking a path with the shortest travel time to help the \ufb01shmonger to\narrive at market city n-1 using time \uf8fft may not lead to the smallest possible tolls. Picking\npath with the cheapest tolls may not ensure that the \ufb01shmonger arrives at market city n-1\nusing time \uf8fft. These two requirements are not independent!\nHowever, if we attach a parameter: t left (time left) to each vertex, then the given\ngraph turns into a DAG as shown in Figure 4.32\u2014right. We start with a vertex (port, t)\nin the DAG. Every time the \ufb01shmonger moves from a current city cur to another city X,\nwe move to a modi\ufb01ed vertex (X, t left-travelTime[cur][X]) in the DAG via edge with\nweight toll[cur][X]. As time is a diminishing resource, we will never encounter a cyclic\nsituation. We can then use this (Top-Down) DP recurrence: dp(cur, t left) to \ufb01nd the\nshortest path (in terms of total tolls paid) on this DAG. The answer can be found by calling\ndp(0, t). The C++ code of dp(cur, t left) is shown in the next page.\nNotice that by using Top-Down DP, we do not have to explicitly build the DAG and\ncompute the required topological order. The recursion will do these steps for us. There are\nonly O(nt) distinct states (notice that the memo table is a pair object). Each state can be\ncomputed in O(n). The overall time complexity is thus O(n2t)\u2014do-able.\n252\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nii dp(int cur, int t_left) {\n// returns a pair\nif (t_left < 0) return {INF, INF};\n// invalid state, prune\nif (cur == n-1) return {0, 0};\n// at market\nif (memo[cur][t_left] != {-1, -1}) return memo[cur][t_left];\nii ans = {INF, INF};\nfor (int X = 0; X < n; ++X)\nif (cur != X) {\n// go to another city\nauto &[tollpaid, timeneeded] = dp(X, t_left-travelTime[cur][X]);\nif (tollpaid+toll[cur][X] < ans.first) {\n// pick the min cost\nans.first\n= tollpaid+toll[cur][X];\nans.second = timeneeded+travelTime[cur][X];\n}\n}\nreturn memo[cur][t_left] = ans;\n// store the answer\n}\nSection 3.5\u2014Revisited\nHere, we want to re-highlight to the readers the strong linkage between DP techniques shown\nin Section 3.5 and algorithms on DAG. Notice that all programming exercises about short-\nest/longest/counting paths on/in DAG (or on general graph that is converted to DAG by\nsome graph modeling/transformation) can also be classi\ufb01ed under DP category. Often when\nwe have a problem with DP solution that \u2018minimizes this\u2019, \u2018maximizes that\u2019, or \u2018counts some-\nthing\u2019, that DP solution actually computes the shortest, the longest, or count the number\nof paths on/in the (usually implicit) DP recurrence DAG of that problem, respectively.\nFigure 4.33: Coin-Change as Shortest Paths on DAG\nWe now invite the readers to revisit some DP problems that we have seen earlier in Section\n3.5 with this likely new viewpoint (viewing DP as algorithms on DAG is not commonly\nfound in other Computer Science textbooks as of year 2020). As a start, we revisit the\nclassic Coin-Change problem. Figure 4.33 shows the same test case used in example 1 of\nCoin-Change subsection in Section 3.5.2. There are n = 2 coin denominations: {1, 5}.\nThe target amount is V = 10. We can model each vertex as the current value. Each vertex\nv has n = 2 unweighted edges that goes to vertex v-1 and v-5 in this test case, unless if it\ncauses the index to go negative.", "mimetype": "text/plain", "start_char_idx": 737647, "end_char_idx": 741163, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5269fb2e-a072-416b-80a1-a59a72e544fc": {"__data__": {"id_": "5269fb2e-a072-416b-80a1-a59a72e544fc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aa5f738b-bb9f-401a-8d87-c88c357515b3", "node_type": "1", "metadata": {}, "hash": "deaa82f521707a61b9e2c4a534c42b5a75dd856da102122efd30e425d7c2eeb9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5c270fad-5bac-4906-b396-bcfb31c83c60", "node_type": "1", "metadata": {}, "hash": "1bcd0c564546c7c441e6853943c6af4b8977fcfb234f9f4a1d08b378443b491a", "class_name": "RelatedNodeInfo"}}, "text": "Figure 4.33: Coin-Change as Shortest Paths on DAG\nWe now invite the readers to revisit some DP problems that we have seen earlier in Section\n3.5 with this likely new viewpoint (viewing DP as algorithms on DAG is not commonly\nfound in other Computer Science textbooks as of year 2020). As a start, we revisit the\nclassic Coin-Change problem. Figure 4.33 shows the same test case used in example 1 of\nCoin-Change subsection in Section 3.5.2. There are n = 2 coin denominations: {1, 5}.\nThe target amount is V = 10. We can model each vertex as the current value. Each vertex\nv has n = 2 unweighted edges that goes to vertex v-1 and v-5 in this test case, unless if it\ncauses the index to go negative. Notice that the graph is a DAG and some states (highlighted\nwith dotted circles) are overlapping (have more than one incoming edges). Now, we can solve\nthis problem by \ufb01nding the shortest path on this DAG from source V = 10 to target V = 0.\nThe easiest topological order is to process the vertices in reverse sorted order, i.e., {10, 9, 8,\n. . . , 1, 0} is a valid topological order. We can de\ufb01nitely use the O(V + E) shortest paths on\nDAG solution. However, since the graph is unweighted, we can also use the O(V + E) BFS\n253\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\nto solve this problem (using Dijkstra\u2019s is also possible but overkill). The path: 10 ! 5 ! 0\nis the shortest with total weight = 2 (or 2 coins needed). Note that for this test case, a\ngreedy solution for Coin-Change happens to also pick the same path: 10 ! 5 ! 0.\nFigure 4.34: 0-1 Knapsack as Longest Paths on DAG\nNext, let\u2019s revisit the classic 0-1 Knapsack Problem.\nThis time we use this test case:\nn = 5, V = {4, 2, 10, 1, 2}, W = {12, 1, 4, 1, 2}, S = 15. We can model each vertex as a pair\nof values (id, remW). Each vertex has at least one edge (id, remW) to (id+1, remW) that\ncorresponds to not taking a certain item id. Some vertices have another edge (id, remW) to\n(id+1, remW-W[id]) if W[id] \uf8ffremW that corresponds to taking a certain item id. Figure\n4.34 shows some parts of the computation DAG of the standard 0-1 Knapsack Problem\nusing the test case above. Notice that some states can be visited with more than one path\n(an overlapping sub-problem is highlighted with a dotted circle). Now, we can solve this\nproblem by \ufb01nding the longest path on this DAG from the source (0, 15) to target (5,\nany). The answer is the following path: (0, 15) ! (1, 15) ! (2, 14) ! (3, 10) !\n(4, 9) ! (5, 7) with value 0 + 2 + 10 + 1 + 2 = 15.\nFigure 4.35: UVa 10943 as Counting Paths in DAG\nLet\u2019s see one more example: The solution for UVa 10943 - How do you add? discussed in\nSection 3.5.3. If we draw the DAG of this test case: n = 3, K = 4, then we have a DAG as\nshown in Figure 4.35. There are overlapping sub-problems highlighted with dotted circles.\nIf we count the number of paths in this DAG, we will indeed \ufb01nd the answer = 20 paths.\n254\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nExercise 4.6.1.1: Earlier in Section 3.5.2, we have de\ufb01ned the basic Coin-Change problem.", "mimetype": "text/plain", "start_char_idx": 740466, "end_char_idx": 743514, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c270fad-5bac-4906-b396-bcfb31c83c60": {"__data__": {"id_": "5c270fad-5bac-4906-b396-bcfb31c83c60", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5269fb2e-a072-416b-80a1-a59a72e544fc", "node_type": "1", "metadata": {}, "hash": "bffed1158c15dcd6bfcdbd09f3684ae89da55323cbccb3af51d50a30fdcab55f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5c150795-2bcf-42c5-8232-9b46b2a508fc", "node_type": "1", "metadata": {}, "hash": "62068a9c2e15f5ad281652e3beb965c58273bc22224e136418388b7f72bf003e", "class_name": "RelatedNodeInfo"}}, "text": "Figure 4.35: UVa 10943 as Counting Paths in DAG\nLet\u2019s see one more example: The solution for UVa 10943 - How do you add? discussed in\nSection 3.5.3. If we draw the DAG of this test case: n = 3, K = 4, then we have a DAG as\nshown in Figure 4.35. There are overlapping sub-problems highlighted with dotted circles.\nIf we count the number of paths in this DAG, we will indeed \ufb01nd the answer = 20 paths.\n254\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nExercise 4.6.1.1: Earlier in Section 3.5.2, we have de\ufb01ned the basic Coin-Change problem.\nNow let\u2019s extend it a bit into the following: Given a target amount V cents and a list of\ndenominations for n coins, i.e., we have coinValue[i] (in cents) and weight[i] (in grams)\nfor coin types i 2 [0..n-1], what is the minimum total weight of coins that we must use\nto represent V ? Assume that 1 \uf8ffn \uf8ff1000, 1 \uf8ffV \uf8ff10 000, we cannot have partial total\nvalue less than 0 or larger than V , and we have unlimited supply of coins of any type. The\nbasic Coin-Change discussed in Section 3.5.2 has positive integers for coinValue[i] and\nall ones for weight[i], i.e., we are only interested to \ufb01nd the minimum number of coins as\ntheir weights are identical. Let\u2019s call this basic version as problem CC1. Now, how to solve\nthese other variants30 of that basic Coin-Change problem?\n1. CC2: Let coinValue[i] be positive integers and weight[i] be positive integers.\n2. CC3: Let coinValue[i] be positive integers and weight[i] be any integers.\n3. CC4: Let coinValue[i] be any integers, including negative integer or even zero.\nweight[i] remain all ones.\n4. CC5: Let coinValue[i] be any integers and weight[i] be positive integers.\nHint: See the discussion at Exercise 4.4.5.1 too.\n5. CC6: Let coinValue[i] be any integers and weight[i] be any integers.\nExercise 4.6.1.2: Draw the DAG for some small test cases of the other classical DP prob-\nlems in Section 3.5, e.g., Traveling Salesman Problem (TSP) \u21e1shortest paths on the implicit\nDAG, Longest Increasing Subsequence (LIS) \u21e1longest paths of the implicit DAG.\n4.6.2\nTree\nTree is a special graph with the following characteristics: it has E = V -1 (any O(V + E)\nalgorithm on tree is O(V )), it has no cycle, it is connected, and there exists one unique path\nfor any pair of vertices. Adding one more edge to a tree forms a cycle (called Pseudotree).\nRemoving any existing edge from a tree disconnects the tree.\nTree Traversal\nIn Section 4.2.2 and 4.2.3, we have seen O(V + E) DFS and BFS algorithms for traversing\na general graph. If the given graph is a rooted binary tree, there are simpler tree traversal\nalgorithms like pre-order, in-order, and post-order traversals (note: level-order traversal is\nessentially BFS). There is no major time speedup as these tree traversal algorithms also run\nin O(V ), but the code are simpler. Their pseudo-codes are shown below:\npre-order(v):\nin-order(v):\npost-order(v):\nvisit(v)\nin-order(left(v))\npost-order(left(v))\npre-order(left(v))\nvisit(v)\npost-order(right(v))\npre-order(right(v))\nin-order(right(v))\nvisit(v)\n30This idea is contributed by a Competitive Programming Book reader: Amit Agarwal.\n255\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\nFinding Articulation Points and Bridges in Tree\nIn Section 4.2.10, we have seen O(V + E) Tarjan\u2019s DFS algorithm for \ufb01nding articulation\npoints and bridges of a graph. But if the given graph is a tree, the problem becomes simpler:\nall edges on a tree are bridges and all internal vertices (degree > 1) are articulation points\n(see Figure 4.5\u2014left).", "mimetype": "text/plain", "start_char_idx": 742977, "end_char_idx": 746490, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c150795-2bcf-42c5-8232-9b46b2a508fc": {"__data__": {"id_": "5c150795-2bcf-42c5-8232-9b46b2a508fc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5c270fad-5bac-4906-b396-bcfb31c83c60", "node_type": "1", "metadata": {}, "hash": "1bcd0c564546c7c441e6853943c6af4b8977fcfb234f9f4a1d08b378443b491a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a5640c6c-8e94-4a89-ba81-281107c3db97", "node_type": "1", "metadata": {}, "hash": "1280903405ebd6ea635c8f9deb2d86f883afb005ed16c4e7a4133769b2f45ce6", "class_name": "RelatedNodeInfo"}}, "text": "Their pseudo-codes are shown below:\npre-order(v):\nin-order(v):\npost-order(v):\nvisit(v)\nin-order(left(v))\npost-order(left(v))\npre-order(left(v))\nvisit(v)\npost-order(right(v))\npre-order(right(v))\nin-order(right(v))\nvisit(v)\n30This idea is contributed by a Competitive Programming Book reader: Amit Agarwal.\n255\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\nFinding Articulation Points and Bridges in Tree\nIn Section 4.2.10, we have seen O(V + E) Tarjan\u2019s DFS algorithm for \ufb01nding articulation\npoints and bridges of a graph. But if the given graph is a tree, the problem becomes simpler:\nall edges on a tree are bridges and all internal vertices (degree > 1) are articulation points\n(see Figure 4.5\u2014left). This is still O(V ) as we have to scan the tree to count the number of\ninternal vertices, but the code is simpler.\nSingle-Source Shortest Paths on Weighted Tree\nIn Sections 4.4.3 and 4.4.4, we have seen two general purpose algorithms (O((V + E) log V )\nDijkstra\u2019s and O(V E) Bellman-Ford\u2019s) for solving the SSSP problem on a weighted graph.\nBut if the given graph is a weighted tree, the SSSP problem becomes simpler: any O(V )\ngraph traversal algorithm, i.e., BFS or DFS, can be used to solve this problem. There is\nonly one unique path between any two vertices in a tree, so we simply traverse the tree to\n\ufb01nd the unique path connecting the two vertices. The shortest path weight between these\ntwo vertices is basically the sum of edge weights of this unique path (e.g., from vertex 5 to\nvertex 3 in Figure 4.36\u2014A, the unique path is 5->0->1->3 with weight 4+2+9 = 15).\nAll-Pairs Shortest Paths on Weighted Tree\nIn Section 4.5, we have seen a general purpose algorithm (O(V 3) Floyd-Warshall) for solving\nthe APSP problem on a weighted graph. But if the given graph is a weighted tree, the APSP\nproblem becomes simpler: repeat the SSSP on weighted tree V times, setting each vertex\nas the source vertex one by one. The overall time complexity is O(V \u21e5V ) = O(V 2).\nDiameter of a Weighted Tree\nDiameter of a graph is with greatest \u2018shortest path length\u2019 between any pair of vertices in\nthe graph. For general graph, we need O(V 3) Floyd-Warshall algorithm discussed in Section\n4.5 plus another O(V 2) all-pairs check to compute the diameter. However, if the given graph\nis a weighted tree, the problem becomes simpler. We only need two O(V ) traversals: do\nDFS/BFS from any vertex s to \ufb01nd the furthest vertex x (e.g., from vertex s=1 to vertex\nx=2 in Figure 4.36\u2014B1), then do DFS/BFS one more time from vertex x to get the furthest\nvertex y from x. The length of the unique path along x to y is the diameter of that tree\n(e.g., path x=2->3->1->0->y=5 with length 20 in Figure 4.36\u2014B2).\nFigure 4.36: A: SSSP (Part of APSP); B1-B2: Diameter of Tree\n256\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nExercise 4.6.2.1*: Given the inorder and preorder traversal of a rooted Binary Search\nTree (BST) T containing n vertices, write a recursive pseudo-code to output the postorder\ntraversal of that BST. What is the time complexity of your best algorithm?\nExercise 4.6.2.2*: In a tree, there is no non-trivial cycle involving 3 or more vertices.\nHowever, there can still be trivial cycles involving bidirectional edges connecting a vertex\nwith its child(ren). Is there an easier way to implement DFS/BFS traversal on a tree without\nusing the Boolean visited \ufb02ag of size n vertices?\nExercise 4.6.2.3*: There is an even faster solution than O(V 2) for the All-Pairs Shortest\nPaths problem on Weighted Tree. It uses LCA. How?", "mimetype": "text/plain", "start_char_idx": 745787, "end_char_idx": 749305, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a5640c6c-8e94-4a89-ba81-281107c3db97": {"__data__": {"id_": "a5640c6c-8e94-4a89-ba81-281107c3db97", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5c150795-2bcf-42c5-8232-9b46b2a508fc", "node_type": "1", "metadata": {}, "hash": "62068a9c2e15f5ad281652e3beb965c58273bc22224e136418388b7f72bf003e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c1d8e65d-ef3e-4219-8d61-f1933587d878", "node_type": "1", "metadata": {}, "hash": "a3a6d1fe7871b245baf0309e49c77ca76413c882f495b5c8a300144c43a5a522", "class_name": "RelatedNodeInfo"}}, "text": "GRAPH\nc\u20ddSteven, Felix, Suhendry\nExercise 4.6.2.1*: Given the inorder and preorder traversal of a rooted Binary Search\nTree (BST) T containing n vertices, write a recursive pseudo-code to output the postorder\ntraversal of that BST. What is the time complexity of your best algorithm?\nExercise 4.6.2.2*: In a tree, there is no non-trivial cycle involving 3 or more vertices.\nHowever, there can still be trivial cycles involving bidirectional edges connecting a vertex\nwith its child(ren). Is there an easier way to implement DFS/BFS traversal on a tree without\nusing the Boolean visited \ufb02ag of size n vertices?\nExercise 4.6.2.3*: There is an even faster solution than O(V 2) for the All-Pairs Shortest\nPaths problem on Weighted Tree. It uses LCA. How?\nExercise 4.6.2.4*: Prove the correctness of the two DFS/BFS algorithm for \ufb01nding diam-\neter of a Weighted Tree above!\n4.6.3\nBipartite Graph\nRecall that Bipartite Graph is a special graph with the following characteristics: the set\nof vertices V can be partitioned into two disjoint sets V1 and V2 and all undirected edges\n(u, v) 2 E have the property that u 2 V1 and v 2 V2. This makes a Bipartite Graph free\nfrom odd-length cycle. Note that a Tree is also a Bipartite Graph!\nMax Cardinality Bipartite Matching (MCBM)\nAbridged problem description of Topcoder Open 2009 Qualifying 1 [28]: Given a list of\nnumbers N, return a list of all the elements in N that can be paired with N[0] successfully\nas part of a complete prime pairing, sorted in ascending order. Complete prime pairing\nmeans that each element a in N is paired to a unique other element b in N such that a + b\nis prime.\nFor example: Given a list of numbers N = {1, 4, 7, 10, 11, 12}, the answer is {4, 10}. This\nis because pairing N[0] = 1 with 4 results in a prime pair and the other four items can also\nform two prime pairs (7 + 10 = 17 and 11 + 12 = 23). Similar situation by pairing N[0] = 1\nwith 10, i.e., 1 + 10 = 11 is a prime pair and we also have two other prime pairs (4 + 7 = 11\nand 11 + 12 = 23). We cannot pair N[0] = 1 with any other item in N. For example, if we\npair N[0] = 1 with 12, we have a prime pair but there will be no way to pair the remaining\n4 numbers to form 2 more prime pairs.\nConstraints: list N contains an even number of elements ([2..50]). Each element of N\nwill be between [1..1000]. Each element of N will be distinct.\nAlthough this problem involves prime numbers, it is not a pure math problem as the\nelements of N are not more than 1K\u2014there are not too many primes below 1000 (only 168\nprimes). The issue is that we cannot do Complete Search pairings as there are 49 possibilities\nfor the \ufb01rst pair (that has to be paired with N[0]), 48C2 for the second pair, . . . , until 2C2\nfor the last pair. DP with bitmask technique (that will be discussed in Book 2) is also not\nusable because 250 is too big.\nThe key to solve this problem is to realize that this pairing (matching) is done on a\nBipartite Graph!\nTo get a prime number in this problem (where all elements of N are\ndistinct), we need to sum 1 odd + 1 even, because 1 odd + 1 odd (or 1 even + 1 even)\nproduces an even number (which is greater than two and not prime). Thus we can split\nodd/even numbers to set1/set2 and add edge i ! j if set1[i] + set2[j] is prime, see\nFigure 4.37\u2014left.\n257\n\n4.6.", "mimetype": "text/plain", "start_char_idx": 748556, "end_char_idx": 751859, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c1d8e65d-ef3e-4219-8d61-f1933587d878": {"__data__": {"id_": "c1d8e65d-ef3e-4219-8d61-f1933587d878", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a5640c6c-8e94-4a89-ba81-281107c3db97", "node_type": "1", "metadata": {}, "hash": "1280903405ebd6ea635c8f9deb2d86f883afb005ed16c4e7a4133769b2f45ce6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b67d5714-2def-4b59-8ac9-2407d0e6d472", "node_type": "1", "metadata": {}, "hash": "40f37196c2005a4e9fb63fe970403b113142a8b22c95a6f49538b1560f1f2c2d", "class_name": "RelatedNodeInfo"}}, "text": ". . , until 2C2\nfor the last pair. DP with bitmask technique (that will be discussed in Book 2) is also not\nusable because 250 is too big.\nThe key to solve this problem is to realize that this pairing (matching) is done on a\nBipartite Graph!\nTo get a prime number in this problem (where all elements of N are\ndistinct), we need to sum 1 odd + 1 even, because 1 odd + 1 odd (or 1 even + 1 even)\nproduces an even number (which is greater than two and not prime). Thus we can split\nodd/even numbers to set1/set2 and add edge i ! j if set1[i] + set2[j] is prime, see\nFigure 4.37\u2014left.\n257\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\nFigure 4.37: Bipartite Matching problem\nAfter we build this Bipartite Graph, the solution is trivial: if the sizes of set1 and set2\nare di\u21b5erent, a complete pairing is not possible. Otherwise, if the size of both sets are n/2,\ntry to match set1[0] with set2[k] for k = [0..n/2-1] and do Max Cardinality Bipartite\nMatching (MCBM) for the rest (MCBM is one of the most common applications involving\nBipartite Graph). If we obtain n/2-1 more matchings, add set2[k] to the answer. For this\ntest case, the answer is {4, 10} (see Figure 4.37\u2014middle and right).\nAugmenting Path Algorithm for MCBM\nTo solve the MCBM problem, one way is to use the specialized and easy to implement\nO(V E) augmenting path algorithm. With its implementation handy, all the MCBM prob-\nlems, including other graph problems that require MCBM\u2014like the Max Independent Set in\nBipartite Graph, Min Vertex Cover in Bipartite Graph, and Min Path Cover on DAG (that\nwill be discussed in Book 2)\u2014can be easily solved.\nAn augmenting path is a path that starts from a free (unmatched) vertex on the left set\nof the Bipartite Graph, alternates between a free (unmatched) edge (now on the right set),\na matched edge (now on the left set again), a free edge, . . . until the path \ufb01nally arrives on\na free vertex on the right set of the Bipartite Graph. A lemma by Claude Berge in 1957\nstates that a matching M in graph G is maximum (has the max possible number of edges)\nif and only if there are no more augmenting paths in G. This augmenting path algorithm is\na direct implementation of Berge\u2019s lemma: \ufb01nd and eliminate augmenting paths.\nNow let\u2019s take a look at a simple Bipartite Graph in Figure 4.38 with n and m vertices\non the left set and the right set, respectively. Vertices of the left set are numbered from\n[1..n] and vertices of the right set are numbered from [n+1..n+m]. This algorithm tries\nto \ufb01nd and eliminate augmenting paths starting from free vertices on the left set.\nWe start with a free vertex 1.\nIn Figure 4.38\u2014A, we see that this algorithm will\n\u2018wrongly31\u2019 match vertex 1 with vertex 3 (rather than vertex 1 with vertex 4) as path 1-3 is\nalready a simple augmenting path. Both vertex 1 and vertex 3 are free vertices. By matching\nvertex 1 and vertex 3, we have our \ufb01rst matching. Notice that after we match vertex 1 and\n3, we are unable to \ufb01nd another matching.\nIn the next iteration (when we are in a free vertex 2), this algorithm now shows its full\nstrength by \ufb01nding the following augmenting path that starts from a free vertex 2 on the\nleft, goes to vertex 3 via a free edge (2-3), goes to vertex 1 via a matched edge (3-1), and\n\ufb01nally goes to vertex 4 via a free edge again (1-4). Both vertex 2 and vertex 4 are free\nvertices. Therefore, the augmenting path is 2-3-1-4 as seen in Figure 4.38\u2014B and 4.38\u2014C.", "mimetype": "text/plain", "start_char_idx": 751269, "end_char_idx": 754695, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b67d5714-2def-4b59-8ac9-2407d0e6d472": {"__data__": {"id_": "b67d5714-2def-4b59-8ac9-2407d0e6d472", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c1d8e65d-ef3e-4219-8d61-f1933587d878", "node_type": "1", "metadata": {}, "hash": "a3a6d1fe7871b245baf0309e49c77ca76413c882f495b5c8a300144c43a5a522", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ce24ebcc-b0a1-4404-b4a9-6bf9fe7ef6b6", "node_type": "1", "metadata": {}, "hash": "da103e144cd0d7311464133a764d0b353fe8b3532422d47e37337d2c468beb2c", "class_name": "RelatedNodeInfo"}}, "text": "Both vertex 1 and vertex 3 are free vertices. By matching\nvertex 1 and vertex 3, we have our \ufb01rst matching. Notice that after we match vertex 1 and\n3, we are unable to \ufb01nd another matching.\nIn the next iteration (when we are in a free vertex 2), this algorithm now shows its full\nstrength by \ufb01nding the following augmenting path that starts from a free vertex 2 on the\nleft, goes to vertex 3 via a free edge (2-3), goes to vertex 1 via a matched edge (3-1), and\n\ufb01nally goes to vertex 4 via a free edge again (1-4). Both vertex 2 and vertex 4 are free\nvertices. Therefore, the augmenting path is 2-3-1-4 as seen in Figure 4.38\u2014B and 4.38\u2014C.\n31We assume that the neighbors of a vertex are ordered based on increasing vertex number, i.e., from\nvertex 1, we will visit vertex 3 \ufb01rst before vertex 4.\n258\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nFigure 4.38: Augmenting Path Algorithm\nIf we \ufb02ip the edge status in this augmenting path, i.e., from \u2018free to matched\u2019 and \u2018matched\nto free\u2019, we will get one more matching (and simultaneously \u2018eliminate\u2019 this augmenting\npath). See Figure 4.38\u2014C where we \ufb02ip the status of edges along the augmenting path\n2-3-1-4. The updated matching is re\ufb02ected in Figure 4.38\u2014D.\nThis algorithm will keep doing this process of \ufb01nding augmenting paths and eliminating\nthem until there are no more augmenting paths. As the algorithm repeats O(E) DFS-like32\ncode V times, it runs in O(V E). The short implementation code is shown below.\nvi match, vis;\n// global variables\nvector<vi> AL;\nint Aug(int L) {\nif (vis[L]) return 0;\n// L visited, return 0\nvis[L] = 1;\nfor (auto &R : AL[L])\nif ((match[R] == -1) || Aug(match[R])) {\nmatch[R] = L;\n// flip status\nreturn 1;\n// found 1 matching\n}\nreturn 0;\n// no matching\n}\n// inside int main()\n// build unweighted Bipartite Graph with directed edge left->right set\n// that has V vertices and Vleft vertices on the left set\nmatch.assign(V, -1);\nint MCBM = 0;\nfor (int L = 0; L < Vleft; ++L) {\n// for each free vertices\nvis.assign(Vleft, 0);\n// reset first\nMCBM += Aug(L);\n// try to match L\n}\ncout << \"Found \" << MCBM << \" matchings\\n\";\n32To simplify the analysis, we assume that E > V in such Bipartite Graphs.\n259\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\nExercise 4.6.3.1*: List down common keywords that can be used to help contestants spot\na Bipartite Graph in the problem statement! e.g., odd-even, male-female, etc. Also take\nnote which programming contest problems have such keywords.\nExercise 4.6.3.2*: Is it good for the MCBM algorithm shown in this section if we randomize\nthe vertex order in Adjacency List instead of keeping it ordered based on increasing vertex\nnumber as usual?\nWe have provided the animation of several Unweighted MCBM algorithms in VisuAlgo\nincluding variants that are better than the simple Augmenting Path Algorithm presented\nin this section33.\nUse it to further strengthen your understanding of this algorithm by\nproviding your own input graph (undirected unweighted Bipartite Graph) and see the MCBM\nalgorithm being animated live on that particular input graph. The URL for the MCBM\nalgorithm visualization and the source code examples are shown below.\nVisualization: https://visualgo.net/en/matching\nSource code: ch4/mcbm.cpp|java|py|ml\n4.6.4\nEulerian Graph\nAn Eulerian path34 in a graph is a trail35 which traverses each edge in the graph exactly\nonce. If such trail is a closed trail (i.e., starting and ending at the same vertex), then it is\nalso called an Eulerian tour. A graph is considered as Eulerian (Eulerian graph) if it has an\nEulerian tour.", "mimetype": "text/plain", "start_char_idx": 754056, "end_char_idx": 757614, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ce24ebcc-b0a1-4404-b4a9-6bf9fe7ef6b6": {"__data__": {"id_": "ce24ebcc-b0a1-4404-b4a9-6bf9fe7ef6b6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b67d5714-2def-4b59-8ac9-2407d0e6d472", "node_type": "1", "metadata": {}, "hash": "40f37196c2005a4e9fb63fe970403b113142a8b22c95a6f49538b1560f1f2c2d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "97cf9a1d-126a-48d6-9dd5-06a2214b55e8", "node_type": "1", "metadata": {}, "hash": "adaae760006f9b4a345ea5525504ed7b58719273cd538fb616bd87d589f0c867", "class_name": "RelatedNodeInfo"}}, "text": "Use it to further strengthen your understanding of this algorithm by\nproviding your own input graph (undirected unweighted Bipartite Graph) and see the MCBM\nalgorithm being animated live on that particular input graph. The URL for the MCBM\nalgorithm visualization and the source code examples are shown below.\nVisualization: https://visualgo.net/en/matching\nSource code: ch4/mcbm.cpp|java|py|ml\n4.6.4\nEulerian Graph\nAn Eulerian path34 in a graph is a trail35 which traverses each edge in the graph exactly\nonce. If such trail is a closed trail (i.e., starting and ending at the same vertex), then it is\nalso called an Eulerian tour. A graph is considered as Eulerian (Eulerian graph) if it has an\nEulerian tour.\nA similar concept to Eulerian tour is the Hamiltonian tour, a path in a graph which visits\neach vertex exactly once. Even though they look similar, \ufb01nding an Eulerian tour is much\neasier than \ufb01nding a Hamiltonian tour which has been proven to be NP-hard (more details\nin Book 2). On the other hand, \ufb01nding an Eulerian tour is P.\nFigure 4.39: K\u00a8onigsberg bridges problem and its corresponding graph representation.\nEulerian graph is one of the \ufb01rst results in graph theory obtained by Leonhard Euler in 1736\nwhile solving the K\u00a8onigsberg bridges problem (see Figure 4.39). The problem asks whether\nall the seven bridges in the city of K\u00a8onigsberg (now Kaliningrad, Russia) can be traversed\nin a single trip without passing through any bridge more than once. Euler proved that there\nis no such trail exists in this problem.\n33These better algorithms will be discussed in Book 2.\n34Although the name is Eulerian path, it actually is a trail in graph theory.\n35A trail in the graph is similar to a path but it may have repeating vertices and no repeating edges, e.g.,\n1 \u22122 \u22125 \u22123 \u22122 \u22124 where vertex 2 is visited twice in this walk of 5 di\u21b5erent edges; on the other hand, the\ncommon de\ufb01nition of path does not allow any vertex to be repeated.\n260\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nChecking an Eulerian Graph\nAn undirected graph is Eulerian if and only if: (1) it is connected, and (2) all the vertices have\nan even degree. The \ufb01rst requirement is obvious as there cannot be a trail that consists of all\nedges if the graph is disconnected. There are several ways to prove the second requirement.\nThe idea is that a closed trail from a vertex u requires an even number of edges adjacent to\nvertex u, i.e., for each edge used from vertex u to other vertices, another edge is required\nto bring back the trail into vertex u. If all the vertices except exactly two vertices have an\neven degree, then the graph has an Eulerian path which starts at one of the two odd-degree\nvertices and ends at the other.\nFor a directed graph, then each vertex should have the same number of incoming and\noutgoing edges (in-degree = out-degree) to be an Eulerian graph.\nFor the connectivity\nrequirement, a directed Eulerian graph should be connected in one Strongly Connected\nComponent (SCC). However, there is no need to compute the SCC (see Section 4.2.10) for\nthe given graph. Instead, it is su\ufb03cient to check the connectivity by assuming all edges are\nundirected, i.e., vertex u and v are connected if there is an edge u ! v or v ! u. If the\ngraph is \u201cconnected\u201d and the requirement for the vertices\u2019 degree is satis\ufb01ed, then the graph\nmust be connected in one SCC. Thus, a directed graph is an Eulerian graph if and only if it\nis \u201cconnected\u201d (assuming each edge is undirected) and each vertex has the same number of\nincoming and outgoing edges. Note that if there is exactly one vertex u which has one extra\noutgoing edge and exactly one vertex v which has one extra incoming edge, then the graph\nhas an Eulerian path from u to v.\nFinding an Eulerian Path\nWhile checking whether a graph is Eulerian is easy, \ufb01nding the Eulerian tour requires more\nwork than simply checking the graph\u2019s connectivity and vertices\u2019 degree.", "mimetype": "text/plain", "start_char_idx": 756903, "end_char_idx": 760820, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "97cf9a1d-126a-48d6-9dd5-06a2214b55e8": {"__data__": {"id_": "97cf9a1d-126a-48d6-9dd5-06a2214b55e8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ce24ebcc-b0a1-4404-b4a9-6bf9fe7ef6b6", "node_type": "1", "metadata": {}, "hash": "da103e144cd0d7311464133a764d0b353fe8b3532422d47e37337d2c468beb2c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e2c380c3-5882-4361-9f19-d0a3cc15bdda", "node_type": "1", "metadata": {}, "hash": "3e053d2152e118ce4ea489985746a283e87488f41e0329467e5a0c9a7f2102b0", "class_name": "RelatedNodeInfo"}}, "text": "v or v ! u. If the\ngraph is \u201cconnected\u201d and the requirement for the vertices\u2019 degree is satis\ufb01ed, then the graph\nmust be connected in one SCC. Thus, a directed graph is an Eulerian graph if and only if it\nis \u201cconnected\u201d (assuming each edge is undirected) and each vertex has the same number of\nincoming and outgoing edges. Note that if there is exactly one vertex u which has one extra\noutgoing edge and exactly one vertex v which has one extra incoming edge, then the graph\nhas an Eulerian path from u to v.\nFinding an Eulerian Path\nWhile checking whether a graph is Eulerian is easy, \ufb01nding the Eulerian tour requires more\nwork than simply checking the graph\u2019s connectivity and vertices\u2019 degree. There are two\npopular algorithms to \ufb01nd the Eulerian path, i.e., Fleury\u2019s algorithm and the more e\ufb03cient\nHierholzer\u2019s algorithm.\nFleury\u2019s algorithm starts at an arbitrary vertex. In each step, it chooses the next edge to\nbe traversed whose removal would not disconnect the graph. If there is no such edge, then it\nchooses that last remaining edge from that vertex. This algorithm requires us to know the\nbridges (see Section 4.2.9) every time an edge being traversed (removed from the remaining\ngraph). Thus, the total time complexity of this algorithm is O(|E|2).\nHierholzer\u2019s algorithm is more e\ufb03cient compared to Fleury\u2019s algorithm. Starting from\nany arbitrary vertex u, \ufb01nd any trail through the graph until it comes back to vertex u. If\nthe graph is Eulerian, then any (random) trail must be able to end at the starting vertex\nsince all vertices have an even degree (i.e., for each outgoing, there is one incoming, thus, we\ncannot get stuck in some vertices other than the starting vertex). So, we have found a closed\ntrail, but such a trail might not contain all the edges yet. Whenever there is a vertex v in\nthe existing trail which has incident edges which are not yet part of the trail, \ufb01nd another\nclosed trail starting from v in the remaining graph (in other words, expand the vertex), then\nmerge the trail found into the existing trail. This method will exhaust all the edges in the\ngraph if the graph is connected, and the resulting trail will be an Eulerian tour. The total\ntime complexity of this algorithm is O(|E|).\nFigure 4.40 shows a running example of Hierholzer\u2019s algorithm on a directed graph. The\n\ufb01rst closed trail found in this example is ABCDA. In this closed trail, vertex A and C still have\nincident edges which are not yet part of the closed trail, i.e., FA, AG, CE, and FC. Hierholzer\u2019s\nalgorithm does not decide which vertex (A or C) to be expanded in such a case (any vertex\nwill do); it highly depends on the implementation. One common implementation of the\nHierholzer\u2019s algorithm is simply expanding the last vertex in the existing closed trail which\n261\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\nstill has incident edges (vertex A in this example). Expand vertex A so we will \ufb01nd another\nclosed trail, AGFA. Merge this trail with the existing trail into ABCDAGFA, i.e., replace (one)\nA which we expand in ABCDA with AFGA. After this, vertex C and F still have incident edges\nwhich are not yet part of the closed trail. Expand vertex F and we will \ufb01nd another closed\ntrail, FCEF, then merge this into ABCDAGFCEFA. After this, there is no vertex which still has\nincident edge which is not part of the closed trail, thus, the algorithm terminates and the\nclosed trail is an Eulerian tour.\nFigure 4.40: Example of Hierholzer\u2019s algorithm. The underlined characters represent vertices\nwhich still have incident edges which are not yet part of the trail.\nThe following is an iterative implementation of Hierholzer\u2019s algorithm to \ufb01nd an Eulerian\npath in a directed graph using two stacks. One stack is used to store the current trail (st)\nwhile the other is to store the output trail (res). The top vertex of st is push into res if\nthat vertex is already exhausted. The resulting trail by this method will be in a reversed\norder, so reversal might be needed36.", "mimetype": "text/plain", "start_char_idx": 760123, "end_char_idx": 764113, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e2c380c3-5882-4361-9f19-d0a3cc15bdda": {"__data__": {"id_": "e2c380c3-5882-4361-9f19-d0a3cc15bdda", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "97cf9a1d-126a-48d6-9dd5-06a2214b55e8", "node_type": "1", "metadata": {}, "hash": "adaae760006f9b4a345ea5525504ed7b58719273cd538fb616bd87d589f0c867", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6b15849a-dd3b-48cd-b709-b08966e31948", "node_type": "1", "metadata": {}, "hash": "7f461140c9367923072d680e4ee88c63aeeb9540fdc37936b960580d791cf203", "class_name": "RelatedNodeInfo"}}, "text": "Expand vertex F and we will \ufb01nd another closed\ntrail, FCEF, then merge this into ABCDAGFCEFA. After this, there is no vertex which still has\nincident edge which is not part of the closed trail, thus, the algorithm terminates and the\nclosed trail is an Eulerian tour.\nFigure 4.40: Example of Hierholzer\u2019s algorithm. The underlined characters represent vertices\nwhich still have incident edges which are not yet part of the trail.\nThe following is an iterative implementation of Hierholzer\u2019s algorithm to \ufb01nd an Eulerian\npath in a directed graph using two stacks. One stack is used to store the current trail (st)\nwhile the other is to store the output trail (res). The top vertex of st is push into res if\nthat vertex is already exhausted. The resulting trail by this method will be in a reversed\norder, so reversal might be needed36.\nint N;\nvector<vi> AL;\n// Directed graph\nvi hierholzer(int s) {\nvi ans, idx(N, 0), st;\nst.push_back(s);\nwhile (!st.empty()) {\nint u = st.back();\nif (idx[u] < (int)AL[u].size()) {\n// still has neighbor\nst.push_back(AL[u][idx[u]]);\n++idx[u];\n}\nelse {\nans.push_back(u);\nst.pop_back();\n}\n}\nreverse(ans.begin(), ans.end());\nreturn ans;\n}\nSource code: ch4/hierholzer.cpp|java|py\n36Reversal only matters if we want an Eulerian path which starts from the start vertex.\n262\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nNote that this implementation is meant for directed graphs. In the case of undirected graphs,\nwe need to \ufb02ag edges which have been used during the traversal to avoid using a bidirectional\nedge twice, e.g., with map or set. Alternatively, we can represent the graph using list with\nreferences to each bidirectional edge so that any reversed edge can be erased in O(1). One\ninteresting thing in this implementation is that both ans and st contain valid trails at any\ntime, thus, for example, it can be modi\ufb01ed to \ufb01nd a trail of a speci\ufb01c length.\n4.6.5\nSpecial Graphs in Programming Contests\nOf the four special graphs mentioned in this Section 4.6. DAGs and Trees are more popular,\nespecially for IOI contestants. It is not rare that Dynamic Programming (DP) on DAG\nor (rooted) Tree appears as an IOI task. As these DP variants (typically) have e\ufb03cient\nsolutions, the input sizes for them are usually large.\nThe next most popular special graph is the Bipartite Graph. This special graph is suitable\nfor Network Flow and Bipartite Matching problems that will be discussed in Book 2. We\nreckon that contestants must master the usage of the simpler augmenting path algorithm\nfor solving the Max Cardinality Bipartite Matching (MCBM) problem. We have seen in this\nsection and later in the special cases of certain NP-hard/complete problems (see Book 2)\nthat several graph problems are somehow reducible to MCBM. ICPC contestants should be\nfamiliar with Bipartite Graph on top of DAG and Tree. IOI contestants also need to also\nstudy Bipartite Graph as it is inside IOI syllabus [16].\nThe other special graph discussed in this chapter\u2014the Eulerian Graph\u2014does not have\ntoo many contest problems involving it the last two decades: 2000-2020. However, when\nEulerian Graph-related problem appears, it can be a decider problem.\nThere are other possible special graphs (see Figure 4.41), but we rarely encounter them,\ne.g., Planar Graph (Kuratowski\u2019s Theorem: does not have K5 or K3,3 as its subgraph; 4\ncolorable; E = O(V )); Complete Graph Kn (the most dense graph; connected; and also a\nclique with diameter 1); Forest of Paths; Star Graph; Acyclic graph plus 1 extra edge (e.g.,\nPseudoforest/Pseudotree), etc. When they appear, try to utilize their special properties to\nspeed up your algorithms.\nFigure 4.41: A Few Other Special Graphs\nPro\ufb01le of Algorithm Inventor\nClaude Berge (1926-2002) was a French mathematician, recognized as one of the modern\nfounders of combinatorics and graph theory.", "mimetype": "text/plain", "start_char_idx": 763280, "end_char_idx": 767107, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6b15849a-dd3b-48cd-b709-b08966e31948": {"__data__": {"id_": "6b15849a-dd3b-48cd-b709-b08966e31948", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e2c380c3-5882-4361-9f19-d0a3cc15bdda", "node_type": "1", "metadata": {}, "hash": "3e053d2152e118ce4ea489985746a283e87488f41e0329467e5a0c9a7f2102b0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "38d9aae8-0938-44d7-8693-2f240adf0426", "node_type": "1", "metadata": {}, "hash": "a63f9c0bd70aa537070eb9c792076bc9fb110277bb3c2215b4ddfce0cfa242bf", "class_name": "RelatedNodeInfo"}}, "text": "There are other possible special graphs (see Figure 4.41), but we rarely encounter them,\ne.g., Planar Graph (Kuratowski\u2019s Theorem: does not have K5 or K3,3 as its subgraph; 4\ncolorable; E = O(V )); Complete Graph Kn (the most dense graph; connected; and also a\nclique with diameter 1); Forest of Paths; Star Graph; Acyclic graph plus 1 extra edge (e.g.,\nPseudoforest/Pseudotree), etc. When they appear, try to utilize their special properties to\nspeed up your algorithms.\nFigure 4.41: A Few Other Special Graphs\nPro\ufb01le of Algorithm Inventor\nClaude Berge (1926-2002) was a French mathematician, recognized as one of the modern\nfounders of combinatorics and graph theory. His main contribution that is included in this\nbook is Berge\u2019s lemma, which states that a matching M in a graph G is maximum if and\nonly if there is no more augmenting path with respect to M in G.\n263\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\nProgramming Exercises related to Special Graphs:\na. Shortest37/Longest Paths on DAG\n1. Entry Level: Kattis - mravi * (reverse edge directions to change the input\ntree into a DAG; \ufb01nd longest path from leaf that contains ant to root)\n2. UVa 00452 - Project Scheduling * (longest paths on DAG)\n3. UVa 10259 - Hippity Hopscotch * (longest paths on implicit DAG; DP)\n4. UVa 10350 - Liftless Eme * (shortest paths; implicit DAG; DP)\n5. Kattis - 246greaaat * (variation of Coin-Change problem; Dijkstra\u2019s on\nDAG; but avoid using Priority Queue)\n6. Kattis - \ufb01btour * (only 90 Fibonacci numbers not more than 1018; Longest-Path\non DAG problem; special case for \ufb01rst two Fibonacci numbers 1 ! 1)\n7. Kattis - safepassage * (SSSP; implicit DAG; s: (cloak pos, bitmask); try all\nways to go back and forth between gate and dorm; report minimum)\nExtra UVa: 00103, 10000, 10051, 10285.\nExtra Kattis: baas, bowserpipes, excavatorexpedition, monopoly, savinguni-\nverse.\nAlso see: Longest Increasing Subsequence (see Section 3.5.2) and the generic\nLongest-Path problem (see Book 2).\nb. DP, Counting Paths in DAG, Easier\n1. Entry Level: UVa 00825 - Walking on the Safe Side * (counting paths\nin grid (implicit DAG); DP; similar to UVa 00926 and 11067)\n2. UVa 10544 - Numbering the Paths * (counting paths in implicit DAG)\n3. UVa 11569 - Lovely Hint * (determine the length of one of the longest\npaths and then count the number of such longest paths in DAG)\n4. UVa 11957 - Checkers * (counting paths in implicit DAG; DP)\n5. Kattis - robotsonagrid * (counting paths in grid (implicit DAG); DP)\n6. Kattis - runningsteps * (LA 7360 - Greater NY15; s: (leg, l2, r2, l1, r1); t:\nleft/right leg 1/2 steps; use unordered map as memo table; use pruning)\n7. Kattis - scenes * (s: (pos, ribbon left); t: try all possible heights; ignore the\n\ufb02at scenes \ufb01rst and subtract those cases at the end)\nExtra UVa: 00926, 00986, 00988, 10401, 10564, 10926, 11067, 11655.\nExtra Kattis: compositions, helpfulcurrents, marypartitions.\nAlso see: DP, Counting Paths in DAG, Harder (see Book 2).\n37SSSP on DAG problems can still be solved with the more general Dijkstra\u2019s algorithm\u2014in a slightly\nslower (by O(log V ) factor) manner.\n264\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nc. Converting General Graph to DAG38\n1. Entry Level: UVa 00590 - Always on the Run * (s: (pos, day left))\n2.", "mimetype": "text/plain", "start_char_idx": 766438, "end_char_idx": 769699, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "38d9aae8-0938-44d7-8693-2f240adf0426": {"__data__": {"id_": "38d9aae8-0938-44d7-8693-2f240adf0426", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6b15849a-dd3b-48cd-b709-b08966e31948", "node_type": "1", "metadata": {}, "hash": "7f461140c9367923072d680e4ee88c63aeeb9540fdc37936b960580d791cf203", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0cb9da55-d5a0-45f4-a60c-fd5c1d55b372", "node_type": "1", "metadata": {}, "hash": "e7994142a8580f379fd9f5df93ee6423ce987682b0b1c0c9f334ae0e778a71a2", "class_name": "RelatedNodeInfo"}}, "text": "Extra Kattis: compositions, helpfulcurrents, marypartitions.\nAlso see: DP, Counting Paths in DAG, Harder (see Book 2).\n37SSSP on DAG problems can still be solved with the more general Dijkstra\u2019s algorithm\u2014in a slightly\nslower (by O(log V ) factor) manner.\n264\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nc. Converting General Graph to DAG38\n1. Entry Level: UVa 00590 - Always on the Run * (s: (pos, day left))\n2. UVa 00907 - Winterim Backpack... * (s: (pos, night left))\n3. UVa 10913 - Walking ... * (s: (r, c, neg left, stat); t: down/(left/right))\n4. UVa 12875 - Concert Tour * (LA 6853 - Bangkok14; similar to UVa\n10702; s: (cur store, cur concert); t: pick any next store for next concert)\n5. Kattis - cardmagic * (s: (deck, tgt left); t: val 1 to K \uf8fftgt left)\n6. Kattis - drinkresponsibly * (s: (cur drink, money left, u left); be careful with\nprecision errors; print solution)\n7. Kattis - maximizingwinnings * (separate the maximizing and minimizing\nproblem; s: (cur room, turns left); t: go to other room or stay)\nExtra UVa: 00607, 00757, 00910, 01025, 10201, 10271, 10543, 10681, 10702,\n10874, 11307, 11487, 11545, 11782, 13122.\nExtra Kattis: quantumsuperposition, shortestpath4.\nOthers: SPOJ FISHER - Fishmonger (s: (cur, t left)).\nd. Tree\n1. Entry Level: UVa 00536 - Tree Recovery * (reconstructing binary tree\nfrom preorder and inorder binary tree traversal)\n2. UVa 10805 - Cockroach Escape ... * (involving diameter of tree)\n3. UVa 12347 - Binary Search Tree * (given pre-order traversal of a BST,\nuse BST property to get the BST; output the post-order traversal that BST)\n4. UVa 12379 - Central Post O\ufb03ce * (\ufb01nd the diameter of tree \ufb01rst; we\nonly traverse the diameter once and we traverse the other edges twice)\n5. Kattis - adjoin * (the key parts are \ufb01nding tree diameter and its center (along\nthat diameter); also see UVa 11695)\n6. Kattis - \ufb02ight * (cut the worst edge along the tree diameter; link two centers;\nalso available at UVa 11695 - Flight Planning)\n7. Kattis - tourists * (APSP on Tree (special requirements); LCA)\nExtra UVa: 00112, 00115, 00122, 00548, 00615, 00699, 00712, 00839, 10308,\n10459, 10701, 11131, 11234, 11615, 12186.\nExtra Kattis: decisions, frozenrose, fulldepthmorningshow, kitten, mazemak-\ners, whostheboss.\n38This category can also be classi\ufb01ed as Dynamic Programming.\n265\n\n4.6.\nSPECIAL GRAPHS\nc\u20ddSteven, Felix, Suhendry\ne. Bipartite Graph\n1. Entry Level: UVa 11138 - Nuts and Bolts * (a pure MCBM problem)\n2. UVa 00670 - The Dog Task * (good MCBM problem modeling)\n3. UVa 12668 - Attacking rooks * (LA 6525 - LatinAmerica13; split rows\nand columns due to the presence of pawns, then run MCBM)\n4. UVa 12644 - Vocabulary * (classic MCBM problem wrapped inside a\ncreative problem statement)\n5. Kattis - bookclub * (check if perfect MCBM is possible)\n6. Kattis - escapeplan * (left set: robots; right set: holes; 3 version of similar\nBipartite Graphs; MCBM)\n7.", "mimetype": "text/plain", "start_char_idx": 769287, "end_char_idx": 772187, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0cb9da55-d5a0-45f4-a60c-fd5c1d55b372": {"__data__": {"id_": "0cb9da55-d5a0-45f4-a60c-fd5c1d55b372", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "38d9aae8-0938-44d7-8693-2f240adf0426", "node_type": "1", "metadata": {}, "hash": "a63f9c0bd70aa537070eb9c792076bc9fb110277bb3c2215b4ddfce0cfa242bf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3a40befc-46b3-4e28-aef5-60a4645a01db", "node_type": "1", "metadata": {}, "hash": "1da57e275707b054542791c82be5c2cf323ef3314fd01e5db220c19285bcf980", "class_name": "RelatedNodeInfo"}}, "text": "Entry Level: UVa 11138 - Nuts and Bolts * (a pure MCBM problem)\n2. UVa 00670 - The Dog Task * (good MCBM problem modeling)\n3. UVa 12668 - Attacking rooks * (LA 6525 - LatinAmerica13; split rows\nand columns due to the presence of pawns, then run MCBM)\n4. UVa 12644 - Vocabulary * (classic MCBM problem wrapped inside a\ncreative problem statement)\n5. Kattis - bookclub * (check if perfect MCBM is possible)\n6. Kattis - escapeplan * (left set: robots; right set: holes; 3 version of similar\nBipartite Graphs; MCBM)\n7. Kattis - \ufb02ippingcards * (left set: n card numbers; right set: 2*n picture num-\nbers; possible if MCBM = n; need fast algorithm)\nExtra UVa: 00663, 00753.\nExtra Kattis: absurdistan3, elementarymath, gopher2, paintball, pianolessons,\nsuperdoku.\nOthers: Topcoder Open 2009: Prime Pairs (MCBM).\nAlso see: Bipartite Graph Check (see Section 4.2.7), some Bipartite Flow\nGraph (see Book 2), a few special cases of NP-hard/complete problems in-\nvolving Bipartite Graph (see Book 2).\nf. Eulerian Graph\n1. Entry Level: UVa 00291 - The House of Santa ... * (Euler tour on a\nsmall graph; backtracking is su\ufb03cient)\n2. UVa 10054 - The Necklace * (printing the Euler tour)\n3. UVa 10203 - Snow Clearing * (the underlying graph is Euler graph)\n4. UVa 10596 - Morning Walk * (Euler graph property check)\n5. Kattis - catenyms * (Euler graph property check; 26 vertices; directed non\nsimple graph; printing the Euler tour in lexicographic order)\n6. Kattis - eulerianpath * (Euler graph property check; directed graph; printing\nthe Euler tour)\n7. Kattis - railroad2 * (x-shaped level junctions have even degrees - ignore X;\ny-shaped switches have degree 3 - Y has to be even)\nExtra UVa: 00117, 00302, 10129.\nExtra Kattis: grandopening.\nAlso see Chinese Postman Problem in Book 2.\nPro\ufb01le of Algorithm Inventors\nCarl Hierholzer (1840-1871) was a German mathematician. He proved and give an algo-\nrithm to \ufb01nd Eulerian trail of an Eulerian graph.\nM. Fleury was a French scientist who gave alternative algorithm to \ufb01nd Eulerian trail (but\nnot as e\ufb03cient as Hierholzer\u2019s).\n266\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\n4.7\nSolution to Non-Starred Exercises\nExercise 4.2.4.1: The minimum number of CCs is 1, when G is a connected graph. The\nminimum number of edges E in this case must be at least V -1 (a tree is the smallest connected\ngraph that has E = V -1). The maximum number of CCs is V , when G contains V vertices\nbut no edge (E = 0).\nExercise 4.2.4.2: UFDS solution is trivial: start with V disjoint vertices. For each undi-\nrected edge (u, v) in the graph, we call unionSet(u, v). The state of disjoint sets after\nprocessing all edges represent the connected components. BFS solution is also trivial: simply\nchange dfs(u) to bfs(u) from source vertex u. Both run in O(V + E) as we assume that\nUFDS operations are constant in competitive programming environment.\nExercise 4.2.6.1: One possible way is to modify the toposort(u) recursion into a recursive\nbacktracking variant (see Section 3.2.2).\nWe reset the VISITED \ufb02ag of vertex u back to\nUNVISITED when we exit the recursion. This is an exponential (slow) algorithm.\nExercise 4.2.7.1: Proof by contradiction. Assume that an undirected graph is a Bipartite\nGraph that has an odd (length) cycle. Let the odd cycle contains 2k+1 vertices for a certain\ninteger k that forms this path: v0 ! v1 ! v2 !", "mimetype": "text/plain", "start_char_idx": 771673, "end_char_idx": 775019, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3a40befc-46b3-4e28-aef5-60a4645a01db": {"__data__": {"id_": "3a40befc-46b3-4e28-aef5-60a4645a01db", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0cb9da55-d5a0-45f4-a60c-fd5c1d55b372", "node_type": "1", "metadata": {}, "hash": "e7994142a8580f379fd9f5df93ee6423ce987682b0b1c0c9f334ae0e778a71a2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bb5abc18-9f27-4940-8b34-c0275c88d8e9", "node_type": "1", "metadata": {}, "hash": "984a5d1f28532a6e0d16df0f9332a8e2bcb8ea1a9e26377c4857703b4ba7fa0d", "class_name": "RelatedNodeInfo"}}, "text": "BFS solution is also trivial: simply\nchange dfs(u) to bfs(u) from source vertex u. Both run in O(V + E) as we assume that\nUFDS operations are constant in competitive programming environment.\nExercise 4.2.6.1: One possible way is to modify the toposort(u) recursion into a recursive\nbacktracking variant (see Section 3.2.2).\nWe reset the VISITED \ufb02ag of vertex u back to\nUNVISITED when we exit the recursion. This is an exponential (slow) algorithm.\nExercise 4.2.7.1: Proof by contradiction. Assume that an undirected graph is a Bipartite\nGraph that has an odd (length) cycle. Let the odd cycle contains 2k+1 vertices for a certain\ninteger k that forms this path: v0 ! v1 ! v2 ! ... ! v2k\u22121 ! v2k ! v0. Now, we can put\nv0 in the left set, v1 in the right set, ..., v2k on the left set again, but then we have an edge\n(v2k, v0) that causes problem as v0 has been placed in the left set earlier ! contradiction.\nTherefore, a Bipartite Graph has no odd cycle. This property can be important to solve\nsome problems involving Bipartite Graph.\nExercise 4.2.7.2: The number of edges in a Bipartite Graph of size V (let\u2019s assume V is\neven) is maximized if we able to partition the left and right set equally. This way, we have a\ncomplete Bipartite Graph KV/2,V/2 with up to V\n2 \u21e5V\n2 = O(V 2) edges, i.e., a Bipartite Graph\ncan still be a dense graph.\nExercise 4.2.7.3: We use the proof from Exercise 4.2.7.1. A tree has no cycle to begin\nwith, so it will be a Bipartite Graph. A simple (constructive) partition is as follows: The\nroot, grandchildren (depth 2), grand-grand-grandchildren (depth 4), and so on will form the\nleft set. The children, grand-grandchildren (depth 3), and so on will form the right set.\nExercise 4.2.8.1: As we only modify O(V + E) DFS with a few more constant factor\nchecks, then cycleCheck also runs in O(V + E). However, if our intention is just to decide\nif the given (directed) graph is cyclic or not, we can speed up cycleCheck a bit to O(V )\nby declaring any input (directed) graph with E > V \u22121 edges as cyclic and we only run\ncycleCheck on small (directed) graph with E \uf8ffV \u22121 edges.\nExercise 4.2.8.2: Try this DAG G with V = 3 vertices and E = 3 edges = {0 ! 1, 1 ! 2,\n0 ! 2}. If we don\u2019t use the third DFS state EXPLORED, we will accidentally classify edge\n0 ! 2 as a back edge while it is actually a forward/cross edge.\nExercise 4.2.10.1: Proof by contradiction. Assume that there exists a path from vertex u\nto w and w to v where w is outside the SCC. From this, we can conclude that we can travel\nfrom vertex w to any vertices in the SCC and from any vertices in the SCC to w. Therefore,\nvertex w should be in the SCC. Contradiction. So there is no path between two vertices in\nan SCC that ever leaves the SCC.\nExercise 4.3.2.1: The reason that this early termination is correct is because Kruskal\u2019s\nonly take edges that will be part of the \ufb01nal MST. If Kruskal\u2019s has taken V -1 edges, we can\nbe sure that these V -1 taken edges will not form a cycle and by de\ufb01nition it must form a tree\nthat already spans graph G. Another possible implementation using Union-Find Disjoint\n267\n\n4.7.\nSOLUTION TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\nSets data structure is to stop the Kruskal\u2019s loop when the number of disjoint sets is already\ndown to one. Remember that we start Kruskal\u2019s loop with initially V disjoint sets and every\nedge that is taken by Kruskal\u2019s reduces the number of disjoint sets by one.", "mimetype": "text/plain", "start_char_idx": 774343, "end_char_idx": 777776, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bb5abc18-9f27-4940-8b34-c0275c88d8e9": {"__data__": {"id_": "bb5abc18-9f27-4940-8b34-c0275c88d8e9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3a40befc-46b3-4e28-aef5-60a4645a01db", "node_type": "1", "metadata": {}, "hash": "1da57e275707b054542791c82be5c2cf323ef3314fd01e5db220c19285bcf980", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8854baf9-a58c-418c-b629-c1cea783ce2d", "node_type": "1", "metadata": {}, "hash": "cd53621a556a7f37b4c76f271f1ffe3e9209295e2987a912da45b323057211df", "class_name": "RelatedNodeInfo"}}, "text": "Exercise 4.3.2.1: The reason that this early termination is correct is because Kruskal\u2019s\nonly take edges that will be part of the \ufb01nal MST. If Kruskal\u2019s has taken V -1 edges, we can\nbe sure that these V -1 taken edges will not form a cycle and by de\ufb01nition it must form a tree\nthat already spans graph G. Another possible implementation using Union-Find Disjoint\n267\n\n4.7.\nSOLUTION TO NON-STARRED EXERCISES\nc\u20ddSteven, Felix, Suhendry\nSets data structure is to stop the Kruskal\u2019s loop when the number of disjoint sets is already\ndown to one. Remember that we start Kruskal\u2019s loop with initially V disjoint sets and every\nedge that is taken by Kruskal\u2019s reduces the number of disjoint sets by one. We can only do\nso V -1 times before there is only one set left.\nExercise 4.4.3.1: It is OK, as the vertex information pair of vertex u is (dist[u], u).\nThe vertex number is unique, so the pairs are always recognized as di\u21b5erent by C++ STL\nset<ii> even though the shortest path distance values may not be unique.\nExercise 4.4.3.2: In Section 2.3.1, we have shown the way to reverse the default max heap\nof C++ STL priority queue into a min heap by multiplying the sort keys with -1.\nExercise 4.4.3.3: The Modi\ufb01ed Dijkstra\u2019s algorithm performance will degenerate, as it will\nprocess all inferior vertex information pairs (that should have been deleted earlier) instead\nof skipping them immediately. But the Modi\ufb01ed Dijkstra\u2019s algorithm should still remain\ncorrect, as inferior vertex information pairs will not cause any successful edge relaxation.\nExercise 4.4.5.1: No, we cannot use DP. The state and transition modeling outlined in\nSection 4.4.3 creates a State-Space graph that is not a DAG. For example, we can start\nfrom state (s, 0), add 1 unit of fuel at vertex s to reach state (s, 1), go to a neighbor vertex\ny\u2014suppose it is just 1 unit distance away\u2014to reach state (y, 0), add 1 unit of fuel again at\nvertex y to reach state (y, 1), and then return back to state (s, 0) (a cycle). This is a shortest\npath problem on general weighted graph. We need to use Dijkstra\u2019s algorithm.\nExercise 4.5.1.1: This is because we will add AM[i][k]+AM[k][j] which will over\ufb02ow\nif both AM[i][k] and AM[k][j] are near the MAX INT range, thus giving wrong answer\nthat is quite hard to debug. Note that memset(AM, 63, sizeof AM); will initialize values\n1 061 109 567 \u2013 which is just above 1e9 but less than half of 231-1 \u2013 to the matrix AM.\nExercise 4.5.1.2: Floyd-Warshall works in graph with negative weight edges. For graph\nwith negative cycle, see Section 4.5.3 about \u2018\ufb01nding negative cycle\u2019.\nExercise 4.5.3.1: Running Warshall\u2019s algorithm directly on a graph with V \uf8ff1000 will\nresult in TLE. Since the number of queries is low, we can a\u21b5ord to run O(V + E) DFS per\nquery to check if vertex u and v are connected by a path. If the input graph is directed, we\ncan \ufb01nd the SCCs of the directed graphs \ufb01rst in O(V + E). If u and v belong to the same\nSCC, then u will surely reach v. This can be tested with no additional cost. If SCC that\ncontains u has a directed edge to SCC that contains v, then u will also reach v. But the\nconnectivity check between di\u21b5erent SCCs is much harder to check and we may as well just\nuse a normal DFS to get the answer.\nExercise 4.5.3.2: In Floyd-Warshall, replace addition with multiplication and set the main\ndiagonal to 1.0. Run Floyd-Warshall and check if the main diagonal > 1.0.\nExercise 4.6.1.1: The implications and the solutions are as follows:\n1. CC2: The underlying State-space graph is a non-negative weighted DAG.", "mimetype": "text/plain", "start_char_idx": 777082, "end_char_idx": 780625, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8854baf9-a58c-418c-b629-c1cea783ce2d": {"__data__": {"id_": "8854baf9-a58c-418c-b629-c1cea783ce2d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bb5abc18-9f27-4940-8b34-c0275c88d8e9", "node_type": "1", "metadata": {}, "hash": "984a5d1f28532a6e0d16df0f9332a8e2bcb8ea1a9e26377c4857703b4ba7fa0d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "af874795-0079-4842-b74d-118633a92be2", "node_type": "1", "metadata": {}, "hash": "65959820fed52bbecf9139a82c2f8edfd25d49e8d4bba8c8247a21e29e329204", "class_name": "RelatedNodeInfo"}}, "text": "If u and v belong to the same\nSCC, then u will surely reach v. This can be tested with no additional cost. If SCC that\ncontains u has a directed edge to SCC that contains v, then u will also reach v. But the\nconnectivity check between di\u21b5erent SCCs is much harder to check and we may as well just\nuse a normal DFS to get the answer.\nExercise 4.5.3.2: In Floyd-Warshall, replace addition with multiplication and set the main\ndiagonal to 1.0. Run Floyd-Warshall and check if the main diagonal > 1.0.\nExercise 4.6.1.1: The implications and the solutions are as follows:\n1. CC2: The underlying State-space graph is a non-negative weighted DAG. We can use\nDP (as it is a DAG) or the slightly slower (by O(log V ) factor) Dijkstra\u2019s algorithm on\nthe implicit State-space graph.\n2. CC3: The underlying State-space graph is a (potentially negative) weighted DAG. But\nsince it is a DAG, there will not be any negative weight cycle to worry about. We can\nuse DP or Modi\ufb01ed Dijkstra\u2019s algorithm on the implicit State-space graph.\n3. CC4: The underlying State-space graph contains cycle (not a DAG). Therefore, we\ncannot use DP. As weight[i] remain all ones, the underlying potentially cyclic State-\n268\n\nCHAPTER 4. GRAPH\nc\u20ddSteven, Felix, Suhendry\nspace graph is unweighted. Hence we can use BFS on the implicit State-space graph\nto solve this unweighted SSSP problem.\n4. CC5: The underlying State-space graph is a potentially cyclic and non-negative weighted\ngraph.\nWe cannot use DP (not a DAG). We cannot use BFS (not an unweighted\ngraph). We have to use Dijkstra\u2019s algorithm (either version) on the implicit weighted\nState-space graph. This variant has been discussed earlier in Exercise 4.4.5.1.\n5. CC6: The underlying State-space graph is a potentially cyclic and potentially negative\nweighted graph. We cannot use DP. We probably can only use Bellman Ford\u2019s algo-\nrithm if the underlying graph is small enough (E = n \u21e5V with 1 \uf8ffn \uf8ff1000 and\n1 \uf8ffV \uf8ff10 000 is not small) and has no negative-weight cycle. Moreover, the problem\nwill be ill-de\ufb01ned if Bellman Ford\u2019s detects that there is at least one negative weight\ncycle in the underlying graph.\nExercise 4.6.1.2: The DAGs are as follows:\nFigure 4.42: Recursion DAG of TSP with n = 5; Also See Figure 3.2\nFigure 4.43: LIS as Longest Path of an Implicit DAG; Also See Figure 3.13\n269\n\n4.8.\nCHAPTER NOTES\nc\u20ddSteven, Felix, Suhendry\n4.8\nChapter Notes\nWe end this relatively long chapter by making a remark that this chapter has lots of algo-\nrithms and algorithm inventors\u2014the most in this book. This trend will likely increase in the\nfuture, i.e., there will be more graph algorithms used in programming contests. However, we\nhave to warn the contestants that recent IOIs and ICPCs usually do not just ask contestants\nto solve problems involving the pure form of these graph algorithms. New problems usually\nrequire contestants to use creative graph modeling, use the special properties of the input\ngraph, or combine two or more algorithms or to combine an algorithm with some advanced\ndata structures, e.g., combining the longest path in DAG with Segment Tree data structure;\nusing SCC contraction of Directed Graph to transform the graph into DAG before solving\nthe actual problem on DAG; etc. Some of these harder forms of graph problems are discussed\nin Book 2. We have shown several examples of such graph modeling skill in this chapter\nwhich we hope you are able to appreciate and eventually make it yours.\nThis chapter, albeit already quite long, still omits many known graph algorithms and\ngraph problems that may be tested in ICPCs.\nSome of them will be discussed later,\nnamely: Network Flow39, Graph Matching, Bitonic Traveling Salesman Problem, Hopcroft-\nKarp MCBM algorithm, Kuhn-Munkres (Hungarian) weighted MCBM algorithm, Edmonds\u2019\nMatching algorithm for general graph, NP-hard/complete graph problems, Tree/Euler graph\nspeci\ufb01c problems/algorithms, etc. We invite readers to continue studying these graph prob-\nlems by continue reading this book.", "mimetype": "text/plain", "start_char_idx": 779986, "end_char_idx": 783984, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "af874795-0079-4842-b74d-118633a92be2": {"__data__": {"id_": "af874795-0079-4842-b74d-118633a92be2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8854baf9-a58c-418c-b629-c1cea783ce2d", "node_type": "1", "metadata": {}, "hash": "cd53621a556a7f37b4c76f271f1ffe3e9209295e2987a912da45b323057211df", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "71f2eebf-98d1-4574-abdc-cbeedaf19805", "node_type": "1", "metadata": {}, "hash": "33a2c229447360bd9f2ef28dcf68e5bc450f1c0a3b448b109f2164bbe0b058cf", "class_name": "RelatedNodeInfo"}}, "text": "Some of these harder forms of graph problems are discussed\nin Book 2. We have shown several examples of such graph modeling skill in this chapter\nwhich we hope you are able to appreciate and eventually make it yours.\nThis chapter, albeit already quite long, still omits many known graph algorithms and\ngraph problems that may be tested in ICPCs.\nSome of them will be discussed later,\nnamely: Network Flow39, Graph Matching, Bitonic Traveling Salesman Problem, Hopcroft-\nKarp MCBM algorithm, Kuhn-Munkres (Hungarian) weighted MCBM algorithm, Edmonds\u2019\nMatching algorithm for general graph, NP-hard/complete graph problems, Tree/Euler graph\nspeci\ufb01c problems/algorithms, etc. We invite readers to continue studying these graph prob-\nlems by continue reading this book.\nIf you want to increase your winning chance in ICPC, please spend some time to study\nmore graph algorithms/problems beyond40 this book. These harder graph problems rarely\nappear in regional contests and if they are, they usually become the decider problems.\nHarder graph problems are more likely to appear in the ICPC World Finals level.\nHowever, we have good news for IOI contestants. We believe that most graph materials in\nthe IOI syllabus are already covered in this chapter that should give you reasonable partial\nmarks for IOI tasks involving graph. However, you still need to really master the basic\nalgorithms covered in this chapter and then improve your problem solving skills in applying\nthese basic algorithms to creative graph problems frequently posed in IOI in order to fully\nsolve the task.\nStatistics of CP Editions\n1st\n2nd\n3rd\n4th\nNumber of Pages\n35\n49\n70\n78 (+11%)\nWritten Exercises\n8\n30\n50\n24+20*=44 (-12%)\nProgramming Exercises\n173\n230\n248\n431 (+74%)\nThe breakdown of the number of programming exercises from each section is shown below:\nSection\nTitle\nAppearance\n% in Chapter\n% in Book\n4.2\nGraph Traversal\n130\n\u21e130%\n\u21e13.8%\n4.3\nMinimum Spanning Tree\n44\n\u21e110%\n\u21e11.3%\n4.4\nSingle-Source Shortest Paths\n102\n\u21e124%\n\u21e12.9%\n4.5\nAll-Pairs Shortest Paths\n42\n\u21e110%\n\u21e11.2%\n4.6\nSpecial Graphs\n113\n\u21e126%\n\u21e13.3%\nTotal\n431\n\u21e112.5%\n39In CP4, we move Network Flow section that was previously in this chapter (in CP3) to Book 2.\n40Interested readers are welcome to explore Felix\u2019s paper [19] that discusses maximum \ufb02ow algorithm for\nlarge graphs of 411 million vertices and 31 billion edges!\n270\n\nEnd of Book 1\nThis is the end of Book 1 but not the end of CP4. Due to the signi\ufb01cant increase of the\nnumber of pages needed to write the updated content between CP3 (published in year 2013,\n447 pages) and this CP4 (published in year 2020, 681 pages, \u21e150% more than CP3), we\nhave decided to split our book into two smaller books for the following practical reasons:\n1. To reduce the thickness of each smaller book by approximately half (329/352 pages for\nBook 1/2, respectively) as not many (economical) book bindings with over 500 pages\nare su\ufb03ciently durable.\n2. To have a cleaner separation of topics:\n\u2022 Book 1 is targeted for beginners in Competitive Programming: high school stu-\ndents/NOI/IOI contestants, freshman/sophomore level University students taking\nbasic data structures and algorithms courses/equivalent who may be interested\nto start their \ufb01rst ICPC, or (fresh) graduates preparing for IT job interview at\ntop IT companies. We foresee that our \ufb01rst time readers will buy and read Book\n1 \ufb01rst and may or may not continue with Book 2 depending on their needs and\nfuture interests. Most of the IOI syllabus [16] are covered in Book 1.\n\u2022 Book 2 is targeted for seasoned contestants in Competitive Programming, mostly\nICPC contestants, junior/senior level University students taking advanced algo-\nrithms courses/equivalent. We assume that our Book 2 readers have mastered\nBook 1 content as we will not repeat the earlier content in Book 2.", "mimetype": "text/plain", "start_char_idx": 783220, "end_char_idx": 787024, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "71f2eebf-98d1-4574-abdc-cbeedaf19805": {"__data__": {"id_": "71f2eebf-98d1-4574-abdc-cbeedaf19805", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "af874795-0079-4842-b74d-118633a92be2", "node_type": "1", "metadata": {}, "hash": "65959820fed52bbecf9139a82c2f8edfd25d49e8d4bba8c8247a21e29e329204", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "736c8c54-49d0-410f-8a8f-67a370f7d149", "node_type": "1", "metadata": {}, "hash": "4161ca5dfeb97ca8064504362449b1d35350d4cea5759ecbde9a1e04a8463b3a", "class_name": "RelatedNodeInfo"}}, "text": "We foresee that our \ufb01rst time readers will buy and read Book\n1 \ufb01rst and may or may not continue with Book 2 depending on their needs and\nfuture interests. Most of the IOI syllabus [16] are covered in Book 1.\n\u2022 Book 2 is targeted for seasoned contestants in Competitive Programming, mostly\nICPC contestants, junior/senior level University students taking advanced algo-\nrithms courses/equivalent. We assume that our Book 2 readers have mastered\nBook 1 content as we will not repeat the earlier content in Book 2. Many mate-\nrial in Book 2 are currently outside the IOI syllabus [16] as of year 2020 and thus\nwill not appear in the NOI/IOI.\n3. Readers can save half of the book weight when they carry either Book 1 or Book 2\naround. We make Book 1 content totally independent of Book 2 and we assume most\nreaders will move on to Book 2 only after mastering the contents of Book 1.\n4. Readers gets \u21e150% money savings if they only need to study the contents of Book 1.\nIf you don\u2019t purchase a copy of Book 2 together with this Book 1, please \ufb02ip over to page\n272 to see a preview of Book 2 and then decide for yourself on whether you want to continue\nthis exciting Competitive Programming journey.\n271\n\nPreview of Book 2\nAre you curious of what are in store if you continue your Competitive Programming journey\nby reading Book 2? There are another 352 pages of material worth to be discovered.\nHere are some preview:\n1. In Chapter 5, we will learn mathematics-related problems and algorithms, e.g.,\n(a) What are the prime factors of 142 391 208 960?\n(b) What is the value of C(100000, 50000)%1000000007?\n(c) What is the value of 72020%1000000007?\nAnswer 1. (a). 210 \u21e534 \u21e55 \u21e574 \u21e511 \u21e513; (b). 149 033 233; (c). 403 769 496.\n2. In Chapter 6, we will learn problems involving (very) long strings, e.g.,\n(a) What is the Longest Repeated Substring in string \u201cCGACATTACATTA\u201d?\n(b) What is the longest palindrome that you can make from \u201cRACEF1CARFAST\u201d by\ndeleting zero or more characters?\nAnswer 2. (a). \u201cACATTA\u201d; (b). \u201cRACECAR\u201d.\n3. In Chapter 7, we will learn (computational) geometry problems and algorithms, e.g.,\n(a) Given 3 points a(2, 2), o(2, 4), and b(4, 3), compute the angle aob in degrees!\n(b) What is the perimeter and the area of polygon described by these 6 points that\nare given counter-clockwise order: (1, 1), (3, 3), (9, 1), (12, 4), (9, 7), (1, 7)?\n(c) What is the value of \u21e1\u21e5\nR 2\n0 (e\u2212x2 + 2 \u00b7 px)2?\nAnswer 3. (a). 63.43 degrees; (b). perimeter = 31.64, area = 49.00; (c). 34.72.\n4. In Chapter 8, we will learn several advanced topics.\n(a) How many ways can you put 15 chess queens on an empty 15 \u21e515 chessboard so\nthat none of them attack each other?\n(b) Given a set of integers S = {10, 77, 2328, 2894, 3117, 4210, 4943, 5690, 7048, 9512},\n\ufb01nd any two non-empty, distinct subsets with equal sum!\nAnswer 4. (a). 2 279 184 ways; (b). {3117, 4210, 4943} and {2328, 2894, 7048}.\n5. In Chapter 9, we will learn several rare (hard) topics, e.g.,\n(a) Give the smallest positive integer answer for the following mathematical puzzle:\n\u201cThere are certain things whose number is unknown. If we count them by threes,\nwe have two left over; by \ufb01ves, we have three left over; and by sevens, two are left\nover. How many things are there?\u201d.", "mimetype": "text/plain", "start_char_idx": 786513, "end_char_idx": 789745, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "736c8c54-49d0-410f-8a8f-67a370f7d149": {"__data__": {"id_": "736c8c54-49d0-410f-8a8f-67a370f7d149", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "71f2eebf-98d1-4574-abdc-cbeedaf19805", "node_type": "1", "metadata": {}, "hash": "33a2c229447360bd9f2ef28dcf68e5bc450f1c0a3b448b109f2164bbe0b058cf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4703a5d2-7cb4-4934-b40d-4c2bbb3e93a4", "node_type": "1", "metadata": {}, "hash": "58f3bad29ea9103339731e345b4b3f7dc9d9758719d56b0801d9347b9c50fc5e", "class_name": "RelatedNodeInfo"}}, "text": "(b) Given a set of integers S = {10, 77, 2328, 2894, 3117, 4210, 4943, 5690, 7048, 9512},\n\ufb01nd any two non-empty, distinct subsets with equal sum!\nAnswer 4. (a). 2 279 184 ways; (b). {3117, 4210, 4943} and {2328, 2894, 7048}.\n5. In Chapter 9, we will learn several rare (hard) topics, e.g.,\n(a) Give the smallest positive integer answer for the following mathematical puzzle:\n\u201cThere are certain things whose number is unknown. If we count them by threes,\nwe have two left over; by \ufb01ves, we have three left over; and by sevens, two are left\nover. How many things are there?\u201d.\n(b) Show a way to put N = 100 000 chess queens on an N \u21e5N chess board so that\nno queen attack each other!\nAnswer 5. (a). 23; (b). There is a pattern to generate the required solution.\n272\n\nBibliography\n[1] Ahmed Shamsul Are\ufb01n.\nArt of Programming Contest (from Steven\u2019s old Website).\nGyankosh Prokashoni (Available Online), 2006.\n[2] Richard Ernest Bellman. On a routing problem. Quarterly of Applied Mathematics, 16\n(1):87\u201390, 1958.\n[3] Frank Carrano. Data Abstraction and Problem Solving with C++: Walls and Mirrors.\nAddison Wesley, 5th edition, 2006.\n[4] Codeforces. Contests.\nhttp://codeforces.com/contests.\n[5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Cli\u21b5Stein. Introduc-\ntion to Algorithm. MIT Press, 3rd edition, 2009.\n[6] Sanjoy Dasgupta, Christos Papadimitriou, and Umesh Vazirani. Algorithms. McGraw\nHill, 2008.\n[7] Mark de Berg, Marc van Kreveld, Mark Overmars, and Otfried Cheong Schwarzkopf.\nComputational Geometry: Algorithms and Applications. Springer, 2nd edition, 2000.\n[8] Edsger Wybe Dijkstra. A note on two problems in connexion with graphs. Numerische\nMathematik, 1:269\u2013271, 1959.\n[9] Adam Drozdek. Data structures and algorithms in Java. Cengage Learning, 3rd edition,\n2008.\n[10] Jack Edmonds. Paths, trees, and \ufb02owers. Canadian Journal on Maths, 17:449\u2013467,\n1965.\n[11] Susanna S. Epp. Discrete Mathematics with Applications. Brooks-Cole, 4th edition,\n2010.\n[12] Fabian Ernst, Jeroen Moelands, and Seppo Pieterse. Teamwork in Prog Contests: 3 *\n1 = 4.\nhttp://xrds.acm.org/article.cfm?aid=332139.\n[13] Duan Fanding. SPFA, fast algorithm for shortest path (in Chinese). Journal of South-\nwest Jiaotong University, 29 (2):207\u2013212, 1994.\n[14] Peter M. Fenwick. A new data structure for cumulative frequency tables. Software:\nPractice and Experience, 24 (3):327\u2013336, 1994.\n[15] Robert W. Floyd. Algorithm 97: Shortest Path. Communications of the ACM, 5 (6):345,\n1962.\n273\n\nBIBLIOGRAPHY\nc\u20ddSteven, Felix, Suhendry\n[16] Michal Fori\u02c7sek. IOI Syllabus.\nhttps://people.ksp.sk/\u21e0misof/ioi-syllabus/ioi-syllabus.pdf.\n[17] Michal Fori\u02c7sek.\nThe di\ufb03culty of programming contests increases.\nIn International\nConference on Informatics in Secondary Schools, 2010.\n[18] Michael R. Garey and David S. Johnson. Computers and Intractability: A Guide to the\nTheory of NP-Completeness. W. H. Freeman & Co. New York, NY, USA, 1979.\n[19] Felix Halim, Roland Hock Chuan Yap, and Yongzheng Wu.", "mimetype": "text/plain", "start_char_idx": 789172, "end_char_idx": 792152, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4703a5d2-7cb4-4934-b40d-4c2bbb3e93a4": {"__data__": {"id_": "4703a5d2-7cb4-4934-b40d-4c2bbb3e93a4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "736c8c54-49d0-410f-8a8f-67a370f7d149", "node_type": "1", "metadata": {}, "hash": "4161ca5dfeb97ca8064504362449b1d35350d4cea5759ecbde9a1e04a8463b3a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fb560e0f-58e0-4f46-9f47-21e54feed8f5", "node_type": "1", "metadata": {}, "hash": "1a8e7b27bed8b6b91516d7281a08ed7b4c16430c6ea0c04ef5ab513cf685ed22", "class_name": "RelatedNodeInfo"}}, "text": "Communications of the ACM, 5 (6):345,\n1962.\n273\n\nBIBLIOGRAPHY\nc\u20ddSteven, Felix, Suhendry\n[16] Michal Fori\u02c7sek. IOI Syllabus.\nhttps://people.ksp.sk/\u21e0misof/ioi-syllabus/ioi-syllabus.pdf.\n[17] Michal Fori\u02c7sek.\nThe di\ufb03culty of programming contests increases.\nIn International\nConference on Informatics in Secondary Schools, 2010.\n[18] Michael R. Garey and David S. Johnson. Computers and Intractability: A Guide to the\nTheory of NP-Completeness. W. H. Freeman & Co. New York, NY, USA, 1979.\n[19] Felix Halim, Roland Hock Chuan Yap, and Yongzheng Wu.\nA MapReduce-Based\nMaximum-Flow Algorithm for Large Small-World Network Graphs. In ICDCS, 2011.\n[20] Steven Halim. Expecting the Unexpected. Olympiads in Informatics, 7:36\u201341, 2013.\n[21] Steven Halim and Felix Halim. Competitive Programming in National University of\nSingapore. In A new learning paradigm: competition supported by technology. Ediciones\nSello Editorial S.L., 2010.\n[22] Steven Halim, Roland Hock Chuan Yap, and Felix Halim. Engineering SLS for the Low\nAutocorrelation Binary Sequence Problem. In Constraint Programming, pages 640\u2013645,\n2008.\n[23] Steven Halim, Roland Hock Chuan Yap, and Hoong Chuin Lau.\nAn Integrated\nWhite+Black Box Approach for Designing & Tuning SLS. In Constraint Programming,\npages 332\u2013347, 2007.\n[24] Steven Halim, Koh Zi Chun, Loh Victor Bo Huai, and Felix Halim. Learning Algorithms\nwith Uni\ufb01ed and Interactive Visualization. Olympiads in Informatics, 6:53\u201368, 2012.\n[25] Michael Held and Richard Manning Karp. A dynamic programming approach to se-\nquencing problems. Journal for the Society for Industrial and Applied Mathematics, 10\n(1):196\u2013210, 1962.\n[26] John Edward Hopcroft and Richard Manning Karp. An n5/2 algorithm for maximum\nmatchings in bipartite graphs. SIAM Journal on Computing, 2 (4):225\u2013231, 1973.\n[27] Topcoder Inc. Algorithm Tutorials.\nhttps://www.topcoder.com/community/data-science/data-science-tutorials/.\n[28] Topcoder Inc. PrimePairs. Copyright 2009 Topcoder, Inc. All rights reserved.\nhttps://community.topcoder.com/stat?c=problem statement&pm=10187&rd=13742.\n[29] Topcoder Inc. Single Round Match (SRM).\nhttps://www.topcoder.com/community/competitive-programming/.\n[30] Competitive Learning Institute. ACM ICPC Live Archive.\nhttps://icpcarchive.ecs.baylor.edu/.\n[31] IOI. International Olympiad in Informatics.\nhttps://ioinformatics.org.\n[32] Giuseppe F. Italiano, Luigi Laura, and Federico Santaroni. Finding Strong Bridges and\nStrong Articulation Points in Linear Time. Combinatorial Optimization and Applica-\ntions, 6508:157\u2013169, 2010.\n274\n\nBIBLIOGRAPHY\nc\u20ddSteven, Felix, Suhendry\n[33] Arthur B. Kahn. Topological sorting of large networks. Communications of the ACM,\n5 (11):558\u2013562, 1962.\n[34] Kattis. Online Judge.\nhttps://open.kattis.com.\n[35] Jon Kleinberg and Eva Tardos. Algorithm Design. Addison Wesley, 2006.\n[36] Alexander Kulikov and Pavel Pevzner. Learning Algorithms through Programming and\nPuzzle Solving. Active Learning Technologies, 2018.\n[37] Antti Laaksonen. Guide to Competitive Programming. Springer, 2017.\n[38] Anany Levitin. Introduction to The Design & Analysis of Algorithms. Addison Wesley,\n2002.\n[39] Rujia Liu. Algorithm Contests for Beginners (In Chinese). Tsinghua University Press,\n2009.\n[40] Rujia Liu and Liang Huang. The Art of Algorithms and Programming Contests (In\nChinese). Tsinghua University Press, 2003.", "mimetype": "text/plain", "start_char_idx": 791608, "end_char_idx": 794964, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fb560e0f-58e0-4f46-9f47-21e54feed8f5": {"__data__": {"id_": "fb560e0f-58e0-4f46-9f47-21e54feed8f5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4703a5d2-7cb4-4934-b40d-4c2bbb3e93a4", "node_type": "1", "metadata": {}, "hash": "58f3bad29ea9103339731e345b4b3f7dc9d9758719d56b0801d9347b9c50fc5e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d752bb49-9b51-447d-a7c2-8d4328f79264", "node_type": "1", "metadata": {}, "hash": "5a1e6c8768799793030032cdc40a0607ee522275d0c7fbfa96abddf415e37521", "class_name": "RelatedNodeInfo"}}, "text": "[34] Kattis. Online Judge.\nhttps://open.kattis.com.\n[35] Jon Kleinberg and Eva Tardos. Algorithm Design. Addison Wesley, 2006.\n[36] Alexander Kulikov and Pavel Pevzner. Learning Algorithms through Programming and\nPuzzle Solving. Active Learning Technologies, 2018.\n[37] Antti Laaksonen. Guide to Competitive Programming. Springer, 2017.\n[38] Anany Levitin. Introduction to The Design & Analysis of Algorithms. Addison Wesley,\n2002.\n[39] Rujia Liu. Algorithm Contests for Beginners (In Chinese). Tsinghua University Press,\n2009.\n[40] Rujia Liu and Liang Huang. The Art of Algorithms and Programming Contests (In\nChinese). Tsinghua University Press, 2003.\n[41] Edward Forrest Moore. The shortest path through a maze. Proceedings of the Interna-\ntional Symposium on the Theory of Switching, 1959.\n[42] Institute of Mathematics and Lithuania Informatics. Olympiads in Informatics.\nhttp://www.mii.lt/olympiads in informatics/.\n[43] USA Computing Olympiad. USACO Training Program Gateway.\nhttps://train.usaco.org/usacogate.\n[44] Formerly University of Valladolid (UVa) Online Judge. Online Judge.\nhttps://onlinejudge.org.\n[45] Joseph O\u2019Rourke. Computational Geometry in C. Cambridge University Press, 2nd\nedition, 1998.\n[46] David Pearson. A polynomial-time algorithm for the change-making problem. Opera-\ntions Research Letters, 33 (3):231\u2013234, 2004.\n[47] George P\u00b4olya. How to Solve It. Princeton University Press, 2nd edition, 1957.\n[48] Janet Prichard and Frank Carrano. Data Abstraction and Problem Solving with Java:\nWalls and Mirrors. Addison Wesley, 3rd edition, 2010.\n[49] Kenneth H. Rosen. Elementary Number Theory and its Applications. Addison Wesley\nLongman, 4th edition, 2000.\n[50] Kenneth H. Rosen. Discrete Mathematics and its Applications. McGraw-Hill, 7th edi-\ntion, 2012.\n[51] Robert Sedgewick. Algorithms in C++, Part 1-5. Addison Wesley, 3rd edition, 2002.\n[52] Steven Sol Skiena. The Algorithm Design Manual. Springer, 2008.\n[53] Steven Sol Skiena and Miguel \u00b4Angel Revilla. Programming Challenges. Springer, 2003.\n275\n\nBIBLIOGRAPHY\nc\u20ddSteven, Felix, Suhendry\n[54] Wing-Kin Sung. Algorithms in Bioinformatics: A Practical Introduction. CRC Press\n(Taylor & Francis Group), 1st edition, 2010.\n[55] Robert Endre Tarjan. Depth-\ufb01rst search and linear graph algorithms. SIAM Journal\non Computing, 1 (2):146\u2013160, 1972.\n[56] Je\u21b5rey Trevers and Stanley Milgram.\nAn Experimental Study of the Small World\nProblem. Sociometry, 32 (4):425\u2013443, 1969.\n[57] Baylor University. International Collegiate Programming Contest.\nhttps://icpc.baylor.edu/.\n[58] Tom Verhoe\u21b5. 20 Years of IOI Competition Tasks. Olympiads in Informatics, 3:149\u2013166,\n2009.\n[59] Henry S. Warren. Hacker\u2019s Delight. Pearson, 1st edition, 2003.\n[60] Stephen Warshall. A theorem on Boolean matrices. Journal of the ACM, 9 (1):11\u201312,\n1962.\n276\n\nIndex\nAbstract Data Type, 79\nAckermann Function, 99\nACM, 4\nAdelson-Velskii, Georgii, 90\nAdjacency List, 95\nAdjacency Matrix, 94\nAlgorithm\nAugmenting Path, 258\nBellman-Ford, 234\nBellman-Ford-Moore, 236\nBreadth First Search, 197\nDepth First Search, 195\nDijkstra\u2019s, 227\nFleury\u2019s, 261\nFloyd-Warshall, 241\nHeld-Karp, 183\nHierholzer\u2019s, 261\nKadane\u2019s, 173\nKahn\u2019s,", "mimetype": "text/plain", "start_char_idx": 794311, "end_char_idx": 797475, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d752bb49-9b51-447d-a7c2-8d4328f79264": {"__data__": {"id_": "d752bb49-9b51-447d-a7c2-8d4328f79264", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fb560e0f-58e0-4f46-9f47-21e54feed8f5", "node_type": "1", "metadata": {}, "hash": "1a8e7b27bed8b6b91516d7281a08ed7b4c16430c6ea0c04ef5ab513cf685ed22", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ff1fc269-e1bb-41ee-836c-57189998bad4", "node_type": "1", "metadata": {}, "hash": "fa7135748abe70f716fb93b497092900484396a9f7dc8bf79559ddf8704d646a", "class_name": "RelatedNodeInfo"}}, "text": "Hacker\u2019s Delight. Pearson, 1st edition, 2003.\n[60] Stephen Warshall. A theorem on Boolean matrices. Journal of the ACM, 9 (1):11\u201312,\n1962.\n276\n\nIndex\nAbstract Data Type, 79\nAckermann Function, 99\nACM, 4\nAdelson-Velskii, Georgii, 90\nAdjacency List, 95\nAdjacency Matrix, 94\nAlgorithm\nAugmenting Path, 258\nBellman-Ford, 234\nBellman-Ford-Moore, 236\nBreadth First Search, 197\nDepth First Search, 195\nDijkstra\u2019s, 227\nFleury\u2019s, 261\nFloyd-Warshall, 241\nHeld-Karp, 183\nHierholzer\u2019s, 261\nKadane\u2019s, 173\nKahn\u2019s, 201\nKosaraju\u2019s, 208\nKruskal\u2019s, 215\nPrim\u2019s, 217\nShunting-yard, 73\nSPFA, 236\nTarjan\u2019s, 209\nWarshall\u2019s, 245\nAll-Pairs Shortest Paths, 241, 256\n(Cheapest/Negative) Cycle, 245\nDiameter of a Graph, 246\nMiniMax and MaxiMin, 245\nPrinting the Shortest Paths, 244\nSCCs of a Directed Graph, 246\nTransitive Closure, 245\nAmortized Analysis, 11, 100, 210\nArray, 55\nArticulation Points, 205, 256\nAugmenting Path Algorithm, 258\nBacktracking, 130, 135, 164, 196\nBalanced Binary Search Tree, 84, 227\nBayer, Rudolf, 90\nBellman, Richard Ernest, 234, 247\nBellman-Ford Algorithm, 234\nBellman-Ford-Moore Algorithm, 236\nBerge\u2019s Lemma, 258, 263\nBerge, Claude, 263\nBFS, 202, 223\nBiconnected, 205\nBig Integer, 66\nBinary Heap, 229\nBinary Indexed Tree, 104\nBinary Search, 57, 148\nBinary Search the Answer, 108, 150\nBinary Search Tree, 84\nBipartite Graph, 257\nCheck, 202\nMCBM, 257\nBipartite Matching, see MCBM\nBisection Method, 149\nBitmask, 62, 182\nBitset, 57\nBoole, George, 65\nBracket (Parenthesis) Matching, 71\nBreadth First Search, see BFS\nBridges, 205, 256\nBrute Force, see Complete Search\nBubble Sort, 56, 59\nBucket Sort, 56\nC++11\nauto, 42\nlambda expression, 56\nunordered map, 81\nunordered set, 81\nC++14\ngeneric lambda expression, 56\nC++17\nstructured binding, 195\ntuple, 42\nCase Analysis, 27\nChord Edge, 220\nCipher, 35\nCodeforces, 21\nCoin-Change, 155, 180\nCollatz\u2019s Conjecture, 146\nCompetitive Programming, 1\n277\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nComplete Search, 130\nCompression, 9, 141\nConjecture\nCollatz\u2019s, 146\nConnected Components, 198\nCounting Paths in DAG, 250\nCounting Sort, 56, 60\nCryptography, 35\nCut Edge, see Bridges\nCut Vertex, see Articulation Points\nCycle\nCheapest Cycle, 245\nNegative Cycle, 245\nD&C, 59, 87, 148, 152\nDAG\nCounting Paths in, 250\nGeneral Graph to DAG, 251\nLongest Paths, 249\nShortest Paths, 249\nData Compression, 141\nData Structures, 53\nDegree of a Vertex, 261\nDepth First Search, 195\nDeque, 70, 224\nDiameter\nGraph, 246\nTree, 256\nDijkstra\u2019s Algorithm, 227\nModi\ufb01ed, 229\nOriginal, 227\nDijkstra, Edsger Wybe, 73, 227, 233\nDilworth\u2019s Theorem, 184, 188\nDirect Addressing Table, 82\nDirected Acyclic Graph, see DAG\nDivide and Conquer, see D&C\nDP, 164, 249\nDynamic Programming, see DP\nEdge List,", "mimetype": "text/plain", "start_char_idx": 796976, "end_char_idx": 799666, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff1fc269-e1bb-41ee-836c-57189998bad4": {"__data__": {"id_": "ff1fc269-e1bb-41ee-836c-57189998bad4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d752bb49-9b51-447d-a7c2-8d4328f79264", "node_type": "1", "metadata": {}, "hash": "5a1e6c8768799793030032cdc40a0607ee522275d0c7fbfa96abddf415e37521", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e7d331d4-2271-418c-b43e-4c2f4bf38933", "node_type": "1", "metadata": {}, "hash": "26a71dd6c05f5220fe573eebcf7e7010cf329ca26d5457f7cd1a65e2278d4d3a", "class_name": "RelatedNodeInfo"}}, "text": "245\nD&C, 59, 87, 148, 152\nDAG\nCounting Paths in, 250\nGeneral Graph to DAG, 251\nLongest Paths, 249\nShortest Paths, 249\nData Compression, 141\nData Structures, 53\nDegree of a Vertex, 261\nDepth First Search, 195\nDeque, 70, 224\nDiameter\nGraph, 246\nTree, 256\nDijkstra\u2019s Algorithm, 227\nModi\ufb01ed, 229\nOriginal, 227\nDijkstra, Edsger Wybe, 73, 227, 233\nDilworth\u2019s Theorem, 184, 188\nDirect Addressing Table, 82\nDirected Acyclic Graph, see DAG\nDivide and Conquer, see D&C\nDP, 164, 249\nDynamic Programming, see DP\nEdge List, 95\nEulerian Graph, 260\nEulerian Path/Tour, 260\nFenwick Tree, 104\nFenwick, Peter M, 123\nFleury\u2019s Algorithm, 261\nFleury, M. 266\nFlood Fill, 199\nFloyd, Robert W, 241, 247\nFloyd-Warshall Algorithm, 241\nFord Jr, Lester Randolph, 234, 247\nForsyth-Edwards Notation (FEN), 36\nFractional Knapsack, 161\nGraph, 193\nData Structure, 94\nDiameter, 246\nGirth, 245\nSpecial, 96, 249\nTranspose, 98\nGraph Modeling, 199, 238\nGreedy Algorithm, 155\nHash Table, 81\nHeap, 78\nHeap Sort, 56, 79\nHeld-Karp Algorithm, 183\nHierholzer\u2019s Algorithm, 261\nHierholzer, Carl, 266\nHopcroft, John Edward, 194, 205\nHu\u21b5man Code, 161\nICPC, 1\nImplicit Graph, 97\nIn-degree, 261\nInclusion-Exclusion, 104, 175\nIn\ufb01x to Post\ufb01x Conversion, 72\nInorder Traversal, 86\nInsertion Sort, 56\nInterval Covering Problem, 157\nInverse Ackermann Function, 99\nInversion Index, 59\nIOI, 1\nIOI 2003 - Trail Maintenance, 222\nIOI 2009 - Garage, 30\nIOI 2009 - POI, 30\nIOI 2010 - Cluedo, 29\nIOI 2010 - Memory, 29\nIOI 2010 - Quality of Living, 154\nIOI 2011 - Crocodile, 240\nIOI 2011 - Elephants, 162\nIOI 2011 - Pigeons, 76\nIOI 2011 - Race, 154\nIOI 2011 - Tropical Garden, 214\nIOI 2011 - Valley, 154\nJarn\u00b4\u0131k, Vojt\u02c6ech, 222\nJava BigInteger Class, 66\nJosephus Problem, 135\nKadane\u2019s Algorithm, 173\nKadane, Jay, 173, 174\nKahn\u2019s Algorithm, 201\n278\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis, 21\nKattis - 10kindsofpeople *, 212\nKattis - 2048 *, 75\nKattis - 246greaaat *, 264\nKattis - 4thought, 144\nKattis - 8queens, 144\nKattis - a1paper *, 154\nKattis - abc, 29\nKattis - abinitio *, 122\nKattis - aboveaverage, 146\nKattis - absurdistan3, 266\nKattis - acm *, 29\nKattis - acm2, 162\nKattis - addemup, 75\nKattis - addingwords *, 92\nKattis - adjoin *, 265\nKattis - administrativeproblems *, 93\nKattis - ads, 214\nKattis - adventuremoving4, 265\nKattis - airconditioned *, 162\nKattis - akcija, 162\nKattis - alehouse, 91\nKattis - alicedigital, 187\nKattis - allpairspath *, 248\nKattis - almostunion\ufb01nd *, 122\nKattis - alphabet,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e7d331d4-2271-418c-b43e-4c2f4bf38933": {"__data__": {"id_": "e7d331d4-2271-418c-b43e-4c2f4bf38933", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ff1fc269-e1bb-41ee-836c-57189998bad4", "node_type": "1", "metadata": {}, "hash": "fa7135748abe70f716fb93b497092900484396a9f7dc8bf79559ddf8704d646a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "68e2d899-0329-41d6-8d37-050f5181fdeb", "node_type": "1", "metadata": {}, "hash": "0ba364b8bbf613fe44181f32189f250421d29ed14f69c56124900c5386f54acc", "class_name": "RelatedNodeInfo"}}, "text": "154\nKattis - abc, 29\nKattis - abinitio *, 122\nKattis - aboveaverage, 146\nKattis - absurdistan3, 266\nKattis - acm *, 29\nKattis - acm2, 162\nKattis - addemup, 75\nKattis - addingwords *, 92\nKattis - adjoin *, 265\nKattis - administrativeproblems *, 93\nKattis - ads, 214\nKattis - adventuremoving4, 265\nKattis - airconditioned *, 162\nKattis - akcija, 162\nKattis - alehouse, 91\nKattis - alicedigital, 187\nKattis - allpairspath *, 248\nKattis - almostunion\ufb01nd *, 122\nKattis - alphabet, 188\nKattis - alphabetanimals, 122\nKattis - alphabetspam *, 91\nKattis - amanda, 213\nKattis - amoebas *, 212\nKattis - andrewant, 162\nKattis - anewalphabet *, 39\nKattis - anotherbrick, 30\nKattis - antiarithmetic, 144\nKattis - ants *, 163\nKattis - apples, 75\nKattis - applesack, 163\nKattis - aprizenoonecanwin, 162\nKattis - arbitrage *, 248\nKattis - arcticnetwork, 219, 222\nKattis - armystrengtheasy, 29\nKattis - armystrengthhard, 29\nKattis - artichoke *, 29\nKattis - asciiaddition *, 40\nKattis - assembly, 248\nKattis - astro, 74\nKattis - autori *, 39\nKattis - averagespeed, 40\nKattis - avoidland, 162\nKattis - awkwardparty *, 92\nKattis - baas, 264\nKattis - babel\ufb01sh, 92\nKattis - babybites, 29\nKattis - babynames *, 93\nKattis - backpackbuddies, 240\nKattis - backspace, 77\nKattis - baconeggsandspam, 93\nKattis - bagoftiles *, 188\nKattis - ballotboxes *, 159, 163\nKattis - ballsandneedles, 213\nKattis - baloni *, 74\nKattis - bank *, 163\nKattis - bard, 92\nKattis - basicinterpreter *, 92\nKattis - basicprogramming1 *, 30\nKattis - basicprogramming2 *, 75\nKattis - basketballoneonone, 29\nKattis - batterup *, 29\nKattis - battleship *, 37\nKattis - battlesimulation *, 30\nKattis - beatspread *, 37\nKattis - beehives2, 239\nKattis - beekeeper, 30\nKattis - beepers *, 189\nKattis - bela *, 36\nKattis - bestbefore *, 38\nKattis - bestrelayteam, 144\nKattis - bijele, 36\nKattis - bikegears, 144\nKattis - birds *, 162\nKattis - birthday *, 213\nKattis - birthdayboy *, 38\nKattis - bitbybit *, 76\nKattis - bits, 76\nKattis - bitsequalizer *, 30\nKattis - blackfriday *, 144\nKattis - blockcrusher *, 240\nKattis - boatparts, 92\nKattis - bookclub *, 266\nKattis - booking, 75\nKattis - bookingaroom *, 91\nKattis - bossbattle *, 30\nKattis - bottledup, 30\nKattis - boundingrobots, 30\nKattis - bowserpipes, 264\nKattis - bread *, 76\nKattis - breakingbad, 213\nKattis - brexit *, 213\nKattis - brexitnegotiations, 213\nKattis - brickwall, 214\n279\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - brokenswords, 29\nKattis - bst *,", "mimetype": "text/plain", "start_char_idx": 801127, "end_char_idx": 803586, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "68e2d899-0329-41d6-8d37-050f5181fdeb": {"__data__": {"id_": "68e2d899-0329-41d6-8d37-050f5181fdeb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e7d331d4-2271-418c-b43e-4c2f4bf38933", "node_type": "1", "metadata": {}, "hash": "26a71dd6c05f5220fe573eebcf7e7010cf329ca26d5457f7cd1a65e2278d4d3a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8b922dca-ff19-4502-aedd-b8ebd109f1b3", "node_type": "1", "metadata": {}, "hash": "70fa85fbb7bd93688b74062054544d129787779f36ab14931c38db8f0a81f926", "class_name": "RelatedNodeInfo"}}, "text": "30\nKattis - blackfriday *, 144\nKattis - blockcrusher *, 240\nKattis - boatparts, 92\nKattis - bookclub *, 266\nKattis - booking, 75\nKattis - bookingaroom *, 91\nKattis - bossbattle *, 30\nKattis - bottledup, 30\nKattis - boundingrobots, 30\nKattis - bowserpipes, 264\nKattis - bread *, 76\nKattis - breakingbad, 213\nKattis - brexit *, 213\nKattis - brexitnegotiations, 213\nKattis - brickwall, 214\n279\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - brokenswords, 29\nKattis - bst *, 93\nKattis - bubbletea *, 30\nKattis - builddeps *, 213\nKattis - buildingboundaries, 145\nKattis - bungeebuilder *, 77\nKattis - bungeejumping, 38\nKattis - busnumbers *, 91\nKattis - bustour *, 189\nKattis - busyschedule, 38\nKattis - buttonbashing *, 239\nKattis - caching, 93\nKattis - cakeymccakeface, 93\nKattis - calculatingdartscores *, 145\nKattis - calories, 37\nKattis - candydivision *, 93\nKattis - canonical *, 188\nKattis - cantinaofbabel *, 214\nKattis - cantor, 154\nKattis - canvas *, 163\nKattis - cardmagic *, 265\nKattis - cardtrading, 163\nKattis - cardtrick2 *, 144\nKattis - carefulascent *, 154\nKattis - carousel, 30\nKattis - carrots *, 28\nKattis - cartrouble, 212\nKattis - carvet, 147\nKattis - catenyms *, 266\nKattis - cats *, 222\nKattis - caveexploration *, 213\nKattis - cd *, 82, 92\nKattis - ceiling *, 154\nKattis - ceremony, 162\nKattis - cetiri *, 29\nKattis - chartingprogress, 75\nKattis - chatter, 122\nKattis - chess *, 36\nKattis - chocolates, 144\nKattis - chopin *, 37\nKattis - chopwood *, 122\nKattis - circuitmath *, 77\nKattis - classpicture, 145\nKattis - classrooms *, 162\nKattis - classy *, 75\nKattis - climbingstairs, 30\nKattis - climbingworm, 30\nKattis - clinic, 91\nKattis - closestsums *, 144\nKattis - closingtheloop, 75\nKattis - coast *, 212\nKattis - coconut, 147\nKattis - codecleanups, 30\nKattis - cold, 29\nKattis - collapse, 213\nKattis - color, 162\nKattis - combinationlock, 29\nKattis - commercials *, 187\nKattis - communication *, 146\nKattis - communicationssatellite, 222\nKattis - compass *, 37\nKattis - competitivearcadebasketball *, 92\nKattis - compositions, 264\nKattis - compoundwords *, 93\nKattis - compromise, 74\nKattis - conformity *, 92\nKattis - connectthedots *, 36\nKattis - conquestcampaign, 239\nKattis - conservation *, 213\nKattis - continuousmedian *, 93\nKattis - control *, 122\nKattis - conundrum *, 39\nKattis - conversationlog *, 92\nKattis - convoy, 163\nKattis - cookieselection *, 93\nKattis - cookingwater, 146\nKattis - costumecontest, 92\nKattis - countingstars *, 212\nKattis - cowcrane, 30\nKattis - crackingrsa *, 146\nKattis - creditcard *, 38\nKattis - crosscountry, 240\nKattis - cudoviste *, 144\nKattis - cups,", "mimetype": "text/plain", "start_char_idx": 803121, "end_char_idx": 805733, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8b922dca-ff19-4502-aedd-b8ebd109f1b3": {"__data__": {"id_": "8b922dca-ff19-4502-aedd-b8ebd109f1b3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "68e2d899-0329-41d6-8d37-050f5181fdeb", "node_type": "1", "metadata": {}, "hash": "0ba364b8bbf613fe44181f32189f250421d29ed14f69c56124900c5386f54acc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ad9c7596-ebd4-4aa3-8775-0378e5a95a1c", "node_type": "1", "metadata": {}, "hash": "431dcdd32c328776be46901bf4cbaa9e71999fd519ce2904e724df53c8cd37bf", "class_name": "RelatedNodeInfo"}}, "text": "93\nKattis - compromise, 74\nKattis - conformity *, 92\nKattis - connectthedots *, 36\nKattis - conquestcampaign, 239\nKattis - conservation *, 213\nKattis - continuousmedian *, 93\nKattis - control *, 122\nKattis - conundrum *, 39\nKattis - conversationlog *, 92\nKattis - convoy, 163\nKattis - cookieselection *, 93\nKattis - cookingwater, 146\nKattis - costumecontest, 92\nKattis - countingstars *, 212\nKattis - cowcrane, 30\nKattis - crackingrsa *, 146\nKattis - creditcard *, 38\nKattis - crosscountry, 240\nKattis - cudoviste *, 144\nKattis - cups, 75\nKattis - cycleseasy *, 189\nKattis - daceydice, 212\nKattis - dancerecital *, 145\nKattis - dasort, 162\nKattis - datum, 38\nKattis - deathstar *, 76\nKattis - deathtaxes, 30\nKattis - debugging, 189\nKattis - decisions, 265\nKattis - deduplicating\ufb01les, 92\nKattis - delimitersoup *, 77\nKattis - delivery *, 162\nKattis - detour, 240\nKattis - dicecup, 146\nKattis - di\u21b5erent *, 28\nKattis - digicomp2, 213\n280\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - digits *, 29\nKattis - dirtydriving, 75\nKattis - disastrousdoubling, 76\nKattis - disgruntledjudge, 146\nKattis - display *, 40\nKattis - divideby100 *, 74\nKattis - dobra *, 147\nKattis - doctorkattis *, 93\nKattis - dominoes2 *, 212\nKattis - dominos *, 214\nKattis - doubleplusgood, 145\nKattis - downtime *, 74\nKattis - draughts, 147\nKattis - dream, 77\nKattis - dreamer *, 145\nKattis - drinkingsong, 29\nKattis - drinkresponsibly *, 265\nKattis - driver, 163\nKattis - driversdilemma, 30\nKattis - drivinglanes, 189\nKattis - drivingrange, 222\nKattis - drmmessages, 39\nKattis - droppingdirections, 214\nKattis - drunkvigenere, 39\nKattis - dst, 38\nKattis - dungeon, 239\nKattis - dvds *, 163\nKattis - dyslectionary *, 75\nKattis - earlywinter, 29\nKattis - easiest *, 146\nKattis - easyascab, 213\nKattis - eenymeeny *, 147\nKattis - election2, 92\nKattis - elementarymath, 266\nKattis - elevatortrouble, 239\nKattis - eligibility *, 28\nKattis - empleh *, 36\nKattis - emptyingbaltic *, 240\nKattis - encodedmessage *, 39\nKattis - engineeringenglish, 92\nKattis - entertainmentbox, 163\nKattis - epigdanceo\u21b5*, 74\nKattis - equivalences *, 214\nKattis - erase, 74\nKattis - erdosnumbers, 239\nKattis - errands *, 189\nKattis - erraticants, 239\nKattis - escapeplan *, 266\nKattis - esej *, 92\nKattis - euclideantsp, 154\nKattis - eulerianpath *, 266\nKattis - eventplanning, 30\nKattis - evenup *, 77\nKattis - everywhere, 92\nKattis - exactchange2 *, 188\nKattis - exactlyelectrical, 30\nKattis - excavatorexpedition, 264\nKattis - excursion, 76\nKattis - expeditiouscubing,", "mimetype": "text/plain", "start_char_idx": 805198, "end_char_idx": 807708, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ad9c7596-ebd4-4aa3-8775-0378e5a95a1c": {"__data__": {"id_": "ad9c7596-ebd4-4aa3-8775-0378e5a95a1c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8b922dca-ff19-4502-aedd-b8ebd109f1b3", "node_type": "1", "metadata": {}, "hash": "70fa85fbb7bd93688b74062054544d129787779f36ab14931c38db8f0a81f926", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a8ec929b-d879-4c29-9aea-7533d4d2ac92", "node_type": "1", "metadata": {}, "hash": "6458c330db2c8bff7e31c075bbfca63afd7776dbefeaca3d961fc85c717ea633", "class_name": "RelatedNodeInfo"}}, "text": "163\nKattis - epigdanceo\u21b5*, 74\nKattis - equivalences *, 214\nKattis - erase, 74\nKattis - erdosnumbers, 239\nKattis - errands *, 189\nKattis - erraticants, 239\nKattis - escapeplan *, 266\nKattis - esej *, 92\nKattis - euclideantsp, 154\nKattis - eulerianpath *, 266\nKattis - eventplanning, 30\nKattis - evenup *, 77\nKattis - everywhere, 92\nKattis - exactchange2 *, 188\nKattis - exactlyelectrical, 30\nKattis - excavatorexpedition, 264\nKattis - excursion, 76\nKattis - expeditiouscubing, 154\nKattis - fairdivision, 162\nKattis - faktor, 28\nKattis - falcondive, 75\nKattis - falling *, 146\nKattis - fallingapart, 162\nKattis - falsesecurity, 39\nKattis - familydag, 213\nKattis - fantasydraft, 93\nKattis - fastfood *, 30\nKattis - faultyrobot *, 214\nKattis - fbiuniversal, 37\nKattis - fenwick *, 123\nKattis - ferryloading3, 77\nKattis - ferryloading4, 77\nKattis - \ufb01btour *, 264\nKattis - \ufb01lip *, 29\nKattis - \ufb01nancialplanning, 154\nKattis - \ufb01re2 *, 239\nKattis - \ufb01re3, 239\nKattis - \ufb01re\ufb02y *, 153\nKattis - \ufb01restation, 240\nKattis - \ufb01retrucksarered, 222\nKattis - \ufb01shmongers, 162\nKattis - \ufb01zzbuzz *, 29\nKattis - \ufb02agquiz *, 75\nKattis - \ufb02exible *, 146\nKattis - \ufb02ight *, 265\nKattis - \ufb02ippingcards *, 266\nKattis - \ufb02ippingpatties, 74\nKattis - \ufb02oodit, 212\nKattis - \ufb02oppy, 91\nKattis - \ufb02owerytrails *, 240\nKattis - \ufb02owshop *, 74\nKattis - \ufb02yingsafely, 122\nKattis - foldedmap, 187\nKattis - foldingacube, 212\nKattis - foolingaround *, 144\nKattis - foosball, 77\nKattis - forestfruits, 240\nKattis - forests, 122\nKattis - freckles, 222\n281\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - freefood *, 91\nKattis - freeweights *, 154\nKattis - friday *, 38\nKattis - fridge, 162\nKattis - froggie *, 40\nKattis - froshweek, 76\nKattis - froshweek2 *, 162\nKattis - frozenrose, 265\nKattis - fruitbaskets *, 147\nKattis - fulldepthmorningshow, 265\nKattis - fulltank, 238, 240\nKattis - functionalfun *, 40\nKattis - funhouse *, 75\nKattis - gamenight, 76\nKattis - gamerank *, 36\nKattis - gcpc *, 93\nKattis - gearchanging, 75\nKattis - genealogical, 39\nKattis - generalizedrecursivefunctions, 76\nKattis - george, 240\nKattis - geppetto *, 145\nKattis - gerrymandering, 40\nKattis - getshorty, 240\nKattis - gettowork, 162\nKattis - glitchbot *, 40\nKattis - goblingardenguards, 145\nKattis - goingtoseed *, 154\nKattis - gold *, 212\nKattis - golombrulers *, 144\nKattis - goodmorning *,", "mimetype": "text/plain", "start_char_idx": 807233, "end_char_idx": 809544, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a8ec929b-d879-4c29-9aea-7533d4d2ac92": {"__data__": {"id_": "a8ec929b-d879-4c29-9aea-7533d4d2ac92", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ad9c7596-ebd4-4aa3-8775-0378e5a95a1c", "node_type": "1", "metadata": {}, "hash": "431dcdd32c328776be46901bf4cbaa9e71999fd519ce2904e724df53c8cd37bf", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "65660e7d-7f7b-4b8d-9629-6aba797d7cbf", "node_type": "1", "metadata": {}, "hash": "eb6d5ba585cc2ddc15b36483f1f9c1a83ffe2e8e53c8fa9504d193d8b13857aa", "class_name": "RelatedNodeInfo"}}, "text": "40\nKattis - funhouse *, 75\nKattis - gamenight, 76\nKattis - gamerank *, 36\nKattis - gcpc *, 93\nKattis - gearchanging, 75\nKattis - genealogical, 39\nKattis - generalizedrecursivefunctions, 76\nKattis - george, 240\nKattis - geppetto *, 145\nKattis - gerrymandering, 40\nKattis - getshorty, 240\nKattis - gettowork, 162\nKattis - glitchbot *, 40\nKattis - goblingardenguards, 145\nKattis - goingtoseed *, 154\nKattis - gold *, 212\nKattis - golombrulers *, 144\nKattis - goodmorning *, 147\nKattis - gopher2, 266\nKattis - gradecurving, 146\nKattis - grandopening, 266\nKattis - grandpabernie *, 92\nKattis - grapevine, 213\nKattis - grass, 157, 162\nKattis - grasshopper *, 239\nKattis - greedilyincreasing *, 74\nKattis - greetingcard *, 92\nKattis - grid *, 239\nKattis - growlinggears *, 146\nKattis - gruesomecave, 240\nKattis - guessinggame *, 36\nKattis - guessthedatastructure, 91\nKattis - hangingout *, 29\nKattis - hardware, 91\nKattis - hardwoodspecies, 93\nKattis - harshadnumbers, 146\nKattis - hauntedgraveyard *, 240\nKattis - haybales, 163\nKattis - haypoints, 92\nKattis - heartrate, 37\nKattis - height *, 75\nKattis - heirsdilemma, 146\nKattis - hello *, 28\nKattis - help, 162\nKattis - helpaphd *, 28\nKattis - helpfulcurrents, 264\nKattis - helpme *, 36\nKattis - hidingplaces *, 239\nKattis - hindex, 154\nKattis - hissingmicrophone *, 29\nKattis - hogwarts2, 214\nKattis - hoppers *, 213\nKattis - hopscotch50, 240\nKattis - horror *, 239\nKattis - horror\ufb01lmnight, 163\nKattis - hotels, 248\nKattis - hothike, 29\nKattis - houselawn, 146\nKattis - howl, 30\nKattis - htoo, 154\nKattis - hypercube, 76\nKattis - iboard, 76\nKattis - icpcawards, 92\nKattis - icpcteamselection *, 162\nKattis - iforaneye, 92\nKattis - imageprocessing *, 74\nKattis - importspaghetti *, 248\nKattis - includescoring, 75\nKattis - increasingsubsequence *, 188\nKattis - in\ufb02ation, 162\nKattis - integerlists *, 77\nKattis - intercept *, 213\nKattis - intergalacticbidding, 162\nKattis - interpreter, 40\nKattis - intervalcover, 162\nKattis - invasion *, 240\nKattis - inventing, 222\nKattis - inverteddeck, 74\nKattis - isahasa, 248\nKattis - isithalloween *, 28\nKattis - island, 212\nKattis - islandhopping *, 222\nKattis - islands *, 146\nKattis - islands3 *, 212\nKattis - iwannabe, 92\nKattis - janeeyre, 91\nKattis - jetpack, 214\nKattis - jewelrybox, 154\n282\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - jobexpenses, 29\nKattis - joinstrings *, 77\nKattis - jollyjumpers *, 74\nKattis - judging, 75\nKattis - judgingmoose *, 28\nKattis - jugglingpatterns *,", "mimetype": "text/plain", "start_char_idx": 809074, "end_char_idx": 811548, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "65660e7d-7f7b-4b8d-9629-6aba797d7cbf": {"__data__": {"id_": "65660e7d-7f7b-4b8d-9629-6aba797d7cbf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a8ec929b-d879-4c29-9aea-7533d4d2ac92", "node_type": "1", "metadata": {}, "hash": "6458c330db2c8bff7e31c075bbfca63afd7776dbefeaca3d961fc85c717ea633", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "96a11867-a9be-461d-bd1c-1b027a50d46d", "node_type": "1", "metadata": {}, "hash": "be882df28ec75af3ccd0b9c073fdd71dfb6942edde1f079b84efa7e0f43933b0", "class_name": "RelatedNodeInfo"}}, "text": "222\nKattis - inverteddeck, 74\nKattis - isahasa, 248\nKattis - isithalloween *, 28\nKattis - island, 212\nKattis - islandhopping *, 222\nKattis - islands *, 146\nKattis - islands3 *, 212\nKattis - iwannabe, 92\nKattis - janeeyre, 91\nKattis - jetpack, 214\nKattis - jewelrybox, 154\n282\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - jobexpenses, 29\nKattis - joinstrings *, 77\nKattis - jollyjumpers *, 74\nKattis - judging, 75\nKattis - judgingmoose *, 28\nKattis - jugglingpatterns *, 91\nKattis - jurrasicjigsaw, 222\nKattis - justaminute *, 38\nKattis - justforsidekicks *, 123\nKattis - kafkaesque, 144\nKattis - karte, 36\nKattis - kastenlauf *, 248\nKattis - kattissquest *, 93\nKattis - kemija08, 39\nKattis - keyboardconcert, 189\nKattis - keypad, 75\nKattis - keytocrypto, 39\nKattis - keywords, 92\nKattis - kingofthewaves, 214\nKattis - kingpinescape, 213\nKattis - kitten, 265\nKattis - knapsack *, 188\nKattis - knightjump *, 239\nKattis - knigsoftheforest *, 91\nKattis - krizaljka, 40\nKattis - kutevi *, 189\nKattis - ladice *, 122\nKattis - landline, 222\nKattis - landlocked, 239\nKattis - lastfactorialdigit, 144\nKattis - lava, 239\nKattis - lawnmower, 75\nKattis - leftbeehind *, 28\nKattis - lektira *, 145\nKattis - licensetolaunch *, 29\nKattis - liga, 144\nKattis - lineup *, 29\nKattis - lipschitzconstant, 146\nKattis - logland, 163\nKattis - longincsubseq, 188\nKattis - longswaps, 75\nKattis - loopycabdrivers, 214\nKattis - loowater, 159, 162\nKattis - lost *, 239\nKattis - lostlineup *, 29\nKattis - lostmap *, 222\nKattis - luckynumber, 144\nKattis - luhnchecksum *, 37\nKattis - lumbercraft, 40\nKattis - magicalcows, 92\nKattis - magicsequence *, 76\nKattis - mali *, 76\nKattis - mallmania *, 239\nKattis - managingpackaging, 213\nKattis - mancala, 144\nKattis - manhattanmornings, 188\nKattis - marblestree *, 163\nKattis - marko, 92\nKattis - marswindow *, 38\nKattis - marypartitions, 264\nKattis - mastermind *, 74\nKattis - mathhomework, 144\nKattis - maximizingwinnings *, 265\nKattis - maximizingyourpay, 189\nKattis - mazemakers, 265\nKattis - measurement, 37\nKattis - medals, 145\nKattis - memorymatch *, 36\nKattis - messages, 162\nKattis - metaprogramming, 92\nKattis - mia *, 29\nKattis - milestones, 146\nKattis - millionairemadness *, 222\nKattis - minimumscalar *, 162\nKattis - ministryofmagic, 93\nKattis - minorsetback, 92\nKattis - minspantree *, 222\nKattis - mirror, 40\nKattis - misa, 145\nKattis - missinggnomes, 93\nKattis - missingnumbers, 30\nKattis - mjehuric *, 75\nKattis - molekule *,", "mimetype": "text/plain", "start_char_idx": 811082, "end_char_idx": 813537, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "96a11867-a9be-461d-bd1c-1b027a50d46d": {"__data__": {"id_": "96a11867-a9be-461d-bd1c-1b027a50d46d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "65660e7d-7f7b-4b8d-9629-6aba797d7cbf", "node_type": "1", "metadata": {}, "hash": "eb6d5ba585cc2ddc15b36483f1f9c1a83ffe2e8e53c8fa9504d193d8b13857aa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b6ccc757-3d15-439f-8782-8b69218b4962", "node_type": "1", "metadata": {}, "hash": "87b4031cd2d1341b4b36e558ed1f63c6a5493230d01280f5ff77d11b381ff231", "class_name": "RelatedNodeInfo"}}, "text": "189\nKattis - mazemakers, 265\nKattis - measurement, 37\nKattis - medals, 145\nKattis - memorymatch *, 36\nKattis - messages, 162\nKattis - metaprogramming, 92\nKattis - mia *, 29\nKattis - milestones, 146\nKattis - millionairemadness *, 222\nKattis - minimumscalar *, 162\nKattis - ministryofmagic, 93\nKattis - minorsetback, 92\nKattis - minspantree *, 222\nKattis - mirror, 40\nKattis - misa, 145\nKattis - missinggnomes, 93\nKattis - missingnumbers, 30\nKattis - mjehuric *, 75\nKattis - molekule *, 213\nKattis - moneymatters, 212\nKattis - monk *, 154\nKattis - monopoly, 264\nKattis - more10, 122\nKattis - moscowdream *, 28\nKattis - mosquito, 29\nKattis - moviecollection *, 123\nKattis - mravi *, 264\nKattis - muddyhike *, 222\nKattis - multiplication, 40\nKattis - musicalchairs *, 147\nKattis - musicalnotation *, 40\nKattis - musicalscales, 37\nKattis - musicyourway *, 75\nKattis - muzicari, 188\nKattis - nastyhacks, 28\nKattis - natjecanje *, 147\n283\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - natrij *, 38\nKattis - naturereserve *, 222\nKattis - nesteddolls *, 188\nKattis - nikola *, 189\nKattis - nineknights *, 74\nKattis - ninepacks, 188\nKattis - nodup, 92\nKattis - notamused, 93\nKattis - npuzzle *, 144\nKattis - numberfun, 28\nKattis - numbertree *, 91\nKattis - oceancurrents *, 239\nKattis - oddgnome *, 29\nKattis - oddities *, 28\nKattis - oddmanout, 92\nKattis - okvir, 40\nKattis - okviri, 40\nKattis - onaveragetheyrepurple, 239\nKattis - onechicken *, 28\nKattis - opensource, 93\nKattis - orders *, 188\nKattis - orphanbackups, 93\nKattis - outofsorts *, 153\nKattis - owlandfox, 146\nKattis - pachydermpeanutpacking *, 40\nKattis - pagelayout *, 147\nKattis - paintball, 266\nKattis - paintings *, 147\nKattis - pairingsocks *, 77\nKattis - palindromicpassword, 93\nKattis - parallelanalysis, 92\nKattis - parking, 37\nKattis - parking2, 146\nKattis - passingsecrets, 240\nKattis - patuljci, 144\nKattis - pearwise, 212\nKattis - peasoup *, 30\nKattis - peg, 144\nKattis - perket, 145\nKattis - permcode, 39\nKattis - permutationdescent, 189\nKattis - pervasiveheartmonitor *, 39\nKattis - pet *, 144\nKattis - physicalmusic, 74\nKattis - pianolessons, 266\nKattis - pickupsticks *, 213\nKattis - piglatin *, 39\nKattis - pikemaneasy, 162\nKattis - piperotation, 74\nKattis - pivot *, 74\nKattis - pizzahawaii, 92\nKattis - planetaris, 162\nKattis - planina, 28\nKattis - plantingtrees, 162\nKattis - playground, 163\nKattis - pokemongogo, 189\nKattis - pokerhand *, 29\nKattis - prerequisites, 30\nKattis - presidentialelections *,", "mimetype": "text/plain", "start_char_idx": 813053, "end_char_idx": 815528, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b6ccc757-3d15-439f-8782-8b69218b4962": {"__data__": {"id_": "b6ccc757-3d15-439f-8782-8b69218b4962", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "96a11867-a9be-461d-bd1c-1b027a50d46d", "node_type": "1", "metadata": {}, "hash": "be882df28ec75af3ccd0b9c073fdd71dfb6942edde1f079b84efa7e0f43933b0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a3c1c4c3-98a3-476e-ad09-112e0b80ce61", "node_type": "1", "metadata": {}, "hash": "ffabc5b8856924d5f79286598d2df912e370084318b3f1ce624b1d24f33fab76", "class_name": "RelatedNodeInfo"}}, "text": "39\nKattis - permutationdescent, 189\nKattis - pervasiveheartmonitor *, 39\nKattis - pet *, 144\nKattis - physicalmusic, 74\nKattis - pianolessons, 266\nKattis - pickupsticks *, 213\nKattis - piglatin *, 39\nKattis - pikemaneasy, 162\nKattis - piperotation, 74\nKattis - pivot *, 74\nKattis - pizzahawaii, 92\nKattis - planetaris, 162\nKattis - planina, 28\nKattis - plantingtrees, 162\nKattis - playground, 163\nKattis - pokemongogo, 189\nKattis - pokerhand *, 29\nKattis - prerequisites, 30\nKattis - presidentialelections *, 188\nKattis - primaryarithmetic *, 76\nKattis - primematrix, 144\nKattis - primes, 147\nKattis - princesspeach *, 91\nKattis - prinova, 146\nKattis - printingcosts *, 40\nKattis - pripreme, 163\nKattis - problemclassi\ufb01cation, 93\nKattis - promotions *, 214\nKattis - proofs, 92\nKattis - provincesandgold *, 28\nKattis - prozor *, 187\nKattis - prva, 75\nKattis - ptice, 29\nKattis - pubs, 213\nKattis - purplerain, 187\nKattis - putovanje, 144\nKattis - qaly *, 28\nKattis - qanat, 154\nKattis - quadrant *, 28\nKattis - quantumsuperposition, 265\nKattis - queens, 74\nKattis - quickbrownfox *, 91\nKattis - r2 *, 28\nKattis - race, 189\nKattis - raceday, 93\nKattis - raidteams, 93\nKattis - railroad, 122\nKattis - railroad2 *, 266\nKattis - rainfall2, 154\nKattis - rationalsequence2, 91\nKattis - rationalsequence3, 91\nKattis - reachableroads *, 212\nKattis - recenice, 92\nKattis - recipes, 37\nKattis - reconnaissance, 154\nKattis - recount *, 92\nKattis - redbluetree, 222\nKattis - redistribution, 162\nKattis - reduction, 144\nKattis - register, 144\n284\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - relocation, 91\nKattis - repeatingdecimal, 146\nKattis - restaurant *, 77\nKattis - retribution, 75\nKattis - reversebinary, 77\nKattis - reverserot, 39\nKattis - reversingroads, 214\nKattis - rimski *, 39\nKattis - rings2 *, 75\nKattis - robotopia, 146\nKattis - robotsonagrid *, 264\nKattis - rockband, 74\nKattis - rockpaperscissors *, 37\nKattis - rockscissorspaper, 37\nKattis - rollcall, 92\nKattis - romanholidays *, 39\nKattis - romans, 28\nKattis - roompainting *, 153\nKattis - runlengthencodingrun, 39\nKattis - runningmom *, 213\nKattis - runningsteps *, 264\nKattis - sabor, 40\nKattis - safehouses, 144\nKattis - safepassage *, 264\nKattis - savingdaylight *, 38\nKattis - savingforretirement, 146\nKattis - savinguniverse, 264\nKattis - saxophone, 38\nKattis - scenes *, 264\nKattis - score, 37\nKattis - secretchamber *, 248\nKattis - secretmessage *, 39\nKattis - securedoors, 92\nKattis - securitybadge, 212\nKattis - sellingspatulas *, 187\nKattis - semafori, 38\nKattis - server,", "mimetype": "text/plain", "start_char_idx": 815020, "end_char_idx": 817558, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a3c1c4c3-98a3-476e-ad09-112e0b80ce61": {"__data__": {"id_": "a3c1c4c3-98a3-476e-ad09-112e0b80ce61", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b6ccc757-3d15-439f-8782-8b69218b4962", "node_type": "1", "metadata": {}, "hash": "87b4031cd2d1341b4b36e558ed1f63c6a5493230d01280f5ff77d11b381ff231", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73f11948-5a0c-4daa-a097-9e1b6c0ef218", "node_type": "1", "metadata": {}, "hash": "d2013c257beff170f455f8e3230b23f76a8306b7586145df8bdf8beba2507ca8", "class_name": "RelatedNodeInfo"}}, "text": "153\nKattis - runlengthencodingrun, 39\nKattis - runningmom *, 213\nKattis - runningsteps *, 264\nKattis - sabor, 40\nKattis - safehouses, 144\nKattis - safepassage *, 264\nKattis - savingdaylight *, 38\nKattis - savingforretirement, 146\nKattis - savinguniverse, 264\nKattis - saxophone, 38\nKattis - scenes *, 264\nKattis - score, 37\nKattis - secretchamber *, 248\nKattis - secretmessage *, 39\nKattis - securedoors, 92\nKattis - securitybadge, 212\nKattis - sellingspatulas *, 187\nKattis - semafori, 38\nKattis - server, 77\nKattis - set *, 144\nKattis - sevenwonders, 29\nKattis - sgcoin *, 144\nKattis - shatteredcake, 30\nKattis - shiritori *, 92\nKattis - shopaholic *, 162\nKattis - shoppingmalls, 240\nKattis - shortestpath1 *, 240\nKattis - shortestpath2 *, 240\nKattis - shortestpath3 *, 240\nKattis - shortestpath4, 265\nKattis - shortsell, 187\nKattis - showroom, 239\nKattis - shu\u270fing *, 36\nKattis - sidewayssorting *, 75\nKattis - silueta, 214\nKattis - sim *, 77\nKattis - simpleaddition *, 76\nKattis - simplicity, 163\nKattis - simpli\ufb01cation, 163\nKattis - sixdegrees, 239\nKattis - skener *, 40\nKattis - skocimis, 163\nKattis - slalom2, 154\nKattis - slikar, 239\nKattis - slowleak, 248\nKattis - smallschedule, 154\nKattis - snappereasy *, 76\nKattis - snapperhard *, 76\nKattis - snow\ufb02akes, 92\nKattis - socialrunning, 146\nKattis - sodaslurper, 146\nKattis - sok, 30\nKattis - solitaire, 147\nKattis - somesum, 146\nKattis - sort, 76\nKattis - sortofsorting *, 75\nKattis - spavanac, 38\nKattis - speed, 154\nKattis - speedlimit, 29\nKattis - spider, 222\nKattis - spiderman *, 189\nKattis - spiral, 239\nKattis - squaredeal *, 145\nKattis - squarepegs *, 162\nKattis - srednji *, 93\nKattis - sretan, 154\nKattis - standings, 162\nKattis - stararrangements, 29\nKattis - statistics *, 29\nKattis - stockbroker *, 163\nKattis - stockprices *, 91\nKattis - stopcounting, 146\nKattis - studentsko, 188\nKattis - subway2, 240\nKattis - succession *, 214\nKattis - summertrip, 144\nKattis - sumoftheothers, 146\nKattis - supercomputer *, 123\nKattis - superdoku, 266\nKattis - suspensionbridges *, 154\nKattis - svada, 154\nKattis - svemir, 222\n285\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - swaptosort, 122\nKattis - sylvester, 154\nKattis - symmetricorder, 77\nKattis - synchronizinglists, 153\nKattis - t9spelling *, 39\nKattis - tajna *, 39\nKattis - tarifa *, 28\nKattis - tautology *, 145\nKattis - taxing, 154\nKattis - teacherevaluation, 163\nKattis - telephones, 144\nKattis - temperature *, 28\nKattis - tenis,", "mimetype": "text/plain", "start_char_idx": 817052, "end_char_idx": 819499, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "73f11948-5a0c-4daa-a097-9e1b6c0ef218": {"__data__": {"id_": "73f11948-5a0c-4daa-a097-9e1b6c0ef218", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a3c1c4c3-98a3-476e-ad09-112e0b80ce61", "node_type": "1", "metadata": {}, "hash": "ffabc5b8856924d5f79286598d2df912e370084318b3f1ce624b1d24f33fab76", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "44d62242-44c1-4ab9-b9dd-8cd34c152969", "node_type": "1", "metadata": {}, "hash": "48fe7f543386c217a0cd15ec1c7c0f688260a6b37cc271ddd23265076b8ed7ff", "class_name": "RelatedNodeInfo"}}, "text": "123\nKattis - superdoku, 266\nKattis - suspensionbridges *, 154\nKattis - svada, 154\nKattis - svemir, 222\n285\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - swaptosort, 122\nKattis - sylvester, 154\nKattis - symmetricorder, 77\nKattis - synchronizinglists, 153\nKattis - t9spelling *, 39\nKattis - tajna *, 39\nKattis - tarifa *, 28\nKattis - tautology *, 145\nKattis - taxing, 154\nKattis - teacherevaluation, 163\nKattis - telephones, 144\nKattis - temperature *, 28\nKattis - tenis, 38\nKattis - teque *, 77\nKattis - terraces *, 212\nKattis - test2, 214\nKattis - tetris, 75\nKattis - texassummers *, 240\nKattis - textmessaging, 162\nKattis - tgif, 38\nKattis - thanos, 29\nKattis - thanosthehero *, 146\nKattis - thegrandadventure, 77\nKattis - thelastproblem *, 28\nKattis - thisaintyourgrandpascheckerboard, 74\nKattis - threepowers, 76\nKattis - throwns *, 77\nKattis - ticketpricing *, 189\nKattis - tictactoe2 *, 37\nKattis - tide, 240\nKattis - tight *, 189\nKattis - tildes, 122\nKattis - timebomb *, 39\nKattis - timeloop *, 28\nKattis - timezones *, 38\nKattis - toilet *, 37\nKattis - torn2pieces *, 213\nKattis - touchdown, 40\nKattis - touchscreenkeyboard *, 38\nKattis - tourdefrance, 144\nKattis - tourists *, 265\nKattis - towering, 145\nKattis - toys *, 147\nKattis - tra\ufb03c, 74\nKattis - trainpassengers *, 37\nKattis - trainsorting *, 188\nKattis - transitwoes, 37\nKattis - transportationplanning *, 248\nKattis - traveltheskies *, 122\nKattis - treasurehunt, 29\nKattis - treehouses, 222\nKattis - trendingtopic, 77\nKattis - tri, 146\nKattis - trick, 146\nKattis - tricktreat, 154\nKattis - trik, 36\nKattis - trip2007, 162\nKattis - tripletexting, 39\nKattis - trollhunt *, 146\nKattis - turbo, 123\nKattis - turtlemaster *, 37\nKattis - tutorial *, 12\nKattis - ultraquicksort, 76\nKattis - union\ufb01nd *, 122\nKattis - upsanddownso\ufb01nvesting, 74\nKattis - variablearithmetic, 92\nKattis - veci *, 145\nKattis - vegetables *, 163\nKattis - victorythroughsynergy, 145\nKattis - videospeedup *, 146\nKattis - vindiagrams, 212\nKattis - virtualfriends, 122\nKattis - virus *, 163\nKattis - visualgo *, 240\nKattis - volim, 29\nKattis - vote *, 30\nKattis - walls *, 146\nKattis - walrusweights *, 189\nKattis - warehouse, 93\nKattis - watersheds, 189\nKattis - weakvertices, 122\nKattis - weightofwords, 189\nKattis - wertyu *, 37\nKattis - wettiles, 239\nKattis - w\u21b5nproof, 162\nKattis - whatdoesthefoxsay, 92\nKattis - wheresmyinternet *, 212\nKattis - whostheboss, 265\nKattis - windows *, 40\nKattis - wine,", "mimetype": "text/plain", "start_char_idx": 819034, "end_char_idx": 821469, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "44d62242-44c1-4ab9-b9dd-8cd34c152969": {"__data__": {"id_": "44d62242-44c1-4ab9-b9dd-8cd34c152969", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73f11948-5a0c-4daa-a097-9e1b6c0ef218", "node_type": "1", "metadata": {}, "hash": "d2013c257beff170f455f8e3230b23f76a8306b7586145df8bdf8beba2507ca8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bb23df04-83cd-4341-a097-4103a5d3abb7", "node_type": "1", "metadata": {}, "hash": "82a29967010c15b2ee28e22722169405b63fe9ea23b4a93be0f39ac4482c07e9", "class_name": "RelatedNodeInfo"}}, "text": "212\nKattis - virtualfriends, 122\nKattis - virus *, 163\nKattis - visualgo *, 240\nKattis - volim, 29\nKattis - vote *, 30\nKattis - walls *, 146\nKattis - walrusweights *, 189\nKattis - warehouse, 93\nKattis - watersheds, 189\nKattis - weakvertices, 122\nKattis - weightofwords, 189\nKattis - wertyu *, 37\nKattis - wettiles, 239\nKattis - w\u21b5nproof, 162\nKattis - whatdoesthefoxsay, 92\nKattis - wheresmyinternet *, 212\nKattis - whostheboss, 265\nKattis - windows *, 40\nKattis - wine, 240\nKattis - wizardofodds *, 76\nKattis - woodcutting, 162\nKattis - wordcloud *, 37\nKattis - wordclouds, 189\nKattis - wordspin, 163\nKattis - workout *, 38\nKattis - workstations *, 163\nKattis - worstweather, 123\nKattis - xyzzy *, 240\nKattis - yinyangstones, 29\n286\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nKattis - zagrade *, 145\nKattis - zamka, 146\nKattis - zanzibar, 29\nKattis - zebrasocelots, 76\nKattis - zipfsong, 75\nKattis - zipline, 154\nKattis - zoning, 239\nKattis - zoo, 93\nKirchho\u21b5\u2019s Matrix Tree Theorem, 215\nKnapsack, 179\nFractional, 161\nKnight Moves, 226\nKnight\u2019s Tour, 226\nKnuth\u2019s Optimization, 186\nKosaraju\u2019s Algorithm, 208\nKosaraju, Sambasiva Rao, 194, 208\nKruskal\u2019s Algorithm, 215\nKruskal, Joseph Bernard, 215, 222\nKuratowski\u2019s Theorem, 263\nLandis, Evgenii Mikhailovich, 90\nLazy\nDeletion, 230\nPropagation, 117\nLemma\nBerge\u2019s, 258, 263\nLibraries, 53\nLinked List, 69\nLive Archive, 21\nLongest Increasing Subsequence, 176\nLongest Paths on DAG, 249\nLowest Common Ancestor, 257\nMatching\nBracket (Parenthesis), 71\nGraph, 257\nMax 1D Range Sum, 173\nMax 2D Range Sum, 174\nMCBM, 257\nMemoization, 167\nMerge Sort, 56, 59\nMin Spanning Tree, 215\n\u2018Maximum\u2019 Spanning Tree, 218\n\u2018Minimum\u2019 Spanning Subgraph, 219\nMinimum \u2018Spanning Forest\u2019, 219\nSecond Best Spanning Tree, 220\nMiniMax and MaxiMin, 219, 245\nMonotone, 149\nMoore, Edward Forrest, 214\nMultiset, 13, 141\nN-Queens Problem, 135\nNegative Cycle, 234, 236, 245\nNP-hard/complete, 249\nCoin-Change, 180\nKnapsack, 179\nSubset-Sum, 179\nTraveling-Salesman-Problem, 182\nO\u270fine Queries, 148\nO\u21b5set, 107\nOrder Statistics, 85, 87\nOut-degree, 261\nParenthesis, 71\nPath Compression, 100\nPatience Sorting, 178\nPERT, 250\nPigeonhole Principle, 156\nPoint Query, 108\nPoint Update, 108, 116\nPolicy-Based Data Structures, 90\nPost\ufb01x Calculator, 72\nPr\u00a8ufer sequence, 122\nPre\ufb01x Sum, 104, 174\nPrim\u2019s Algorithm, 217\nPrim, Robert Clay, 217, 222\nPriority Queue, 79, 201, 217, 229\nPseudoforest, 263\nPseudotree, 255, 263\nPython\nBig (Unlimited Precision) Integer, 66\nQuadrangle Inequality, 186\nQueue, 69, 197, 201, 202, 223, 236\nQuick Select, 87\nQuick Sort,", "mimetype": "text/plain", "start_char_idx": 821000, "end_char_idx": 823532, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bb23df04-83cd-4341-a097-4103a5d3abb7": {"__data__": {"id_": "bb23df04-83cd-4341-a097-4103a5d3abb7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "44d62242-44c1-4ab9-b9dd-8cd34c152969", "node_type": "1", "metadata": {}, "hash": "48fe7f543386c217a0cd15ec1c7c0f688260a6b37cc271ddd23265076b8ed7ff", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "752fe29a-722b-4620-baae-5dda32fe01da", "node_type": "1", "metadata": {}, "hash": "cc1fbc165535cc505e4976cc4c150378cb6656cebb172565c0f525f24c1d9b53", "class_name": "RelatedNodeInfo"}}, "text": "87\nOut-degree, 261\nParenthesis, 71\nPath Compression, 100\nPatience Sorting, 178\nPERT, 250\nPigeonhole Principle, 156\nPoint Query, 108\nPoint Update, 108, 116\nPolicy-Based Data Structures, 90\nPost\ufb01x Calculator, 72\nPr\u00a8ufer sequence, 122\nPre\ufb01x Sum, 104, 174\nPrim\u2019s Algorithm, 217\nPrim, Robert Clay, 217, 222\nPriority Queue, 79, 201, 217, 229\nPseudoforest, 263\nPseudotree, 255, 263\nPython\nBig (Unlimited Precision) Integer, 66\nQuadrangle Inequality, 186\nQueue, 69, 197, 201, 202, 223, 236\nQuick Select, 87\nQuick Sort, 56\nRadix Sort, 56, 61\nRandomized Algorithm, 88\nRange Minimum Query, 114\nRange Query, 108, 109, 115\nRange Sum\nMax 1D Range Sum, 173\nMax 2D Range Sum, 174\nRange Update, 108, 109, 117\nRanking Problem, 87\nReachability, 196, 198\nRecursive Backtracking, see Backtracking\nReduction, 9, 157\nRoman Numerals, 34\nSCC, 208, 246\n287\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nSearching, 57\nSecond Best Spanning Tree, 220\nSegment Tree, 114\nSelection Problem, 87\nSelection Sort, 56\nShunting-yard Algorithm, 73\nSingle-Source Shortest Paths, see SSSP\nSliding Window, 70\nSort\nBubble Sort, 59\nCounting Sort, 60\nMerge Sort, 59\nRadix Sort, 61\nSorting, 56, 79\nSpecial Graphs, 249\nSPFA, 236\nSPOJ FISHER - Fishmonger, 265\nSSSP, 256\nNegative Cycle, 234, 236\nUnweighted, 223\nWeighted, 227\nStack, 69, 71, 72\nStrongly Connected Components, see SCC\nSubsequence, 176\nSubset-Sum, 179\nSweep Line, 158\nTarjan\u2019s Algorithm, 209\nTarjan, Robert Endre, 194, 205, 208\nTernary Search, 152\nTheorem\nDilworth\u2019s, 184, 188\nKirchho\u21b5\u2019s Matrix Tree, 215\nKuratowski\u2019s, 263\nThinking Backwards, 9, 140\nTime Complexity, 12\nTopcoder, 21\nTopcoder Open 2009: Prime Pairs, 266\nTopological Sort, 200\nTransitive Closure, 245\nTraveling-Salesman-Problem, 182\nTreap, 127\nTree, 255\nAPSP, 256\nArticulation Points and Bridges, 256\nDiameter of, 256\nSSSP, 256\nTree Traversal, 255\nTSP, 182\nUnion-Find Disjoint Sets, 99\nUSACO, 21\nUVa, 21\nUVa 00100 - The 3n + 1 problem, 146\nUVa 00101 - The Blocks Problem, 75\nUVa 00102 - Ecological Bin Packing, 146\nUVa 00103 - Stacking Boxes, 264\nUVa 00104 - Arbitrage, 248\nUVa 00105 - The Skyline Problem, 144\nUVa 00108 - Maximum Sum, 174, 187\nUVa 00110 - Meta-loopless sort, 40\nUVa 00111 - History Grading, 188\nUVa 00112 - Tree Summing, 265\nUVa 00114 - Simulation Wizardry, 37\nUVa 00115 - Climbing Trees, 265\nUVa 00116 - Unidirectional TSP, 189\nUVa 00117 - The Postal Worker . 266\nUVa 00118 - Mutant Flatworld Explorers, 214\nUVa 00119 - Greedy Gift Givers, 30\nUVa 00122 - Trees on the level, 265\nUVa 00123 - Searching Quickly, 75\nUVa 00124 - Following Orders, 213\nUVa 00125 - Numbering Paths, 248\nUVa 00127 - \u201cAccordian\u201d Patience,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "752fe29a-722b-4620-baae-5dda32fe01da": {"__data__": {"id_": "752fe29a-722b-4620-baae-5dda32fe01da", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bb23df04-83cd-4341-a097-4103a5d3abb7", "node_type": "1", "metadata": {}, "hash": "82a29967010c15b2ee28e22722169405b63fe9ea23b4a93be0f39ac4482c07e9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "39ced19f-b8be-482c-bae7-654e71a682b3", "node_type": "1", "metadata": {}, "hash": "d19b8fbd8fe3057abeaa05add308396437cf9bd0fa468419913cf38be13b104d", "class_name": "RelatedNodeInfo"}}, "text": "174, 187\nUVa 00110 - Meta-loopless sort, 40\nUVa 00111 - History Grading, 188\nUVa 00112 - Tree Summing, 265\nUVa 00114 - Simulation Wizardry, 37\nUVa 00115 - Climbing Trees, 265\nUVa 00116 - Unidirectional TSP, 189\nUVa 00117 - The Postal Worker . 266\nUVa 00118 - Mutant Flatworld Explorers, 214\nUVa 00119 - Greedy Gift Givers, 30\nUVa 00122 - Trees on the level, 265\nUVa 00123 - Searching Quickly, 75\nUVa 00124 - Following Orders, 213\nUVa 00125 - Numbering Paths, 248\nUVa 00127 - \u201cAccordian\u201d Patience, 77\nUVa 00129 - Krypton Factor, 147\nUVa 00130 - Roman Roulette, 147\nUVa 00133 - The Dole Queue, 147\nUVa 00139 - Telephone Tangles, 38\nUVa 00140 - Bandwidth, 145\nUVa 00141 - The Spot Game, 37\nUVa 00144 - Student Grants, 40\nUVa 00145 - Gondwanaland Telecom, 38\nUVa 00146 - ID Codes, 145\nUVa 00147 - Dollars, 188\nUVa 00150 - Double Time, 38\nUVa 00151 - Power Crisis *, 147\nUVa 00154 - Recycling, 144\nUVa 00157 - Route Finding, 240\nUVa 00158 - Calendar, 38\nUVa 00161 - Tra\ufb03c Lights *, 37\nUVa 00162 - Beggar My Neighbour, 36\nUVa 00165 - Stamps *, 144\nUVa 00166 - Making Change, 188\nUVa 00167 - The Sultan Successor, 144\nUVa 00168 - Theseus and the . 214\nUVa 00170 - Clock Patience, 38\nUVa 00173 - Network Wars, 214\nUVa 00183 - Bit Maps *, 154\nUVa 00185 - Roman Numerals *, 39\nUVa 00186 - Trip Routing, 248\nUVa 00187 - Transaction Processing, 37\n288\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 00188 - Perfect Hash *, 146\nUVa 00200 - Rare Order *, 213\nUVa 00208 - Firetruck *, 147\nUVa 00214 - Code Generation, 40\nUVa 00216 - Getting in Line *, 189\nUVa 00220 - Othello, 37\nUVa 00222 - Budget Travel *, 147\nUVa 00227 - Puzzle, 37\nUVa 00230 - Borrowers, 74\nUVa 00231 - Testing the Catcher, 188\nUVa 00232 - Crossword Answers, 37\nUVa 00234 - Switching Channels *, 145\nUVa 00242 - Stamps and . *, 188\nUVa 00245 - Uncompress *, 39\nUVa 00246 - 10-20-30, 77\nUVa 00247 - Calling Circles *, 214, 246\nUVa 00253 - Cube painting, 145\nUVa 00255 - Correct Move *, 36\nUVa 00256 - Quirksome Squares, 144\nUVa 00260 - Il Gioco dell\u2019X, 212\nUVa 00271 - Simply Syntax, 39\nUVa 00272 - TEX Quotes, 29\nUVa 00274 - Cat and Mouse, 248\nUVa 00278 - Chess *, 36\nUVa 00280 - Vertex, 212\nUVa 00291 - The House of Santa . *, 266\nUVa 00296 - Safebreaker, 145\nUVa 00297 - Quadtrees, 123\nUVa 00299 - Train Swapping, 76\nUVa 00300 - Maya Calendar, 38\nUVa 00301 - Transportation, 147\nUVa 00302 - John\u2019s Trip, 266\nUVa 00305 - Joseph, 147\nUVa 00307 - Sticks *, 147\nUVa 00311 - Packets, 163\nUVa 00314 - Robot, 239\nUVa 00315 - Network *,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "39ced19f-b8be-482c-bae7-654e71a682b3": {"__data__": {"id_": "39ced19f-b8be-482c-bae7-654e71a682b3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "752fe29a-722b-4620-baae-5dda32fe01da", "node_type": "1", "metadata": {}, "hash": "cc1fbc165535cc505e4976cc4c150378cb6656cebb172565c0f525f24c1d9b53", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b1348c77-3357-4750-90a7-1b7fbdc05799", "node_type": "1", "metadata": {}, "hash": "d8a831af7356bba22fedfd698baca73cd8e02dcd9ed0e2e891c89a5509380a63", "class_name": "RelatedNodeInfo"}}, "text": "39\nUVa 00272 - TEX Quotes, 29\nUVa 00274 - Cat and Mouse, 248\nUVa 00278 - Chess *, 36\nUVa 00280 - Vertex, 212\nUVa 00291 - The House of Santa . *, 266\nUVa 00296 - Safebreaker, 145\nUVa 00297 - Quadtrees, 123\nUVa 00299 - Train Swapping, 76\nUVa 00300 - Maya Calendar, 38\nUVa 00301 - Transportation, 147\nUVa 00302 - John\u2019s Trip, 266\nUVa 00305 - Joseph, 147\nUVa 00307 - Sticks *, 147\nUVa 00311 - Packets, 163\nUVa 00314 - Robot, 239\nUVa 00315 - Network *, 213\nUVa 00318 - Domino E\u21b5ect, 214\nUVa 00320 - Border, 40\nUVa 00327 - Evaluating Simple C . 39\nUVa 00331 - Mapping the Swaps, 147\nUVa 00333 - Recognizing Good ISBNs, 38\nUVa 00334 - Identifying Concurrent . 248\nUVa 00335 - Processing MX Records, 40\nUVa 00336 - A Node Too Far *, 239\nUVa 00337 - Interpreting Control . 40\nUVa 00339 - SameGame Simulation, 37\nUVa 00340 - Master-Mind Hints, 36\nUVa 00341 - Non-Stop Travel, 248\nUVa 00344 - Roman Digititis *, 39\nUVa 00346 - Getting Chorded, 38\nUVa 00347 - Run, Run, Runaround . 144\nUVa 00349 - Transferable Voting (II), 40\nUVa 00352 - The Seasonal War *, 212\nUVa 00357 - Let Me Count The Ways, 188\nUVa 00362 - 18,000 Seconds Remaining, 37\nUVa 00371 - Ackermann Functions, 146\nUVa 00379 - HI-Q, 37\nUVa 00380 - Call Forwarding, 147\nUVa 00381 - Making the Grade, 40\nUVa 00382 - Perfection *, 146\nUVa 00383 - Shipping Routes, 239\nUVa 00386 - Perfect Cubes *, 145\nUVa 00388 - Galactic Import, 239\nUVa 00391 - Mark-up, 39\nUVa 00394 - Mapmaker, 74\nUVa 00397 - Equation Elation *, 39\nUVa 00400 - Unix ls, 75\nUVa 00402 - M*A*S*H, 147\nUVa 00403 - Postscript, 38\nUVa 00405 - Message Routing *, 40\nUVa 00410 - Station Balance, 156, 162\nUVa 00414 - Machined Surfaces, 74\nUVa 00416 - LED Test, 147\nUVa 00417 - Word Index *, 92\nUVa 00418 - Molecules, 145\nUVa 00423 - MPI Maelstrom, 240\nUVa 00424 - Integer Inquiry, 76\nUVa 00429 - Word Transformation *, 239\nUVa 00431 - Trial of the Millennium, 188\nUVa 00433 - Bank (Not Quite O.C.R.", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b1348c77-3357-4750-90a7-1b7fbdc05799": {"__data__": {"id_": "b1348c77-3357-4750-90a7-1b7fbdc05799", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "39ced19f-b8be-482c-bae7-654e71a682b3", "node_type": "1", "metadata": {}, "hash": "d19b8fbd8fe3057abeaa05add308396437cf9bd0fa468419913cf38be13b104d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d8d2fcff-05f7-4c65-895b-d61ef7c3bb83", "node_type": "1", "metadata": {}, "hash": "7decf81294e2760ad7f029820263ad97a33064a61bb56bd18730cfed33160cfa", "class_name": "RelatedNodeInfo"}}, "text": "74\nUVa 00397 - Equation Elation *, 39\nUVa 00400 - Unix ls, 75\nUVa 00402 - M*A*S*H, 147\nUVa 00403 - Postscript, 38\nUVa 00405 - Message Routing *, 40\nUVa 00410 - Station Balance, 156, 162\nUVa 00414 - Machined Surfaces, 74\nUVa 00416 - LED Test, 147\nUVa 00417 - Word Index *, 92\nUVa 00418 - Molecules, 145\nUVa 00423 - MPI Maelstrom, 240\nUVa 00424 - Integer Inquiry, 76\nUVa 00429 - Word Transformation *, 239\nUVa 00431 - Trial of the Millennium, 188\nUVa 00433 - Bank (Not Quite O.C.R.), 147\nUVa 00434 - Matty\u2019s Blocks, 75\nUVa 00435 - Block Voting, 145\nUVa 00436 - Arbitrage (II), 246, 248\nUVa 00437 - The Tower of Babylon, 188\nUVa 00439 - Knight Moves *, 239\nUVa 00440 - Eeny Meeny Moo, 147\nUVa 00441 - Lotto *, 131, 144\nUVa 00442 - Matrix Chain Multiplication, 39\nUVa 00444 - Encoder and Decoder, 39\nUVa 00445 - Marvelous Mazes, 40\nUVa 00447 - Population Explosion, 37\nUVa 00448 - OOPS, 38\nUVa 00449 - Majoring in Scales, 38\nUVa 00450 - Little Black Book, 75\nUVa 00452 - Project Scheduling *, 250, 264\nUVa 00457 - Linear Cellular Automata, 37\nUVa 00459 - Graph Connectivity *, 198, 212\nUVa 00462 - Bridge Hand Evaluator, 36\nUVa 00465 - Over\ufb02ow, 76\n289\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 00466 - Mirror Mirror *, 75\nUVa 00467 - Synching Signals, 74\nUVa 00469 - Wetlands of Florida, 199, 212\nUVa 00471 - Magic Numbers, 146\nUVa 00481 - What Goes Up? *, 188\nUVa 00482 - Permutation Arrays, 74\nUVa 00483 - Word Scramble, 39\nUVa 00484 - The Department . 92\nUVa 00486 - English-Number Translator, 39\nUVa 00487 - Boggle Blitz, 147\nUVa 00488 - Triangle Wave *, 40\nUVa 00489 - Hangman Judge *, 36\nUVa 00490 - Rotating Sentences, 40\nUVa 00492 - Pig Latin *, 39\nUVa 00493 - Rational Spiral, 146\nUVa 00497 - Strategic Defense Initiative, 188\nUVa 00499 - What\u2019s The Frequency . *, 91\nUVa 00501 - Black Box, 93\nUVa 00507 - Jill Rides Again, 173, 187\nUVa 00512 - Spreadsheet Tracking, 75\nUVa 00514 - Rails *, 77\nUVa 00517 - Word, 145\nUVa 00523 - Minimum Transport Cost, 240\nUVa 00524 - Prime Ring Problem, 147\nUVa 00529 - Addition Chain, 147\nUVa 00532 - Dungeon Master, 239\nUVa 00534 - Frogger, 222\nUVa 00536 - Tree Recovery *, 265\nUVa 00537 - Arti\ufb01cial Intelligence?, 39\nUVa 00538 - Balancing Bank Accounts, 38\nUVa 00540 - Team Queue, 77\nUVa 00541 - Error Correction, 74\nUVa 00544 - Heavy Cargo, 222\nUVa 00548 - Tree, 265\nUVa 00550 - Multiplying by Rotation, 146\nUVa 00551 - Nesting a Bunch of . *, 77\nUVa 00555 - Bridge Hands, 36\nUVa 00556 - Amazing, 40\nUVa 00558 - Wormholes *, 234, 240\nUVa 00562 - Dividing Coins, 188\nUVa 00565 - Pizza Anyone?,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d8d2fcff-05f7-4c65-895b-d61ef7c3bb83": {"__data__": {"id_": "d8d2fcff-05f7-4c65-895b-d61ef7c3bb83", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b1348c77-3357-4750-90a7-1b7fbdc05799", "node_type": "1", "metadata": {}, "hash": "d8a831af7356bba22fedfd698baca73cd8e02dcd9ed0e2e891c89a5509380a63", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5c314b63-09df-4dce-a50f-be993514b32a", "node_type": "1", "metadata": {}, "hash": "8726b316bd83b2abe106608878c71a789335cbb85d0c140eefeb1790773dbb10", "class_name": "RelatedNodeInfo"}}, "text": "239\nUVa 00534 - Frogger, 222\nUVa 00536 - Tree Recovery *, 265\nUVa 00537 - Arti\ufb01cial Intelligence?, 39\nUVa 00538 - Balancing Bank Accounts, 38\nUVa 00540 - Team Queue, 77\nUVa 00541 - Error Correction, 74\nUVa 00544 - Heavy Cargo, 222\nUVa 00548 - Tree, 265\nUVa 00550 - Multiplying by Rotation, 146\nUVa 00551 - Nesting a Bunch of . *, 77\nUVa 00555 - Bridge Hands, 36\nUVa 00556 - Amazing, 40\nUVa 00558 - Wormholes *, 234, 240\nUVa 00562 - Dividing Coins, 188\nUVa 00565 - Pizza Anyone?, 147\nUVa 00567 - Risk, 248\nUVa 00571 - Jugs, 147\nUVa 00572 - Oil Deposits *, 212\nUVa 00573 - The Snail, 30\nUVa 00579 - Clock Hands *, 23, 38\nUVa 00584 - Bowling *, 37\nUVa 00585 - Triangles, 74\nUVa 00589 - Pushing Boxes *, 240\nUVa 00590 - Always on the Run *, 265\nUVa 00591 - Box of Bricks, 74\nUVa 00592 - Island of Logic *, 144\nUVa 00594 - One Little, Two Little . 76\nUVa 00598 - Bundling Newspaper, 147\nUVa 00599 - The Forrest for the Trees *, 122\nUVa 00601 - The PATH, 212\nUVa 00602 - What Day Is It?, 38\nUVa 00603 - Parking Lot, 40\nUVa 00607 - Scheduling Lectures, 265\nUVa 00608 - Counterfeit Dollar, 154\nUVa 00610 - Street Directions, 213\nUVa 00612 - DNA Sorting *, 76\nUVa 00614 - Mapping the Route, 214\nUVa 00615 - Is It A Tree?, 265\nUVa 00616 - Coconuts, Revisited *, 146\nUVa 00617 - Nonstop Travel, 144\nUVa 00618 - Doing Windows, 40\nUVa 00619 - Numerically Speaking, 76\nUVa 00621 - Secret Research, 28\nUVa 00626 - Ecosystem, 144\nUVa 00627 - The Net, 239\nUVa 00628 - Passwords, 147\nUVa 00632 - Compression (II), 39\nUVa 00633 - Chess Knight *, 239\nUVa 00637 - Booklet Printing *, 37\nUVa 00639 - Don\u2019t Get Rooked *, 145\nUVa 00641 - Do the Untwist, 39\nUVa 00647 - Chutes and Ladders, 37\nUVa 00654 - Ratio, 146\nUVa 00657 - The Die is Cast, 212\nUVa 00661 - Blowing Fuses, 30\nUVa 00662 - Fast Food *, 189\nUVa 00663 - Sorting Slides, 266\nUVa 00665 - False Coin, 74\nUVa 00668 - Parliament, 163\nUVa 00670 - The Dog Task *, 266\nUVa 00673 - Parentheses Balance *, 77\nUVa 00674 - Coin Change *, 182, 188\nUVa 00677 - All Walks of length \u201cn\u201d . 147\nUVa 00679 - Dropping Balls, 153\nUVa 00696 - How Many Knights *, 36\nUVa 00697 - Jack and Jill, 146\nUVa 00699 - The Falling Leaves, 265\nUVa 00700 - Date Bugs, 76\nUVa 00703 - Triple Ties: The . 144\nUVa 00705 - Slash Maze, 212\nUVa 00706 - LC-Display *, 38\nUVa 00707 - Robbery, 75\nUVa 00712 - S-Trees, 265\nUVa 00713 - Adding Reversed . *, 76\n290\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 00721 - Invitation Cards, 240\nUVa 00722 - Lakes, 212\nUVa 00725 - Division *, 131,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c314b63-09df-4dce-a50f-be993514b32a": {"__data__": {"id_": "5c314b63-09df-4dce-a50f-be993514b32a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d8d2fcff-05f7-4c65-895b-d61ef7c3bb83", "node_type": "1", "metadata": {}, "hash": "7decf81294e2760ad7f029820263ad97a33064a61bb56bd18730cfed33160cfa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4a4d332b-a670-4bcb-b934-b252c1c3c550", "node_type": "1", "metadata": {}, "hash": "4587a0a06cb9399d0d9b47b6ab9eb1ab582f02ddbcdd3c94682f62ef6c5efece", "class_name": "RelatedNodeInfo"}}, "text": "147\nUVa 00679 - Dropping Balls, 153\nUVa 00696 - How Many Knights *, 36\nUVa 00697 - Jack and Jill, 146\nUVa 00699 - The Falling Leaves, 265\nUVa 00700 - Date Bugs, 76\nUVa 00703 - Triple Ties: The . 144\nUVa 00705 - Slash Maze, 212\nUVa 00706 - LC-Display *, 38\nUVa 00707 - Robbery, 75\nUVa 00712 - S-Trees, 265\nUVa 00713 - Adding Reversed . *, 76\n290\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 00721 - Invitation Cards, 240\nUVa 00722 - Lakes, 212\nUVa 00725 - Division *, 131, 146\nUVa 00727 - Equation *, 77\nUVa 00729 - The Hamming . *, 147\nUVa 00732 - Anagram by Stack, 77\nUVa 00735 - Dart-a-Mania *, 144\nUVa 00739 - Soundex Indexing, 39\nUVa 00740 - Baudot Data . 39\nUVa 00748 - Exponentiation, 76\nUVa 00750 - 8 Queens Chess . *, 135, 144\nUVa 00753 - A Plug for Unix, 266\nUVa 00755 - 487-3279, 91\nUVa 00757 - Gone Fishing, 265\nUVa 00758 - The Same Game, 212\nUVa 00759 - The Return of the . *, 39\nUVa 00762 - We Ship Cheap, 239\nUVa 00776 - Monkeys in a Regular . 212\nUVa 00781 - Optimisation, 214\nUVa 00782 - Countour Painting, 212\nUVa 00784 - Maze Exploration, 212\nUVa 00785 - Grid Colouring, 212\nUVa 00787 - Maximum Sub . *, 187\nUVa 00790 - Head Judge Headache, 75\nUVa 00793 - Network Connections, 122\nUVa 00795 - Sandorf\u2019s Cipher, 39\nUVa 00796 - Critical Links, 213\nUVa 00821 - Page Hopping *, 248\nUVa 00824 - Coast Tracker *, 214\nUVa 00825 - Walking on the Safe Side *, 264\nUVa 00830 - Shark, 40\nUVa 00836 - Largest Submatrix, 187\nUVa 00839 - Not so Mobile, 265\nUVa 00840 - Deadlock Detection, 213\nUVa 00846 - Steps, 146\nUVa 00852 - Deciding victory in Go *, 212\nUVa 00855 - Lunch in Grid City, 75\nUVa 00857 - Quantiser, 37\nUVa 00859 - Chinese Checkers, 239\nUVa 00860 - Entropy Text Analyzer, 92\nUVa 00861 - Little Bishops, 144\nUVa 00865 - Substitution Cypher, 39\nUVa 00868 - Numerical maze, 147\nUVa 00869 - Airline Comparison *, 248\nUVa 00871 - Counting Cells in a Blob *, 212\nUVa 00872 - Ordering *, 213\nUVa 00893 - Y3K, 38\nUVa 00895 - Word Problem, 91\nUVa 00902 - Password Search *, 92\nUVa 00906 - Rational Neighbor, 146\nUVa 00907 - Winterim Backpack. *, 265\nUVa 00908 - Re-connecting . 222\nUVa 00910 - TV Game, 265\nUVa 00924 - Spreading the News, 239\nUVa 00925 - No more prerequisites . 248\nUVa 00926 - Walking Around Wisely, 264\nUVa 00929 - Number Maze, 240\nUVa 00939 - Genes, 93\nUVa 00945 - Loading a Cargo Ship, 40\nUVa 00946 - A Pile of Boxes, 74\nUVa 00947 - Master Mind Helper *, 36\nUVa 00949 - Getaway, 239\nUVa 00957 - Popes, 153\nUVa 00978 - Lemmings Battle *, 93\nUVa 00983 - Localized Summing for .", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4a4d332b-a670-4bcb-b934-b252c1c3c550": {"__data__": {"id_": "4a4d332b-a670-4bcb-b934-b252c1c3c550", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5c314b63-09df-4dce-a50f-be993514b32a", "node_type": "1", "metadata": {}, "hash": "8726b316bd83b2abe106608878c71a789335cbb85d0c140eefeb1790773dbb10", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "92d88b27-bc15-4c28-9fed-d2f23b0453dd", "node_type": "1", "metadata": {}, "hash": "5b660ae9846045c90d3323e93862a75a143a990eba56af8c037f9f0398f44086", "class_name": "RelatedNodeInfo"}}, "text": "146\nUVa 00907 - Winterim Backpack. *, 265\nUVa 00908 - Re-connecting . 222\nUVa 00910 - TV Game, 265\nUVa 00924 - Spreading the News, 239\nUVa 00925 - No more prerequisites . 248\nUVa 00926 - Walking Around Wisely, 264\nUVa 00929 - Number Maze, 240\nUVa 00939 - Genes, 93\nUVa 00945 - Loading a Cargo Ship, 40\nUVa 00946 - A Pile of Boxes, 74\nUVa 00947 - Master Mind Helper *, 36\nUVa 00949 - Getaway, 239\nUVa 00957 - Popes, 153\nUVa 00978 - Lemmings Battle *, 93\nUVa 00983 - Localized Summing for . 187\nUVa 00986 - How Many?, 264\nUVa 00988 - Many paths, one . 250, 264\nUVa 00990 - Diving For Gold, 188\nUVa 01013 - Island Hopping *, 222\nUVa 01025 - A Spy in the Metro, 265\nUVa 01047 - Zones *, 145\nUVa 01056 - Degrees of . *, 246, 248\nUVa 01061 - Consanguine Calc. *, 38\nUVa 01062 - Containers *, 77\nUVa 01064 - Network *, 145\nUVa 01091 - Barcodes *, 38\nUVa 01103 - Ancient Messages *, 199, 212\nUVa 01105 - Co\u21b5ee Central *, 187\nUVa 01112 - Mice and Maze *, 240\nUVa 01124 - Celebrity Jeopardy *, 28\nUVa 01148 - The mysterious X network, 239\nUVa 01153 - Keep the Customer . *, 163\nUVa 01160 - X-Plosives, 222\nUVa 01174 - IP-TV, 222\nUVa 01176 - A Benevolent Josephus *, 147\nUVa 01193 - Radar Install. *, 162\nUVa 01196 - Tiling Up Blocks *, 188\nUVa 01197 - The Suspects *, 122\nUVa 01198 - Geodetic Set Problem, 248\nUVa 01200 - A DP Problem *, 39\nUVa 01202 - Finding Nemo, 240\nUVa 01203 - Argus *, 91\nUVa 01208 - Oreon, 222\nUVa 01209 - Word\ufb01sh, 145\nUVa 01213 - Sum of Di\u21b5erent Primes *, 188\nUVa 01216 - The Bug Sensor Problem, 222\nUVa 01225 - Digit Counting *, 146\nUVa 01226 - Numerical surprises, 76\nUVa 01229 - Sub-dictionary, 214, 246\nUVa 01232 - SKYLINE, 123\n291\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 01233 - USHER, 248\nUVa 01234 - RACING, 218, 222\nUVa 01235 - Anti Brute Force Lock, 222\nUVa 01237 - Expert Enough, 30\nUVa 01241 - Jollybee Tournament, 76\nUVa 01247 - Interstar Transport *, 248\nUVa 01260 - Sales, 144\nUVa 01261 - String Popping, 189\nUVa 01262 - Password *, 147\nUVa 01265 - Tour Belt *, 222\nUVa 01281 - Bus Tour, 189\nUVa 01329 - Corporative Network *, 122\nUVa 01339 - Ancient Cipher, 39\nUVa 01368 - DNA Consensus String *, 91\nUVa 01513 - Movie collection, 123\nUVa 01583 - Digit Generator, 146\nUVa 01585 - Score *, 29\nUVa 01586 - Molar mass *, 37\nUVa 01588 - Kickdown *, 144\nUVa 01605 - Building for UN *, 40\nUVa 01610 - Party Games *, 75\nUVa 01641 - ASCII Area, 29\nUVa 01647 - Computer Transformation, 76\nUVa 01709 - Amalgamated Artichokes, 29\nUVa 01721 - Window Manager,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "92d88b27-bc15-4c28-9fed-d2f23b0453dd": {"__data__": {"id_": "92d88b27-bc15-4c28-9fed-d2f23b0453dd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4a4d332b-a670-4bcb-b934-b252c1c3c550", "node_type": "1", "metadata": {}, "hash": "4587a0a06cb9399d0d9b47b6ab9eb1ab582f02ddbcdd3c94682f62ef6c5efece", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b95ab453-715d-4a61-be3b-ba011d6f15ac", "node_type": "1", "metadata": {}, "hash": "a593940b12b67ac827b8cf876618dd33eea233a46b881dd7b33f52b384355545", "class_name": "RelatedNodeInfo"}}, "text": "222\nUVa 01281 - Bus Tour, 189\nUVa 01329 - Corporative Network *, 122\nUVa 01339 - Ancient Cipher, 39\nUVa 01368 - DNA Consensus String *, 91\nUVa 01513 - Movie collection, 123\nUVa 01583 - Digit Generator, 146\nUVa 01585 - Score *, 29\nUVa 01586 - Molar mass *, 37\nUVa 01588 - Kickdown *, 144\nUVa 01605 - Building for UN *, 40\nUVa 01610 - Party Games *, 75\nUVa 01641 - ASCII Area, 29\nUVa 01647 - Computer Transformation, 76\nUVa 01709 - Amalgamated Artichokes, 29\nUVa 01721 - Window Manager, 40\nUVa 01738 - Ceiling Function, 154\nUVa 01753 - Need for Speed, 154\nUVa 01757 - Secret Chamber . 248\nUVa 10000 - Longest Paths, 264\nUVa 10001 - Garden of Eden, 147\nUVa 10003 - Cutting Sticks *, 185, 189\nUVa 10004 - Bicoloring *, 202, 213\nUVa 10008 - What\u2019s Cryptanalysis?, 91\nUVa 10009 - All Roads Lead Where?, 239\nUVa 10013 - Super long sums, 76\nUVa 10015 - Joseph\u2019s Cousin, 147\nUVa 10016 - Flip-\ufb02op the Squarelotron, 75\nUVa 10019 - Funny Encryption Method, 39\nUVa 10020 - Minimal Coverage *, 162\nUVa 10025 - The ? 1 ? 2 ? ..., 146\nUVa 10026 - Shoemaker\u2019s Problem *, 162\nUVa 10028 - Demerit Points, 40\nUVa 10033 - Interpreter, 40\nUVa 10034 - Freckles, 222\nUVa 10035 - Primary Arithmetic, 146\nUVa 10036 - Divisibility, 189\nUVa 10037 - Bridge, 162\nUVa 10038 - Jolly Jumpers, 74\nUVa 10039 - Railroads, 189\nUVa 10041 - Vito\u2019s Family, 144\nUVa 10044 - Erdos numbers, 239\nUVa 10048 - Audiophobia *, 220, 222\nUVa 10050 - Hartals, 74\nUVa 10051 - Tower of Cubes, 264\nUVa 10054 - The Necklace *, 266\nUVa 10055 - Hashmat the Brave ..., 28\nUVa 10057 - A mid-summer night ..., 153\nUVa 10062 - Tell me the frequencies, 91\nUVa 10063 - Knuth\u2019s Permutation, 147\nUVa 10067 - Playing with Wheels, 239\nUVa 10069 - Distinct Subsequences, 189\nUVa 10070 - Leap Year or Not Leap ..., 38\nUVa 10071 - Back to High School ... *, 28\nUVa 10074 - Take the Land, 187\nUVa 10077 - The Stern-Brocot ..., 153\nUVa 10080 - Gopher II, 266\nUVa 10081 - Tight words, 189\nUVa 10082 - WERTYU, 37\nUVa 10083 - Division, 76\nUVa 10086 - Test the Rods, 189\nUVa 10094 - Place the Guards, 147\nUVa 10099 - Tourist Guide, 222\nUVa 10102 - The Path in the ..., 144\nUVa 10106 - Product, 76\nUVa 10107 - What is the Median?", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b95ab453-715d-4a61-be3b-ba011d6f15ac": {"__data__": {"id_": "b95ab453-715d-4a61-be3b-ba011d6f15ac", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "92d88b27-bc15-4c28-9fed-d2f23b0453dd", "node_type": "1", "metadata": {}, "hash": "5b660ae9846045c90d3323e93862a75a143a990eba56af8c037f9f0398f44086", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "516c14f3-66f7-4253-ace5-1fa005e1848e", "node_type": "1", "metadata": {}, "hash": "6801ff957e4e232a07d14b5ff0b4b433606010c30700acc6fa6b755b0445cad3", "class_name": "RelatedNodeInfo"}}, "text": "*, 75\nUVa 10113 - Exchange Rates, 214\nUVa 10114 - Loansome Car Buyer, 30\nUVa 10116 - Robot Motion *, 213\nUVa 10120 - Gift?, 189\nUVa 10128 - Queue *, 144\nUVa 10129 - Play on Words, 266\nUVa 10130 - SuperSale *, 188\nUVa 10131 - Is Bigger Smarter?, 188\nUVa 10132 - File Fragmentation, 92\nUVa 10134 - AutoFish, 40\nUVa 10138 - CDVII *, 93\nUVa 10141 - Request for Proposal, 30\nUVa 10142 - Australian Voting, 40\nUVa 10145 - Lock Manager *, 92\nUVa 10146 - Dictionary, 40\nUVa 10147 - Highways, 219, 222\nUVa 10152 - ShellSort, 163\nUVa 10154 - Weights and Measures, 188\nUVa 10158 - War, 122\nUVa 10164 - Number Game, 189\nUVa 10166 - Travel, 240\nUVa 10171 - Meeting Prof. Miguel, 248\nUVa 10172 - The Lonesome Cargo ... *, 77\nUVa 10177 - (2/3/4)-D Sqr/Rects/..., 144\nUVa 10187 - From Dusk Till Dawn, 240\n292\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 10188 - Automated Judge Script *, 40\nUVa 10189 - Minesweeper *, 36\nUVa 10191 - Longest Nap, 37\nUVa 10194 - Football a.k.a. Soccer, 75\nUVa 10196 - Check The Check, 36\nUVa 10198 - Counting, 76\nUVa 10199 - Tourist Guide, 213\nUVa 10201 - Adventures in Moving . 265\nUVa 10203 - Snow Clearing *, 266\nUVa 10205 - Stack \u2019em Up, 36\nUVa 10222 - Decode the Mad Man, 39\nUVa 10226 - Hardwood Species, 93\nUVa 10227 - Forests, 122\nUVa 10239 - The Book-shelver\u2019s Problem, 189\nUVa 10246 - Asterix and Obelix, 248\nUVa 10249 - The Grand Dinner, 162\nUVa 10252 - Common Permutation, 91\nUVa 10258 - Contest Scoreboard *, 75\nUVa 10259 - Hippity Hopscotch *, 264\nUVa 10260 - Soundex *, 91\nUVa 10261 - Ferry Loading, 188\nUVa 10264 - The Most Potent Corner *, 76\nUVa 10267 - Graphical Editor, 40\nUVa 10271 - Chopsticks, 265\nUVa 10276 - Hanoi Tower . *, 144\nUVa 10278 - Fire Station, 240\nUVa 10279 - Mine Sweeper, 36\nUVa 10280 - Old Wine Into New Bottles, 240\nUVa 10281 - Average Speed, 40\nUVa 10282 - Babel\ufb01sh, 92\nUVa 10284 - Chessboard in FEN *, 36\nUVa 10285 - Longest Run . 264\nUVa 10293 - Word Length and Frequency, 91\nUVa 10295 - Hay Points, 92\nUVa 10300 - Ecological Premium, 29\nUVa 10305 - Ordering Tasks, 213\nUVa 10308 - Roads in the North, 265\nUVa 10313 - Pay the Price, 188\nUVa 10315 - Poker Hands, 36\nUVa 10324 - Zeros and Ones, 30\nUVa 10327 - Flip Sort, 76\nUVa 10331 - The Flyover Construction, 248\nUVa 10336 - Rank the Languages, 212\nUVa 10337 - Flight Planner, 189\nUVa 10339 - Watching Watches, 38\nUVa 10340 - All in All *, 163\nUVa 10341 - Solve It, 154\nUVa 10342 - Always Late *, 248\nUVa 10344 - 23 Out of 5 *, 147\nUVa 10346 - Peter\u2019s Smoke *,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "516c14f3-66f7-4253-ace5-1fa005e1848e": {"__data__": {"id_": "516c14f3-66f7-4253-ace5-1fa005e1848e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b95ab453-715d-4a61-be3b-ba011d6f15ac", "node_type": "1", "metadata": {}, "hash": "a593940b12b67ac827b8cf876618dd33eea233a46b881dd7b33f52b384355545", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1046d801-81ce-4023-b131-d396de2ee0f7", "node_type": "1", "metadata": {}, "hash": "db738ab92829197cf31c79daea60e2ea7c5a704ca5f0c5f8b026fed9fc25a0cd", "class_name": "RelatedNodeInfo"}}, "text": "29\nUVa 10305 - Ordering Tasks, 213\nUVa 10308 - Roads in the North, 265\nUVa 10313 - Pay the Price, 188\nUVa 10315 - Poker Hands, 36\nUVa 10324 - Zeros and Ones, 30\nUVa 10327 - Flip Sort, 76\nUVa 10331 - The Flyover Construction, 248\nUVa 10336 - Rank the Languages, 212\nUVa 10337 - Flight Planner, 189\nUVa 10339 - Watching Watches, 38\nUVa 10340 - All in All *, 163\nUVa 10341 - Solve It, 154\nUVa 10342 - Always Late *, 248\nUVa 10344 - 23 Out of 5 *, 147\nUVa 10346 - Peter\u2019s Smoke *, 146\nUVa 10350 - Liftless Eme *, 264\nUVa 10354 - Avoiding Your Boss *, 248\nUVa 10356 - Rough Roads, 240\nUVa 10360 - Rat Attack, 140, 145\nUVa 10363 - Tic Tac Toe, 37\nUVa 10365 - Blocks, 145\nUVa 10369 - Arctic Networks, 219, 222\nUVa 10370 - Above Average, 146\nUVa 10371 - Time Zones, 38\nUVa 10374 - Election, 92\nUVa 10377 - Maze Traversal, 214\nUVa 10382 - Watering Grass, 157, 162\nUVa 10385 - Duathlon *, 154\nUVa 10388 - Snap *, 36\nUVa 10389 - Subway, 240\nUVa 10397 - Connect the Campus, 222\nUVa 10400 - Game Show Math, 189\nUVa 10401 - Injured Queen Problem, 264\nUVa 10409 - Die Game, 36\nUVa 10415 - Eb Alto Saxophone Player, 38\nUVa 10420 - List of Conquests, 93\nUVa 10424 - Love Calculator *, 29\nUVa 10426 - Knights\u2019 Nightmare *, 239\nUVa 10430 - Dear GOD, 76\nUVa 10433 - Automorphic Numbers, 76\nUVa 10436 - Cheapest Way, 248\nUVa 10440 - Ferry Loading II, 163\nUVa 10443 - Rock, Scissors, Paper, 37\nUVa 10446 - The Marriage Interview, 189\nUVa 10448 - Unique World *, 188\nUVa 10449 - Tra\ufb03c *, 240\nUVa 10452 - Marcus, help, 147\nUVa 10457 - Magic Car *, 222\nUVa 10459 - The Tree Root, 265\nUVa 10460 - Find the Permuted String, 147\nUVa 10462 - Is There A Second . 222\nUVa 10464 - Big Big Real Numbers, 76\nUVa 10465 - Homer Simpson, 189\nUVa 10469 - To Carry or not to Carry, 76\nUVa 10474 - Where is the Marble?, 153\nUVa 10475 - Help the Leaders, 147\nUVa 10477 - The Hybrid Knight *, 239\nUVa 10483 - The Sum Equals . 145\nUVa 10487 - Closest Sums, 144\nUVa 10494 - If We Were a Child Again, 76\nUVa 10496 - Collecting Beepers, 189\nUVa 10500 - Robot maps *, 40\nUVa 10502 - Counting Rectangles, 145\nUVa 10503 - The dominoes solitaire, 147\nUVa 10505 - Montesco vs Capuleto *, 213\n293\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 10507 - Waking up brain, 122\nUVa 10510 - Cactus, 213\nUVa 10519 - Really Strange, 76\nUVa 10520 - Determine it, 189\nUVa 10523 - Very Easy *, 76\nUVa 10525 - New to Bangladesh?, 248\nUVa 10528 - Major Scales *, 37\nUVa 10530 - Guessing Game, 36\nUVa 10534 - Wavio Sequence *, 188\nUVa 10543 - Traveling Politician, 265\nUVa 10544 - Numbering the Paths *,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1046d801-81ce-4023-b131-d396de2ee0f7": {"__data__": {"id_": "1046d801-81ce-4023-b131-d396de2ee0f7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "516c14f3-66f7-4253-ace5-1fa005e1848e", "node_type": "1", "metadata": {}, "hash": "6801ff957e4e232a07d14b5ff0b4b433606010c30700acc6fa6b755b0445cad3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9952d9f7-2036-444c-a07e-e17d7bad1436", "node_type": "1", "metadata": {}, "hash": "7ffff9252d1ef2d5fde2cc8494ca97573520ec5045d9bd8a83c63ddf0e9f91a9", "class_name": "RelatedNodeInfo"}}, "text": "145\nUVa 10503 - The dominoes solitaire, 147\nUVa 10505 - Montesco vs Capuleto *, 213\n293\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 10507 - Waking up brain, 122\nUVa 10510 - Cactus, 213\nUVa 10519 - Really Strange, 76\nUVa 10520 - Determine it, 189\nUVa 10523 - Very Easy *, 76\nUVa 10525 - New to Bangladesh?, 248\nUVa 10528 - Major Scales *, 37\nUVa 10530 - Guessing Game, 36\nUVa 10534 - Wavio Sequence *, 188\nUVa 10543 - Traveling Politician, 265\nUVa 10544 - Numbering the Paths *, 264\nUVa 10550 - Combination Lock, 29\nUVa 10554 - Calories from Fat, 37\nUVa 10557 - XYZZY, 240\nUVa 10564 - Path through the Hourglass, 264\nUVa 10567 - Helping Fill Bates, 153\nUVa 10570 - Meeting with Aliens, 144\nUVa 10576 - Y2K Accounting Bug *, 147\nUVa 10582 - ASCII Labyrinth, 147\nUVa 10583 - Ubiquitous Religions, 122\nUVa 10592 - Freedom Fighter, 212\nUVa 10596 - Morning Walk *, 266\nUVa 10600 - ACM Contest and . 220, 222\nUVa 10602 - Editor Nottobad, 163\nUVa 10603 - Fill, 240\nUVa 10608 - Friends, 122\nUVa 10610 - Gopher and Hawks, 239\nUVa 10611 - Playboy Chimp, 153\nUVa 10616 - Divisible Group Sum, 188\nUVa 10624 - Super Number, 147\nUVa 10625 - GNU = GNU\u2019sNotUnix, 91\nUVa 10646 - What is the Card? *, 36\nUVa 10651 - Pebble Solitaire, 189\nUVa 10653 - Bombs; NO they . *, 239\nUVa 10656 - Maximum Sum (II) *, 163\nUVa 10659 - Fitting Text into Slides, 38\nUVa 10660 - Citizen attention . *, 145\nUVa 10662 - The Wedding, 144\nUVa 10664 - Luggage, 188\nUVa 10667 - Largest Block, 187\nUVa 10669 - Three powers, 76\nUVa 10670 - Work Reduction, 144\nUVa 10672 - Marbles on a tree, 163\nUVa 10681 - Teobaldo\u2019s Trip, 265\nUVa 10683 - The decadary watch, 38\nUVa 10684 - The Jackpot *, 187\nUVa 10685 - Nature *, 122\nUVa 10686 - SQF Problem, 92\nUVa 10687 - Monitoring the Amazon, 212\nUVa 10688 - The Poor Giant, 189\nUVa 10690 - Expression Again, 188\nUVa 10698 - Football Sort, 75\nUVa 10700 - Camel Trading, 163\nUVa 10701 - Pre, in and post, 265\nUVa 10702 - Traveling Salesman, 265\nUVa 10703 - Free spots, 74\nUVa 10706 - Number Sequence, 153\nUVa 10707 - 2D - Nim, 212\nUVa 10714 - Ants, 163\nUVa 10718 - Bit Mask, 163\nUVa 10721 - Bar Codes, 189\nUVa 10724 - Road Construction, 248\nUVa 10730 - Antiarithmetic?, 144\nUVa 10731 - Test, 214, 246\nUVa 10742 - New Rule in Euphomia, 153\nUVa 10755 - Garbage Heap *, 187\nUVa 10763 - Foreign Exchange, 162\nUVa 10765 - Doves and Bombs *, 213\nUVa 10771 - Barbarian tribes, 147\nUVa 10774 - Repeated Josephus *, 147\nUVa 10776 - Determine The . 147\nUVa 10783 - Odd Sum, 146\nUVa 10785 - The Mad Numerologist,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9952d9f7-2036-444c-a07e-e17d7bad1436": {"__data__": {"id_": "9952d9f7-2036-444c-a07e-e17d7bad1436", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1046d801-81ce-4023-b131-d396de2ee0f7", "node_type": "1", "metadata": {}, "hash": "db738ab92829197cf31c79daea60e2ea7c5a704ca5f0c5f8b026fed9fc25a0cd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1a411229-227a-4178-a507-6f219c8e6373", "node_type": "1", "metadata": {}, "hash": "af71d66fe59e230402c818d501cd4f8175fee61a269b6eed0068ed891c87f5b6", "class_name": "RelatedNodeInfo"}}, "text": "212\nUVa 10714 - Ants, 163\nUVa 10718 - Bit Mask, 163\nUVa 10721 - Bar Codes, 189\nUVa 10724 - Road Construction, 248\nUVa 10730 - Antiarithmetic?, 144\nUVa 10731 - Test, 214, 246\nUVa 10742 - New Rule in Euphomia, 153\nUVa 10755 - Garbage Heap *, 187\nUVa 10763 - Foreign Exchange, 162\nUVa 10765 - Doves and Bombs *, 213\nUVa 10771 - Barbarian tribes, 147\nUVa 10774 - Repeated Josephus *, 147\nUVa 10776 - Determine The . 147\nUVa 10783 - Odd Sum, 146\nUVa 10785 - The Mad Numerologist, 162\nUVa 10793 - The Orc Attack, 248\nUVa 10801 - Lift Hopping, 240\nUVa 10803 - Thunder Mountain, 248\nUVa 10805 - Cockroach Escape . *, 265\nUVa 10810 - Ultra Quicksort, 76\nUVa 10812 - Beat the Spread, 37\nUVa 10813 - Traditional BINGO *, 37\nUVa 10815 - Andy\u2019s First Dictionary *, 93\nUVa 10819 - Trouble of 13-Dots, 188\nUVa 10821 - Constructing BST *, 163\nUVa 10827 - Maximum Sum on . 187\nUVa 10842 - Tra\ufb03c Flow, 222\nUVa 10849 - Move the bishop, 36\nUVa 10850 - The Gossipy Gossipers . 40\nUVa 10851 - 2D Hieroglyphs . *, 39\nUVa 10855 - Rotated squares, 75\nUVa 10858 - Unique Factorization, 77\nUVa 10874 - Segments, 265\nUVa 10878 - Decode the Tape, 39\nUVa 10879 - Code Refactoring, 146\nUVa 10880 - Colin and Ryan, 75\nUVa 10887 - Concatenation of . *, 92\nUVa 10894 - Save Hridoy, 40\nUVa 10895 - Matrix Transpose *, 122\nUVa 10896 - Known Plaintext Attack, 39\nUVa 10901 - Ferry Loading III, 77\nUVa 10903 - Rock-Paper-Scissors . 37\n294\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 10905 - Children\u2019s Game, 75\nUVa 10906 - Strange Integration *, 39\nUVa 10908 - Largest Square *, 146\nUVa 10909 - Lucky Number *, 93\nUVa 10910 - Mark\u2019s Distribution, 189\nUVa 10911 - Forming Quiz . *, 1\nUVa 10912 - Simple Minded . *, 189\nUVa 10913 - Walking . *, 265\nUVa 10919 - Prerequisites?, 30\nUVa 10920 - Spiral Tap, 74\nUVa 10921 - Find the Telephone, 39\nUVa 10925 - Krakovia *, 76\nUVa 10926 - How Many Dependencies?, 264\nUVa 10928 - My Dear Neighbours, 122\nUVa 10935 - Throwing cards away I, 77\nUVa 10942 - Can of Beans *, 38\nUVa 10943 - How do you add?, 184, 189, 254\nUVa 10946 - You want what \ufb01lled?, 212\nUVa 10947 - Bear with me, again. 248\nUVa 10950 - Bad Code, 147\nUVa 10954 - Add All *, 163\nUVa 10959 - The Party, Part I, 239\nUVa 10961 - Chasing After Don Giovanni, 40\nUVa 10963 - The Swallowing Ground, 29\nUVa 10967 - The Great Escape, 240\nUVa 10973 - Triangle Counting, 145\nUVa 10977 - Enchanted Forest, 239\nUVa 10978 - Let\u2019s Play Magic *, 74\nUVa 10980 - Lowest Price in Town, 189\nUVa 10982 - Troublemakers, 163\nUVa 10986 - Sending email *,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1a411229-227a-4178-a507-6f219c8e6373": {"__data__": {"id_": "1a411229-227a-4178-a507-6f219c8e6373", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9952d9f7-2036-444c-a07e-e17d7bad1436", "node_type": "1", "metadata": {}, "hash": "7ffff9252d1ef2d5fde2cc8494ca97573520ec5045d9bd8a83c63ddf0e9f91a9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "513056ca-4109-48ae-99dd-ad90ffd40f55", "node_type": "1", "metadata": {}, "hash": "b2c95b862d5740d80d17362591070d3134400523fda73488ee53a29ef7e8d230", "class_name": "RelatedNodeInfo"}}, "text": "184, 189, 254\nUVa 10946 - You want what \ufb01lled?, 212\nUVa 10947 - Bear with me, again. 248\nUVa 10950 - Bad Code, 147\nUVa 10954 - Add All *, 163\nUVa 10959 - The Party, Part I, 239\nUVa 10961 - Chasing After Don Giovanni, 40\nUVa 10963 - The Swallowing Ground, 29\nUVa 10967 - The Great Escape, 240\nUVa 10973 - Triangle Counting, 145\nUVa 10977 - Enchanted Forest, 239\nUVa 10978 - Let\u2019s Play Magic *, 74\nUVa 10980 - Lowest Price in Town, 189\nUVa 10982 - Troublemakers, 163\nUVa 10986 - Sending email *, 240\nUVa 10987 - Anti\ufb02oyd *, 248\nUVa 10992 - The Ghost of Programmers, 76\nUVa 10993 - Ignoring Digits, 239\nUVa 10997 - Medals, 145\nUVa 11001 - Necklace, 146\nUVa 11003 - Boxes, 188\nUVa 11013 - Get Straight *, 37\nUVa 11015 - 05-32 Rendezvous, 248\nUVa 11026 - A Grouping Problem, 189\nUVa 11034 - Ferry Loading IV, 77\nUVa 11039 - Building Designing, 75\nUVa 11040 - Add bricks in the wall, 74\nUVa 11044 - Searching for Nessy *, 28\nUVa 11047 - The Scrooge Co Problem, 248\nUVa 11049 - Basic Wall Maze, 239\nUVa 11052 - Economic phone calls, 147\nUVa 11054 - Wine Trading in Gergovia, 163\nUVa 11057 - Exact Sum *, 153\nUVa 11059 - Maximum Product, 144\nUVa 11060 - Beverages *, 201, 213\nUVa 11062 - Andy\u2019s Second Dictionary, 93\nUVa 11067 - Little Red Riding Hood, 264\nUVa 11074 - Draw Grid, 40\nUVa 11078 - Open Credit System *, 29\nUVa 11080 - Place the Guards, 213\nUVa 11085 - Back to the 8-Queens, 144\nUVa 11093 - Just Finish it up, 74\nUVa 11094 - Continents *, 212\nUVa 11100 - The Trip, 2007, 162\nUVa 11101 - Mall Mania, 239\nUVa 11103 - WFF\u2019N Proof, 162\nUVa 11108 - Tautology, 145\nUVa 11110 - Equidivisions, 212\nUVa 11111 - Generalized Matrioshkas *, 77\nUVa 11130 - Billiard bounces *, 146\nUVa 11131 - Close Relatives, 265\nUVa 11136 - Hoax or what *, 93\nUVa 11137 - Ingenuous Cubrency, 188\nUVa 11138 - Nuts and Bolts *, 266\nUVa 11140 - Little Ali\u2019s Little Brother, 40\nUVa 11147 - KuPellaKeS BST *, 154\nUVa 11148 - Moliu Fractions, 39\nUVa 11150 - Cola, 146\nUVa 11157 - Dynamic Frog, 163\nUVa 11172 - Relational Operators *, 28\nUVa 11173 - Grey Codes, 65, 76\nUVa 11192 - Group Reverse, 74\nUVa 11201 - The Problem with the . 147\nUVa 11203 - Can you decide it . *, 91\nUVa 11205 - The Broken Pedometer, 145\nUVa 11219 - How old are you?, 38\nUVa 11220 - Decoding the message, 39\nUVa 11222 - Only I did it *, 74\nUVa 11223 - O: dah, dah, dah, 38\nUVa 11225 - Tarot scores, 36\nUVa 11228 - Transportation . *, 222\nUVa 11230 - Annoying painting tool, 163\nUVa 11234 - Expressions, 265\nUVa 11235 - Frequent Values,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "513056ca-4109-48ae-99dd-ad90ffd40f55": {"__data__": {"id_": "513056ca-4109-48ae-99dd-ad90ffd40f55", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1a411229-227a-4178-a507-6f219c8e6373", "node_type": "1", "metadata": {}, "hash": "af71d66fe59e230402c818d501cd4f8175fee61a269b6eed0068ed891c87f5b6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1319e319-f429-48ed-a40e-d46426f2057d", "node_type": "1", "metadata": {}, "hash": "5149fca0d4063dd438fec0e5524a8c5a637a13c5565520965cf25df411de582a", "class_name": "RelatedNodeInfo"}}, "text": "28\nUVa 11173 - Grey Codes, 65, 76\nUVa 11192 - Group Reverse, 74\nUVa 11201 - The Problem with the . 147\nUVa 11203 - Can you decide it . *, 91\nUVa 11205 - The Broken Pedometer, 145\nUVa 11219 - How old are you?, 38\nUVa 11220 - Decoding the message, 39\nUVa 11222 - Only I did it *, 74\nUVa 11223 - O: dah, dah, dah, 38\nUVa 11225 - Tarot scores, 36\nUVa 11228 - Transportation . *, 222\nUVa 11230 - Annoying painting tool, 163\nUVa 11234 - Expressions, 265\nUVa 11235 - Frequent Values, 123\nUVa 11236 - Grocery Store *, 145\nUVa 11239 - Open Source, 93\nUVa 11240 - Antimonotonicity, 163\nUVa 11242 - Tour de France, 144\nUVa 11244 - Counting Stars, 212\nUVa 11247 - Income Tax Hazard, 146\nUVa 11254 - Consecutive Integers *, 146\nUVa 11259 - Coin Changing Again *, 188\nUVa 11264 - Coin Collector *, 162\nUVa 11269 - Setting Problems, 162\n295\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 11278 - One-Handed Typist *, 39\nUVa 11279 - Keyboard Comparison *, 38\nUVa 11280 - Flying to Fredericton *, 240\nUVa 11286 - Conformity, 92\nUVa 11292 - The Dragon of . 159, 162\nUVa 11297 - Census, 123\nUVa 11300 - Spreading the Wealth, 75\nUVa 11307 - Alternative Arborescence, 265\nUVa 11308 - Bankrupt Baker *, 93\nUVa 11313 - Gourmet Games, 146\nUVa 11321 - Sort Sort and Sort *, 75\nUVa 11330 - Andy\u2019s Shoes, 163\nUVa 11332 - Summing Digits *, 29\nUVa 11335 - Discrete Pursuit, 163\nUVa 11338 - Mine\ufb01eld, 240\nUVa 11340 - Newspaper *, 91\nUVa 11341 - Term Strategy, 188\nUVa 11342 - Three-square, 145\nUVa 11348 - Exhibition *, 92\nUVa 11349 - Symmetric Matrix, 74\nUVa 11350 - Stern-Brocot Tree, 123\nUVa 11351 - Last Man Standing *, 147\nUVa 11352 - Crazy King *, 239\nUVa 11356 - Dates, 38\nUVa 11360 - Have Fun with Matrices *, 75\nUVa 11364 - Parking, 29\nUVa 11367 - Full Tank?, 238, 240\nUVa 11368 - Nested Dolls, 188\nUVa 11369 - Shopaholic *, 162\nUVa 11377 - Airport Setup, 239\nUVa 11389 - The Bus Driver Problem, 162\nUVa 11396 - Claw Decomposition, 213\nUVa 11402 - Ahoy, Pirates *, 123\nUVa 11407 - Squares, 189\nUVa 11412 - Dig the Holes, 145\nUVa 11413 - Fill the . 154\nUVa 11420 - Chest of . *, 189\nUVa 11423 - Cache Simulator *, 123\nUVa 11448 - Who said crisis?, 76\nUVa 11450 - Wedding Shopping, 164, 189\nUVa 11456 - Trainsorting, 188\nUVa 11459 - Snakes and Ladders *, 36\nUVa 11462 - Age Sort *, 76\nUVa 11463 - Commandos *, 241, 248\nUVa 11470 - Square Sums, 212\nUVa 11482 - Building a Triangular . 40\nUVa 11485 - Extreme Discrete . 189\nUVa 11487 - Gathering Food, 265\nUVa 11490 - Just Another Problem *, 146\nUVa 11491 - Erasing and Winning *, 163\nUVa 11492 - Babel,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1319e319-f429-48ed-a40e-d46426f2057d": {"__data__": {"id_": "1319e319-f429-48ed-a40e-d46426f2057d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "513056ca-4109-48ae-99dd-ad90ffd40f55", "node_type": "1", "metadata": {}, "hash": "b2c95b862d5740d80d17362591070d3134400523fda73488ee53a29ef7e8d230", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3081a98c-a13b-48c7-a9b1-acc30f34b13d", "node_type": "1", "metadata": {}, "hash": "fc93f9c8f82799ff2fc0b1556e2385f0aabef49884dfa691a2da2b95e9a54da2", "class_name": "RelatedNodeInfo"}}, "text": "154\nUVa 11420 - Chest of . *, 189\nUVa 11423 - Cache Simulator *, 123\nUVa 11448 - Who said crisis?, 76\nUVa 11450 - Wedding Shopping, 164, 189\nUVa 11456 - Trainsorting, 188\nUVa 11459 - Snakes and Ladders *, 36\nUVa 11462 - Age Sort *, 76\nUVa 11463 - Commandos *, 241, 248\nUVa 11470 - Square Sums, 212\nUVa 11482 - Building a Triangular . 40\nUVa 11485 - Extreme Discrete . 189\nUVa 11487 - Gathering Food, 265\nUVa 11490 - Just Another Problem *, 146\nUVa 11491 - Erasing and Winning *, 163\nUVa 11492 - Babel, 240\nUVa 11494 - Queen, 36\nUVa 11495 - Bubbles and Buckets *, 76\nUVa 11496 - Musical Loop, 74\nUVa 11498 - Division of Nlogonia, 29\nUVa 11503 - Virtual Friends, 122\nUVa 11504 - Dominos, 214\nUVa 11507 - Bender B. Rodriguez . *, 30\nUVa 11514 - Batman, 189\nUVa 11517 - Exact Change, 188\nUVa 11518 - Dominos 2, 212\nUVa 11520 - Fill the Square *, 163\nUVa 11530 - SMS Typing, 37\nUVa 11532 - Simple Adjacency . 163\nUVa 11541 - Decoding, 39\nUVa 11545 - Avoiding . 265\nUVa 11547 - Automatic Answer *, 28\nUVa 11548 - Blackboard Bonanza, 145\nUVa 11550 - Demanding Dilemma *, 122\nUVa 11559 - Event Planning *, 30\nUVa 11561 - Getting Gold, 212\nUVa 11565 - Simple Equations, 132, 145\nUVa 11566 - Let\u2019s Yum Cha *, 188\nUVa 11567 - Moliu Number Generator, 163\nUVa 11569 - Lovely Hint *, 264\nUVa 11571 - Simple Equations - Extreme, 132\nUVa 11572 - Unique Snow\ufb02akes, 92\nUVa 11573 - Ocean Currents, 239\nUVa 11577 - Letter Frequency *, 91\nUVa 11581 - Grid Successors *, 74\nUVa 11583 - Alien DNA *, 163\nUVa 11585 - Nurikabe *, 212\nUVa 11586 - Train Tracks, 30\nUVa 11588 - Image Coding, 75\nUVa 11608 - No Problem, 74\nUVa 11614 - Etruscan Warriors . *, 28\nUVa 11615 - Family Tree, 265\nUVa 11616 - Roman Numerals *, 39\nUVa 11621 - Small Factors *, 153\nUVa 11624 - Fire, 239\nUVa 11627 - Slalom, 154\nUVa 11629 - Ballot evaluation *, 92\nUVa 11631 - Dark Roads *, 222\nUVa 11638 - Temperature Monitoring *, 40\nUVa 11650 - Mirror Clock, 38\nUVa 11655 - Waterland, 264\nUVa 11658 - Best Coalition, 188\nUVa 11659 - Informants *, 145\nUVa 11661 - Burger Time?, 30\nUVa 11664 - Langton\u2019s Ant, 76\n296\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 11677 - Alarm Clock, 38\nUVa 11678 - Card\u2019s Exchange *, 36\nUVa 11679 - Sub-prime *, 29\nUVa 11683 - Laser Sculpture *, 30\nUVa 11686 - Pick up sticks, 213\nUVa 11687 - Digits, 29\nUVa 11689 - Soda Surpler, 146\nUVa 11690 - Money Matters, 122\nUVa 11692 - Rain Fall, 154\nUVa 11695 - Flight Planning, 265\nUVa 11701 - Cantor, 154\nUVa 11703 - sqrt log sin, 189\nUVa 11709 - Trust Groups *, 214\nUVa 11710 - Expensive Subway,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3081a98c-a13b-48c7-a9b1-acc30f34b13d": {"__data__": {"id_": "3081a98c-a13b-48c7-a9b1-acc30f34b13d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1319e319-f429-48ed-a40e-d46426f2057d", "node_type": "1", "metadata": {}, "hash": "5149fca0d4063dd438fec0e5524a8c5a637a13c5565520965cf25df411de582a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4b6dfc30-1afb-47e7-b07c-7144417a344d", "node_type": "1", "metadata": {}, "hash": "04361974c067a81a4932f1bc092a6002819b2c6da55b199d92feefc9dc99a7c0", "class_name": "RelatedNodeInfo"}}, "text": "76\n296\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 11677 - Alarm Clock, 38\nUVa 11678 - Card\u2019s Exchange *, 36\nUVa 11679 - Sub-prime *, 29\nUVa 11683 - Laser Sculpture *, 30\nUVa 11686 - Pick up sticks, 213\nUVa 11687 - Digits, 29\nUVa 11689 - Soda Surpler, 146\nUVa 11690 - Money Matters, 122\nUVa 11692 - Rain Fall, 154\nUVa 11695 - Flight Planning, 265\nUVa 11701 - Cantor, 154\nUVa 11703 - sqrt log sin, 189\nUVa 11709 - Trust Groups *, 214\nUVa 11710 - Expensive Subway, 222\nUVa 11716 - Digital Fortress, 39\nUVa 11717 - Energy Saving Micro. *, 40\nUVa 11723 - Numbering Road, 28\nUVa 11727 - Cost Cutting, 28\nUVa 11729 - Commando War *, 162\nUVa 11733 - Airports, 222\nUVa 11736 - Debugging RAM *, 37\nUVa 11742 - Social Constraints *, 133, 145\nUVa 11743 - Credit Check, 37\nUVa 11744 - Parallel Carry Adder, 37\nUVa 11747 - Heavy Cycle Edges *, 222\nUVa 11749 - Poor Trade Advisor *, 212\nUVa 11753 - Creating Palindrome, 147\nUVa 11760 - Brother Arif, . 76\nUVa 11764 - Jumping Mario *, 29\nUVa 11770 - Lighting Away *, 214\nUVa 11777 - Automate the Grades, 75\nUVa 11782 - Optimal Cut, 265\nUVa 11786 - Global Raining . *, 30\nUVa 11787 - Numeral Hieroglyphs *, 39\nUVa 11790 - Murcia\u2019s Skyline *, 188\nUVa 11792 - Krochanska is Here *, 239\nUVa 11795 - Mega Man\u2019s Mission *, 189\nUVa 11797 - Drutojan Express, 77\nUVa 11799 - Horror Dash *, 29\nUVa 11804 - Argentina *, 145\nUVa 11805 - Bafana Bafana, 28\nUVa 11821 - High-Precision Number, 76\nUVa 11824 - A Minimum Land Price, 75\nUVa 11830 - Contract revision, 76\nUVa 11831 - Sticker Collector . *, 214\nUVa 11832 - Account Book *, 188\nUVa 11833 - Route Change, 240\nUVa 11835 - Formula 1, 74\nUVa 11838 - Come and Go *, 208, 214\nUVa 11841 - Y-game, 212\nUVa 11849 - CD, 92\nUVa 11850 - Alaska, 74\nUVa 11857 - Driving Range, 222\nUVa 11858 - Frosh Week, 76\nUVa 11860 - Document Analyzer *, 92\nUVa 11875 - Brick Game, 74\nUVa 11876 - N + NOD (N), 153\nUVa 11877 - The Coco-Cola Store, 146\nUVa 11878 - Homework Checker *, 39\nUVa 11879 - Multiple of 17 *, 76\nUVa 11881 - Internal Rate of Return, 154\nUVa 11890 - Calculus Simpli\ufb01ed *, 163\nUVa 11900 - Boiled Eggs *, 162\nUVa 11902 - Dominator, 212\nUVa 11906 - Knight in a War Grid *, 212\nUVa 11908 - Skyscraper, 189\nUVa 11917 - Do Your Own Homework, 92\nUVa 11926 - Multitasking, 76\nUVa 11933 - Splitting Numbers *, 76\nUVa 11934 - Magic Formula, 146\nUVa 11935 - Through the Desert, 150, 154\nUVa 11942 - Lumberjack Sequencing, 29\nUVa 11945 - Financial Management, 37\nUVa 11946 - Code Number, 39\nUVa 11947 - Cancer or Scorpio *, 38\nUVa 11951 - Area,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4b6dfc30-1afb-47e7-b07c-7144417a344d": {"__data__": {"id_": "4b6dfc30-1afb-47e7-b07c-7144417a344d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3081a98c-a13b-48c7-a9b1-acc30f34b13d", "node_type": "1", "metadata": {}, "hash": "fc93f9c8f82799ff2fc0b1556e2385f0aabef49884dfa691a2da2b95e9a54da2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9cb1834a-25b9-41d0-968b-59f486c8a99e", "node_type": "1", "metadata": {}, "hash": "4c3c290b8e0c261acaf7c6b2488ed0a5b267d21e804fa648a3028ce5f9449872", "class_name": "RelatedNodeInfo"}}, "text": "163\nUVa 11900 - Boiled Eggs *, 162\nUVa 11902 - Dominator, 212\nUVa 11906 - Knight in a War Grid *, 212\nUVa 11908 - Skyscraper, 189\nUVa 11917 - Do Your Own Homework, 92\nUVa 11926 - Multitasking, 76\nUVa 11933 - Splitting Numbers *, 76\nUVa 11934 - Magic Formula, 146\nUVa 11935 - Through the Desert, 150, 154\nUVa 11942 - Lumberjack Sequencing, 29\nUVa 11945 - Financial Management, 37\nUVa 11946 - Code Number, 39\nUVa 11947 - Cancer or Scorpio *, 38\nUVa 11951 - Area, 187\nUVa 11953 - Battleships *, 212\nUVa 11956 - Brain****, 30\nUVa 11957 - Checkers *, 264\nUVa 11958 - Coming Home, 38\nUVa 11959 - Dice, 145\nUVa 11961 - DNA, 147\nUVa 11965 - Extra Spaces, 40\nUVa 11968 - In The Airport, 146\nUVa 11975 - Tele-loto, 145\nUVa 11984 - A Change in Thermal Unit, 37\nUVa 11987 - Almost Union-Find, 122\nUVa 11988 - Broken Keyboard . *, 77\nUVa 11991 - Easy Problem from . *, 122\nUVa 11995 - I Can Guess . 91\nUVa 11997 - K Smallest Sums *, 91\nUVa 12015 - Google is Feeling Lucky *, 29\nUVa 12019 - Doom\u2019s Day Algorithm, 38\nUVa 12032 - The Monkey . *, 154\nUVa 12047 - Highest Paid Toll *, 240\nUVa 12049 - Just Prune The List *, 92\nUVa 12060 - All Integer . 40\nUVa 12071 - Understanding Recursion, 75\nUVa 12085 - Mobile Casanova *, 40\nUVa 12086 - Potentiometers, 123\n297\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 12100 - Printer Queue, 77\nUVa 12108 - Extraordinarily Tired . *, 77\nUVa 12124 - Assemble, 163\nUVa 12136 - Schedule of a Marr. *, 38\nUVa 12143 - Stopping Doom\u2019s Day, 76\nUVa 12144 - Almost Shortest Path, 240\nUVa 12148 - Electricity *, 38\nUVa 12150 - Pole Position *, 74\nUVa 12157 - Tari\u21b5Plan *, 30\nUVa 12160 - Unlock the Lock *, 239\nUVa 12169 - Disgruntled Judge, 146\nUVa 12186 - Another Crisis, 265\nUVa 12187 - Brothers *, 74\nUVa 12190 - Electric Bill *, 154\nUVa 12192 - Grapevine *, 153\nUVa 12195 - Jingle Composing, 37\nUVa 12205 - Happy Telephones, 144\nUVa 12207 - This is Your Queue, 77\nUVa 12210 - A Match Making Problem, 162\nUVa 12239 - Bingo, 36\nUVa 12247 - Jollo *, 36\nUVa 12249 - Overlapping Scenes *, 145\nUVa 12250 - Language Detection *, 28\nUVa 12269 - Land Mower, 75\nUVa 12279 - Emoogle Balance *, 29\nUVa 12280 - A Digital Satire of . *, 40\nUVa 12289 - One-Two-Three, 28\nUVa 12290 - Counting Game, 146\nUVa 12291 - Polyomino Composer *, 75\nUVa 12299 - RMQ with Shifts *, 123\nUVa 12319 - Edgetown\u2019s Tra\ufb03c Jams, 248\nUVa 12321 - Gas Station *, 162\nUVa 12324 - Philip J. Fry . *, 189\nUVa 12337 - Bob\u2019s Beautiful Balls, 145\nUVa 12342 - Tax Calculator, 38\nUVa 12346 - Water Gate Management, 145\nUVa 12347 - Binary Search Tree *, 265\nUVa 12348 - Fun Coloring,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9cb1834a-25b9-41d0-968b-59f486c8a99e": {"__data__": {"id_": "9cb1834a-25b9-41d0-968b-59f486c8a99e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4b6dfc30-1afb-47e7-b07c-7144417a344d", "node_type": "1", "metadata": {}, "hash": "04361974c067a81a4932f1bc092a6002819b2c6da55b199d92feefc9dc99a7c0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "91bc5dd8-d2b2-490a-84de-c57e0165a662", "node_type": "1", "metadata": {}, "hash": "0f93d0bdc2b6d1206113fb79aba0bc861e987eb21fefe81b0c54548a861ab476", "class_name": "RelatedNodeInfo"}}, "text": "75\nUVa 12279 - Emoogle Balance *, 29\nUVa 12280 - A Digital Satire of . *, 40\nUVa 12289 - One-Two-Three, 28\nUVa 12290 - Counting Game, 146\nUVa 12291 - Polyomino Composer *, 75\nUVa 12299 - RMQ with Shifts *, 123\nUVa 12319 - Edgetown\u2019s Tra\ufb03c Jams, 248\nUVa 12321 - Gas Station *, 162\nUVa 12324 - Philip J. Fry . *, 189\nUVa 12337 - Bob\u2019s Beautiful Balls, 145\nUVa 12342 - Tax Calculator, 38\nUVa 12346 - Water Gate Management, 145\nUVa 12347 - Binary Search Tree *, 265\nUVa 12348 - Fun Coloring, 145\nUVa 12356 - Army Buddies *, 74\nUVa 12363 - Hedge Mazes *, 213\nUVa 12364 - In Braille *, 40\nUVa 12366 - King\u2019s Poker, 36\nUVa 12372 - Packing for Holiday *, 28\nUVa 12376 - As Long as I Learn, I Live *, 214\nUVa 12379 - Central Post O\ufb03ce *, 265\nUVa 12390 - Distributing . *, 159, 163\nUVa 12394 - Peer Review, 38\nUVa 12397 - Roman Numerals *, 39\nUVa 12398 - NumPuzz I, 75\nUVa 12403 - Save Setu, 29\nUVa 12405 - Scarecrow, 162\nUVa 12406 - Help Dexter, 145\nUVa 12439 - February 29, 38\nUVa 12442 - Forwarding Emails *, 214\nUVa 12455 - Bars *, 133\nUVa 12459 - Bees\u2019 ancestors, 76\nUVa 12468 - Zapping, 28\nUVa 12478 - Hardest Problem . 28\nUVa 12482 - Short Story Competition *, 163\nUVa 12485 - Perfect Choir, 162\nUVa 12488 - Start Grid *, 144\nUVa 12498 - Ant\u2019s Shopping Mall, 144\nUVa 12503 - Robot Instructions *, 29\nUVa 12504 - Updating a . *, 93\nUVa 12515 - Movie Police *, 144\nUVa 12516 - Cinema Cola, 163\nUVa 12527 - Di\u21b5erent Digits, 146\nUVa 12531 - Hours and Minutes, 38\nUVa 12532 - Interval Product, 123\nUVa 12541 - Birthdates *, 75\nUVa 12543 - Longest Word, 39\nUVa 12545 - Bits Equalizer, 30\nUVa 12554 - A Special . Song, 29\nUVa 12555 - Baby Me, 37\nUVa 12571 - Brother & Sisters *, 76\nUVa 12577 - Hajj-e-Akbar, 28\nUVa 12582 - Wedding of Sultan, 214\nUVa 12583 - Memory Over\ufb02ow, 144\nUVa 12592 - Slogan Learning of Princess, 92\nUVa 12608 - Garbage Collection *, 40\nUVa 12614 - Earn for Future, 30\nUVa 12621 - On a Diet, 188\nUVa 12626 - I (love) Pizza *, 91\nUVa 12640 - Largest Sum Game, 187\nUVa 12643 - Tennis Rounds *, 30\nUVa 12644 - Vocabulary *, 266\nUVa 12646 - Zero or One, 28\nUVa 12648 - Boss, 214\nUVa 12650 - Dangerous Dive *, 91\nUVa 12654 - Patches, 189\nUVa 12658 - Character Recognition? *, 29\nUVa 12662 - Good Teacher *, 74\nUVa 12665 - Joking with Fermat\u2019s . 146\nUVa 12667 - Last Blood *, 74\nUVa 12668 - Attacking rooks *, 266\nUVa 12673 - Football *, 162\nUVa 12694 - Meeting Room . *, 145\nUVa 12696 - Cabin Baggage *, 29\nUVa 12700 - Banglawash, 40\nUVa 12709 - Falling Ants *,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "91bc5dd8-d2b2-490a-84de-c57e0165a662": {"__data__": {"id_": "91bc5dd8-d2b2-490a-84de-c57e0165a662", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9cb1834a-25b9-41d0-968b-59f486c8a99e", "node_type": "1", "metadata": {}, "hash": "4c3c290b8e0c261acaf7c6b2488ed0a5b267d21e804fa648a3028ce5f9449872", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d3f48770-22aa-448d-8f44-0d1086753eec", "node_type": "1", "metadata": {}, "hash": "725cf1555dafde89dd1d8631041f0e6b4ebaa0d66565c8564c6dc57d88800355", "class_name": "RelatedNodeInfo"}}, "text": "30\nUVa 12644 - Vocabulary *, 266\nUVa 12646 - Zero or One, 28\nUVa 12648 - Boss, 214\nUVa 12650 - Dangerous Dive *, 91\nUVa 12654 - Patches, 189\nUVa 12658 - Character Recognition? *, 29\nUVa 12662 - Good Teacher *, 74\nUVa 12665 - Joking with Fermat\u2019s . 146\nUVa 12667 - Last Blood *, 74\nUVa 12668 - Attacking rooks *, 266\nUVa 12673 - Football *, 162\nUVa 12694 - Meeting Room . *, 145\nUVa 12696 - Cabin Baggage *, 29\nUVa 12700 - Banglawash, 40\nUVa 12709 - Falling Ants *, 75\n298\n\nINDEX\nc\u20ddSteven, Felix, Suhendry\nUVa 12720 - Algorithm of Phil *, 76\nUVa 12750 - Keep Rafa at Chelsea, 29\nUVa 12768 - Inspired Procrastination *, 240\nUVa 12783 - Weak Links *, 213\nUVa 12791 - Lap, 154\nUVa 12792 - Shu\u270fed Deck, 146\nUVa 12798 - Handball, 29\nUVa 12801 - Grandpa Pepe\u2019s Pizza, 144\nUVa 12808 - Banning Balconing, 37\nUVa 12820 - Cool Word, 91\nUVa 12822 - Extraordinarily large LED *, 38\nUVa 12826 - Incomplete Chessboard *, 239\nUVa 12834 - Extreme Terror *, 162\nUVa 12840 - The Archery Puzzle *, 147\nUVa 12841 - In Puzzleland (III) *, 189\nUVa 12844 - Outwitting the . *, 144\nUVa 12854 - Automated Checking . 74\nUVa 12861 - Help cupid, 75\nUVa 12862 - Intrepid climber *, 189\nUVa 12875 - Concert Tour *, 265\nUVa 12878 - Flowery Trails, 240\nUVa 12893 - Count It *, 154\nUVa 12895 - Armstrong Number, 146\nUVa 12896 - Mobile SMS *, 39\nUVa 12917 - Prop Hunt, 28\nUVa 12930 - Bigger or Smaller, 76\nUVa 12938 - Just Another Easy Problem, 146\nUVa 12950 - Even Obsession *, 240\nUVa 12951 - Stock Market, 189\nUVa 12952 - Tri-du, 36\nUVa 12955 - Factorial *, 189\nUVa 12959 - Strategy Game, 74\nUVa 12965 - Angry Birds *, 153\nUVa 12981 - Secret Master Plan, 74\nUVa 12996 - Ultimate Mango Challenge, 74\nUVa 13007 - D as in Daedalus, 30\nUVa 13012 - Identifying tea, 29\nUVa 13015 - Promotions, 214\nUVa 13018 - Dice Cup, 144\nUVa 13025 - Back to the Past *, 28\nUVa 13026 - Search the Khoj, 74\nUVa 13031 - Geek Power Inc. 162\nUVa 13034 - Solve Everything :-), 29\nUVa 13037 - Chocolate *, 93\nUVa 13038 - Directed Forest, 214\nUVa 13047 - Arrows, 39\nUVa 13048 - Burger Stand *, 74\nUVa 13054 - Hippo Circus *, 162\nUVa 13055 - Inception *, 77\nUVa 13059 - Tennis Championship, 146\nUVa 13082 - High School Assembly, 163\nUVa 13091 - No Ball, 40\nUVa 13093 - Acronyms, 39\nUVa 13095 - Tobby and Query, 187\nUVa 13103 - Tobby and Seven, 145\nUVa 13107 - Royale With Cheese, 39\nUVa 13109 - Elephants *, 162\nUVa 13113 - Presidential Election, 75\nUVa 13122 - Funny Cardiologist, 265\nUVa 13127 - Bank Robbery *, 240\nUVa 13130 - Cacho, 29\nUVa 13131 - Divisors,", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d3f48770-22aa-448d-8f44-0d1086753eec": {"__data__": {"id_": "d3f48770-22aa-448d-8f44-0d1086753eec", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "416c68dd-511e-4fd9-9b42-3c428fbc005d", "node_type": "4", "metadata": {}, "hash": "0eaad0a1b721df24eb1f8bed2138a4bc4b837356807c3c87a358a88e62dd32fd", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "91bc5dd8-d2b2-490a-84de-c57e0165a662", "node_type": "1", "metadata": {}, "hash": "0f93d0bdc2b6d1206113fb79aba0bc861e987eb21fefe81b0c54548a861ab476", "class_name": "RelatedNodeInfo"}}, "text": "74\nUVa 13054 - Hippo Circus *, 162\nUVa 13055 - Inception *, 77\nUVa 13059 - Tennis Championship, 146\nUVa 13082 - High School Assembly, 163\nUVa 13091 - No Ball, 40\nUVa 13093 - Acronyms, 39\nUVa 13095 - Tobby and Query, 187\nUVa 13103 - Tobby and Seven, 145\nUVa 13107 - Royale With Cheese, 39\nUVa 13109 - Elephants *, 162\nUVa 13113 - Presidential Election, 75\nUVa 13122 - Funny Cardiologist, 265\nUVa 13127 - Bank Robbery *, 240\nUVa 13130 - Cacho, 29\nUVa 13131 - Divisors, 146\nUVa 13141 - Growing Trees *, 189\nUVa 13142 - Destroy the Moon . *, 154\nUVa 13145 - Wuymul Wixcha *, 39\nUVa 13148 - A Giveaway *, 92\nUVa 13151 - Rational Grading *, 37\nUVa 13177 - Orchestral scores *, 163\nUVa 13181 - Sleeping in hostels *, 74\nUVa 13190 - Rockabye Tobby *, 91\nUVa 13212 - How many inversions? *, 76\nUVa 13249 - A Contest to Meet, 248\nUVa 13275 - Leap Birthdays, 38\nVector, 55\nWarshall\u2019s Algorithm, 245\nWarshall, Stephen, 241, 245, 248\nWilliams, John W.J., 83\nXor Operation, 63\n299", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"416c68dd-511e-4fd9-9b42-3c428fbc005d": {"node_ids": ["9e7640ce-ab93-4262-a732-a73f9dd97e82", "99931567-eeec-475e-b958-c8081027bcaa", "f3042a90-da33-4fce-86a4-cba13454b325", "a70440e4-965b-4d18-a789-b4ed02a5b664", "5c57b46b-5b48-4e89-a0e4-2326b2648c6e", "31dae6ff-2c08-4116-8078-f1f44fe27016", "283b477f-83e5-4a9c-b71b-8e437232de9f", "4b7f32e0-1dd6-4863-b1b4-4e78f8df7a5d", "035e79ca-eb2a-439f-b4fb-e0077ea563ca", "c25de355-1f0b-4f5f-a995-59725a59b112", "d42da43f-6120-4c1a-b232-536251c3675c", "81e2871e-a153-4bca-b9c0-88f601e6af51", "a892ac17-5046-48c4-b190-0121079e9a6c", "cabb17a6-c955-47a8-91bf-62e29404f9fb", "9c903b83-4464-4314-81fc-01550ca75547", "6ea117f5-0801-452e-aa74-920af4c88e85", "3ee4a736-0bbd-4db0-8f82-8cede134cb6d", "f5d39c19-e7e2-49d5-b54e-f38071da7c81", "e539adf6-499c-4618-8ea4-04f1de63bf39", "245729d6-825a-47a2-a58e-20c7de435c72", "74134c91-4832-4f2e-bd57-749151651b9f", "5e679599-9d3e-49bb-88e8-e9e04ac0b266", "b7aa21ea-d15e-4ec6-a5a9-6e31519129f1", "a76c70bc-0efa-4158-9b4b-2025daf63bf7", "dfb680fd-020c-4781-8fd3-92837d2f471d", "8658b90c-0ecb-402f-adc7-16201f8f11ba", "915b0bc5-aec5-4084-b602-c96698cb7d0b", "0d15a50d-f5d6-4306-96c8-d3c6c92016a0", "994ecc5e-da2d-4242-9c94-6c5336c198f9", "3a11a3ed-ea2d-4d2b-bed1-4c2ce792ecb9", "5bd5f64b-f497-4484-a8b8-e67275bba34b", "23ea8d9e-0d14-46e5-9278-42d342ee811f", "d7581205-66b6-4b56-a1ef-264ea7fa50d9", "cb3cf225-a62c-455e-b776-73000c34bd29", "272dcb3b-a3f1-4bcb-b1fe-1fd5f850e885", "2644c642-bfaa-4c2e-81ec-4dcca17be037", "ec9d5d5d-8344-4ec1-84a6-b6b4ea800749", "7128023b-576e-4ec1-8821-d9181e48fc0c", "f7829b03-f6e8-4e87-aa6b-3a7d12b7d21e", "5af3a4f7-6e9b-4156-bdf7-33156cdbf1b5", "2b246c2f-6e2d-49d3-89d8-8e5eb8475dbb", "ae652625-8732-4cdc-b7c9-7572925d2de7", "73e17c4f-b629-46b8-aee0-f8c79ba84b14", "afa08a1f-7d79-44e1-9a98-42ed8daaec7c", "bed8ed10-c3f3-43d7-a759-c6d8530e4501", "9d06f407-cadd-463b-bb56-f36f7f1afa22", "eef3ba66-0dc6-4d5e-b329-2c2b136989b5", "881d7beb-790c-4444-97d9-d8b22f1ec288", "b8647d1c-cdee-4664-b486-bfecb4c4fd20", "4ad7982f-7bd8-400d-b81d-b46e26fcee55", "115bf630-860d-4919-b530-39d5df9da62e", "dab07ff0-9214-41ee-aec4-9f4cbe1dc276", "4229cd55-0250-4c4a-a793-95c7c0f060ae", "b917c4e6-8479-4744-877f-75eeebaf8262", "f023453c-c045-4644-aea6-aeb80c792cc2", "25acbd6a-0f97-436e-944b-ae5cd6317ec1", "a66a21f5-1094-478d-8536-4eb310b19dc8", "30b0c3c3-891f-428d-a037-6ebca59d31e8", "f0332119-eb61-4172-9e14-dd98d0c7e966", "72f21f4e-2596-4943-bf96-8bd3780ce7d6", "096c2e4b-4d6a-4c89-9fba-aaa0adc1d2e6", "8615ed30-6595-4da8-bf62-9e4edff63f7a", "9c0daa2d-6cab-41af-ba67-2eaef05b7afb", "36697aaf-12f2-4dd0-a2cb-0bee99087d57", "66db4153-a9a4-4486-a152-60d2363d841c", "49f087de-9be7-4150-9afb-39916233a484", "a921c7e4-1eec-4fc2-aabe-1074dcc07d31", "5870f848-a410-46df-9219-2fb7430a1c17", "0a8914b0-ce95-4dbd-9dc8-6b802701792e", "7eb778d0-b5ac-41fe-a7e8-7ede998fa443", "40d136a9-d91c-4b5e-bfa5-5d144e3d4948", "a2b41182-5217-4261-bf9d-d115c43d6299", "4a22fb06-f827-4bd3-a09b-4a0f882e6e36", "b2d38d6b-69fe-4bd0-bf05-389b1ba783cb", "c40dd641-061f-4420-b550-23ce55093235", "62d527f0-310e-4f9a-89ce-a3fdd9d3296f", "dbf4cbd1-7037-460a-948c-79cea6f16272", "4f49f486-d93d-4f73-beec-228e10ae1996", "a92cd5b3-2750-480e-8458-d8827a917cc7", "2228205c-6c56-4f82-8adc-cf2239eace53", "5c10c372-7baa-4d65-8af0-3437081adb09", "d564279a-159a-49ed-95de-6c89d7e5ea8f", "04c3c39d-0dea-46c0-bfd4-cff92937b41a", "6e6fb7b4-caf7-41dc-914c-335ef093838b", "5e3bb644-fe1a-43e5-b19a-051a233098d0", "72062330-c47b-437f-8883-1369d75e870d", "53f0463a-e472-49c2-a787-599301a971b4", "e939f213-d4c0-4734-9263-499221f5c85f", "daa38e64-5d54-42be-8375-5958dea13124", "c7bf8e0f-6c52-4568-aaa6-b9197b41b246", "a22dc1c5-b431-4fa2-9f0b-a3ac38ad0e43", "83f5682c-3881-4658-9c71-18f247e7939e", "5c71451f-7e77-4ba3-92d0-63b3fe268459", "e4dc2d94-b8ee-4dc0-a3bb-d00b48d4a41f", "2584ed75-4493-4a8d-a06c-0c99dc1846d6", "757736e5-bdba-42a9-938b-d6cfc7a30f4b", "a96fccec-1e0d-4682-b3e4-692f102c8440", "b3197541-d5da-46a3-998c-a159675ba1f9", "1d1381ce-7f54-4530-8a45-1930ddaad0a6", "90d3e703-2125-4d39-9aa8-efa943425a53", "a737f9c4-c064-4793-b8a8-63171cab5780", "75c043fd-02e6-43a2-b834-fea90df8f100", "b5d5aac7-a068-43e0-bc4b-f800c6ef3f4a", "2d74e6ae-bfb6-4566-9daa-9f5d5b2125fb", "42ecfd74-6f9d-4e60-93ab-67b0c41c35fd", "24249ab0-2b7c-42c4-993d-f67e77dd96b0", "a905f101-515e-43d2-99e2-e0ac3a759970", "24148f9a-3e02-4379-a425-f35959db7777", "9a7a1d2b-b1b9-45dd-9d34-e51736138a24", "1be4cee3-acc9-40a3-be4e-a0f0422f8422", "3638f542-4b64-4566-993c-e941e9d28f3b", "090b0a35-827e-4f04-a7ab-2f331a1f9e54", "3de92378-8f37-4a4e-a806-80ce63529c50", "34f28792-d2e6-48b7-90f2-f3c2edba834c", "58249bd0-3409-45a6-b57a-b91e60fae83d", "3faad072-71fe-4728-95ba-2c86e29ba076", "89058d4e-e6c9-4560-9756-e798ac837423", "cc19f965-ea78-4393-9207-38dfa2c76166", "7dc77a20-4081-4ae4-90fa-60f300b4c566", "cc6bb88c-c41a-4a95-b204-59176e916630", "cfd46ede-8865-49cb-b6fb-447cff08180f", "f9fb01c4-28b8-4e22-80fe-61a5504ef95a", "13a69172-f1fb-4bbe-b486-6705ca0dd3e0", "976a0b82-c220-4608-8717-f5fda40b589d", "97b42b37-b833-47db-b78a-6fcf958d82b8", "2eab4670-82a5-49ce-885f-89d05076d69c", "2ee4f07a-65ae-427d-aa18-bad8268671e6", "6a6a26e0-0d81-48a9-8da1-f5ee8fff4301", "8636d26e-b777-4881-8bd2-36070d66bde9", "aeabf378-88c2-4ab0-a6e1-3bae6af8fcbe", "c675890d-a913-41fa-a267-900d2db8baf5", "ca35db60-20eb-4da3-9813-e64de6027423", "318eb557-470c-4488-a451-ad0d441fa2aa", "51ed877b-aecd-49d0-a93f-1c927ef760ba", "b735c775-4891-4d95-bb6d-747bf379c53c", "6c2c430a-4ebe-4be8-876a-d61898dffd12", "b2fcd079-151e-4762-afb3-75e73662d773", "d8c40691-573b-4a8d-8fcd-055c94dd275c", "68d3de96-3bda-4161-a2c6-831b02493bec", "e8777ce0-4e3d-4037-ade1-90c2954d1850", "d2cd5c0d-e1fd-464a-b5fd-658275486540", "2fe778c2-016e-4e95-b2f8-b910574f4ff1", "7984f61f-4dad-4704-988f-83feeed85ad9", "5cd45d32-1e0f-4f69-8824-260fff5f6ee8", "bd315507-f7d0-49e4-b4d5-45328d276e85", "bc9679ce-bece-4931-bc92-1d48aa2e3ff3", "02bbd247-cc7a-4e94-934d-8de0d27d31d1", "88e619bc-7cc8-4174-af95-6704c3570f8b", "6e23ec52-328a-4fa1-a402-ebed7090d1e9", "503ae3a8-7cf8-48e7-87e7-26f381793dc0", "c318a363-0581-48cb-a76f-fc84d1d606f8", "da0abace-9b8c-4942-a950-38241689c0db", "9f229035-8f40-4b06-9eca-a730b0f59151", "da83e738-5c56-4ad6-af6f-3f789fb909b0", "54bed8ff-4170-458d-945a-ae93ba18f467", "507838c2-28ce-4e8e-9be5-c1d7668559af", "54d91d97-f3da-4ef6-93ff-0c481f4155dc", "daa2b039-82c1-44bd-8498-e3a34c17ab91", "a441f272-97bb-44b0-9b41-cdcfbe1271de", "f706fc4f-014f-4c4a-a424-37d4f575b6e1", "c510323f-9234-4cc9-9177-972882dc4c92", "c4464ade-f4b5-45fb-954a-bf08970554a4", "41c7ce11-0858-4f4c-a529-c975f25fcce1", "5a7ece0e-17c3-4104-a056-a89ea1159c7d", "3d07c2c0-5fa3-45b9-896a-b00b8b9376db", "3fa16795-8749-49ca-b368-e0aee1c9bb8b", "305b3fad-ab0d-4347-a4a8-f692396fe162", "e3d50b49-642b-49ce-b5a1-6a6957ea1bff", "b63d9d27-8c18-4865-9312-d9295047e3a2", "a2dd392f-caf8-4f63-b39a-89af7d5e45b9", "4590ec06-6d10-4146-b6ad-f95e18cc7981", "9f6f7fca-ffc5-43e3-934c-ffd8477c0b68", "5e800259-51fc-4253-8153-6610aab6703c", "f46dcf2d-6e3b-47d4-9ad0-f9e6b19eed13", "3c75a03b-7b40-4cac-aafd-9404b1e6f6a4", "50e0a2be-b209-4d61-9e8e-c0265ccf1eb8", "df1cae18-e5c4-4c8c-a057-f3acfed248d5", "1592a926-e773-47a5-b542-8e4892271326", "e3805032-ebeb-4017-841f-772afe7d80da", "5320215f-7cb1-479e-8f0a-98d19b52685e", "a5957a05-1510-4b01-a59b-1e7b2ff465f8", "6536fe42-1b76-4d6f-9030-34c29459e4ae", "f4c68d10-8304-4201-9740-ed93244612aa", "97ee77f4-e793-406e-a5f7-86aa16ca3c50", "24ca5357-fc2e-437f-9809-532a330299ba", "3119c97f-6fd0-458b-a756-00c02f2f8bde", "08e6b320-9bbf-4928-b482-7a9a4cc3ec48", "b30f64a4-fd94-4eb3-aa15-f5d024b11799", "50f949a3-5060-4181-971a-6f6ecb238efa", "430e339a-2652-48a2-96dd-99bf1ca848c2", "02512f5c-1172-4850-9c8e-40a38cf8919a", "69d36dc7-323b-443e-816b-ea8566566973", "54eef8ca-ca40-4ab8-b607-e39c8fe7e12e", "737a7657-def7-4a13-a2dd-ea5889e96d95", "0cf25ae8-d2c0-4ec3-ac51-0140398bfcc3", "4c7d79c2-68a3-42cf-879e-384021a7d199", "091820a0-24c0-4db1-b3f4-dd04c696811f", "a00682a1-bdd1-4df0-a918-7d20e17c388e", "a54c614a-4953-4373-ac65-18bd0fdfd974", "9d4ae3e9-054a-42ff-8ef3-376c2791e575", "5b504746-7a4f-45e1-a7fb-16e1d447bd50", "f3645bf1-aca8-4b4d-b1a0-f96bfefee913", "35e563a8-9cf4-48af-8f65-b5a626108753", "2adb80b9-5b48-40cf-9a74-9f7cb3dce652", "26f81cb3-be38-4548-8613-8d465df3cf20", "87123bb9-c1be-45c2-b433-7eee74da94c1", "1531d0a3-9773-49a9-baf4-4c08b11c96ac", "e8071a64-431c-424e-9c9d-84857be6e6b0", "20e1f495-27f3-4ccc-9296-d26dbcdccf84", "f3a149d5-39bb-4d66-9110-e2b871e141f8", "e4707514-89d9-4daf-bc92-44468f41403d", "075d378b-1cd4-4457-a226-4c53ce9489a9", "54b24a89-1196-4580-8a2b-a9063e64aadf", "5fb3adb6-49f4-4767-b5a8-fb0bd7221819", "aa1ac5a5-622f-44f5-8bd2-502973bac1e2", "159c0ce9-0550-433e-ad21-7308cb963196", "e677c92a-3dfd-452d-a54f-aad2deddd8d1", "d4b4d6b0-7837-4ba8-b7ee-97743637a9e7", "04dd4beb-8f76-40d8-b789-ab091ed11cba", "9bed1b83-2d62-47cc-b9e7-9c76a5ef2803", "316c77f3-760e-40bc-b7cc-bec6cc17a976", "4ca516a4-f1dc-4ec7-b35f-90a45bcd5210", "bc703d50-b163-4f8d-9ebb-4c0513f3df80", "47debdbf-a2a9-4d09-9159-aea64f35bd83", "464020d2-e8b6-46b9-9bc0-f57eb9f27c35", "49195315-41bc-4a7a-b48d-3134fc835c35", "c5ca4760-838f-42a3-903d-47ba895f0514", "82d4b21c-b6f3-42be-80b3-dfb4045929c3", "9350a3b4-adf8-4c48-b84d-d4f3495efe3b", "6403085f-ae51-46ed-8355-3aa29b08b8c1", "62c72ac7-89c5-44a0-885c-844999408084", "d85f620b-8926-462e-a0e0-d08bcd62afbe", "12c30ae7-9b7b-4425-8027-dd3868a8d8e1", "47ec6063-7b80-4c92-b55f-7d81a1f08061", "a0d2e95c-d2c5-4cb7-9ae3-1a01263383d0", "7ef2cdd7-418f-4923-ab27-8f78e129dbaa", "966e6019-4b2c-459a-9336-3878b710fd9b", "ca96cf2f-ec15-48c9-868b-e75d14d47fd3", "a4046b38-68a8-4f7d-97be-10949973f986", "a1d0c310-32d6-4c3c-aaab-0cf3066e1f25", "fc74c24d-2187-40b2-b17e-1fa5dc5e1f70", "64e41ea4-f089-414e-bd82-d8db9412fbdd", "3e6e80e9-2e24-4f20-a2ec-10cbfe4c0717", "0e373c6e-7abf-4cd7-89d6-c0039b2c2832", "64861338-bd52-4209-9ba0-dd38ea526402", "cbcb136e-dcb6-4092-a715-687f97c07afc", "3d58f128-51bc-4f87-b7aa-ae0384b91819", "b8b21f69-38f1-4343-b0b7-1b75c059e6af", "0af3b05b-de1c-4c1d-b2ae-2ee2f8a61ad0", "55bb1aa3-9096-4fe8-a422-e0485256687e", "df366276-0ad7-4421-b5a1-bfd1a663f6a5", "2be2bfb0-b7eb-4196-bf01-e71f9154f193", "2ccc1970-bb12-46ad-a341-d9d54f45fa00", "b37734f1-1a9b-4530-aa5c-74f0364f41f5", "7601a4c3-90b8-4fa4-ac73-5ba24aba0b49", "6cf9c5c8-a429-4b8e-b762-9c079b356f8a", "67d6d349-d8fc-4870-bda8-36b410558650", "bea0a649-6bb3-4d32-b387-6702794f15ae", "c2aa1c65-2c93-4d7a-9c3a-aa645b1ea611", "a93e5b70-9208-4de1-9529-c0fd4780f777", "bdd83ef0-09f0-4f91-a6b2-f797268f2753", "aa5f738b-bb9f-401a-8d87-c88c357515b3", "5269fb2e-a072-416b-80a1-a59a72e544fc", "5c270fad-5bac-4906-b396-bcfb31c83c60", "5c150795-2bcf-42c5-8232-9b46b2a508fc", "a5640c6c-8e94-4a89-ba81-281107c3db97", "c1d8e65d-ef3e-4219-8d61-f1933587d878", "b67d5714-2def-4b59-8ac9-2407d0e6d472", "ce24ebcc-b0a1-4404-b4a9-6bf9fe7ef6b6", "97cf9a1d-126a-48d6-9dd5-06a2214b55e8", "e2c380c3-5882-4361-9f19-d0a3cc15bdda", "6b15849a-dd3b-48cd-b709-b08966e31948", "38d9aae8-0938-44d7-8693-2f240adf0426", "0cb9da55-d5a0-45f4-a60c-fd5c1d55b372", "3a40befc-46b3-4e28-aef5-60a4645a01db", "bb5abc18-9f27-4940-8b34-c0275c88d8e9", "8854baf9-a58c-418c-b629-c1cea783ce2d", "af874795-0079-4842-b74d-118633a92be2", "71f2eebf-98d1-4574-abdc-cbeedaf19805", "736c8c54-49d0-410f-8a8f-67a370f7d149", "4703a5d2-7cb4-4934-b40d-4c2bbb3e93a4", "fb560e0f-58e0-4f46-9f47-21e54feed8f5", "d752bb49-9b51-447d-a7c2-8d4328f79264", "ff1fc269-e1bb-41ee-836c-57189998bad4", "e7d331d4-2271-418c-b43e-4c2f4bf38933", "68e2d899-0329-41d6-8d37-050f5181fdeb", "8b922dca-ff19-4502-aedd-b8ebd109f1b3", "ad9c7596-ebd4-4aa3-8775-0378e5a95a1c", "a8ec929b-d879-4c29-9aea-7533d4d2ac92", "65660e7d-7f7b-4b8d-9629-6aba797d7cbf", "96a11867-a9be-461d-bd1c-1b027a50d46d", "b6ccc757-3d15-439f-8782-8b69218b4962", "a3c1c4c3-98a3-476e-ad09-112e0b80ce61", "73f11948-5a0c-4daa-a097-9e1b6c0ef218", "44d62242-44c1-4ab9-b9dd-8cd34c152969", "bb23df04-83cd-4341-a097-4103a5d3abb7", "752fe29a-722b-4620-baae-5dda32fe01da", "39ced19f-b8be-482c-bae7-654e71a682b3", "b1348c77-3357-4750-90a7-1b7fbdc05799", "d8d2fcff-05f7-4c65-895b-d61ef7c3bb83", "5c314b63-09df-4dce-a50f-be993514b32a", "4a4d332b-a670-4bcb-b934-b252c1c3c550", "92d88b27-bc15-4c28-9fed-d2f23b0453dd", "b95ab453-715d-4a61-be3b-ba011d6f15ac", "516c14f3-66f7-4253-ace5-1fa005e1848e", "1046d801-81ce-4023-b131-d396de2ee0f7", "9952d9f7-2036-444c-a07e-e17d7bad1436", "1a411229-227a-4178-a507-6f219c8e6373", "513056ca-4109-48ae-99dd-ad90ffd40f55", "1319e319-f429-48ed-a40e-d46426f2057d", "3081a98c-a13b-48c7-a9b1-acc30f34b13d", "4b6dfc30-1afb-47e7-b07c-7144417a344d", "9cb1834a-25b9-41d0-968b-59f486c8a99e", "91bc5dd8-d2b2-490a-84de-c57e0165a662", "d3f48770-22aa-448d-8f44-0d1086753eec"], "metadata": {}}}}